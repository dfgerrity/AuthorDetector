QUESTION,USERID,USERNAME,ANSWER
"<p>Where, ClassA has an operator as such, that returns ClassB:</p>

<pre><code>class ClassA
{
public:
    ClassA();
    ClassB &amp;operator[](int index);
}
</code></pre>

<p>If I want to access said operator from within ClassA's constructor, as so:</p>

<pre><code>ClassA::ClassA()
{
    // How do I access the [] operator?
}
</code></pre>

<p>At the moment, as a work-around I'm just using a method called GetAtIndex(int index) which the [] operator calls, and so does the constructor.</p>

<p>It would be nice if I could access it in the same as as C# works:</p>

<pre><code>// Note: This is C#
class ClassA
{
   ClassB this[int index]
   {
       get { /* ... */ }
       set { /* ... */ }
   }

   void ClassA()
   {
       this[0] = new ClassB();
   }
}
</code></pre>

<p><strong>Note:</strong> I'm using g++</p>
","87234","","<p>Another solution is to follow the STL style by making an ""at"" function:</p>

<pre><code>const ClassB&amp; at(int index) const
{
    return /* get it by index */;
}

ClassB&amp; at(int index)
{
    return /* get it by index */;
}

const ClassB&amp; operator[](unsigned index) const
{
    return at(index);
}

ClassB&amp; operator[](unsigned index)
{
    return at(index);
}
</code></pre>

<p>But usually ""at"" does range checks (and possibly throws std::out_of_range) while [] does not, so you might make a private function (const and non-const) to factor both out:</p>

<pre><code>public:
    const ClassB&amp; at(int index) const
    {
        if ( /* out of range */ )
        {
            throw std::out_of_range( /* message */ );
        }

        return get(index);
    }

    ClassB&amp; at(int index)
    {
        if ( /* out of range */ )
        {
            throw std::out_of_range( /* message */ );
        }

        return get(index);
    }

    const ClassB&amp; operator[](unsigned index) const
    {
        return get(index);
    }

    ClassB&amp; operator[](unsigned index)
    {
        return get(index);
    }

private:
    const ClassB&amp; get(int index) const { return /* get it by index */; }
    ClassB&amp; get(int index) { return /* get it by index */; }
</code></pre>

<p>Now you only have to maintain your get functions. Now you can call ""get"" in your constructor, or at, or (*this)[].</p>

<p>But doing ""at"" and all that is more complete.</p>
"
"<p>Where is the correct place to initialize a class data member?
I have the class declaration in a header file like this:</p>

<p>Foo.h:</p>

<pre><code>class Foo {
private:
    int myInt;
};
</code></pre>

<p>Then I try to set a value to myInt in the corresponding .cpp file:</p>

<p>Foo.cpp:</p>

<pre><code>int Foo::myInt = 1;
</code></pre>

<p>I get a compiler error for redefining myInt. What am I doing wrong???</p>
","87234","","<p>To extend on Jared's answer, if you want to initialize it the way it is now, you need to put it in the Constructor.</p>

<pre><code>class Foo
{
public:
    Foo(void) :
    myInt(1) // directly construct myInt with 1.
    {
    }

    // works but not preferred:
    /*
    Foo(void)
    {
        myInt = 1; // not preferred because myInt is default constructed then assigned
                   // but with POD types this makes little difference. for consistency
                   // however, it's best to put it in the initializer list, as above
                   // Edit, from comment: Also, for const variables and references,
                   // they must be directly constructed with a valid value, so they
                   // must be put in the initializer list.
    }
    */

private:
    int myInt;
};
</code></pre>
"
"<pre><code>#include &lt;iostream&gt;
using namespace std;

class Foo
{

public:

 Foo(): initialised(0)
 {
  cout &lt;&lt; ""Foo() gets called AFTER test() ?!"" &lt;&lt; endl;
 };

 Foo test()
 {
  cout &lt;&lt; ""initialised= "" &lt;&lt; initialised &lt;&lt; "" ?! - "";
  cout &lt;&lt; ""but I expect it to be 0 from the 'initialised(0)' initialiser on Foo()"" &lt;&lt; endl;
  cout &lt;&lt; ""this method test() is clearly working on an uninitialised object ?!"" &lt;&lt; endl;
  return Foo();
 }

 ~Foo()
 {};

private:

 int initialised;

};


int main()
{

 //SURE this is bad coding but it compiles and runs
 //I want my class to DETECT and THROW an error to prevent this type of coding
 //in other words how to catch it at run time and throw ""not initialised"" or something

 Foo foo=foo.test();

}
</code></pre>
","87234","","<p><strong>You can't prevent people from coding poorly</strong>, really. It works just like it ""should"":</p>

<ol>
<li>Allocate memory for Foo (which is the value of the ""this"" pointer)</li>
<li>Going to Foo::test by doing: Foo::test(this), in which,</li>
<li>It gets the value by this->initialised, which is random junk, then it</li>
<li>Calls Foo's default constructor (because of return Foo();), then</li>
<li>Call Foo's copy constructor, to copy the right-handed Foo().</li>
</ol>

<p>Just like it should. You can't prevent people from not knowing the right way to use C++.</p>

<p>The best you could do is have a magic number:</p>

<pre><code>class A
{
public:
    A(void) :
    _magicFlag(1337)
    {
    }

    void some_method(void)
    {
        assert (_magicFlag == 1337); /* make sure the constructor has been called */
    }

private:
    unsigned _magicFlag;
}
</code></pre>

<p>This ""works"" because the chances _magicFlag gets allocated where the value is already 1337 is low.</p>

<p>But really, don't do this.</p>
"
"<pre><code>Linking... 
Directory.obj : error LNK2019: unresolved external symbol ""public: void __thiscall indexList&lt;class entry,100&gt;::read(class std::basic_istream&lt;char,struct std::char_traits&lt;char&gt; &gt; &amp;)"" (?read@?$indexList@Ventry@@$0GE@@@QAEXAAV?$basic_istream@DU?$char_traits@D@std@@@std@@@Z) referenced in function _main
</code></pre>

<p>Getting this error and others associated with indexList implementation. I have included all the right files, not sure what this means?</p>

<p><a href=""http://www2.cs.uregina.ca/%7Emouhoubm/=teaching/=cs170/=indexList/indexList.h"" rel=""nofollow"">indexList.h</a><br />
<a href=""http://www2.cs.uregina.ca/%7Emouhoubm/=teaching/=cs170/=indexList/indexList.cpp"" rel=""nofollow"">indexList.cpp</a>  </p>

<p>Also, using VS .NET 2003 - They are under the ""Source Files"" and ""Header Files"" However, I tested with deleting the indexLish.h and the error doesn't change? </p>
","87234","","<p>Your class is a templated class. This means when the compiler needs to call a function, it will look at your template definition and from that generate the corresponding code.</p>

<p>For example, the following has obvious errors in it:</p>

<pre><code>template &lt;typename T&gt;
void doSomething(const T&amp; something)
{
    ././.a/at983y62pegha9eg;
}
</code></pre>

<p>But as long as you don't call ""doSomething"", you won't get errors. The problem here is that you have this header file that tells the compiler, ""Hey, these functions exist"" but when the compiler tries to make them, it looks in your .h, but can't find the actual definition; that's because it is in your .cpp file.</p>

<p>This solution has <a href=""http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=52"" rel=""nofollow"">an answer</a>, but no major compiler vendors implement it. The best solution is to simply define the class in the .h file, or #include the .cpp file, such as you have commented out. Now the compiler (and then the file that included your header) knows what the functions look like so it can make correct instances of the template.</p>
"
"<p>i have a problem with my program. It should be program that recognize palindome through the stack. Everything works great, only thing that don't work is printing stacks(original and reversed) after the funcion is done.
Here is my entire code, and the problem is at case d and e:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;


const int MAXSTACK = 21;
class stack {
private:
    int  stop;  
    char stk[MAXSTACK];
public:
    stack();
    ~stack();
    stack(const stack&amp; s);
    void push(const char c);
    char pop();
    char top(void);
    int  emptystack(void);
    int  fullstack(void);
    void stack_print(void);
    int stack::create(void);
};
stack::stack()
{
    stop = 0;
}
stack::~stack() { }  
stack::stack(const stack&amp; s)
{
    stop = s.stop;
    strcpy(stk,s.stk);
}
void stack::push(const char c)
{
    stk[stop++] = c;
}
char stack::pop()
{
    return stop--;
}
char stack::top(void)
{
    return stk[stop - 1];
}
int  stack::emptystack(void)
{
    return !stop; 
}
int  stack::fullstack(void)
{
    return stop == MAXSTACK;
}
void stack::stack_print(void)
{
    for (int i=0; i&lt;stop; i++)
        cout&lt;&lt;stk[i];
    cout&lt;&lt;endl;
}
int  stack::create(void)
{
    return !stop; 
}
char menu()
{

    char volba;

    cout&lt;&lt;""\n"";
    cout&lt;&lt;"" **********.\n"";
    cout&lt;&lt;""\n"";
    cout&lt;&lt;"" a ... make new containers\n"";
    cout&lt;&lt;"" b ... delete content\n"";
    cout&lt;&lt;"" c ... enter string\n"";
    cout&lt;&lt;"" d ... print on screen first stack\n"";
    cout&lt;&lt;"" e ...  print on screen first stack\n"";
    cout&lt;&lt;"" f ... is it palindrom\n"";
    cout&lt;&lt;"" x ... exit\n"";
    cout&lt;&lt;""\n your choice : "";

    cin &gt;&gt;  volba;
    return volba;
}
int main() {
    char  palindrome[MAXSTACK]; 
    char volba;
    stack original,reversed;
    int   stackitems = 0,i;
    //cin.getline(palindrome,MAXSTACK);
    do{
        volba = menu();
        switch (volba)
        {
        case'a':
            {
                original.create();
                reversed.create();
                cout&lt;&lt;""done'"";
                break;
            }
        case'b':
            {
            original.emptystack();
            reversed.emptystack();
            cout&lt;&lt;""empty"";
            break;
            }
        case'c':
            {
                cout&lt;&lt;""enter your string""&lt;&lt;endl;
            cin.get();
            //cin.get();
            cin.getline(palindrome,MAXSTACK);
    for(int o = 0; o &lt; strlen(palindrome); o++)

        if (isalpha(palindrome[o]))
        {
            original.push(tolower(palindrome[o]));
            stackitems++;                           
        }
            original.stack_print();

        break;
            }
        case'd':
            {
                original.~stack();
                for(int g = 0; g &lt; strlen(palindrome); g++)
                original.push(tolower(palindrome[g]));
                original.stack_print();
            }
            /*//cin.getline(palindrome,MAXSTACK);
    for(int g = 0; g &lt; strlen(palindrome); g++)

        if (isalpha(palindrome[g]))
        {
            original.push(tolower(palindrome[g]));
            stackitems++;                           
        }

            }
            original.stack_print();*/
            break;


        /*{
                cout&lt;&lt;""original: "";
        original.stack_print();
                break;
            }*/
            break;
        case'e':
            {
            cout&lt;&lt;""reversed:""&lt;&lt;endl;
            for( i = 0; i &lt; stackitems; i++) {
            reversed.push(original.top());
            original.pop();
        }
        reversed.stack_print();
            }
            break;

        case'f':
            {
            for( i = 0; i &lt; stackitems / 2; i++) {
            reversed.push(original.top());
            original.pop();
        }


        if (stackitems % 2)
            original.pop();

        while (!original.emptystack()) {
            if (original.top() != reversed.top()) break;
            original.pop(); reversed.pop();
        }
        if (original.emptystack())
            cout &lt;&lt; ""it is palindrom\n"";
        else
            cout &lt;&lt; ""not palindrom\n"";

        break;

            }
        default:cout&lt;&lt;""!??!"";


        }
    } while(volba!='x');
}
</code></pre>
","87234","","<p>I'd like to add that maybe it would be easier to test your palindrome code if you just use std::stack in the meantime, and once that is figured out you can go back to a custom stack if you need (homework?).</p>

<p>Edit for comment:</p>

<p>To elaborate, I was asking if you wrote that Stack class because you had to, such as for a homework assignment, or for your own use? Because the standard library provides a stack for you:</p>

<pre><code>#include &lt;stack&gt;
</code></pre>

<p>Now you can make one:</p>

<pre><code>std::stack&lt;int&gt; intStack; // stack: {}
intStack.push(4); // stack: {4}
intStack.push(5); // stack: {4, 5}

int anInt = intStack.top(); // anInt is 5, stack is still {4, 5}

intStack.pop(); // stack: {4}
intStack.pop(); // stack: {}
</code></pre>

<p>With this you will not have to worry about stack functionality: you know it works.</p>

<p>Then you can focus more on the problem at hand.</p>
"
"<p>I'm using the pthread library on Linux.</p>

<p>I'm assigning a string in thread A, and then trying to print the string in thread B. However, the string just prints out empty (I have verified that it works in thread A).</p>

<p>Note: The string resides inside an object, which I suspect may be getting cleaned up or re-instantiated empty... The container object doesn't give me a seg fault or anything, just all the values are empty.</p>

<p>Is this because threads cannot access memory from other threads, or because the memory is being unallocated once thread A stops? Or is it neither; it could well be a bug in my code, but I just wanted to rule this out...</p>

<h3>Update:</h3>

<p>Turns out it was a memory issue. With thanks to your answers, I have also <a href=""http://stackoverflow.com/questions/724536/does-memory-stay-allocated-when-a-c-thread-exits/730868#730868"">answered this my self</a>, please do comment on my answer if you agree/disagree.</p>
","87234","","<p>How is B getting access to the string in A? Threads share the same global memory, so if you have something like:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

// global
std::string theString = ""I am a string."";

void theThread(void*)
{
    std::cout &lt;&lt; theString &lt;&lt; std::endl; // should work
}

int main(void)
{


    std::cout &lt;&lt; theString &lt;&lt; std::endl; //works, right?

    /* create thread */
    /* wait for thread to finish */

    return 0;
}
</code></pre>

<p>But if you have something like:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

void theThread(void* data)
{
    std::string theString = *(reinterpret_cast&lt;std::string*&gt;(data));

    std::cout &lt;&lt; theString &lt;&lt; std::endl; // see notes
}

int main(void)
{
    // local
    std::string theString = ""I am a string."";    

    std::cout &lt;&lt; theString &lt;&lt; std::endl; //works, right?

    /* create thread, passing &amp;theString to the thread */

    // Printing here should work!

    /* wait for thread to finish */

    return 0;
}
</code></pre>

<p>But if you begin leaving main as the thread begins getting the string, the thread might get a bogus string. The problem might be you not waiting for the thread.</p>

<p>Sorry I can't be more specific with the actual functions themselves, my thread experience is limited in POSIX, good in Windows, and...boost::thread rocks.</p>

<p>Hopefully something in there gives you an idea what might be wrong.</p>
"
"<p>C++ references have two properties:</p>

<ul>
<li>They always point to the same object.</li>
<li>They can not be 0.</li>
</ul>

<p>Pointers are the opposite:</p>

<ul>
<li>They can point to different objects.</li>
<li>They can be 0.</li>
</ul>

<p>Why is there no ""non-nullable, reseatable reference or pointer"" in C++? I can't think of a good reason why references shouldn't be reseatable.</p>

<p><strong>Edit:</strong>
The question comes up often because I usually use references when I want to make sure that an ""association"" (I'm avoiding the words ""reference"" or ""pointer"" here) is never invalid.</p>

<p>I don't think I ever thought ""great that this ref always refers to the same object"". If references were reseatable, one could still get the current behavior like this:</p>

<pre><code>int i = 3;
int& const j = i;</code></pre>

<p>This is already legal C++, but meaningless.</p>

<p><strong>I restate my question like this:</strong> ""What was the rationale behind the 'a reference <em>is</em> the object' design? Why was it considered useful to have references <em>always</em> be the same object, instead of only when declared as const?""</p>

<p>Cheers, Felix</p>
","87234","","<p>Because references represent the variable themselves.</p>

<p>When you make a reference to a variable, you shouldn't thinking of it as ""another way of accessing the variable"". You should think of it as being the variable itself. </p>

<p>How would you reset a reference, and what use would it be?</p>

<p><strong>EDIT:</strong></p>

<p>For clarification, the problem is in your sentence: ""[References] ...always point to the same object.""</p>

<p>References do not point; they <em>are</em>. (It just so happens they are implemented using pointers.)</p>

<p><strong>Edit for OP Edit:</strong></p>

<p>You're missing the point of references. Did you read <a href=""http://www.parashift.com/c%2B%2B-faq-lite/references.html#faq-8.1"" rel=""nofollow"">this</a>? A reference is an alias, it's just another way of accessing the same variable.</p>

<p>Here's a main reason:</p>

<p>I have a class that takes up 500 MB of memory, so copying this class is too expensive, which means a function:</p>

<pre><code>void do_something_with_fatty_class(FattyClass c);
</code></pre>

<p>Is not an option, since the original class will be copied onto the stack (500 MB!), and the function called. So in C, we did this:</p>

<pre><code>void do_something_with_fatty_class(FattyClass *c);
</code></pre>

<p>Which is great: The class is not copied and we can still access it. But the problem is if we don't check for null, doing this:</p>

<pre><code>do_something_with_fatty_class(0);
</code></pre>

<p>Will crash. Lots of functions have:</p>

<pre><code>if (!c) return; // return if function was passed null
</code></pre>

<p>At the top. The point of references was: You don't need to copy the object, but you also can NEVER* have a ""null"" reference. You don't need to check for null because it cannot happen, yet you've got the object. You have an <em>alias</em> to the object. Not a copy or pointer.</p>

<p>So reseating them would be bad: how would the syntax look? References are not like pointers, they don't point to an address. There isn't anything to change about a reference because a reference isn't a type. The reference itself takes no memory. The address of the reference is the address of the original, along with the size, operators, etc...it's just another way of getting some data, safely.</p>

<p>Not sure what else to add.</p>

<ul>
<li>Except when people do strange things, like another answer states. But if something does that they deserve a crash.</li>
</ul>
"
"<p>Can an application depend on two different versions of libstdc++ at the same time? (e.g.: libstdc++5 and libstdc++6)?  The scenario being - some binary depends on libstdc++ 6 but loads an .so that depends on libstdc++5...</p>

<p>Will that have any chance of working?</p>
","87234","","<p>I'm sure two libraries can co-exist as long as there are no multiple definition conflicts.</p>

<p>However, I think you can find at least <em>one</em> function signature that didn't change between versions. ;)</p>

<p>So I'm gonna go with no: they will conflict. But this is within the same application.</p>

<p>If you are dynamically (not static) linking with another library, you will not conflict.</p>
"
"<p>I'm having trouble iterating in reverse over a map in gcc c++. When I use a reverse iterator, it seems I can't assign anything to it - the compiler complains. I'm working around it with some awkward code using a forward iterator, but it's not very elegant. Any thoughts?  </p>
","87234","","<p>You mean something like:</p>

<pre><code>std::map&lt;std::string, std::string&gt; theMap;
/* do stuff */

for (std::map&lt;std::string, std::string&gt;::reverse_iterator iter = theMap.rbegin(); iter != theMap.rend(); ++iter)
{
    /* do more stuff */
}
</code></pre>

<p>Does not work? When you say ""the compiler complains"", we can only guess so much. How does it complain? Error? Warning?</p>
"
"<p>I'm writing a program where performance is quite important, but not critical. Currently I am reading in text from a <code>FILE*</code> line by line and I use <code>fgets</code> to obtain each line. After using some performance tools, I've found that 20% to 30% of the time my application is running, it is inside <code>fgets</code>.</p>

<p>Are there faster ways to get a line of text? My application is single-threaded with no intentions to use multiple threads. Input could be from stdin or from a file. Thanks in advance.</p>
","87234","","<p>You might try minimizing the amount of time you spend reading from the disk by reading large amounts of data into RAM then working on that. Reading from disk is slow, so minimize the amount of time you spend doing that by reading (ideally) the entire file once, then working on it.</p>

<p>Sorta like the way CPU cache minimizes the time the CPU actually goes back to RAM, you could use RAM to minimize the number of times you actually go to disk.</p>
"
"<p>I can call a setfocus and setcapture using a toggle mechanism and in OnLButtonDown make sure the message doesn't get passed on, but that seems to fail the moment you left click. Is there any way to ensure that the window which has capture and focus does not give it up?</p>
","87234","","<p>For a color picker, try reading <a href=""http://www.codeproject.com/KB/GDI/screencolorpicker.aspx"" rel=""nofollow"">this article</a> on getting colors from anywhere on screen.</p>

<p><a href=""http://www.codeproject.com/KB/applications/colour.aspx"" rel=""nofollow"">This one</a> is a more complete utility, let's you do what you want. The difference is capturing stops on a key combination [Alt+Ctrl+P], where you want to stop on a click.</p>

<p>In the second link, the following function calls will be useful for you:</p>

<pre><code>SetWindowPos(&amp;wndTopMost, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
RegisterHotKey(m_hWnd, 0x1FEB, MOD_CONTROL | MOD_ALT, 0x50);
</code></pre>

<p>The first one keeps the window active, and the second registers Alt+Ctrl+P (And when that is pressed the window will receive a WM_HOTKEY event, where upon you can stop capturing colors). Sadly you cannot use RegisterHotKey with mouse buttons. You will want to look into <a href=""http://msdn.microsoft.com/en-us/library/ms644990%28VS.85%29.aspx"" rel=""nofollow"">SetWindowsHookEx</a></p>

<p>With SetWindowsHookEx, you can make sure your application will receive events even without focus. Call SetWindowsHookEx with the hook ""WH_MOUSE"", along with a <a href=""http://msdn.microsoft.com/en-us/library/ms644988%28VS.85%29.aspx"" rel=""nofollow"">Mouse Procedure</a>.</p>

<p>It is in this procedure you will get the mouse message, stop capturing where the mouse moves (lock the color), and use SetWindowPos to move your window to the top. Then unregister your hook with <a href=""http://msdn.microsoft.com/en-us/library/ms644993%28VS.85%29.aspx"" rel=""nofollow"">UnhookWindowsHookEx</a>.</p>

<p>This is quite a bit of stuff you might need to learn, but all the MSDN pages I've linked you to have plenty of information that should help you out, not to mention if you're willing to settle with a key combination instead the second link is perfect for you.</p>

<p>Hope that helps.</p>
"
"<p>Is there any c function that allow me to convert a raw image to a PNG file?
Preferably, I don't need to pull in a big library for that. </p>

<p>Thank you.</p>
","87234","","<p>C does not have any built in image-manipulation functions. You will need to either write your own routine or use someone else's library.</p>
"
"<p>input X:</p>

<pre><code>if (0 &lt;= X and X &lt; 49)
    output ""abc""
else if (50 &lt;= X and X &lt; 70)
    output ""def""
else if (70 &lt;= X and X &lt; 85)
    output ""ghi""
else if (85 &lt;= X and X &lt; 100)
    output ""jkl""
endif
</code></pre>
","87234","","<p>They are nested, but formatted like they are not.</p>

<p>Your code is the same as:</p>

<pre><code>if (0 &lt;= X and X &lt; 49)
    output ""abc""
else
    if (50 &lt;= X and X &lt; 70)
        output ""def""
    else
        if (70 &lt;= X and X &lt; 85)
            output ""ghi""
        else
            if (85 &lt;= X and X &lt; 100)
                output ""jkl""
            endif
        endif
    endif
endif
</code></pre>

<p>This is not nested:</p>

<pre><code>if (0 &lt;= X and X &lt; 49)
    output ""abc""
endif
if (50 &lt;= X and X &lt; 70)
    output ""def""
endif
if (70 &lt;= X and X &lt; 85)
    output ""ghi""
endif
if (85 &lt;= X and X &lt; 100)
    output ""jkl""
endif
</code></pre>

<p>This is valid in all (?) languages that have if statements (ignoring things like using {} instead of endif)</p>

<p>However, some languages have an actual ""elseif"" (or ""elif"") command, in which case you will <strong>not</strong> nest, but written as ""else if"" you can assume it's just a differently formatted nest.</p>
"
"<p>I'd like to create a dll library from <strong>C++</strong> code and use it in <strong>C</strong> program.
I'd like to export only one function:</p>

<pre><code>GLboolean load_obj (const char *filename, GLuint &amp;object_list);
</code></pre>

<p>Header file from library:</p>

<pre><code>#ifndef __OBJ__H__
#define __OBJ__H__

#include &lt;windows.h&gt;  
#include &lt;GL/gl.h&gt;
#include &lt;GL/glext.h&gt;
#include &lt;GL/glu.h&gt;
#include &lt;GL/glut.h&gt;

#if defined DLL_EXPORT
#define DECLDIR __declspec(dllexport)
#else
#define DECLDIR __declspec(dllimport)
#endif

extern ""C"" GLboolean load_obj (const char *filename, GLuint &amp;object_list);

#endif // __3DS__H__
</code></pre>

<p>in .cpp (in library project) function is also declared as:</p>

<pre><code>extern ""C"" GLboolean load_obj (const char *filename, GLuint &amp;object_list)
{
 code...
}
</code></pre>

<p>File .lib is added in VS project options (Linker/Input/Additional dependencies). .dll is in folder where .exe is.
When I compile C project - error: </p>

<pre><code>Error   1	error C2059: syntax error : 'string'
</code></pre>

<p>It is about part ""extern ""C"" "" in header file.</p>

<p>I've tried to change header file to:</p>

<pre><code>extern GLboolean load_obj (const char *filename, GLuint &amp;object_list);
</code></pre>

<p>then</p>

<pre><code>Error   1	error C2143: syntax error : missing ')' before '&amp;'	
Error   2	error C2143: syntax error : missing '{' before '&amp;'	
Error   3	error C2059: syntax error : '&amp;'	
Error   4	error C2059: syntax error : ')'
</code></pre>

<p>and even when I changed <strong>&amp;</strong> to * appeared:</p>

<pre><code>Error   6	error LNK2019: unresolved external symbol _load_obj referenced in function _main	main.obj
</code></pre>

<p>I've no idea why it is wrong. .lib .h and .dll are properly added.</p>
","87234","","<p>C has no references, as David pointed out.</p>

<p>In addition, take out extern ""C"". C does not have a use for nor know about it.</p>

<p>If you need to share the header, do something like:</p>

<pre><code>#ifdef __cplusplus
    extern ""C"" {
#endif

/* extern ""C"" stuff */

#ifdef __cplusplus
    }
#endif
</code></pre>

<p>In C, __cplusplus won't be defined.</p>
"
"<p>I've asked a similar question on structs <a href=""http://stackoverflow.com/questions/744477/assignment-and-structs-in-c"">here</a> but I'm trying to figure out how C handles things like assigning variables and why it isn't allowed to assign them to eachother if they are functionally the same.</p>

<p>Lets say I have two arrays:</p>

<pre><code>int x[10];  
int y[10];
</code></pre>

<p>Why won't x = y compile?  If they are both the same ""signature"" like that, then shouldn't you be able to assign them back and forth?</p>

<p>Can I declare these in a way that would allow me to do that in C?  It makes sense to me that you would be able to, but maybe there is a way that this can be done?  Typedefs for structs seemed to be the solution, would it be the same for array declaration and assignment?</p>

<p>I appreciate your guys help, I'm new to Stackoverflow but it has been a really good resource for me so far!</p>
","87234","","<p>You have to look at what the variables represent. In your code, you now have two chunks of memory, both big enough to hold 10 integers.</p>

<p>Now, x[0] is the first chunks 0th integer, and y[0] is the seconds. But x itself is a pointer to the first element. Likewise, y is a pointer to the second chunk.</p>

<p>So saying x = y would try to assign x to now be pointing at y's chunk. And x's array is a lost forever. If you dynamically allocated these 2 chunks with malloc, you would be able to say ""x = y"", setting x to point to the second dynamically allocated chunk, but losing x's chunk forever (memory leak).</p>

<p>This error is the compiler preventing you from doing so. To copy each element, you have to loop through the arrays:</p>

<pre><code>for (int i = 0; i &lt; 10; ++i)
{
    x[i] = y[i];
}
</code></pre>
"
"<p>What does the following syntax mean?</p>

<pre><code>typedef void* hMyClass; //typedef as a handle or reference
hMyClass f = &amp;something;
const MyClass&amp; foo = static_cast&lt;MyClass&amp;&gt;(*f);
foo.bar();
</code></pre>
","87234","","<p>It's fairly unsafe code. Basically, this is happening:</p>

<pre><code>int *pointer_to_int = new int; // create int

void *pointer_to_anything =
    reinterpret_cast&lt;void*&gt;(pointer_to_int); // now store it in a void*

// later

int *another_pointer =
    reinterpret_cast&lt;int*&gt;(pointer_to_anything); // cast it back to int

*another_pointer = 5; // set the int to 5
</code></pre>

<p>That last line is unsafe because a void* can point to anything. What happens when, in your code, hMyClass does <strong>not</strong> point to a MyClass object? The cast will compile, but at runtime you'll (hopefully) crash.</p>

<p>That said, your code does not compile as is. hMyClass is a type (void*), not a variable. You would need something like:</p>

<pre><code>typedef void* hMyClass; //typedef as a handle or reference
hMyClass theHandle = /*something*/;

const MyClass&amp; foo = *static_cast&lt;MyClass*&gt;(*theHandle);
foo.bar();
</code></pre>

<p>** EDIT **</p>

<p>I fixed the code above, I missed an error. Anyway, the &amp; denotes a <a href=""http://www.parashift.com/c%2B%2B-faq-lite/references.html"" rel=""nofollow"">reference</a>. It differs from a pointer in that a reference is just an alias to a variable, while a pointer only points. There was a <a href=""http://stackoverflow.com/questions/728233/why-are-references-not-reseatable-in-c/"">thread on this recently</a>.</p>

<p>To go with the integer example above:</p>

<pre><code>int *pointer_to_int = new int; // create int

void *pointer_to_anything =
    reinterpret_cast&lt;void*&gt;(pointer_to_int); // now store it in a void*

// later
int *another_pointer =
    reinterpret_cast&lt;int*&gt;(pointer_to_anything); // cast it back to int

   *another_pointer = 5; // set the int to 5
// ^ this dereferences the pointer

int&amp; int_reference = *another_pointer;
// int_reference acts just like a normal integer,
// but is an alias to the original

int_reference = 2; // same as *another_pointer = 2
int_reference = *another_pointer; // no effect: the integer is still 2.
// this is because references are only assigned on the line they are defined.
// this line is the same as *another_pointer = *another_pointer,
// which has no effect

int normal_int = *another_pointer; // has the value of 2
normal_int = int_reference; // still has a value of 2

normal_int = 100; // normal_int is 100, but int_reference/another_pointer are
// both still 2, since normal_int is not a reference or pointer to the
// original integer

*another_pointer = -1; // the original int is now -1
// and since int_reference **is** the original int, it too is now -1.
// however, normal_int is still 100
</code></pre>

<p>Hope that helps. More information <a href=""http://en.wikipedia.org/wiki/Reference%5F%28C%2B%2B%29"" rel=""nofollow"">here</a> and <a href=""http://www.cprogramming.com/tutorial/references.html"" rel=""nofollow"">here</a>.</p>
"
"<p>Compare the following two pieces of code, the first using a reference to a large object, and the second has the large object as the return value. The emphasis on a ""large object"" refers to the fact that repeated copies of the object, unnecessarily, is wasted cycles.</p>

<p>Using a reference to a large object:</p>

<pre><code>void getObjData( LargeObj&amp; a )
{
  a.reset() ;
  a.fillWithData() ;
}

int main()
{
  LargeObj a ;
  getObjData( a ) ;
}
</code></pre>

<p>Using the large object as a return value:</p>

<pre><code>LargeObj getObjData()
{
  LargeObj a ;
  a.fillWithData() ;
  return a ;
}

int main()
{
  LargeObj a = getObjData() ;
}
</code></pre>

<p>The first snippet of code does not require copying the large object.</p>

<p>In the second snippet, the object is created inside the function, and so in general, a copy is needed when returning the object.  In this case, however, in <code>main()</code> the object is being declared. Will the compiler first create a default-constructed object, then copy the object returned by <code>getObjData()</code>, or will it be as efficient as the first snippet?</p>

<p>I think the second snippet is easier to read but I am afraid it is less efficient.</p>

<p><strong>Edit:</strong> Typically, I am thinking of cases <code>LargeObj</code> to be generic container classes that, for the sake of argument, contains thousands of objects inside of them. For example,</p>

<pre><code>typedef std::vector&lt;HugeObj&gt; LargeObj ;
</code></pre>

<p>so directly modifying/adding methods to <code>LargeObj</code> isn't a directly accessible solution.</p>
","87234","","<p>The second is the ""right"" way to do it, and in most cases the compiler will <a href=""http://www.parashift.com/c%2B%2B-faq-lite/ctors.html"" rel=""nofollow"">optimize it for you</a>.</p>

<p>However, if you want to be sure you can do the first method. When <a href=""http://en.wikipedia.org/wiki/C%2B%2B0x"" rel=""nofollow"">C++0x</a> rolls around, it will <a href=""http://blogs.msdn.com/vcblog/archive/2009/02/03/rvalue-references-c-0x-features-in-vc10-part-2.aspx"" rel=""nofollow"">not be a problem</a>:</p>

<pre><code>LargeObj&amp;&amp; getObjData()
{
  LargeObj a ;
  a.fillWithData() ;
  return a ;
}

int main()
{
  LargeObj a = getObjData(); // calls the move constructor
}
</code></pre>

<p>I'm no C++0x expert, tell me if that's wrong.</p>
"
"<p>For Operating Systems class I'm going to write a scheduling simulator entitled ""Jurrasic Park"".</p>

<p>The ultimate goal is for me to have a series of cars following a set path and passengers waiting in line at a set location for those cars to return to so they can be picked up and be taken on the tour. This will be a simple 2d, top-down view of the track and the cars moving along it.</p>

<p>While I can code this easily without having to visually display anything I'm not quite sure what the best way would be to implement a car moving along a fixed track.</p>

<p>To start out, I'm going to simply use OpenGL to draw my cars as rectangles but I'm still a little confused about how to approach updating the car's position and ensuring it is moving along the set path for the simulated theme park.</p>

<p>Should I store vertices of the track in a list and have each call to <code>update()</code> move the cars a step closer to the next vertex?</p>
","87234","","<p>You might find <a href=""http://en.wikipedia.org/wiki/Spline%5F%28mathematics%29"" rel=""nofollow"">Splines</a> useful.</p>
"
"<p>I know that if you leave a member out of an initialization list in a no-arg constructor, the default constructor of that member will be called.</p>

<p>Do copy constructors likewise call the copy constructor of the members, or do they also call the default constructor?</p>

<pre><code>class myClass {
  private:
    someClass a;
    someOtherClass b;
  public:
    myClass() : a(DEFAULT_A) {} //implied is b()
    myClass(const myClass&amp; mc) : a(mc.a) {} //implied is b(mc.b)??? or is it b()?
}
</code></pre>
","87234","","<p>Basically to expand Charlie's answer:</p>

<p>When you enter the body of a class constructor, every member of that class has to have been constructed. So when you hit {, you are guaranteed that all your members have been constructed.</p>

<p>And this means by calling their default constructor, unless of course you explicitly call another one.</p>

<p><hr /></p>

<h1>Information / Edit</h1>

<p>You didn't mark your edit, but I think it was the clarification on if it calls b's copy-constructor if not specified. The answer is no, it does do the default constructor, if a manual copy constructor is defined at all.</p>

<p>Here is a small program you can copy-paste somewhere and mess around with:</p>

<pre><code>#include &lt;iostream&gt;

class Foo
{
public:
    Foo(void)
    {
    	std::cout &lt;&lt; ""In Foo::Foo()"" &lt;&lt; std::endl;
    }

    Foo(const Foo&amp; rhs)
    {
    	std::cout &lt;&lt; ""In Foo::Foo(const Foo&amp;)"" &lt;&lt; std::endl;
    }
};

class Bar
{
public:
    Bar(void)
    {
    	std::cout &lt;&lt; ""In Bar::Bar()"" &lt;&lt; std::endl;
    }

    Bar(const Bar&amp; rhs)
    {
    	std::cout &lt;&lt; ""In Bar::Bar(const Bar&amp;)"" &lt;&lt; std::endl;
    }
};

class Baz
{
public:
    Foo foo;
    Bar bar;

    Baz(void)
    {
    	std::cout &lt;&lt; ""In Baz::Baz()"" &lt;&lt; std::endl;
    }

    Baz(const Baz&amp; rhs)
    {
    	std::cout &lt;&lt; ""In Baz::Baz(const Baz&amp;)"" &lt;&lt; std::endl;
    }
};

int main(void)
{
    Baz baz1;
    Baz baz2(baz1);

    return 0;
}
</code></pre>

<p>This as-is (defined copy-constructor) prints this:</p>

<pre><code>In Foo::Foo()
In Bar::Bar()
In Baz::Baz()
In Foo::Foo()
In Bar::Bar()
In Baz::Baz(const Baz&amp;)
</code></pre>

<p>So left as is, it calls default on both. </p>

<p><hr /></p>

<p>By commenting out the explicit copy constructor, like:</p>

<pre><code>/*
Baz(const Baz&amp; rhs)
{
	std::cout &lt;&lt; ""In Baz::Baz(const Baz&amp;)"" &lt;&lt; std::endl;
}
*/
</code></pre>

<p>The output will become this:</p>

<pre><code>In Foo::Foo()
In Bar::Bar()
In Baz::Baz()
In Foo::Foo(const Foo&amp;)
In Bar::Bar(const Bar&amp;)
</code></pre>

<p>That is, it calls the copy-constructor on both. So as you can see, once you explicitly declare a copy-constructor <em>you</em> are responsible for the copying of all class members; otherwise they will be default constructed.</p>

<p><hr /></p>

<p>To finish up, only explicitly call foo's copy-constructor, like:</p>

<pre><code>Baz(const Baz&amp; rhs) :
foo(rhs.foo)
{
	std::cout &lt;&lt; ""In Baz::Baz(const Baz&amp;)"" &lt;&lt; std::endl;
}
</code></pre>

<p>And you will get this:</p>

<pre><code>In Foo::Foo()
In Bar::Bar()
In Baz::Baz()
In Foo::Foo(const Foo&amp;)
In Bar::Bar()
In Baz::Baz(const Baz&amp;)
</code></pre>

<p>So it will still only default-construct your members.</p>

<p><hr /></p>

<h1>Conclusion</h1>

<p>When explicitly defining a copy-constructor, the compiler will no longer automatically copy <strong>any</strong> members for you.</p>
"
"<p>in C, what exactly are the performance benefits that come with observing strict aliasing?</p>
","87234","","<p>There is a page that describes aliasing very thoroughly <a href=""http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html"" rel=""nofollow"">here</a>.</p>

<p>There are also some SO topics <a href=""http://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule"">here</a> and <a href=""http://stackoverflow.com/questions/262379/when-is-char-safe-for-strict-pointer-aliasing"">here</a>.</p>

<p>To summarize, the compiler cannot assume the value of data when two pointers of different types are accessing the same location (i.e. it must read the value every time and therefore cannot make optimizations).</p>

<p>This only occurs when strict aliasing is not being enforced. Strict aliasing options:</p>

<ul>
<li>gcc: <strong>-fstrict-aliasing [default]</strong> and <strong>-fno-strict-aliasing</strong></li>
<li>msvc:
<strong>Strict aliasing is off by default.</strong>
(If somebody knows how to turn it on,
please say so.)</li>
</ul>

<hr>

<h1>Example</h1>

<p>Copy-paste this code into main.c:</p>

<pre><code>void f(unsigned u)
{
    unsigned short* const bad = (unsigned short*)&amp;u;
} 

int main(void)
{
    f(5);

    return 0;
}
</code></pre>

<p>Then compile the code with these options:</p>

<blockquote>
  <p>gcc main.c -Wall -O2</p>
</blockquote>

<p>And you will get:</p>

<blockquote>
  <p>main.c:3:
  warning: dereferencing type-punned
  pointer will break strict-aliasing
  rules</p>
</blockquote>

<p>Disable aliasing with:</p>

<blockquote>
  <p>gcc main.c -fno-strict-aliasing
  -Wall -O2</p>
</blockquote>

<p>And the warning goes away. (Or just take out -Wall but...don't compile without it)</p>

<p>Try as I might I could not get MSVC to give me a warning.</p>
"
"<p>When I moved a program from a Mac to this Windows PC, the VC++ 2008 compiler is giving me errors for passing unsigned ints to the cmath pow() function. As I understand, this function is not overloaded to accept anything but floating-point numbers.</p>

<p>Is there some compiler flag/setting that will ignore these errors? Also does anyone know how to find the documentation on the VC++ compiler?</p>

<p>Thanks!</p>

<p>EDIT: This isn't a <em>warning</em>, it's an <em>error</em>. However, for me it's not an issue since my program is only dealing with numbers that come out as integers, so I don't care that they aren't floats. If it was just warnings I would move on with my life, but it's not letting me compile. Can I suppress errors somehow? Like I said, the errors aren't coming up on my Mac and the program is fine.</p>
","87234","","<p>Don't ignore warnings, fix them. Cast your number to a float with static_cast before you call pow().</p>
"
"<p>I know <em>unsigned int</em> can't hold negative values. But the following code compiles without any errors/warnings.</p>

<pre><code>unsigned int a = -10;
</code></pre>

<p>When I print the variable <em>a</em>, I get a wrong value printed. If unsigned variables can't hold signed values, why do compilers allow them to compile without giving any error/warning?</p>

<p>Any thoughts?</p>

<p><strong>Edit</strong></p>

<p>Compiler : VC++ compiler</p>

<p><strong>Solution</strong></p>

<p>Need to use the warning level 4.</p>
","87234","","<h3>Microsoft Visual C++:</h3>

<blockquote>
  <p>warning C4245: 'initializing' :
  conversion from 'int' to 'unsigned
  int', signed/unsigned mismatch</p>
</blockquote>

<p>On warning level 4.</p>

<h3>G++</h3>

<p>Gives me the warning:</p>

<blockquote>
  <p>warning: converting of negative value
  <code>-0x00000000a' to </code>unsigned int'</p>
</blockquote>

<p>Without any -W directives.</p>

<h3>GCC</h3>

<p>You must use:</p>

<blockquote>
  <p>gcc main.c -Wconversion</p>
</blockquote>

<p>Which will give the warning:</p>

<blockquote>
  <p>warning: negative integer implicitly converted to unsigned type</p>
</blockquote>

<p>Note that -Wall will not enable this warning.</p>

<p><hr /></p>

<p>Maybe you just need to turn your warning levels up. </p>
"
"<pre><code>int num = n/4;
for (int i = 1; i &lt;= num; i++) {
    for (int j = 1; j &lt;= n; j++) {
        for (int k = 1; k &lt;= n; k++) {
            int count = 1;
        }
    }
}
</code></pre>

<p>According to the books I have read, this code should be O((n^3)/4). But apparently its not. to find the Big-O for nested loops are you supposed to multiply the bounds? So this one should be num *n *n or n/4 *n *n.</p>
","87234","","<p>The outer loop is N. The second loop is N/4, and is executed N times, giving N^2/4, or O(N^2).</p>

<p>The last loop is N/4, and is executed N^2/4 times, giving N^3/4.</p>

<p>However, in big-O, it's just O(N^3).</p>
"
"<p>Is there a template that can be used to create threads when we program in
OO language ?</p>

<p>How to go about designing a threading package for an OO language?</p>
","87234","","<h3>Support</h3>

<p>C++0x will support threads in the <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2320.html"" rel=""nofollow"">standard library</a>.</p>

<p>As of now, each platform has its own way of implementing threads (<a href=""http://www.boost.org/doc/libs/1%5F38%5F0/doc/html/thread.html"" rel=""nofollow"">Windows</a>, <a href=""http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html"" rel=""nofollow"">POSIX</a>) but you can use something such as <a href=""http://www.boost.org/doc/libs/1%5F38%5F0/doc/html/thread.html"" rel=""nofollow"">boost::thread</a> to not have to worry about platform-specific stuff.</p>

<p>In Java, there is a <a href=""http://www.javaworld.com/javaworld/jw-04-1996/jw-04-threads.html"" rel=""nofollow"">Thread class</a>.</p>

<h3>Methods</h3>

<p>In general, to put a class into another thread, you will create a thread while passing that class into the thread. Then the thread will call a function in that class. Here is some pseudo-C++-code:</p>

<pre><code>main()
{
    Object myObject;

    thread = CreateThread(threadFunction, myObject);

    thread.join(); // wait for thread
}

threadFunction(Object theObject)
{
    theObject.doSomething();
}
</code></pre>

<p>This is all simplified by the use of boost (or C++0x threads) in C++, and the Thread class in Java handles this for you.</p>

<h3>Related Information</h3>

<p>A large problem in threaded applications is synchronization of threads. This includes problems like <a href=""http://en.wikipedia.org/wiki/Race%5Fcondition"" rel=""nofollow"">race conditions</a> and <a href=""http://en.wikipedia.org/wiki/Deadlock"" rel=""nofollow"">deadlocks</a>, to name a couple.</p>

<p>Methods/object exist to help these problems, such as a <a href=""http://en.wikipedia.org/wiki/Mutual%5Fexclusion"" rel=""nofollow"">mutex</a>. A mutex can be locked by one thread, and any other threads that try to lock the mutex will be blocked until the original thread releases the mutex.</p>

<p>A <a href=""http://en.wikipedia.org/wiki/Semaphore%5F%28programming%29"" rel=""nofollow"">semaphore</a> is a generalized mutex.</p>

<p>There are other useful concepts as outlined in Eric's post.</p>
"
"<p>It seems difficult  to design a threading package in OO class than in
functional programming.</p>
","87234","","<p>Do you have a specific question? You have asked an extremely similar <a href=""http://stackoverflow.com/questions/771298/how-to-create-a-thread-in-a-class"">question here</a>, and I would call this one a duplicate. You can look at the design and answers in that thread to give you an idea.</p>

<p>But we cannot help you until you ask a specific question.</p>
"
"<p>Let's say I have a struct defined as:</p>

<pre><code>typedef
struct number{
    int areaCode;
    int prefix;
    int suffix;
} PhoneNumber;
</code></pre>

<p>When I create an instance of this struct, if I use the following syntax:</p>

<pre><code>PhoneNumber homePhone = {858, 555, 1234};
</code></pre>

<p>...which constructor is it calling? The default constructor, or the copy constructor, or none at all because it's not calling 'new'?</p>

<p>The real purpose of this question is to figure out how I can add a fourth field. So I want to re-define my struct as:</p>

<pre><code>typedef
struct number{
    int areaCode;
    int prefix;
    int suffix;
    int extension; // NEW FIELD INTRODUCED
} PhoneNumber;
</code></pre>

<p>So now, I can create new PhoneNumber objects with FOUR fields:</p>

<pre><code>PhoneNumber officePhone = {858, 555, 6789, 777}
</code></pre>

<p>However, I have hundreds of these PhoneNumber instances already created with only 3 fields (xxx, xxx, xxxx). So I don't want to go through and modify EVERY single instantiation of my PhoneNumber object that is already defined. I want to be able to leave those alone, but still be able to create new phone number instances with FOUR fields.  So I am trying to figure out how I can overwrite the constructor so that my existing three-parameter instantiations will not break, but it will also support my new four-parameter instantiations.</p>

<p>When I try to define an overriding default constructor that takes 3 fields and sets the fourth to a default value '0', I get errors (in the instantiation part of the code, not the constructor definition) complaining that my object must be initialized by constructor, not by {...}. So it seems that if I do override the default constructor, I can no longer use curly braces to create my new objects?</p>

<p>Sorry if this strays away from the original questions completely. </p>
","87234","","<blockquote>
  <p>none at all because it's not calling
  'new'?</p>
</blockquote>

<p>Just for the record, any object will always have a constructor called. You cannot use an object that has not been constructed.</p>
"
"<p>I generally will always write conditional code along the lines of</p>

<pre><code>if (number==1) 
    name=""a"";
if (number==2)
    name=""b"";
</code></pre>

<p>no matter how short, although I find a fair chunk of people writing </p>

<pre><code>if (number==1) name =""a"";
if (number==2) name =""b""...
</code></pre>

<p>To me this seems inconsistent, and actually makes the code look messier.</p>

<p>What is the best way to do this?</p>
","87234","","<p>I always write my conditionals the same:</p>

<pre><code>if (number == 1)
{
    name = ""a"";
}
else if (number == 2)
{
    name = ""b"";
}
</code></pre>

<p>It's easy to read and consistent. Consistent with if statements that have more than one statement, etc...</p>

<p><hr /></p>

<h3>Edit</h3>

<p>To expand on this, I try to follow this rule:</p>

<blockquote>
  <p>Each line does one thing.</p>
</blockquote>

<p>That is, each line should execute one statement (and scope should be easily visible). So I do not prefer:</p>

<pre><code>if (number==1) name =""a"";
</code></pre>

<p>Because two things are happening on one line, which makes reading and debugging more difficult than it should be. So I would move to:</p>

<pre><code>if (number==1)
    name =""a"";
</code></pre>

<p>But this has the problem that it's inconsistent with a multi-statement if. That's why (as other have stated) it's good to place brackets around things:</p>

<pre><code>if (number==1)
{
    name =""a"";
}
</code></pre>

<p>The reason I prefer the '{' on it's own line is that when I scan the code, I can quickly identify where a scope begins and ends. It also follows the one statement rule, since having 'if' and '{' does an if statement <em>and</em> starts a new scope.</p>

<p>I do not think that, ""it saves vertical whitespace"" is a good enough reason to skip readability and good formatting (both {}'s on the same column == sexy). This is because considering the resolution of today's monitors, you don't need to struggle to view code.</p>
"
"<p>I have developed a reverse-string program. I am wondering if there is a better way to do this, and if my code has any potential problems. I am looking to practice some advanced features of C. </p>

<pre><code>char* reverse_string(char *str)
{
char temp;
size_t len = strlen(str) - 1;
size_t i;
size_t k = len;

for(i = 0; i &lt; len; i++)
{
	temp = str[k];
	str[k] = str[i];
	str[i] = temp;
	k--;

	    /* As 2 characters are changing place for each cycle of the loop
	       only traverse half the array of characters */
	    if(k == (len / 2))
	    {
	   	    break;
	    }
    }
}
</code></pre>
","87234","","<p>Just a rearrangement, and safety check. I also removed your non-used return type. I think this is a safe and clean as it gets:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void reverse_string(char *str)
{
    /* skip null */
    if (str == 0)
    {
    	return;
    }

    /* skip empty string */
    if (*str == 0)
    {
    	return;
    }

    /* get range */
    char *start = str;
    char *end = start + strlen(str) - 1; /* -1 for \0 */
    char temp;

    /* reverse */
    while (end &gt; start)
    {
    	/* swap */
    	temp = *start;
    	*start = *end;
    	*end = temp;

    	/* move */
    	++start;
    	--end;
    }
}


int main(void)
{
    char s1[] = ""Reverse me!"";
    char s2[] = ""abc"";
    char s3[] = ""ab"";
    char s4[] = ""a"";
    char s5[] = """";

    reverse_string(0);

    reverse_string(s1);
    reverse_string(s2);
    reverse_string(s3);
    reverse_string(s4);
    reverse_string(s5);

    printf(""%s\n"", s1);
    printf(""%s\n"", s2);
    printf(""%s\n"", s3);
    printf(""%s\n"", s4);
    printf(""%s\n"", s5);

    return 0;
}
</code></pre>

<p>Edited so that end will not point to a possibly bad memory location when strlen is 0.</p>
"
"<p>Accidentally I pressed some keys while writing C# code in VS2008 and space characters replaced by . and enter key replaced by some square boxes, now how do I reset the editor
<img src=""http://lh4.ggpht.com/%5FM5W2QFQgto4/SfFzUDSaH5I/AAAAAAAADUg/cieNm6UXXHQ/dots.jpg"" alt=""alt text"" /></p>
","87234","","<p>You're probably viewing whitespace, duplicate topic here:</p>

<p><a href=""http://stackoverflow.com/questions/784039/how-do-i-get-rid-of-the-dots"">http://stackoverflow.com/questions/784039/how-do-i-get-rid-of-the-dots</a></p>
"
"<p>How would i make it so in my program there is a button when that button is clicked i want it to play a .wma file without opening and media player?</p>
","87234","","<p>The C++ standard does not include this functionality. That means it depends on what your system offers.</p>

<p>For Windows, you can try something like <a href=""http://msdn.microsoft.com/en-us/library/ms712879.aspx"">PlaySound</a>.</p>

<p>However, you best bet is to use a pre-existing library, like:</p>

<ul>
<li><a href=""http://connect.creativelabs.com/openal/default.aspx"">OpenAL</a></li>
<li><a href=""http://www.un4seen.com/"">BASS</a></li>
<li><a href=""http://www.fmod.org/"">FMOD</a></li>
<li><a href=""http://www.libsdl.org/"">SDL</a>'s: <a href=""http://www.libsdl.org/intro.en/usingsound.html"">Sound</a>.</li>
</ul>

<p>Googling for <a href=""http://www.google.com/search?ie=UTF-8&amp;oe=UTF-8&amp;sourceid=navclient&amp;gfns=1&amp;q=C%2B%2B%2BSound%2BLibrary"">C++ Sound Library</a> brings up a lot of information.</p>

<p>Also, check out these three other <a href=""http://stackoverflow.com/search?q=c%2B%2B%2Bplay%2Bsound"">SO topics</a>:</p>

<ul>
<li><a href=""http://stackoverflow.com/questions/314522/what-is-the-best-c-sound-api-for-windows"">What Is The Best C++ Sound API For Windows?</a></li>
<li><a href=""http://stackoverflow.com/questions/428884/how-to-play-mp3-files-in-c"">How to play MP3 files in C?</a></li>
<li><a href=""http://stackoverflow.com/questions/711350/learning-to-work-with-audio-in-c"">Learning to work with audio in C++</a></li>
</ul>
"
"<p>Can anbody explain me how <code>settimer</code> works in vc++, and what are its parameters?</p>
","87234","","<p><a href=""http://msdn.microsoft.com/en-us/library/ms644906.aspx"" rel=""nofollow"">MSDN says this</a>.</p>

<p>And here is an <a href=""http://msdn.microsoft.com/en-us/library/ms644901%28VS.85%29.aspx"" rel=""nofollow"">example</a>.</p>
"
"<p>Knowing an edge is defined by both <strong>initial</strong> and <strong>final</strong> vertices,
How do you call edges coming <strong>from</strong> and <strong>to</strong> a vertex ?
For now, I name those <strong>incoming</strong> and <strong>outgoing</strong>.</p>

<p>Thanks.</p>
","87234","","<p><a href=""http://en.wikipedia.org/wiki/Graph%5F%28mathematics%29"" rel=""nofollow"">Wikipedia</a> has lots of <a href=""http://en.wikipedia.org/wiki/Graph%5Ftheory"" rel=""nofollow"">information</a> for you. I know them as Inward and Outward edges.</p>
"
"<p>I have tried wcscat() but i get a runtime access violation.</p>

<pre><code>wchar_t* a = L""aaa"";
wchar_t* b = L""bbb"";
wchar_t* c;
c = wcscat(a, b);
</code></pre>

<p>Can somebody tell me what is wrong here? Or another way to solve my problem? Thanks</p>
","87234","","<p>Why not use std::wstring? Here's a <a href=""http://stackoverflow.com/questions/402283/stdwstring-vs-stdstring/402918#402918"">great answer</a> explaining it. </p>

<p>Here is your code with wstring:</p>

<pre><code>#include &lt;string&gt;

int main(void)
{
    std::wstring a(L""aaa"");
    std::wstring b(L""bbb"");

    std::wstring c = a + b;

    return 0;
}
</code></pre>

<p>To answer your actual question though, you are using <a href=""http://msdn.microsoft.com/en-us/library/ms860384.aspx"" rel=""nofollow"">wcscat</a> incorrectly. Try like this:</p>

<pre><code>#include &lt;string&gt;

int main(void)
{
    // constant wchar_t
    const wchar_t *a = L""aaa"";
    const wchar_t  *b = L""bbb"";

    // buffer for concatenation, could change to a call to new
    wchar_t c[50] = {0};

    // add a to c, then b to c (ending up with a + b)
    wcscat(c, a);
    wcscat(c, b);

    // would free memory here if you used new
    return 0;
}
</code></pre>
"
"<p>What is the difference between the following declarations:</p>

<pre><code>int* arr1[8];
int (*arr2)[8];
int *(arr3[8]);
</code></pre>

<p>What is the general rule for understanding more complex declarations?</p>
","87234","","<p>I don't know if it has an official name, but I call it the Right-Left Thingy(TM).</p>

<p>Start at the variable, then go right, and left, and right...and so on.</p>

<pre><code>int* arr1[8];
</code></pre>

<p><em>arr1 is an array of 8 pointers to integers.</em></p>

<pre><code>int (*arr2)[8];
</code></pre>

<p><em>arr2 is a pointer (the parenthesis block the right-left) to an array of 8 integers.</em></p>

<pre><code>int *(arr3[8]);
</code></pre>

<p><em>arr3 is an array of 8 pointers to integers.</em></p>

<p>This should help you out with complex declarations.</p>
"
"<p>Here's a constructor for my Game class:</p>

<pre><code>// Construct a Game to be played with player on a copy of the board b.
Game(const Board&amp; b, Player* player)
{
  ...
}
</code></pre>

<p>Here's how I'm using the constructor:</p>

<pre><code>Player p(""Player Name"");
Board b(6,3);
Game g(b, &amp;p);
</code></pre>

<p>How does this work? Is b being copied?</p>

<p>If I want to save a pointer to player, should I create a private ivar like the following?</p>

<pre><code>private:
  Player* _player;

...
// In Game constructor
_player = player;
</code></pre>
","87234","","<p>You are passing the board by <a href=""http://www.parashift.com/c%2B%2B-faq-lite/references.html"" rel=""nofollow"">reference</a>, so no, it is not being copied.</p>

<p>If you have some code later like:</p>

<pre><code>Board _privateBoard = b;
</code></pre>

<p>Then you are copying <strong>b</strong>. But it isn't getting copied into the function.</p>

<p>As for your question, yes you'll need to store the pointer somewhere if you want to get it back.</p>
"
"<p>I have a <code>for</code> loop generating integers. </p>

<p>For instance:</p>

<pre><code>for (int i=300; i&gt;200; i--)
    {(somefunction)*i=n;
    cout&lt;&lt;n;
    }
</code></pre>

<p>This produces an output on the screen like this:</p>

<pre><code>f=00000000000100023;
</code></pre>

<p>I want to store the 100023 part of this number (i.e just ignore all the zeros before the non zero numbers start but then keeping the zeros which follow) as an array.</p>

<p>Like this:</p>

<pre><code>array[0]=1;
array[1]=0;
array[2]=0;
array[3]=0;
array[4]=2;
array[5]=3;
</code></pre>

<p>How would I go about achieving this?</p>
","87234","","<p>This is a mish-mash of answers, because they are all there, I just don't think you're seeing the solution.</p>

<p>First off, if they are integers <a href=""http://stackoverflow.com/questions/879375/how-can-i-remove-the-leading-zeroes-from-an-integer-generated-by-a-loop-and-store/879446#879446"">Bill's answer</a> along with the other answers are great, save some of them skip out on the ""store in array"" part. Also, as pointed out in a comment on your question, this part is <a href=""http://stackoverflow.com/questions/515612/convert-an-integer-number-into-an-array"">a duplicate</a>.</p>

<p>But with your new code, the solution I had in mind was <a href=""http://stackoverflow.com/questions/879375/how-can-i-remove-the-leading-zeroes-from-an-integer-generated-by-a-loop-and-store/879525#879525"">John's solution</a>. You just need to figure out how to ignore leading zero's, which is easy:</p>

<pre><code>std::vector&lt;int&gt; digits;
bool inNumber = false;

for (int i=300; i&gt;200; i--)    
{
    int value = (somefunction) * i;

    if (value != 0)
    {
        inNumber = true; // its not zero, so we have entered the number
    }

    if (inNumber)
    {
        // this code cannot execute until we hit the first non-zero number
        digits.push_back(value);
    }
}
</code></pre>

<p>Basically, just don't start pushing until you've reached the actual number.</p>
"
"<p>How do I remove an element of an array and shift the remaining elements down. So, if I have an array, </p>

<pre><code>array[]={1,2,3,4,5} 
</code></pre>

<p>and want to delete 3 and shift the rest so I have,</p>

<pre><code>array[]={1,2,4,5}
</code></pre>

<p>How would I go about this in the least amount of code?</p>
","87234","","<p>You just need to overwrite what you're deleting with the next value in the array, propagate that change, and then keep in mind where the new end is:</p>

<pre><code>int array[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};

// delete 3 (index 2)
for (int i = 2; i &lt; 8; ++i)
    array[i] = array[i + 1]; // copy next element left
</code></pre>

<p>Now your array is <code>{1, 2, 4, 5, 6, 7, 8, 9, 9}</code>. You cannot delete the extra <code>9</code> since this is a statically-sized array, you just have to ignore it. This can be done with <code>std::copy</code>:</p>

<pre><code>std::copy(array + 3, // copy everything starting here
          array + 9, // and ending here, not including it,
          array + 2) // to this destination
</code></pre>

<p>In C++11, use can use <code>std::move</code> (the algorithm overload, not the utility overload) instead.</p>

<p>More generally, use <code>std::remove</code> to remove elements matching a value:</p>

<pre><code>// remove *all* 3's, return new ending (remaining elements unspecified)
auto arrayEnd = std::remove(std::begin(array), std::end(array), 3);
</code></pre>

<p>Even more generally, there is <code>std::remove_if</code>.</p>

<p>Note that the use of <code>std::vector&lt;int&gt;</code> may be more appropriate here, as its a ""true"" dynamically-allocated resizing array. (In the sense that asking for its <code>size()</code> reflects removed elements.)</p>
"
"<p>is there any way to build/run small C++ programs,  in Visual Studio without creating projects, like in old days in IDEs like turbo c++ you could just compile and run without creating projects.</p>

<p>Thanks in advance!</p>
","87234","","<p>Within the actual IDE, I don't think it's possible to run a small program, you have to use the command line like Matt suggested.</p>

<p>The solution I have for this problem, is that I have one project on my computers called ""sandbox"", which just has a main.cpp, and it's where I can mess around.</p>

<p>It let's me try things out here and there, but I never have to keep starting a new project.</p>
"
"<p>if I compile (under G++) and run the following code it prints ""Foo::Foo(int)"". However after making copy constructor and assignment operators private, it fails to compile with the following error: ""error: ‘Foo::Foo(const Foo&amp;)’ is private"". How comes it needs a copy constructor if it only calls standard constructor at runtime?</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

struct Foo {
    Foo(int x) {
        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;
    }


    Foo(const Foo&amp; f) {
        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;
    }

    Foo&amp; operator=(const Foo&amp; f) {
        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;
        return *this;
    }
};

int main() {
    Foo f = Foo(3);
}
</code></pre>
","87234","","<p>When you say <code>Foo f = Foo(3)</code>, it's going to make a temporary Foo constructed from 3, then copy construct it into f.</p>

<p>You want:</p>

<pre><code>Foo f(3);
</code></pre>

<p>You might also notice that even though you are saying =, it uses the copy constructor. The compiler will directly construct f from a copy of the temporary when using this syntax.</p>

<p>It will actually call operator= if you say something like:</p>

<pre><code>Foo f;
f = Foo(3);
</code></pre>
"
"<p>Variable <code>x</code> is int with possible values: <code>-1, 0, 1, 2, 3</code>.
Which expression will be faster (in CPU ticks):</p>

<pre><code>1. (x &lt; 0)
2. (x == -1)
</code></pre>

<p>Language: C/C++, but I suppose all other languages will have the same.</p>

<p>P.S. I personally think that answer is <code>(x &lt; 0)</code>.</p>

<p>More widely for gurus: what if <code>x</code> from <code>-1</code> to <code>2^30</code>?</p>
","87234","","<p>Why? Whichever you do, the compiler will optimize it on whatever platform you are currently compiling on.</p>

<p>If you need to check if it's -1, use (x == -1), if you want to know if it's less than zero, use that one instead. Write what you would read out loud.</p>

<p>Tiny things like this won't make anything faster, and you should be worried about readability and clean design rather than which tiny operation is faster.</p>

<p>And even if it doesn't do any logical changes, chances are on your platform, <strong>both will perform in one CPU cycle</strong>.</p>
"
"<p>I've always wondered, if it's good or bad practice to define trivial method twice, depending
<br>if the project's on debug / release -state. This is for inlining them. For instance, Foo.h:</p>

<pre><code>
class Foo
{
        public:
                ...

                const bool& IsBoolean() const;

        private:
                bool _boolean;
};

#ifndef _DEBUG

/** We're in release, so let's advice compiler to inline this...
  *
  *
  */

inline const bool& Foo::IsBoolean() const
{
        return _boolean;
}

#endif

</code></pre>

<p>And now, in Foo.cpp:</p>

<pre><code>
#include ""Foo.h""

...

#ifdef _DEBUG

/** We're debugging this, no need for inlining...
  *
  *
  */

const bool& Foo::IsBoolean() const
{
        return _boolean;
}

#endif
</code></pre>

<p>Is this completely useless? For example due to compiler's (MSVC) ability to inline / optimize methods all by itself?<br><br>
Nevertheless, this is something I've been using for years now. Please correct me, if I'm completely wrong here...</p>
","87234","","<p>Wow, that's a lot of duplicate code if I understand this correctly. And just for the alone I'd say this is not a good thing. What a nightmare to maintain. =O</p>

<p>Just place the implementation in the .cpp file, and if you feel the need, mark the function as inline.</p>

<p>But yes, any decent compiler will inline anything it wants or ignore inlining on anything it does not want.</p>

<p>Work on clean design, and the compiler will have an easier time inlining anyway.</p>
"
"<p>Basically what I want to do is, depending on the some variable, to cast a void pointer into a different datatype.  For example (the 'cast' variable is just something in order to get my point across):</p>

<pre><code>void* ptr = some data;
int temp = some data;
int i = 0;

...

if(temp == 32)      cast = (uint32*)
else if(temp == 16) cast = (uint16*)
else                cast = (uint8*)

i = someArray[*((cast)ptr)];
</code></pre>

<p>Is there anything in C++ that can do something like this (since you can't actually assign a variable to be just (uint32*) or something similar)?  I apologize if this isn't clear, any help would be greatly appreciated.</p>
","87234","","<p>Perhaps <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/doc/html/any.html"" rel=""nofollow"">boost::any</a> would be of interest.</p>
"
"<p>For a program of mine I made a small function to clear the various std::vectors of pointers that I have.</p>

<pre><code>template &lt;class S&gt;
void clearPtrVector(std::vector&lt;S*&gt; &amp;a,int size)
{
    for(size_t i = 0; i &lt; size; i++)
         delete a[i];

    a.clear();
}
</code></pre>

<p>I must have done something wrong here though since when calling this function in a destructor like so :</p>

<pre><code>clearPtrVector(neurons,neurons.size());
</code></pre>

<p>I get the following undefined reference two times:</p>

<pre><code>undefined reference to `void clearPtrVector&lt;Neuron&gt;(std::vector&lt;Neuron*,std::allocator&lt;Neuron*&gt; &gt;&amp;, int)'
</code></pre>

<p>I have to admit I am not familiar with what the std::allocator is, so I can not guess what the problem might be here. Any help is really appreciated. Thanks in advance!</p>

<p>-Lefteris</p>
","87234","","<p>A few things:</p>

<p>In your original code, don't pass in the size; just get it from the vector:</p>

<pre><code>template &lt;class S&gt;
void clearPtrVector(std::vector&lt;S*&gt; &amp;a)
{
    for(size_t i = 0; i &lt; a.size(); ++i)
    {
         delete a[i];
    }

    a.clear();
}
</code></pre>

<p>Secondly, just pass in the vector itself, not the type it points to:</p>

<pre><code>template &lt;class Vector&gt;
void clearPtrVector(Vector &amp;vec)
{
    for(size_t i = 0; i &lt; vec.size(); ++i)
    {
         delete vec[i];
    }

    vec.clear();
}
</code></pre>

<p>Thirdly, that error sounds like you have it placed in a .cpp file. The code will be generated when you first call the function, which means the compiler needs to know the definition of the function. Move the function into the header file, so the compiler can find it.</p>

<p>Lastly, consider using things more suited to this:</p>

<ul>
<li><a href=""http://www.boost.org/doc/libs/1%5F35%5F0/libs/ptr%5Fcontainer/doc/ptr%5Fcontainer.html"" rel=""nofollow"">Boost Pointer Container</a></li>
<li>A std::vector with a <a href=""http://www.boost.org/doc/libs/1%5F38%5F0/libs/smart%5Fptr/smart%5Fptr.htm"" rel=""nofollow"">smart pointer</a>, specifically a <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/smart%5Fptr/shared%5Fptr.htm"" rel=""nofollow"">shared_ptr</a>, as <a href=""http://www.cplusplus.com/reference/std/memory/auto%5Fptr/"" rel=""nofollow"">auto_ptr</a> will not work.</li>
</ul>
"
"<p>I have a class in c++ a portion of which is below</p>

<pre><code>class Node{
    public:
       vector&lt;string&gt; getNames() const;
    private:
        vector&lt;string&gt; names_;
};
vector&lt;string&gt; Node::getNames(){
    return names_;
}
</code></pre>

<p>the function getNames() passes a copy of the vector. How can i modify my class so that i can reference the vector 'by const reference' from any other class that i declare the Node object instead of passing a copy?</p>
","87234","","<p>Try this:</p>

<pre><code>class Node
{
    public:
       const vector&lt;string&gt;&amp; getNames() const;

    private:
        vector&lt;string&gt; names_;
};

const vector&lt;string&gt;&amp; Node::getNames() const
{
    return names_;
}
</code></pre>

<p>Few things:</p>

<ol>
<li>getNames() is now a const method, because the Node does not logically change.</li>
<li>Return as a constant reference, so you don't make a copy.</li>
</ol>
"
"<p>I'm currently doing a project in C# with a lot of rendering, and throughout almost all the classes there's a constant value of the type integer being used for scaling of the rendering. I know I could define this constant in one place as a normal variable and then pass it around, but this seemes really cumbersome. When is it acceptable to use static variables in C#? The easiest solution to my problem would be to create a class containing the static variable that all the other classes could reference - would that be bad design?</p>
","87234","","<p>I wanted to add something to the other answers.</p>

<p>In games, what you're doing is fairly common. So just look at the other answers. But to add on to your current situation:</p>

<p>If these are game constants, like player health, gravity, speed of entities, etc...I would not hardcode them.</p>

<p>Rather, make these global, but load them from a file. This way you can tweak your game without requiring a rebuild of everything that uses these globals, which will be a lot of things.</p>
"
"<p>Considering this code, VC9 doesn't detect aliasing :</p>

<pre><code>typedef struct { int x, y; } vec_t;

void rotate_cw(vec_t const *from,
               vec_t       *to)
{
        /* Notice x depends on y and vice versa */
        to-&gt;x = from-&gt;y;
        to-&gt;y = -from-&gt;x;
}

/* ... */
vec_t a, b;
rotate_cw(&amp;a, &amp;b); /* OK, no aliasing */
rotate_cw(&amp;a, &amp;a); /* FAIL, aliasing is not detected */
</code></pre>

<p>The obvious fix is to use a temporary :</p>

<pre><code>void rotate_cw(vec_t const *from,
               vec_t       *to)
{
        int temp = from-&gt;x;
        to-&gt;x = from-&gt;y;
        to-&gt;y = -temp;
}
</code></pre>

<p>Is this standard behavior ? I was expecting that the compiler, unless told so, would assume <strong>both</strong> pointers to be possibly aliased.</p>
","87234","","<p><a href=""http://stackoverflow.com/questions/754929/strict-aliasing/754970#754970"">Check out this answer</a>.</p>

<p>Try putting <a href=""http://msdn.microsoft.com/en-us/library/5ft82fed%28VS.80%29.aspx"" rel=""nofollow"">__restrict</a> before the parameters, seems to be the only way anybody found of getting MSVC to give any warnings.</p>
"
"<p>I'm going to extend the existing std::map class and add a new function to it:</p>

<pre><code>template&lt;typename key_type, typename value_type&gt;
class CleanableMap : public Cleanable, public std::map&lt;key_type, value_type&gt; 
{
    CleanableMap(const CleanableMap&amp; in); //not implemented
    CleanableMap&amp; operator=(const CleanableMap&amp; in); //not implemented
public:
    CleanableMap() {}
    CleanableMap(const std::map&lt;key_type, value_type&gt;&amp; in) { *this = in; }
    virtual ~CleanableMap() {}
    std::map&lt;key_type, value_type&gt;&amp; operator=(const std::map&lt;key_type, value_type&gt;&amp; in)
    {
    	*((std::map&lt;key_type, value_type&gt;*)this) = in;
    	return *this;
    }
};
</code></pre>

<p>I've got a copy constructor and assignment operator such that I can simply assign an existing std::map of the same type to my new map:</p>

<pre><code>CleanableMap&lt;DWORD, DWORD&gt; cm;
std::map&lt;DWORD, DWORD&gt; stdm;
cm = stdm;
</code></pre>

<p>The problem is, the compiler is complaining with an error that doesn't make sense -- I've explicitly coded for what it's complaining about:</p>

<pre><code>1&gt;c:\dev\proj\commonfunc.cpp(399) : error C2679: binary '=' : no operator found which takes a right-hand operand of type 'std::map&lt;_Kty,_Ty&gt;' (or there is no acceptable conversion)
1&gt;        with
1&gt;        [
1&gt;            _Kty=DWORD,
1&gt;            _Ty=DWORD
1&gt;        ]
1&gt;        c:\dev\proj\templates.h(245): could be 'CleanableMap&lt;key_type,value_type&gt; &amp;CleanableMap&lt;key_type,value_type&gt;::operator =(const CleanableMap&lt;key_type,value_type&gt; &amp;)'
1&gt;        with
1&gt;        [
1&gt;            key_type=DWORD,
1&gt;            value_type=DWORD
1&gt;        ]
1&gt;        c:\dev\proj\templates.h(250): or       'std::map&lt;_Kty,_Ty&gt; &amp;CleanableMap&lt;key_type,value_type&gt;::operator =(const std::map&lt;_Kty,_Ty&gt; &amp;)'
1&gt;        with
1&gt;        [
1&gt;            _Kty=unsigned long,    &lt;--- where did it come up with that?
1&gt;            _Ty=std::pair&lt;const DWORD,DWORD&gt;,  &lt;--- where did it come up with that?
1&gt;            key_type=DWORD,
1&gt;            value_type=DWORD
1&gt;        ]
1&gt;        while trying to match the argument list '(CleanableMap&lt;key_type,value_type&gt;, std::map&lt;_Kty,_Ty&gt;)'
1&gt;        with
1&gt;        [
1&gt;            key_type=DWORD,
1&gt;            value_type=DWORD
1&gt;        ]
1&gt;        and
1&gt;        [
1&gt;            _Kty=DWORD,
1&gt;            _Ty=DWORD
1&gt;        ]
</code></pre>

<p>There 'could be' it mentions on line 245 doesn't make sense -- there is no assignment operator like that (well, it's private.  Removing it completely doesn't change anything).</p>

<p>The 'could be' it mentions on line 250 is the assignment operator that I defined, but it was somehow deduced some other non-matching template types.  Where did it get those??</p>

<p>Help!!! :)</p>
","87234","","<p>And one last tip to add to those:</p>

<p>When it comes to extending (anything, really), it's almost always better to do it with a wrapper class than inheritance.</p>
"
"<p>I'm working on a windowed Direct3D data plotting application that needs to display multiple overlays on top of the data (similar to HUDs in games).  Since there could be a large amount of data that needs plotting, and not all overlays will be changed every time, I figured it wouldn't be a good idea to replot verticies when only one overlay in the display changes.  </p>

<p>This led me to the idea of rendering the textures and verticies of the overlays to multiple textures with transparent backgrounds that could be overlaid in the render loop and updated independently (similar to layers in Photoshop). </p>

<p>Before I embark on changing a large portion of this program to render to textures as opposed to surfaces, I was just wondering if using textures is the best approach.</p>
","87234","","<p>RTT works well, I used it in a game I did recently. Each scene (scene refers to layer, ""HUD"" was a scene, ""Main"" was the main scene etc...) was rendered onto a texture, then each texture was rendering onto a quad, sorted back to front (for alpha blending). I chose this over just rendering the scenes directly onto the back buffer because it allowed me to do post-processing.</p>

<p>For your caching purposes this seems to be the best way to go, but just be aware that the textures can eat memory quickly, and sometimes its just better to render everything again, making sure you sort back to front.</p>
"
"<p>Question is probably pretty basic, but can't find out what's wrong (and it leads to huge of memleaks in my app):</p>

<pre><code>class MyClass {
public:
    MyClass() { cout &lt;&lt; ""constructor();\n""; };
    MyClass operator= (const MyClass&amp; b){ 
        cout &lt;&lt; ""operator=;\n""; return MyClass(); 
    };
    ~MyClass() { cout &lt;&lt; ""destructor();\n""; };
};

main() {
	cout &lt;&lt; ""1\n"";
	vector&lt;MyClass&gt; a;
	cout &lt;&lt; ""2\n"";
	MyClass b;
	cout &lt;&lt; ""3\n"";
	a.push_back(b);
	cout &lt;&lt; ""4\n"";
}
</code></pre>

<p>The output is:</p>

<pre><code>1
2
constructor();
3
4
destructor();
destructor();
</code></pre>

<ol>
<li>Why are there 2 destructors? </li>
<li>If it's because a copy is created to be inserted into vector - how come ""operator="" is never called?</li>
</ol>
","87234","","<p>Try this code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

class MyClass
{
public:
    MyClass(void)
    {
    	std::cout &lt;&lt; ""constructor(void)"" &lt;&lt; std::endl;
    };

    MyClass(const MyClass&amp; rhs)
    { 
    	std::cout &lt;&lt; ""constructor(copy)"" &lt;&lt; std::endl;
    };

    MyClass&amp; operator=(const MyClass&amp; rhs)
    {
            // check for self-assignment. saying a = a should have
            // no effect.
            if (this != &amp;rhs)
            {
    	        std::cout &lt;&lt; ""operator="" &lt;&lt; std::endl;
            }

    	// note the return type. now return a reference to self
    	// to allow chaining: a = b = c = d;
    	// This is the standard way of implementing
    	// operator=, but wasn't related to your question too much.
    	// Just good to clarify on.
    	return *this; 
    };

    ~MyClass(void)
    {
    	std::cout &lt;&lt; ""destructor"" &lt;&lt; std::endl;
    };
};

int main(void)
{
    std::cout &lt;&lt; ""1"" &lt;&lt; std::endl;

    std::vector&lt;MyClass&gt; theArray;

    std::cout &lt;&lt; ""2"" &lt;&lt; std::endl;

    MyClass foo;

    std::cout &lt;&lt; ""3"" &lt;&lt; std::endl;

    theArray.push_back(foo);

    std::cout &lt;&lt; ""4"" &lt;&lt; std::endl;
}
</code></pre>

<p>And you will get:</p>

<ul>
<li>1</li>
<li>2</li>
<li>constructor(void)</li>
<li>3</li>
<li>constructor(copy)</li>
<li>4</li>
<li>destructor</li>
<li>destructor</li>
</ul>

<h3>Copy-construct versus operator=</h3>

<p>The reason it is using the copy-constructor instead of operator= is because the object does not exist until the push_back.</p>

<p>That is, it's like saying this:</p>

<pre><code>MyClass a;
MyClass b(a); // push_back
</code></pre>

<p>Rather than:</p>

<pre><code>MyClass a;
MyClass b;
b = a; // push_back
</code></pre>

<p>The reason the first is used then is because whe you push_back, the object is created right at that call site inside the vector.</p>

<p>It would be silly for the vector to always call both the <strong>constructor(void)</strong>, then <strong>operator=</strong>, rather than constructing directly from the original with one <strong>constructor(copy)</strong>.</p>

<p>To further this point, something like:</p>

<pre><code>MyClass a;
MyClass b = a;
</code></pre>

<p>With automatically be treated like this by the compiler:</p>

<pre><code>MyClass a;
MyClass b(a);
</code></pre>

<p>So the standard itself (I don't know the exact quote, I know Neil Butterworth's does) says that this conversion should occur, because it's more correct.</p>

<h3>Destructors</h3>

<p>The reason there are two destructor's is that the vector has its destructor called, upon which is destructs all of it's contents. in this case, this is one instance of the class, and that accounts for one output of ""destructor"". Had you pushed <em>n</em> MyClass's on the vector, you'd have <em>n</em> calls to the destructor, one for each.</p>

<p>The second comes from destructing <strong>b</strong>.</p>
"
"<p>In theory, is it more efficient to remove elements from an <code>ArrayList</code> or a <code>LinkedList</code>?</p>
","87234","","<p>Well, removal of an element from a (doubly-linked-)list is O(1). But removal from an array will require that the remaining elements are shifted down one space in the array, which is O(n).</p>

<p>That said, getting a specific element in a list by index is O(n), while getting a specific element in an array by index is O(1).</p>

<p>So, the for actual removal, LinkedList will be better. There is more info on Array's versus LinkedList <a href=""http://stackoverflow.com/questions/166884/array-vs-linked-list"">here</a>.</p>
"
"<p>Ok, I know this has been asked before but after searching I couldn't find a proper answer.</p>

<p>I need to convert a buffer (unsigned char *) to base64, the base64 function I am using takes as paramters:</p>

<pre><code>void Base64Enc(const unsigned char *src, int srclen, unsigned char *dest)
</code></pre>

<p>where <code>int srclen</code> is the length of the <code>src</code> string.</p>

<p>My question is, how do I get the length of my buffer. No, it's not null terminated. No, I don't want the <code>sizeof(BYTE)</code>. I just need to know what to pass to as <code>srclen</code> so i can convert that buffer to base64.</p>

<p><strong>EDIT</strong>:</p>

<p>Here's some code showing what I am doing:</p>

<pre><code>unsigned char *pBytes;
unsigned char *B64Encoded;
int b64size = 0;

if (pBytes = (unsigned char *) GlobalLock(hMem))
{
    DWORD size = (DWORD)GlobalSize(hMem);
    b64size = size / sizeof(unsigned char);
    Base64Enc(pBytes, b64size, B64Encoded);

    // in this case save the buffer to a file just for testing
    if (fp = fopen(""ububub.txt"", ""wb""))
    {   
    	printf(""data: %s\n"", B64Encoded);
        fwrite(B64Encoded, strlen(B64Encoded), 1, fp);
        fclose(fp);
    }
}
</code></pre>
","87234","","<p>If it's not NULL terminated or something-terminated, the only way to know the size is to keep track of it when you first got it.</p>

<p>How are you getting the buffer in the first place? Whatever that is probably gives you a method of also obtaining the length of the buffer.</p>

<h3>EDIT</h3>

<p>Your comment: </p>

<blockquote>
  <p>I have the size of the memory that the
  data takes. I tried playing with that
  but it's not the correct information
  apparently.</p>
</blockquote>

<p>In that case, take your raw size and divide it by the size of each element to get the number of elements:</p>

<pre><code>unsigned numelem = size / sizeof(unsigned char)
</code></pre>

<p>Thanks to <a href=""http://stackoverflow.com/users/54858/todd-gardner"">Todd Gardner</a> for pointing out that <strong>sizeof(unsigned char)</strong> is defined by the standard to be 1, so the number of elements in your buffer is just the amount of space your buffer uses.</p>

<p>The ""divide by size of element"" is the more general solution to any type of element.</p>
"
"<p>Is it a bug to do this:</p>

<pre><code>if(some_error)
  throw Cat(""Minoo"");
</code></pre>

<p>Where Cat is a class. </p>

<p>Then in some other function that called the method that threw the exception...</p>

<p>I would have:</p>

<pre><code>catch(const Cat &amp;c)
{ 
}
</code></pre>

<p>If it is invalid, do I use new Cat(""Minoo"");  </p>

<p>Would that cause a memory leak?</p>
","87234","","<p>What you have now is what everyone should be doing, and most do. Throw the object itself and catch by const-reference.</p>

<p>Throwing pointers has hairy issues such as ""who deletes it?"".</p>

<p>More information <a href=""http://www.parashift.com/c%2B%2B-faq-lite/exceptions.html"" rel=""nofollow"">here</a>.</p>
"
"<p>There are N values in the array, and one of them is the smallest value. How can I find the smallest value most efficiently?</p>
","87234","","<p>If they are unsorted, you can't do much but look at each one, which is O(N), and when you're done you'll know the minimum.</p>

<p><hr /></p>

<p>Pseudo-code:</p>

<pre><code>small = &lt;biggest value&gt; // such as std::numerical_limits&lt;int&gt;::max
for each element in array:
    if (element &lt; small)
        small = element
</code></pre>

<p>A better way reminded by <a href=""http://stackoverflow.com/users/38924/ben"">Ben</a> to me was to just initialize small with the first element:</p>

<pre><code>small = element[0]
for each element in array, starting from 1 (not 0):
    if (element &lt; small)
        small = element
</code></pre>

<p>The above is wrapped in the <a href=""http://www.cppreference.com/wiki/stl/algorithm/start"">algorithm</a> header as <a href=""http://www.cppreference.com/wiki/stl/algorithm/min%5Felement"">std::min_element</a>.</p>

<p><hr /></p>

<p>If you can keep your array sorted as items are added, then finding it will be O(1), since you can keep the smallest at front.</p>

<p>That's as good as it gets with arrays.</p>
"
"<p>Let's say I'm programming in Java or Python or C++ for a simple problem, could be to build an TCP/UDP echo server or computation of factorial. Do I've to bother about the architecture details, i.e., if it is 32 or 64-bit?</p>

<p>IMHO, unless I'm programming something to do with fairly low-level stuff then I don't have to bother if its 32 or 64 bit. Where am I going wrong? Or am I correct???</p>
","87234","","<p>Knowing how things work, be it how the virtual machine works, and how it works on your platform, or how certain C++ constructs are transformed into assembly will always make you a better programmer, because you will understand why things should be done the way they are.</p>

<p>You need to understand things like memory to know what cache-misses are and why those might affect your program. You should know how certain things are implemented, even though you might only use an interface or high-level way to get to it, knowing how it works will make sure you're doing it in the best way.</p>

<p>For packet work, you need to understand how data is stored on platforms and how sending that across the network to a different platform might change how the data is read (endian-ness).</p>

<p>Your compiler will make best use of the platform you're compiling on, so as long as you stick to standards and code well, you can ignore most things and assume the compiler will whip out what's best.</p>

<p>So in short, no. You don't need to know the low level stuff, but it <strong>never hurts to know</strong>.</p>
"
"<p>What is a good random number generator to use for a game in C++?</p>

<p>My considerations are:</p>

<ol>
<li>Lots of random numbers are needed, so speed is good.</li>
<li>Players will always complain about random numbers, but I'd like to be able to point them to a reference that explains that I really did my job. </li>
<li>Since this is a commercial project which I don't have much time for, it would be nice if the algorithm either a) was relatively easy to implement or b) had a good non-GPL implementation available.</li>
<li>I'm already using <code>rand()</code> in quite a lot of places, so any other generator had better be good to justify all the changes it would require.</li>
</ol>

<p>I don't know much about this subject, so the only alternative I could come up with is the <a href=""http://en.wikipedia.org/wiki/Mersenne%5FTwister"">Mersenne Twister</a>; does it satisfy all these requirements? Is there anything else that's better?</p>

<p><strong>Edit:</strong> Mersenne Twister seems to be the consensus choice. But what about point #4? Is it really that much better than <code>rand()</code>?</p>

<p><strong>Edit 2:</strong> Let me be a little clearer on point 2: There is no way for players to cheat by knowing the random numbers. Period. I want it random enough that people (at least those who understand randomness) can't complain about it, but I'm not worried about predictions. 
That's why I put speed as the top consideration.</p>

<p><strong>Edit 3:</strong> I'm leaning toward the Marsaglia RNGs now, but I'd still like more input. Therefore, I'm setting up a bounty.</p>

<p><strong>Edit 4:</strong> Just a note: I intend to accept an answer just before midnight UTC today (to avoid messing with someone's rep cap). So if you're thinking of answering, don't wait until the last minute!<br />
Also, I like the looks of Marsaglia's XORshift generators. Does anyone have any input about them?</p>
","87234","","<p>Mersenne Twister is very good, and it's fast as well. I used it in a game and it's not hard at all to implement or use.</p>

<p>The <a href=""http://www.iro.umontreal.ca/~panneton/WELLRNG.html"">WELL random algorithm</a> was designed as an improvement over the Mersenne Twister. <a href=""http://rads.stackoverflow.com/amzn/click/1584505273"">Game Gems</a> 7 has more info. on it, if you can borrow that or have it.</p>

<p>On that WELL page I linked you to, the number is the period of the algorithm. That is, you can get 2^N - 1 numbers before it needs reseeding, where N is: 512, 1024, 19937, or 44497. Mersenne Twister has a period of N = 19937, or 2^19937 - 1. You'll see this is a <em>very large number</em> :)</p>

<p>The only other thing I can point out is that <a href=""http://www.boost.org/"">boost</a> has a <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/random/index.html"">random library</a>, which you should find useful.</p>

<p>In response to your edit, yes the Twister or WELL is that much better than rand(). Also, the old modulus trick harms the distribution of the numbers. Even more reason to use boost :)</p>
"
"<p>I wrote an abstraction class for a math  object, and defined all of the operators. While using it, I came across:</p>

<pre><code>Fixed f1 = 5.0f - f3;
</code></pre>

<p>I have only two subtraction operators defined:</p>

<pre><code>inline const Fixed operator - () const;
inline const Fixed operator - (float f) const;
</code></pre>

<p>I get what is wrong here - addition is swappable (1 + 2 == 2 + 1) while subtraction is not (same goes for multiplication and division). 
I immediately wrote a function <em>outside</em> my class like this:</p>

<pre><code>static inline const Fixed operator - (float f, const Fixed &amp;fp);
</code></pre>

<p>But then I realized this cannot be done, because to do that I would have to touch the class's privates, which results to using the keyword <code>friend</code> which I loath, as well as polluting the namespace with a 'static' unnecessary function.</p>

<p>Moving the function inside the class definition yields this error in gcc-4.3:</p>

<pre><code>error: ‘static const Fixed Fixed::operator-(float, const Fixed&amp;)’ must be either a non-static member function or a non-member function
</code></pre>

<p>Doing as GCC suggested, and making it a non-static function results the following error:</p>

<pre><code>error: ‘const Fixed Fixed::operator-(float, const Fixed&amp;)’ must take either zero or one argument
</code></pre>

<p>Why can't I define the same operator inside the class definition? if there's no way to do it, is there anyway else not using the <code>friend</code> keyword?</p>

<p>Same question goes for division, as it suffers from the same problem.</p>
","87234","","<p>What's wrong with friend? That's the standard way of doing things.</p>

<p>Put it in the class definition, so you don't pollute anything.</p>
"
"<p>Does C++ have any type of utility to return to the beginning of a function after a function call? For example, example the call to help() in the calculate function.</p>

<pre><code>void help()
{
     cout &lt;&lt; ""Welcome to this annoying calculator program.\n"";
     cout &lt;&lt; ""You can add(+), subtract(-), multiply(*), divide(/),\n"";
     cout &lt;&lt; ""find the remainder(%), square root(sqrt()), use exponents(pow(x,x)),\n"";
     cout &lt;&lt; ""use parentheses, assign variables (ex: let x = 3), and assign\n"";
     cout &lt;&lt; "" constants (ex: const pi = 3.14). Happy Calculating!\n"";
     return;
}

void clean_up_mess()        // purge error tokens
{
    ts.ignore(print);
}

const string prompt = ""&gt; "";
const string result = ""= "";

void calculate()
{
    while(true) try {
    	cout &lt;&lt; prompt;
    	Token t = ts.get();
    	if (t.kind == help_user) help();  
        else if (t.kind == quit) return;
    	while (t.kind == print) t=ts.get();
    	ts.unget(t);
    	cout &lt;&lt; result &lt;&lt; statement() &lt;&lt; endl;
    }
    catch(runtime_error&amp; e) {
    	cerr &lt;&lt; e.what() &lt;&lt; endl;
    	clean_up_mess();
    }
}
</code></pre>

<p>While technically my implementation of a help function works fine, it's not perfect. After help is called, and returns, it proceeds with trying to cout &lt;&lt; result &lt;&lt; statement() &lt;&lt; endl; which isn't possible because no values have been entered. Thus it gives a little error message (elsewhere in the program) and then proceeds on with the program. No problem with functionality, but it's ugly and I don't like it (:P). </p>

<p>So is there any way for when the help function returns, to return to the beginning of calculate and start over? (I played around with inserting a function call in if(t.kind == help_user) block to call calculate, but as I figured that just delays the problem rather than solving it.)</p>
","87234","","<p>You can use goto, but the moment you do that consider yourself over. It's considered bad practice and good uses of it are rare and far apart.</p>

<p>I think what you're looking for is continue:</p>

<pre><code>void do_calculate(void)
{
    while (true)
    {
    	cout &lt;&lt; prompt;
    	Token t = ts.get();

    	if (t.kind == help_user)
    	{
    		help();  
    		continue; // &lt;- here
    	}
    	else if (t.kind == quit)
    	{
    		return;
    	}

    	while (t.kind == print)
    	{
    		t = ts.get();
    	}
    	ts.unget(t);

    	cout &lt;&lt; result &lt;&lt; statement() &lt;&lt; endl;
    }
}

void calculate()
{
    try
    {
    	do_calculate();
    }
    catch (const std::exception&amp; e)
    {
    	cerr &lt;&lt; e.what() &lt;&lt; endl;
    	clean_up_mess();
    }
}
</code></pre>

<p>I have also reformatted your code. I think this is more readable, to each his own but just wanted to let you compare.</p>

<ul>
<li><p>The try/catch clause is now no longer interfering with the calculation function.</p></li>
<li><p>The 'if' statements use brackets for consistency. Also, it's much easier to read, because I <em>know</em> whatever the if is controlling is within these brackets.</p></li>
<li><p>The catch will catch a std::exception, rather than runtime_error. All standard exceptions inherit from std::exception, so by catching that you know you can catch anything.</p></li>
</ul>
"
"<p>I'm having a hard time using std::string::iterators in C++. This code compiles fine (still not getting correct output, but that's my fault: TODO, fix algorithm) in Dev-C++, and I don't get runtime errors. The error is with Visual Studio Express 2008 C++, where I'm getting an error pointing to &lt; xstring>: ""Expression: string iterator not dereferencable,"" and points to line 112 of the &lt; xstring> file.</p>

<p>My debugging tells me I might be trying to dereference past the end of the sentence input, but I can't see where. Can anyone shed some light?</p>

<pre><code>std::string wordWrap(std::string sentence, int width)
{    
    std::string::iterator it = sentence.begin();

    //remember how long next word is
    int nextWordLength = 0;
    int distanceFromWidth = width;

    while (it &lt; sentence.end())
    {
       while (*it != ' ' &amp;&amp; it != sentence.end())
       {
          nextWordLength++;
          distanceFromWidth--;
          it++;
       }

       if (nextWordLength &gt; distanceFromWidth)
       {
          *it = '\n';
          distanceFromWidth = width;
          nextWordLength = 0;
       }

       //skip the space
       it++;

   }

   return sentence;    
}
</code></pre>
","87234","","<p>Firstly, use operator!=() on iterators, not operator&lt;():</p>

<pre><code>while (it != sentence.end())
</code></pre>

<p><hr /></p>

<p>Secondly, this is backwards: <code>while (*it != ' ' &amp;&amp; it != sentence.end())</code></p>

<p>You do something with the iterator, than check if the iterator is valid. Rather, you should check if it's valid first:</p>

<pre><code>while (it != sentence.end() &amp;&amp; *it != ' ')
</code></pre>

<p><hr /></p>

<p>Thirdly, you should use ++iterator over iterator++, though this isn't related to your crashing.</p>

<p><hr /></p>

<p>Fourth, a main issue is here:</p>

<pre><code>*it = '\n';
</code></pre>

<p>Because of the preceeding check, <code>while (it != sentence.end()</code>, it's possible to reach that iterator dereference while being at the end. A fix would be to do this:</p>

<pre><code>if (it != sentence.end() &amp;&amp; nextWordLength &gt; distanceFromWidth)
</code></pre>

<p>So now if you have reached the end, you stop.</p>

<p><hr /></p>

<p>After fixing the previous issue, now the only problem is this:</p>

<pre><code>//skip the space
++it;
</code></pre>

<p>This assumes that the character you are skipping is in fact a space. But what about the end of the string? Run this function with this string:</p>

<p><code>""a test string "" // &lt;- space at end</code></p>

<p>And it will succeed; it skips the space, putting the iterator at <code>end()</code>, the loop exits and success.</p>

<p>However, without the space it will crash, because you have reached the end, and are skipping past the end. To fix, add a check:</p>

<pre><code>//skip the space
if (it != sentence.end())
{
    ++it;
}
</code></pre>

<p><hr /></p>

<p>Resulting in this final code:</p>

<pre><code>std::string wordWrap(std::string sentence, int width)
{    
    std::string::iterator it = sentence.begin();

    //remember how long next word is
    int nextWordLength = 0;
    int distanceFromWidth = width;

    while (it != sentence.end())
    {
    	while (it != sentence.end() &amp;&amp; *it != ' ')
    	{
    		nextWordLength++;
    		distanceFromWidth--;
    		++it;
    	}

    	if (it != sentence.end() &amp;&amp; nextWordLength &gt; distanceFromWidth)
    	{
    		*it = '\n';
    		distanceFromWidth = width;
    		nextWordLength = 0;
    	}

    	//skip the space
    	if (it != sentence.end())
    	{
    		++it;
    	}

    }

    return sentence;    
}
</code></pre>

<p><hr /></p>

<p>You might notice this seems like it has a lot of redundant checks. This can be fixed:</p>

<pre><code>std::string wordWrap(std::string sentence, int width)
{    
    std::string::iterator it = sentence.begin();

    //remember how long next word is
    int nextWordLength = 0;
    int distanceFromWidth = width;

    while (it != sentence.end())
    {
    	while (*it != ' ')
    	{
    		nextWordLength++;
    		distanceFromWidth--;

    		++it;

    		// check if done
    		if (it == sentence.end())
    		{
    			return sentence;
    		}
    	}

    	if (nextWordLength &gt; distanceFromWidth)
    	{
    		*it = '\n';
    		distanceFromWidth = width;
    		nextWordLength = 0;
    	}

    	//skip the space
    	++it;
    }

    return sentence;    
}
</code></pre>

<p><hr /></p>

<p>Hopefully that helps!</p>
"
"<p>I am extending the Visual Studio 2003 debugger using autoexp.dat and a DLL to improve the way it displays data in the watch window. The main reason I am using a DLL rather than just the basic autoexp.dat functionality is that I want to be able to display things conditionally. e.g. I want to be able to say ""If the name member is not an empty string, display name, otherwise display [some other member]""</p>

<p>I'm quite new to OOP and haven't got any experience with the STL. So it might be that I'm missing the obvious.</p>

<p>I'm having trouble displaying vector members because I don't know how to get the pointer to the memory the actual values are stored in.</p>

<p>Am I right in thinking the values are stored in a contiguous block of memory? And is there any way to get access to the pointer to that memory?</p>

<p>Thanks!</p>

<p>[edit:] To clarify my problem (I hope):</p>

<p>In my DLL, which is called by the debugger, I use a function called ReadDebuggeeMemory which makes a copy of the memory used by an object. It doesn't copy the memory the object points to. So I need to know the actual address value of the internal pointer in order to be able to call ReadDebuggeeMemory on that as well. At the moment, the usual methods of getting the vector contents are returning garbage because that memory hasn't been copied yet.</p>

<p>[update:]</p>

<p>I was getting garbage, even when I was looking at the correct pointer _Myfirst because I was creating an extra copy of the vector, when I should have been using a pointer to a vector. So the question then becomes: how do you get access to the pointer to the vector's memory via a pointer to the vector? Does that make sense?</p>
","87234","","<p>The elements in a standard vector are allocated as one contiguous memory chunk.</p>

<p>You can get a pointer to the memory by taking the address of the first element:</p>

<pre><code>std::vector&lt;int&gt; vec;

int *array = &amp;vec[0]; // method 1
int *array = &amp;vec.front(); // method 2
</code></pre>

<p>However, you can just use the operators available to access the vector, unless you really need a raw pointer.</p>

<h3>Edit</h3>

<p>Now that you have a pointer to a vector, you can do the same thing above:</p>

<pre><code>std::vector&lt;int&gt; *vec;

int *array = &amp;vec-&gt;operator[](0); // method 1
int *array = &amp;vec-&gt;front(); // method 2
</code></pre>

<p>Method 2 seems rather clean, but you could just dereference to get back to the original solution:</p>

<pre><code>std::vector&lt;int&gt; *vec;

int *array = &amp;(*vec)[0]; // method 1
int *array = &amp;(*vec).front(); // method 2
</code></pre>

<p>I think this can be made more elegant by design. For example, do you have to get the vector by pointer? If so, use <code>int *array = &amp;vec-&gt;front();</code>, since that seems most concise.</p>

<p>Better yet though, try to get a reference to it.</p>

<h3>About your solution</h3>

<p>You came up with the solution:</p>

<pre><code>int *vMem = vec-&gt;_Myfirst;
</code></pre>

<p>The only time this will work is on your very implementation of that compiler versio. This is not-standard, so this probably won't work between compilers, or even different version of your compiler.</p>

<p>It might seem ok if you're only developing on that single platform &amp; compiler, but it's better to do the the standard way.</p>
"
"<p>I have a very simple iPhone app that requires a random integer from 1-100.</p>

<p>I have a button that calls the random number function then displays it.</p>

<pre><code>-(IBAction)buttonReleased;
{
    srandom(time(NULL)); 
    int theNum = random() % 100 + 1;
    numberDisplay.text = [NSString stringWithFormat:@""%d"", theNum];
}
</code></pre>

<p>The problem is, if I press the button quickly, sometimes it won't display a new random number.</p>
","87234","","<p>The problem is you're seeding with <code>time</code>.</p>

<p><code>time</code> is only updated every second, so if you click it within the second, you will seed the generator with the same number, which means you'll be getting the same number.</p>

<p>You should only be seeding once, at the start of the application.</p>
"
"<p>I have a program that allows the user to enter a level number, and then it plays that level:</p>

<pre><code>char lvlinput[4];
std::cin.getline(lvlinput, 4)
char param_str[20] = ""levelplayer.exe ""
strcat_s(param_str, 20, lvlinput);
system(param_str);
</code></pre>

<p>And the level data is stored in folders \001, \002, \003, etc., etc. However, I have no way of telling whether the user entered three digits, ie: 1, 01, or 001.  And all of the folders are listed as three digit numbers.  I can't just  check the length of the lvlinput string because it's an array, so How could I make sure the user entered three digits?</p>
","87234","","<p>This is the C++ solution to this problem, I think:</p>

<pre><code>#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

void pad_string(std::string&amp; str, char padChar, unsigned padSize)
{
    std::stringstream ss;
    ss &lt;&lt; std::setfill(padChar) &lt;&lt; std::setw(padSize) &lt;&lt; str;

    str = ss.str();
}


int main()
{
    std::string levelNumber;
    std::cin &gt;&gt; levelNumber;

    pad_string(levelNumber, '0', 3);

    std::string levelString = ""levelplayer.exe "" + levelNumber;

    std::cout &lt;&lt; levelString &lt;&lt; std::endl;
}
</code></pre>

<h2>Edit</h2>

<p>This is a much more elegant way of implementing pad_string:</p>

<pre><code>void pad_string(std::string&amp; str, char padChar, unsigned padSize)
{
    if (str.length() &lt; 3)
    {
    	str.insert(0, padSize - str.length(), padChar);
    }
}
</code></pre>
"
"<p>I have a structure called vertex and I created some pointers to them.  What I want to do is add those pointers to a list.  My code below, when it tries to insert the pointer into the list, creates a segmentation fault.  Can someone please explain what is going on?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;list&gt;

#define NUM_VERTICES 8

using namespace std;

enum { WHITE, GRAY, BLACK };

struct vertex
{
    int color;
    int distance;
    char parent;
};

int main()
{
    //create the vertices
    vertex r = {WHITE, NULL, NULL};

    //create pointer to the vertex structures
    vertex *pr = &amp;r;

    //create a list to hold the vertices
    list&lt;vertex*&gt; *r_list = new list&lt;vertex*&gt;;

    list&lt;vertex*&gt;::iterator it;

    r_list-&gt;insert(it, pr);
}
</code></pre>
","87234","","<p>There are several things wrong here.</p>

<p>First off, you aren't initializing the iterator, like other's have said:</p>

<pre><code>list&lt;vertex*&gt;::iterator it = r_list-&gt;begin();
</code></pre>

<p>Do this and your code will be fine. But your code is done in a bad manner.</p>

<p>Why are you allocating the list from the heap? Look at your code: you have a memory leak. You aren't calling <code>delete r_list</code> anywhere. This is why you should use smart pointers (<a href=""http://en.cppreference.com/w/cpp/memory/unique_ptr"" rel=""nofollow""><code>std::unique_ptr</code></a>, <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr"" rel=""nofollow""><code>std::shared_ptr</code></a> if you have C++11, boost equivalents otherwise : <a href=""http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm"" rel=""nofollow""><code>boost::scoped_ptr</code></a> and <a href=""http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm"" rel=""nofollow""><code>boost::shared_ptr</code></a>)</p>

<p>But better yet, just do it on the stack:</p>

<pre><code>//create a list to hold the vertices
list&lt;vertex*&gt; r_list;

list&lt;vertex*&gt;::iterator it = r_list-&gt;begin();

r_list.insert(it, pr);
</code></pre>

<p>In addition, using the iterator to insert is going about things the long way. Just use <a href=""http://en.cppreference.com/w/cpp/container/list/push_front"" rel=""nofollow"">push front()</a> or <a href=""http://en.cppreference.com/w/cpp/container/list/push_back"" rel=""nofollow"">push back()</a>:</p>

<pre><code>//create a list to hold the vertices
list&lt;vertex*&gt; r_list;

r_list.push_back(pr);
</code></pre>

<p>Another thing: if your list outlives the vertex you've constructed, it will be pointing to something invalid.</p>

<p>For example:</p>

<pre><code>// global
list&lt;vertex*&gt; r_list;

void some_function(void)
{
    //create the vertices
    vertex r = {WHITE, NULL, NULL};

    //create pointer to the vertex structures
    vertex *pr = &amp;r;

    r_list.push_back(pr);
} // right here, vertex r stops existing: the list now contains an
  // invalid pointer.
</code></pre>

<p>One solution is to store pointers to heap-allocated vertices:</p>

<pre><code>// global
list&lt;vertex*&gt; r_list;

void some_function(void)
{
    //create the vertices
    vertex *r = new vertex;
    r-&gt;color = WHITE;
    r-&gt;distance = 0;
    r-&gt;parent = 0;

    r_list.push_back(r);
}
</code></pre>

<p>Now even after the function the list is pointing to a valid heap-allocated vertex. This now has the problem that when you're done using the list, you need to go through the lsit and call <code>delete</code> on each element. This problem is assisted by using the <a href=""http://www.boost.org/doc/libs/1_39_0/libs/ptr_container/doc/ptr_container.html"" rel=""nofollow"">Boost Pointer Container Library</a>.</p>

<p>The best way, though, is to just store vertices themselves (rather than pointers to them):</p>

<pre><code>//create a list to hold the vertices
list&lt;vertex&gt; r_list;

//create the vertices
vertex r = {WHITE, NULL, NULL};

r_list.push_back(r);
</code></pre>

<p>If you give vertex a constructor, you can even just construct them in-place:</p>

<pre><code>struct vertex
{
    int color;
    int distance;
    char parent;

    vertex(int _color, int _distance, char _parent) :
    color(_color),
    distance(_distance),
    parent(_parent)
    {
    }
};

//create a list to hold the vertices
list&lt;vertex&gt; r_list;

r_list.push_back(vertex(WHITE, NULL, NULL));
</code></pre>

<p>(these are now outside your problem)</p>

<p>Firstly, NULL is generally only used when dealing with pointers. Since <code>distance</code> and <code>parent</code> are not pointers, use <code>0</code> to initialize them, rather than <code>NULL</code>:</p>

<pre><code>//create the vertices
vertex r = {WHITE, 0, 0};
</code></pre>

<p>Secondly, use <code>constants</code> rather than <code>#define</code>:</p>

<pre><code>#define NUM_VERTICES 8 // &lt;- bad
const int NumberVertices = 8; // &lt;- good
</code></pre>

<p>Lastly, give your enum a name, or place it in a namespace:</p>

<pre><code>enum Color { WHITE, GRAY, BLACK };
</code></pre>

<p>Hope these help!</p>
"
"<p>What is the best place or a link to learn algorithms in C? How do you know when and where to use the implementation of algorithms by just looking into the problems?</p>
","87234","","<p>Algorithms aren't necessarily tied to a specific language, just to clarify, so any algorithms book will work great as long as you can understand the concept being the data structure/algorithm.</p>

<p>That said, this seems like a good choice: <a href=""http://rads.stackoverflow.com/amzn/click/0201314525"">Algorithms in C</a>. I have the <a href=""http://rads.stackoverflow.com/amzn/click/0201350882"">C++ equivalent</a> on my shelf.</p>

<p>There is also a book that seems language agnostic (correct me if I'm wrong) called <a href=""http://rads.stackoverflow.com/amzn/click/0201000237"">Data Structures &amp; Algorithm's</a>, though I hear it's a bit dated, so you'll miss out on more recent structures.</p>

<p>Don't forget the internet has a plethora of information <a href=""http://en.wikipedia.org/wiki/List%5Fof%5Fdata%5Fstructures"">available to you</a>. However, books are usually better for these sorts of things. This is because internet resources tend to focus on one thing at a time. For example, you need to understand what <a href=""http://en.wikipedia.org/wiki/Big%5FO%5Fnotation"">Big-O notation</a> is before you can understand what it means when we say a List has O(1) [constant time] removal.</p>

<p>A book will cover these things in the correct order, but an internet resource will focus on either Big-O notation or data structures, but often won't easily connect the two.</p>

<p><hr /></p>

<p>When it comes to using it, you'll mostly make the connection when it comes to what you'll be doing with the data.</p>

<p>For example, you might want a <a href=""http://en.wikipedia.org/wiki/Dynamic%5Farray"">vector</a> (array) if you just need ordered elements, but if you need ordered elements and removal from any place (but can sacrifice random access), then a <a href=""http://en.wikipedia.org/wiki/List%5F%28computing%29"">list</a> would be more appropriate, due to it's constant-time removal.</p>
"
"<p>So the common (at least VS 2005 states) way to define exports/imports for a DLL is:</p>

<pre><code>#ifdef MY_EXPORTS
#define MY_API __declspec(dllexport)
#else
#define MY_API __declspec(dllimport)
#endif

class MY_API MyClass {
    ...
};
</code></pre>

<p>This works great if I'm just building my code as a DLL. However, I want to have the option of using a static library OR a DLL. Now one obvious (but terrible) solution, is to copy all the code, removing the DLL 'MY_API' defines. Now what would seem a much better approach is a command line switch to either define, or not define the DLL stuff. However in the case of a static library what should 'MY_API' be?</p>

<pre><code>#ifdef DLL_CONFIG
    #ifdef MY_EXPORTS
    #define MY_API __declspec(dllexport)
    #else
    #define MY_API __declspec(dllimport)
    #endif
#else
    #define MY_API // What goes here?
#endif

class MY_API MyClass {
    ...
};
</code></pre>

<p>Now assuming that this can be done will there be issues when a user of the library includes the header files (ie. will they have to define 'DLL_CONFIG')?</p>
","87234","","<p>Nothing.</p>

<p>Leave it as <code>#define MY_API</code> and all instances of MY_API will simply vanish.</p>

<p>You can add new build configurations, such as Debug - DLL and Release - DLL that mimic the others except they <code>#define DLL_CONFIG</code>.</p>

<p>To clone a configuration, get to the configuration manager (like the drop down of the Debug/Release list box), then under 'Active solution configuration' select new. You can now name it ""Debug - DLL"" and set <code>Copy Settings</code> to <code>Debug</code> and now that's left to do is define <code>DLL_CONFIG</code>.</p>

<p>To do this, go to project properties->configuration properties->C/C++->Preprocessor, and type <code>DLL_CONFIG</code> in there. You will also see that's where things like <code>NDEBUG</code> and <code>WIN32</code> are defined.</p>

<p>Like <a href=""http://stackoverflow.com/questions/1089828/same-header-file-for-both-dll-and-static-library/1089853#1089853"">haffax said</a>, use project specific names. I would recommend something like:</p>

<pre><code>#ifdef THEPROJECT_USE_DLL
    #ifdef THEPROJECT_BUILDING_PROJECT
        #define THEPROJECT_API __declspec(dllexport)
    #else
        #define THEPROJECT_API __declspec(dllimport)
    #endif
#else
    #define THEPROJECT_API
#endif
</code></pre>

<p>Now users of your DLL just <code>#define THEPROJECT_USE_DLL</code> if they are using the DLL version, just like your ""- DLL"" configurations have.</p>
"
"<p>To be clear, I'm not asking if/why multiple inheritance is good or bad. I've heard a lot of arguments from both sides of that debate.</p>

<p>I'm wondering if there is any kind of design problem or scenario in C++ in which multiple inheritance is either the only way to accomplish something, or at least is the most optimal way over all other alternatives to the point that it wouldn't make sense to consider anything else.</p>

<p>Obviously, this question doesn't apply to languages that don't support multiple inheritance.</p>
","87234","","<p>You can't do <a href=""http://en.wikipedia.org/wiki/Policy-based%5Fdesign"">policy-based design</a> without multiple inheritance. So if policy-based design is the most elegant way to solve your problem, than that means you need multiple inheritance to solve your problem, over all other options.</p>

<p>Multiple-inheritance can be very useful if it's not misused (like everything, in any language).</p>
"
"<p>After-the-dot-in-a-file-name, it is called extension.</p>
","87234","","<p>Drive:/File/Path/FileName.FileExtension</p>

<p>After the period is the extension, the immediate name before it is the file name, the path before all that is the File Path, and of course at the end (or beginning) is the drive.</p>

<p>BaseName is another name for FileName.</p>
"
"<p>I have a simple question that I am posing mostly for my curiousity.</p>

<p>What are the differences between these two lines of code? (in C++)</p>

<pre><code>for(int i = 0; i &lt; N, N &gt; 0; i++)

for(int i = 0; i &lt; N &amp;&amp; N &gt; 0; i++)
</code></pre>

<p>The selection of the conditions is completely arbitrary, I'm just interested in the differences between , and &amp;&amp;.</p>

<p>I'm not a beginner to coding by any means, but I've never bothered with the comma operator.</p>

<p>Are there performance/behavior differences or is it purely aesthetic?</p>

<p>One last note, I know there are bigger performance fish to fry than a conditional operator, but I'm just curious.  Indulge me.</p>

<p><em>Edit</em>
Thanks for your answers.</p>

<p>It turns out the code that prompted this question had misused the comma operator in the way I've described.  I wondered what the difference was and why it wasn't a &amp;&amp; operator, but it was just written incorrectly. I didn't think anything was wrong with it because it worked just fine.  Thanks for straightening me out.</p>
","87234","","<p>Using &amp;&amp; will short-circuit if i &lt; N, but the comma operator can't do that.</p>

<p>It's being used incorrectly. The comma operator will have the value of the last statement in it. (5.18 in the C++ standard)</p>

<p>So this:</p>

<pre><code>i &lt; N, N &gt; 0
</code></pre>

<p>Will execute <code>i &lt; N</code>, discard the result, then execute <code>N &gt; 0</code>, and use that as the result for the comma operator. That is, in this context you could just replace it with:</p>

<pre><code>N &gt; 0
</code></pre>

<p>And have the same behavior. You could probably try something like this:</p>

<pre><code>for(int i = 0; (bool b = i &lt; N, b = b &amp;&amp; N &gt; 0); i++)
</code></pre>

<p>Which will then be slower than <code>i &lt; N &amp;&amp; N &gt; 0</code>, because both operators will execute, unless the compiler optimizes it into <code>i &lt; N &amp;&amp; N &gt; 0</code> anyway.</p>
"
"<p>I'm wondering why I can't use STL maps with user-defined classes.  When I compile the code below, I get this cryptic error message. What does it mean? Also, why is it only happening with user-defined types? (primitive types are okay when it is used for the key)</p>

<blockquote>
  <p>C:\MinGW\bin..\lib\gcc\mingw32\3.4.5........\include\c++\3.4.5\bits\stl_function.h||In
  member function `bool
  std::less&lt;_Tp>::operator()(const _Tp&amp;,
  const _Tp&amp;) const [with _Tp =
  Class1]':|</p>
  
  <p>C:\MinGW\bin..\lib\gcc\mingw32\3.4.5........\include\c++\3.4.5\bits\stl_map.h|338|instantiated
  from `_Tp&amp; std::map&lt;_Key, _Tp,
  _Compare, _Alloc>::operator [with _Key = Class1, _Tp = int, _Compare = std::less, _Alloc = std::allocator >]'|</p>
  
  <p>C:\Users\Admin\Documents\dev\sandbox\sandbox\sandbox.cpp|24|instantiated
  from here|</p>
  
  <p>C:\MinGW\bin..\lib\gcc\mingw32\3.4.5........\include\c++\3.4.5\bits\stl_function.h|227|error: no match for 'operator&lt;' in '__x &lt;
  __y'| ||=== Build finished: 1 errors, 0 warnings ===|</p>
</blockquote>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;

using namespace std;

class Class1
{
public:
    Class1(int id);

private:
    int id;
};

Class1::Class1(int id): id(id)
{}

int main()
{
    Class1 c1(1);

    map&lt; Class1 , int&gt; c2int;
    c2int[c1] = 12;

    return 0;
}
</code></pre>
","87234","","<p>By default <a href=""http://www.cplusplus.com/reference/stl/map/"">std::maps</a> (and <a href=""http://www.cplusplus.com/reference/stl/set/"">std::sets</a>) use <a href=""http://www.cplusplus.com/reference/std/functional/less/"">operator&lt;</a> to determine sorting.</p>

<p>You need to define operator&lt; on your class.</p>

<p>To objects are deemed equal if !(a &lt; b) &amp;&amp; !(b &lt; a).</p>

<p>If for some reason you'd like to use a different comparator, the third template argument of the map can be changed, to <a href=""http://www.cplusplus.com/reference/std/functional/greater/"">std::greater</a>, for example.</p>
"
"<p>I'm working on a file format that should be written and read in several different operating systems and computers. Some of those computers should be x86 machines, others x86-64. Some other processors may exist, but I'm not concerned about them <em>yet</em>.</p>

<p>This file format should contain several numbers that would be read like this:</p>

<pre><code>struct LongAsChars{
    char c1, c2, c3, c4;
};

long readLong(FILE* file){
    int b1 = fgetc(file);
    int b2 = fgetc(file);
    int b3 = fgetc(file);
    int b4 = fgetc(file);
    if(b1&lt;0||b2&lt;0||b3&lt;0||b4&lt;0){
    	//throwError
    }

    LongAsChars lng;
    lng.c1 = (char) b1;
    lng.c2 = (char) b2;
    lng.c3 = (char) b3;
    lng.c4 = (char) b4;

    long* value = (long*) &amp;lng;

    return *value;
}
</code></pre>

<p>and written as:</p>

<pre><code>void writeLong(long x, FILE* f){
    long* xptr = &amp;x;
    LongAsChars* lng = (LongAsChars*) xptr;
    fputc(lng-&gt;c1, f);
    fputc(lng-&gt;c2, f);
    fputc(lng-&gt;c3, f);
    fputc(lng-&gt;c4, f);
}
</code></pre>

<p>Although this seems to be working on my computer, I'm concerned that it may not in others or that the file format may end up being different across computers(32 bits vs 64 bits computers, for example).
Am I doing something wrong? How should I implement my code to use a constant number of bytes per number?</p>

<p>Should I just use fread(which would possibly make my code faster too) instead?</p>
","87234","","<p>Well you can use a union, for one:</p>

<pre><code>union LongAsChars{
    long l;
    char c1, c2, c3, c4;
};
</code></pre>

<p>And it's more traditional to use an array, I think:</p>

<pre><code>union LongAsChars{
    long l;
    char c[4];
};
</code></pre>

<p>Which makes your routine something like this (no compiler on-hand to test):</p>

<pre><code>long readLong(FILE* file){

    LongAsChars lng;

    for (unsigned i = 0; i &lt; 4; ++i)
    {
        lng.c[i] = fgetc(file);
        if (lng.c[i] &lt; 0)
        {
            //throwError
        }


    }

    return lng.l;
}

void writeLong(long x, FILE* f){

    LongAsChars lng;
    lng.l = x;

    for (unsigned i = 0; i &lt; 4; ++i)
    {
        fputc(lng.c[i], f);
    }
}
</code></pre>

<p>The only issues you'll get with standard types deal with <a href=""http://en.wikipedia.org/wiki/Endianness"" rel=""nofollow"">endianness</a>.</p>

<p>Also, unless I'm missing something, <strong>yes</strong>, just <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fread/"" rel=""nofollow"">read</a> and <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fwrite/"" rel=""nofollow"">write</a> the long value directly, no need to chop things up, which at best just makes things confusing:</p>

<pre><code>long readLong(FILE* file){

    long x;

    fread(&amp;x, sizeof(long), 1, file);    

    return x;
}

void writeLong(long x, FILE* f){

    fwrite(&amp;x, sizeof(long), 1, file);    

    return x;
}
</code></pre>
"
"<p>HI,</p>

<p>Consider the following code:</p>

<pre><code>void Foo() {
  ......
  LOG_ERROR(""I'm error 1"")   // call 1
  .....
  LOG_ERROR(""I'm error 2"")  // call 2
  .....

}
</code></pre>

<p><code>LOG_ERROR()</code> is a macro. <code>LOG_ERROR()</code> should print string identifying it
in code, while the assumption is that code can change, but <code>A::Foo()</code>
will remain unchanged. The identifier should retain while code
changes.</p>

<p>This can be solved by adding error code as argument to <code>LOG_ERROR()</code>,
but we want to remove from the programmer the burden to manage error
codes.</p>

<p>Using <code>__LINE__</code> is not an answer, since <code>Foo()</code> can move from build to
build.</p>

<p>Therefore I thought about identifying <code>LOG_ERROR()</code> relative to start of
<code>Foo()</code>:</p>

<ul>
<li>a. Identify by file name (<code>__FILE__</code>) + function name (<code>__FUNCTION__</code>) +
line number of <code>LOG_ERROR()</code> relative to <code>Foo()</code> start.</li>
<li>b. Identify by file name (<code>__FILE__</code>) + function name (<code>__FUNCTION__</code>) +
<code>LOG_ERROR()</code> call number in <code>Foo()</code>.</li>
</ul>

<p>The solution should be work with VC++ 2008 and g++ 4.1.1 at least.</p>

<p>One proposed solution (<a href=""http://groups.google.com/group/comp.lang.c++.moderated/browse%5Fthread/thread/bf4abc4fc9f023a1#"" rel=""nofollow"">link text</a>) is: </p>

<pre><code>#define ENABLE_LOG_ERROR static const int LOG_ERROR_start_line = __LINE__
#define LOG_ERROR(s) cerr &lt;&lt; ""error #"" &lt;&lt; (__LINE__ - LOG_ERROR_start_line) \
    &lt;&lt; "" in "" &lt;&lt; __func__ &lt;&lt; "": "" &lt;&lt; s &lt;&lt; endl

void Foo() {
     ENABLE_LOG_ERROR;
     //...
     LOG_ERROR(""error 1"");
     int i;
     LOG_ERROR(""error 2"");
}
</code></pre>

<p>This will force user to write <code>ENABLE_LOG_ERROR</code> in start of each function containing
<code>LOG_ERROR()</code> and there're many such functions.</p>

<p>Is there other way to accomplish the task?</p>

<p>Thanks
Dima </p>
","87234","","<p>Here's a little something I threw together. It works by maintaining a global ""stack"", which means the number will still increase between function calls. If you're ok with putting in <code>ENABLE_LOG_ERROR</code>, then it works as desired:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

// appends a line number to a string
#define APPENDLINE_IMPL(x, l) x##l
#define APPENDLINE_DETAIL(x, l) APPENDLINE_IMPL(x, l)
#define APPENDLINE(x) APPENDLINE_DETAIL(x, __LINE__)

// make a unique log error object using the line number
#define LOG_ERROR(s) LogError APPENDLINE(LOGERROR)(s); (void)0
#define ENABLE_LOG_ERROR LogErrorEnabler LOGERRORENABLER;

// Logs an error
class LogError
{
public:
    // log the error, increment the number
    LogError(const std::string&amp; error)
    {
    	std::cerr &lt;&lt; ""Error #"" &lt;&lt; _errorCount &lt;&lt; "": "" &lt;&lt; error &lt;&lt; std::endl;

    	++_errorCount;
    }

    // going out of scope, decrement
    ~LogError(void)
    {
    	--_errorCount;
    }

private:
    // let the enabler handle the number
    friend class LogErrorEnabler;

    // current error number (in function)
    static unsigned _errorCount;
};

// resets &amp; restores the error count
class LogErrorEnabler
{
public:
    // reset but save the error count
    LogErrorEnabler(void)
    {
    	_oldErrorCount = LogError::_errorCount;

    	LogError::_errorCount = 0;
    }

    // reset error count (function is ending)
    ~LogErrorEnabler(void)
    {
    	LogError::_errorCount = _oldErrorCount;
    }

private:
    // old error number
    unsigned _oldErrorCount;
};

// would be in LogError.cpp
unsigned LogError::_errorCount = 0; 



void foo(void)
{
    ENABLE_LOG_ERROR;

    LOG_ERROR(""Top of foo function"");
    LOG_ERROR(""Middle of foo function"");
    LOG_ERROR(""Bottom of foo function"");
}

void bar(void)
{
    ENABLE_LOG_ERROR;

    LOG_ERROR(""Top of bar function"");
    foo();
    LOG_ERROR(""Bottom of bar function"");
}

int main(void)
{
    bar();

    return 0;
}
</code></pre>

<h2>Edit</h2>

<p>The following code works as intended, but without the <code>ENABLE_LOG_ERROR</code> requirement. :)</p>

<p>It works by letting the first <code>LogErrorEnabler</code> do it's job, but if any are instantiated after the initial Enabler is created, they are put into a zombie state and do nothing.</p>

<p>The only trick was to detect when an Enabler was being created in a new scope, with an Enabler already active in the previous scope. This was done using the (non-standard but soon to be, so is supported) <code>__FUNCTION__</code> macro. This macro is passed into the Enabler, upon where it can check if it's being created in a different function than the original Enabler.</p>

<p>Here is the code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

// appends a line number to a string
#define APPENDLINE_IMPL(x, l) x##l
#define APPENDLINE_DETAIL(x, l) APPENDLINE_IMPL(x, l)
#define APPENDLINE(x) APPENDLINE_DETAIL(x, __LINE__)

// make a unique log error object using the line number
#define LOG_ERROR(s) LogErrorEnabler APPENDLINE(LOGERRORENABLER)(__FUNCTION__); \
    					LogError APPENDLINE(LOGERROR)(s); \
    					(void)0

// Logs an error
class LogError
{
public:
    // log the error, increment the number
    LogError(const std::string&amp; error)
    {
    	std::cerr &lt;&lt; ""Error #"" &lt;&lt; _errorCount &lt;&lt; "": "" &lt;&lt; error &lt;&lt; std::endl;

    	++_errorCount;
    }

    // going out of scope, decrement
    ~LogError(void)
    {
    	--_errorCount;
    }

private:
    // let the enabler handle the number
    friend class LogErrorEnabler;

    // current error number (in function)
    static unsigned _errorCount;
};

// resets &amp; restores the error count
class LogErrorEnabler
{
public:
    // reset but save the error count
    LogErrorEnabler(const std::string&amp; functionName)
    {
    	if (functionName != _currentFunctionName)
    	{
    		// entered new function
    		_oldErrorCount = LogError::_errorCount;
    		LogError::_errorCount = 0;

    		// store function name
    		_oldFunctionName = _currentFunctionName;
    		_currentFunctionName = functionName;

    		// this enabler is active
    		_zombie = false;
    	}
    	else
    	{
    		// make this enabler do nothing
    		_zombie = true;
    	}
    }

    // reset error count (function is ending)
    ~LogErrorEnabler(void)
    {
    	if (!_zombie)
    	{
    		// restore old state
    		LogError::_errorCount = _oldErrorCount;
    		_currentFunctionName = _oldFunctionName;
    	}
    }

private:
    // old error number
    unsigned _oldErrorCount;

    // old function name
    std::string _oldFunctionName;

    // zombie state
    bool _zombie;

    // current function
    static std::string _currentFunctionName;
};

// would be in LogError.cpp
unsigned LogError::_errorCount = 0; 

// would be in LogErrorEnabler.cpp
std::string LogErrorEnabler::_currentFunctionName = """";



void foo(void)
{
    LOG_ERROR(""Top of foo function"");
    LOG_ERROR(""Middle of foo function"");
    LOG_ERROR(""Bottom of foo function"");
}

void bar(void)
{
    LOG_ERROR(""Top of bar function"");
    foo();
    LOG_ERROR(""Bottom of bar function"");
}

int main(void)
{
    bar();

    return 0;
}
</code></pre>

<p>Let me know if there are more modifications you require. :)</p>
"
"<p>Is there a way to convert an <code>int</code> into a <code>char</code> ?</p>

<p><strong>Edit:</strong> </p>

<p>Here's the problem with Jeff Johnson's answer (it shows weird characters):
<img src=""http://img17.imageshack.us/img17/7229/sanstitrecht.jpg"" alt=""image""></p>
","87234","","<p>In response to your edit, just use printf and specify an integer:</p>

<pre><code>int i = 10;
printf(""%d"", i);
</code></pre>

<p>The reason for this is 0 represents the number 0. The <a href=""http://www.cppreference.com/wiki/ascii"">ASCII character</a> ""0"" is not at zero, but at 48.</p>

<p>This is why <a href=""http://stackoverflow.com/questions/1114741/convert-int-to-char-c/1114759#1114759"">Jared's Answer</a> will work: <code>char dig = (char)(((int)'0')+i);</code></p>

<p>It takes ""0"" (which is 48), and adds your number to it. 0 + 48 is 48, so 0 becomes ""0"". If you are converting a 1, it will be 48 + 1, or 49, which corresponds to ""1"" on the ASCII chart.</p>

<p>This only works for numbers 0 through 9, as ""10"" is not an ASCII character, but rather ""1"" followed by a ""0"".</p>
"
"<p>I'm looking for a pretty easy algorithm for a collision detection with two three-dimensional triangles, which can move constantly (rather better if the could accelerate, too). I've found a method to solve this problem but that's a difficult one with movement of the two three-dimensional triangles.</p>
","87234","","<p>First to clear some terminology:</p>

<blockquote>
  <p>Intersection detection will tell you if two things are intersecting.</p>
  
  <p>Collision detection will tell if two things will collide.</p>
</blockquote>

<p>There is a difference here. If one object [Polygon A] is moving quickly, and you are using intersection tests, it's possible for it to be non-intersecting, move past Polygon B, and then be on the other side, also non-intersecting.</p>

<p>Collision detection, on the other hand, will say, ""Polygon A will collide with Polygon B"". There is a subtle difference, so saying ""Collision ... with some movement"" is somewhat redundant.</p>

<p>The most intuitive way to do collision detection is to sweep the polygon's out over the course of the time step, and do intersection tests with the resulting polygons.</p>

<p>Anyway:</p>

<p><a href=""http://www.realtimerendering.com/intersections.html"" rel=""nofollow"">This page</a> contains lots of information about determining if two shapes are <em>intersecting</em>.</p>

<p><a href=""http://softsurfer.com/Archive/algorithm%5F0105/algorithm%5F0105.htm"" rel=""nofollow"">This page</a> is specifically about rays, planes, and triangles, and includes source code.</p>
"
"<p>I want to call a function using a variable. Is that possible in C?</p>

<p>Actually, what I want to do is, get the function name from the user and store it in a variable. Now I want to call the function that has its name stored. Can anyone tell me how this can be done in C?</p>

<p>I want to develop an AI game engine for a two player game. Two programs with no main function that implement the logic for winning the game will be fed to the game engine.
Let me be clear that the program names will be same as that of the primefunctions in the program that implement the logic for winning the game.</p>

<p>So when the user enters the name of first and second players, I can store them in 2 different variables. Now, since the primefunction names are same as that of the program names, I intend to call the functions with variables containing the prog names.</p>
","87234","","<p>The best you can do is something like this:</p>

<pre><code>#include &lt;stdio.h&gt;

// functions
void foo(int i);
void bar(int i);

// function type
typedef void (*FunctionCallback)(int);
FunctionCallback functions[] = {&amp;foo, &amp;bar};

int main(void)
{
    // get function id
    int i = 0;
    scanf(""%i"", &amp;i);

    // check id
    if( i &gt;= sizeof(functions))
    {
        printf(""Invalid function id: %i"", i);
        return 1;
    }

    // call function
    functions[i](i);

    return 0;
}

void foo(int i)
{
    printf(""In foo() with: %i"", i);
}

void bar(int i)
{
    printf(""In bar() with: %i"", i);
}
</code></pre>

<p>This uses numbers instead of strings to identify the functions, but doing it with strings is simply a matter of converting the string into the proper function.</p>

<p>What are you doing, exactly? If just for curiosity, here you go, but if you're trying to solve a problem with this, I'm sure there is a way better suited to your task.</p>

<h2>Edit</h2>

<p>In concern with your edit, you will want to go with <a href=""http://stackoverflow.com/questions/1118705/call-a-function-using-a-string-variable-in-c/1118742#1118742"">onebyone's</a> answer, for sure.</p>

<p>You want your user's to build dynamic libraries (thats a shared object [.so] in Linux, and a dynamic link library [.dll] in Windows).</p>

<p>Once you do that, if they provide you with the name of their library, you can ask the operating system to load that library for you, and request a pointer to a function within that library.</p>
"
"<p>Im trying to text serialize and deserialize an object containing a container of abstract objects in c++,does somebody know of a code example of the above?</p>
","87234","","<p>Take a look at <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/serialization/doc/index.html"" rel=""nofollow"">boost::serialize</a>.</p>

<p>It contains methods to assist in the <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/serialization/doc/tutorial.html#stl"" rel=""nofollow"">serialization of containers</a> (link loses frame on left).</p>

<p>Of course, don't just skip to that page, you'll want to read the whole thing. :)</p>
"
"<p>I was looking through the DXUTCore project that comes with the DirectX March 2009 SDK, and noticed that instead of making normal accessor methods, they used macros to create the generic accessors, similar to the following:</p>

<pre><code>#define GET_ACCESSOR( x, y )  inline x Get##y()  { DXUTLock l; return m_state.m_##y;};
...

GET_ACCESSOR( WCHAR*, WindowTitle );
</code></pre>

<p>It seems that the ## operator just inserts the text from the second argument into the macro to create a function operating on a variable using that text.  Is this something that is standard in C++ (i.e. not Microsoft specific)? Is its use considered good practice? And, what is that operator called?</p>
","87234","","<p>This is also standard C++, contrary to what <a href=""http://stackoverflow.com/questions/1121971/what-is-the-purpose-of-the-operator-in-c-and-what-is-it-called/1122005#1122005"">Raldolpho</a> stated.</p>

<p>Here is the relevant information:</p>

<blockquote>
  <p>16.3.3 The ## operator [cpp.concat]</p>
  
  <p>1 A <code>##</code> preprocessing token shall not
  occur at the beginning or at the end
  of a replacement list for either form
  of macro definition.</p>
  
  <p>2 If, in the
  replacement list, a parameter is
  immediately preceded or followed by a
  <code>##</code> preprocessing token, the parameter is replaced by the corresponding
  argument’s preprocessing token
  sequence.</p>
  
  <p>3 For both object-like and
  function-like macro invocations,
  before the replacement list is
  reexamined for more macro names to
  replace, each instance of a <code>##</code>
  preprocessing token in the replacement
  list (not from an argument) is deleted
  and the preceding preprocessing token
  is concatenated with the following
  preprocessing token. If the result is
  not a valid preprocessing token, the
  behavior is undefined. The resulting
  token is available for further macro
  replacement. The order of evaluation
  of <code>##</code> operators is unspecified.</p>
</blockquote>
"
"<p>I'm having some trouble compiling/linking a set of classes, several of them dealing with a common global variable. </p>

<p>Basically, I declare and define a extern variable foo in class A and access/update it in classes B and C.</p>

<p>The relevant code looks like this:</p>

<p>A.h    </p>

<pre><code>extern string foo; // declare it &lt;=== compiler error ""storage class specified for foo""
</code></pre>

<p>B.cpp  </p>

<pre><code>include A.h  
string foo; // define it  

main () {   
...  
foo = ""abc"";      
}
</code></pre>

<p>C.cpp   </p>

<pre><code>include A.h  
cout &lt;&lt; foo; // print it
</code></pre>

<p>My current error is ""storage class specified for foo"". But, I'm wondering if this is the correct approach. Should I be using a static variable? Any help much appreciated, as I've been on this for at least an hour by now. </p>
","87234","","<p>Since your error is on the extern, I'm guessing it doesn't know what the type is.</p>

<p>Have you included string?</p>

<p><code>#include &lt;string&gt;</code></p>

<p>And if so, you need to put <code>std::</code> before it:</p>

<pre><code>#include &lt;string&gt;
extern std::string foo;
</code></pre>

<p>Side note, make sure you don't use any <code>using</code> directives (<code>using namespace std</code> or <code>using std::string</code>) in your header file, because then you force everyone who sues your header file to do the same, which is bad practice.</p>

<h2>Edit</h2>

<blockquote>
  <p>...but that's how I have it coded.</p>
</blockquote>

<p>Are you sure? I just tried this and it works completely fine in both VC++ and g++:</p>

<h3>A.h</h3>

<pre><code>#include &lt;string&gt;

extern std::string foo;
</code></pre>

<h3>B.cpp</h3>

<pre><code>#include ""A.h""

std::string foo;

int main (void)
{   
    foo = ""abc"";      
}
</code></pre>

<h3>C.cpp</h3>

<pre><code>#include ""A.h""
#include &lt;iostream&gt;

int some_function(void)
{   
    std::cout &lt;&lt; foo &lt;&lt; std::endl;
}
</code></pre>

<p>Try that out and see if it works.</p>
"
"<p>Should every C++ programmer read the ISO standard to become professional?</p>
","87234","","<p>I think a lot of things like, ""is this ok to do?"" are only really answered by looking at the standard.</p>

<p>You can learn a lot of things by reading the standard, because it includes all the tiny details people tend to skip out on.</p>

<p>Having standard on hand also helps you back up your statements, because if someone says, ""This is okay to do"", you can say, ""Actually, <em>according to the standard</em>, it's not okay because...""</p>

<p>I think in conclusion, I'll repeat what I've said before:</p>

<p>Knowing it can't hurt you, but you don't need to have it memorized to be a good C++ programmer.</p>
"
"<p>Using the following code snippet as an illustration to my question:</p>

<pre><code>// #includes and other macros

class MyClass : public CFormView
{
private:
    	DECLARE_DYNCREATE(MyClass)

    	bool privateContent;

    	...

public:
    	bool publicContent;

    	...
};

class MusicPlayer
{
public:
    AppClass *theApp;   				// which has a pointer accessing the MyClass object instantiated in the program

    ...
}
</code></pre>

<p>When I place the keyword ""private"" in MyClass definition as such, the privateContent member variable doesn't appear to be private when I try to access it in a method of MusicPlayer class. However, if I place the ""private"" keyword after the DECLARE_DYNCREATE(MyClass) line, the behavior of privateContent member variable returns to what is expected. Does anyone know why this is the case? Thanks in advance.</p>
","87234","","<p>If you look at the definition of <code>DECLARE_DYNCREATE</code>, you will see that it uses another macro:</p>

<pre><code>// not serializable, but dynamically constructable
#define DECLARE_DYNCREATE(class_name) \
    DECLARE_DYNAMIC(class_name) \
    static CObject* PASCAL CreateObject();
</code></pre>

<p>And if you look at that macro, <code>DECLARE_DYNAMIC</code>, you'll see why your class turns public:</p>

<pre><code>#define DECLARE_DYNAMIC(class_name) \
protected: \
    static CRuntimeClass* PASCAL _GetBaseClass(); \
public: \
    static const CRuntimeClass class##class_name; \
    static CRuntimeClass* PASCAL GetThisClass(); \
    virtual CRuntimeClass* GetRuntimeClass() const; \
</code></pre>

<p>When it expands, it's going to add that <code>public:</code> keyword, leaving the rest of your class definition public after that.</p>

<p>So when you say say <code>private:</code> after <code>DECLARE_DYNCREATE</code>, you're then changing it from public to private.</p>

<p>The usual use of this macro would be like this:</p>

<pre><code>class MyClass : public CFormView
{
        DECLARE_DYNCREATE(MyClass)
private:
        bool privateContent;

        ...

public:
        bool publicContent;

        ...
};
</code></pre>

<p>The class will implicitly be private at the start, so the effect is the same.</p>

<p>Also, most C++ programmers will agree you should start trying to get into the habit of placing your private variables at the bottom.</p>

<p>The justification is that when people, including yourself, are reading the class, they will want to see what you can do with the class, which is in the public interface, rather than how the class is going to work, which is private.</p>

<p>By putting the public interface first, you won't have to be bothered by all the private stuff.</p>

<p>I used to put my private stuff at the top too (because I came from Visual Basic 6, before C++), and hated being told my privates should be on the bottom, but once you get into the habit you'll wish you changed sooner.</p>
"
"<p>I remember seeing somewhere there ""^"" operator is used as a pointer operator in Managed C++ code. Hence ""^"" should be equivalent to ""*"" operator right?? </p>

<p>Assuming my understanding is right, when I started understanding .Net and coded a few example programs, I came across some code like this:</p>

<pre><code>String ^username; //my understanding is you are creating a pointer to string obj
.
.         // there is no malloc or new that allocates memory to username pointer
.
username = ""XYZ""; // shouldn't you be doing a malloc first??? isn't it null pointer
</code></pre>

<p>I am having trouble understanding this.</p>
","87234","","<p>That's a reference, not pointer, to a garbage collected string.</p>

<p>It will be allocated and deallocated automatically, when nothing is referencing it anymore.</p>
"
"<p>Greetings,</p>

<p>I am trying to perform a copy from one vector (vec1) to another vector (vec2) using the following 2 abbreviated lines of code (full test app follows):</p>

<pre><code>vec2.reserve( vec1.size() );
copy(vec1.begin(), vec1.end(), vec2.begin());
</code></pre>

<p>While the call to vec2 sets the capacity of vector vec2, the copying of data to vec2 seems to not fill in the values from vec1 to vec2.</p>

<p>Replacing the copy() function with calls to push_back() works as expected.</p>

<p>What am I missing here?</p>

<p>Thanks for your help. vectest.cpp test program followed by resulting output follows.</p>

<p>Compiler: gcc 3.4.4 on cygwin.</p>

<h2>Nat</h2>

<pre><code>/**
 * vectest.cpp
 */

#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main()
{
    vector&lt;int&gt; vec1;
    vector&lt;int&gt; vec2;

    vec1.push_back(1);
    vec1.push_back(2);
    vec1.push_back(3);
    vec1.push_back(4);
    vec1.push_back(5);
    vec1.push_back(6);
    vec1.push_back(7);

    vec2.reserve( vec1.size() );
    copy(vec1.begin(), vec1.end(), vec2.begin());

    cout &lt;&lt; ""vec1.size()     = "" &lt;&lt; vec1.size() &lt;&lt; endl;
    cout &lt;&lt; ""vec1.capacity() = "" &lt;&lt; vec1.capacity() &lt;&lt; endl;

    cout &lt;&lt; ""vec1: "";
    for( vector&lt;int&gt;::const_iterator iter = vec1.begin(); iter &lt; vec1.end(); ++iter ) {
        cout &lt;&lt; *iter &lt;&lt; "" "";
    }
    cout &lt;&lt; endl;

    cout &lt;&lt; ""vec2.size()     = "" &lt;&lt; vec2.size() &lt;&lt; endl;
    cout &lt;&lt; ""vec2.capacity() = "" &lt;&lt; vec2.capacity() &lt;&lt; endl;
    cout &lt;&lt; ""vec2: "";
    for( vector&lt;int&gt;::const_iterator iter = vec2.begin(); iter &lt; vec2.end(); ++iter ) {
        cout &lt;&lt; *iter &lt;&lt; endl;
    }

    cout &lt;&lt; endl;
}
</code></pre>

<p><hr /></p>

<p>output:</p>

<pre><code>vec1.size()     = 7
vec1.capacity() = 8
vec1: 1 2 3 4 5 6 7 
vec2.size()     = 0
vec2.capacity() = 7
vec2:
</code></pre>
","87234","","<p>As noted in other answers and comments, you should just use vector's built-in functionality for this. But:</p>

<p>When you <code>reserve()</code> elements, the vector will allocate enough space for (at least?) that many elements. The elements do not exist in the vector, but the memory is ready to be used. This will then possibly speed up <code>push_back()</code> because the memory is already allocated.</p>

<p>When you <code>resize()</code> the vector, it will allocate enough space for those elements, <strong><em>but also add them to the vector</em></strong>.</p>

<p>So if you resize a vector to 100, you can access elements 0 - 99, but if you reserve 100 elements, they are not inserted yet, just ready to be used.</p>

<p>What you want is something like this:</p>

<pre><code>vec2.reserve( vec1.size() );
copy(vec1.begin(), vec1.end(), std::back_inserter(vec2));
</code></pre>

<p><a href=""http://www.cplusplus.com/reference/std/iterator/back_inserter/"" rel=""nofollow""><code>std::back_inserter</code></a> is defined in <a href=""http://www.cplusplus.com/reference/std/iterator/"" rel=""nofollow""><code>&lt;iterator&gt;</code></a></p>
"
"<p>I overloaded operator &lt;&lt; </p>

<pre><code>template &lt;Typename T&gt;
UIStream&amp; operator&lt;&lt;(const T);

UIStream my_stream;
my_stream &lt;&lt; 10 &lt;&lt; "" heads"";
</code></pre>

<p>Works but:</p>

<pre><code>my_stream &lt;&lt; endl;
</code></pre>

<p>Gives compilation error:</p>

<blockquote>
  <p>error C2678: binary '&lt;&lt;' : no operator found which takes a left-hand operand of type 'UIStream' (or there is no acceptable conversion)</p>
</blockquote>

<p>What is the work around for making <code>my_stream &lt;&lt; endl</code> work?</p>
","87234","","<p><code>std::endl</code> is a function and <code>std::cout</code> utilizes it by implementing <code>operator&lt;&lt;</code> to take  a function pointer with the same signature as <code>std::endl</code>. </p>

<p>In there, it calls the function, and forwards the return value.</p>

<p>Here is a code example:</p>

<pre><code>#include &lt;iostream&gt;

struct MyStream
{
    template &lt;typename T&gt;
    MyStream&amp; operator&lt;&lt;(const T&amp; x)
    {
        std::cout &lt;&lt; x;

        return *this;
    }


    // function that takes a custom stream, and returns it
    typedef MyStream&amp; (*MyStreamManipulator)(MyStream&amp;);

    // take in a function with the custom signature
    MyStream&amp; operator&lt;&lt;(MyStreamManipulator manip)
    {
        // call the function, and return it's value
        return manip(*this);
    }

    // define the custom endl for this stream.
    // note how it matches the `MyStreamManipulator`
    // function signature
    static MyStream&amp; endl(MyStream&amp; stream)
    {
        // print a new line
        std::cout &lt;&lt; std::endl;

        // do other stuff with the stream
        // std::cout, for example, will flush the stream
        stream &lt;&lt; ""Called MyStream::endl!"" &lt;&lt; std::endl;

        return stream;
    }

    // this is the type of std::cout
    typedef std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt; CoutType;

    // this is the function signature of std::endl
    typedef CoutType&amp; (*StandardEndLine)(CoutType&amp;);

    // define an operator&lt;&lt; to take in std::endl
    MyStream&amp; operator&lt;&lt;(StandardEndLine manip)
    {
        // call the function, but we cannot return it's value
        manip(std::cout);

        return *this;
    }
};

int main(void)
{
    MyStream stream;

    stream &lt;&lt; 10 &lt;&lt; "" faces."";
    stream &lt;&lt; MyStream::endl;
    stream &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Hopefully this gives you a better idea of how these things work.</p>
"
"<p>I am trying to compile an object file using the code below.</p>

<pre><code>//--Begin test.cpp
class A;

void (A::* f_ptr) ();

void test() {
    A *a;
    (a-&gt;*f_ptr)();
}
//-- End test.cpp
</code></pre>

<p>For GNU g++ compiler, it is able to compile the object file.</p>

<p><code>$ g++ -c test.cpp</code></p>

<p>But for Sun Studio 12 on a Solaris 10 (SPARC), it outputs an error.</p>

<p><code>$ CC -c test.cpp</code></p>

<blockquote>
  <p>""test.cpp"", line 7: Error: Cannot call through pointer to member function before defining class A.</p>
  
  <p>1 Error(s) detected.</p>
</blockquote>

<p>Is there a compiler flags to get the Sun Studio C++ compiler to build
the object file?  Is there another workaround?</p>
","87234","","<p>Try to <code>#include &lt;A.h&gt;</code> in that file. The compiler needs to know what <code>class A</code> looks like.</p>
"
"<p>I know there are string tokenizers but is there an ""int tokenizer""?</p>

<p>For example, I want to split the string ""12 34 46"" and have:</p>

<blockquote>
  <p>list[0]=12</p>
  
  <p>list[1]=34</p>
  
  <p>list[2]=46</p>
</blockquote>

<p>In particular, I'm wondering if Boost::Tokenizer does this. Although I couldn't find any examples that didn't use strings.</p>
","87234","","<p>You will want to split the string up at spaces, then use <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/conversion/lexical%5Fcast.htm"" rel=""nofollow"">boost::lexical_cast</a> to convert the text form of the number into the binary form.</p>

<pre><code>#include &lt;boost/lexical_cast.hpp&gt;
#include &lt;boost/tokenizer.hpp&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

int main(void)
{
    // the integers
    const std::string intText = ""12 34 46"";
    std::vector&lt;int&gt; intArray;

    // tokenize integers
    boost::tokenizer&lt;&gt; tokens(intText);

    // read integers
    for (boost::tokenizer&lt;&gt;::const_iterator it = tokens.begin();
    	it != tokens.end(); ++it)
    {
    	intArray.push_back(boost::lexical_cast&lt;int&gt;(*it));
    }

    // print out array
    std::copy(intArray.begin(), intArray.end(), std::ostream_iterator&lt;int&gt;(std::cout, ""\n""));
}
</code></pre>
"
"<p>I was reading Joel's book where he was suggesting as interview question:</p>

<blockquote>
  <p>Write a program to reverse the ""ON"" bits in a given byte.</p>
</blockquote>

<p>I only can think of a solution using C. </p>

<p>Asking here so you can show me how to do in a Non C way (if possible)</p>
","87234","","<p>I claim trick question. :) Reversing all bits means a flip-flop, but only the bits that are on clearly means:</p>

<pre><code>return 0;
</code></pre>
"
"<p>Could somebody please explain to me why does this code only print ""42"" instead of ""created\n42""?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

using namespace std;

class MyClass
{
public:
    MyClass() {cout&lt;&lt;""created""&lt;&lt;endl;};
    int solution() {return 42;}
    virtual ~MyClass() {};
};

int main(int argc, char *argv[])
{
    auto_ptr&lt;MyClass&gt; ptr;
    cout&lt;&lt;ptr-&gt;solution()&lt;&lt;endl;
    return 0;
}
</code></pre>

<p>BTW I tried this code with different values in solution and I always get the ""right"" value, so it doesn't seem to be a random lucky value.</p>
","87234","","<p><a href=""http://en.cppreference.com/w/cpp/memory/auto_ptr"" rel=""nofollow"">std::auto_ptr</a> will not automatically create an object for you. That is, <code>ptr</code> in main as it stands is initialized to null. Dereferencing this is undefined behavior, and you just happen to be getting lucky and getting 42 as a result.</p>

<p>If you actually create the the object:</p>

<pre><code>int main(int argc, char *argv[])
{
    auto_ptr&lt;MyClass&gt; ptr(new MyClass);

    cout &lt;&lt; ptr-&gt;solution() &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>You will get the output you expect.</p>
"
"<p>Unless you're programming parts of an OS or an embedded system are there any reasons to do so? I can imagine that for some particular classes that are created and destroyed frequently overloading memory management functions or introducing a pool of objects might lower the overhead, but doing these things globally?</p>

<p><strong>Addition</strong><br>
I've just found a bug in an overloaded delete function - memory wasn't always freed. And that was in a not-so memory critical application. Also, disabling these overloads decreases performance by ~0.5% only.</p>
","87234","","<p>The most common reason to overload new and delete are simply to check for <a href=""http://en.wikipedia.org/wiki/Memory%5Fleak"">memory leaks</a>, and memory usage stats. Note that ""memory leak"" is usually generalized to memory errors. You can check for things such as double deletes and buffer overruns.</p>

<p>The uses after that are usually memory-allocation schemes, such as <a href=""http://en.wikipedia.org/wiki/Garbage%5Fcollection%5F%28computer%5Fscience%29"">garbage collection</a>, and <a href=""http://en.wikipedia.org/wiki/Memory%5Fpool"">pooling</a>.</p>

<p>All other cases are just specific things, mentioned in other answers (logging to disk, kernel use).</p>
"
"<p>What is the alternative if I need to use a reference, and the data I am passing I cannot change the type of, hence I cannot really store a pointer to it?</p>

<h3>Code:</h3>

<pre><code>    #include &lt;map&gt;     
    #include&lt;iostream&gt;
    #include&lt;string&gt;     

    using namespace std;

    int main()
    {
       string test;
       pair&lt;string, string&gt; p=pair&lt;string, string&gt;(""Foo"",""Bar"");
       map&lt;pair&lt;string, string&gt;, string&amp;&gt; m;
       m[make_pair(""aa"",""bb"")]=test;

       return 0;
}
</code></pre>

<h3>Error:</h3>

<blockquote>
  <p>$ g++ MapPair.cpp
  /usr/include/c++/3.2.3/bits/stl_map.h:
  In instantiation of
  <code>std::map&lt;std::pair&lt;std::string,
  std::string&gt;, std::string&amp;,
  std::less&lt;std::pair&lt;std::string,
  std::string&gt; &gt;,
  std::allocator&lt;std::pair&lt;const
  std::pair&lt;std::string, std::string&gt;,
  std::string&amp;&gt; &gt; &gt;': MapPair.cpp:15:<br />
  instantiated from here
  /usr/include/c++/3.2.3/bits/stl_map.h:221:
  forming reference to reference type<br />
  </code>std::string&amp;' MapPair.cpp: In
  function <code>int main()': MapPair.cpp:16:
  no match for
  </code>std::map,     std::string&amp;,
  std::less >,<br />
  std::allocator,<br />
  std::string&amp;> > >&amp; [std::pair]' operator
  /usr/include/c++/3.2.3/bits/stl_pair.h:
  At global scope:
  /usr/include/c++/3.2.3/bits/stl_pair.h:
  In instantiation of <code>std::pair&lt;const
  std::pair&lt;std::string, std::string&gt;,
  std::string&amp;&gt;':
  /usr/include/c++/3.2.3/bits/stl_tree.h:122:
  instantiated from
  </code>std::_Rb_tree_node
</blockquote>

<p>What am I doing wrong to cause this errror?</p>
","87234","","<p>You cannot store references. References are just <a href=""http://www.parashift.com/c++-faq-lite/references.html"">aliases to another variable</a>.</p>

<p>The map needs a copy of the string to store:</p>

<pre><code>map&lt;pair&lt;string, string&gt;, string&gt; m;
</code></pre>

<p>The reason you are getting that particular error is because somewhere in map, it's going to do an operation on the <code>mapped_type</code> which in your case is <code>string&amp;</code>. One of those operations (like in <code>operator[]</code>, for example) will return a reference to the <code>mapped_type</code>:</p>

<pre><code>mapped_type&amp; operator[](const key_type&amp;)
</code></pre>

<p>Which, with your <code>mapped_type</code>, would be:</p>

<pre><code>string&amp;&amp; operator[](const key_type&amp; _Keyval)
</code></pre>

<p>And you cannot have a reference to a reference:</p>

<blockquote>
  <p>Standard 8.3.4:</p>
  
  <p>There shall be no references to references, no arrays of references, and no pointers to references. </p>
</blockquote>

<p><hr /></p>

<p>On a side note, I would recommend you use <code>typedef</code>'s so your code is easier to read:</p>

<pre><code>int main()
{
    typedef pair&lt;string, string&gt; StringPair;
    typedef map&lt;StringPair, string&gt; StringPairMap;

    string test;

    StringPair p(""Foo"",""Bar"");
    StringPairMap m;
    m[make_pair(""aa"",""bb"")] = test;

   return 0;
</code></pre>

<p>}</p>
"
"<p>General question: Where is usually defined class, namespace. </p>

<p>My case: </p>

<p>I am only using this maps in my class implementation:</p>

<pre><code>std::map&lt;const std::pair&lt;string, string&gt;,const string*&gt;
</code></pre>

<p>and I wonder where is it good place to put it in the class (in public:) or in the enclosing header file?  I don't have namespaces</p>
","87234","","<p>If it is in your class only, I usually put it at the top of the private section:</p>

<pre><code>class Foo
{
public:
    void some_functions(void);

private:
    typedef std::pair&lt;std::string, std::string&gt; StringPair;
    typedef std::map&lt;StringPair, std::string&gt; StringPairMap;

    StringPairMap _stringMap;
}
</code></pre>

<p>To clarify, as with most things you want to specify these things as local as possible. Variables should do this: you don't define <code>int i</code> for your for-loop until you've reached the loop, etc..</p>

<p>Likewise, if your class uses these typedef's internally, do what I said above. If only a specific function in your class needs that typedef, place the typedef at the beginning of that function.</p>

<p>If you need to expose this typedef to clients of the class, I like to place the typedef's at the top of the <code>public</code> section.</p>
"
"<p>the C++ standard seems to make no statement regarding side-effects on capacity by either 
resize(n), with n &lt; size(), or clear().</p>

<p>It does make a statement about amortized cost of push_back and pop_back - O(1)</p>

<p>I can envision an implementation that does the usual sort of capacity changes 
ala CLRS Algorithms (eg double when enlarging, halve when decreasing size to &lt; capacity()/4).
(Cormen Lieserson Rivest Stein)</p>

<p>Does anyone have a reference for any implementation restrictions?</p>
","87234","","<p>Actually, the standard does specify what should happen:</p>

<p>This is from <code>vector</code>, but the theme is the same for all the containers (<code>list</code>, <code>deque</code>, etc...)</p>

<blockquote>
  <p>23.2.4.2 vector capacity [lib.vector.capacity]</p>
</blockquote>

<p><code>void resize(size_type sz, T c = T());</code></p>

<blockquote>
  <p>6) Effects:</p>
</blockquote>

<pre><code>if (sz &gt; size())
    insert(end(), sz-size(), c);
else if (sz &lt; size())
    erase(begin()+sz, end());
else
    ; //do nothing
</code></pre>

<p>That is to say: If the size specified to <code>resize</code> is less than the number of elements, those elements will be erased from the container. Regarding <code>capacity()</code>, this depends on what <code>erase()</code> does to it.</p>

<p>I cannot locate it in the standard, but I'm pretty sure <code>clear()</code> is defined to be:</p>

<pre><code>void clear()
{
    erase(begin(), end());
}
</code></pre>

<p>Therefore, the effects <code>clear()</code> has on <code>capacity()</code> is also tied to the effects <code>erase()</code> has on it. According to the standard:</p>

<blockquote>
  <p>23.2.4.3 vector modifiers [lib.vector.modifiers]</p>
</blockquote>

<pre><code>iterator erase(iterator position);
iterator erase(iterator first, iterator last);
</code></pre>

<blockquote>
  <p>4) Complexity: The destructor of T is called the number of times equal to the number of the elements erased....</p>
</blockquote>

<p>This means that the elements will be destructed, but the memory will remain intact. <code>erase()</code> has no effect on capacity, therefore <code>resize()</code> and <code>clear()</code> also have no effect.</p>
"
"<p>Suppose I have a free function called <code>InitFoo</code>. I'd like to protect this function from being called multiple times by accident. Without much thought I wrote the following:</p>

<pre><code>void InitFoo()
{
    {
        static bool flag = false;
        if(flag) return;
        flag = true;
    }

    //Actual code goes here.
}
</code></pre>

<p>This looks like a big wart, though. <code>InitFoo</code> does <em>not</em> need to preserve any other state information. Can someone suggest a way to accomplish the same goal without the ugliness?</p>

<p>Macros don't count, of course.</p>
","87234","","<p>Well, a constructor is only automatically called once. If you create a single instance of this class:</p>

<pre><code>class Foo
{
public:
    Foo(void)
    {
        // do stuff
    }
}
</code></pre>

<p>Then <code>//do stuff</code> will only execute once. The only way to execute it twice is to create another instance of the class.</p>

<p>You can prevent this by using a <a href=""http://en.wikipedia.org/wiki/Singleton%5Fpattern"" rel=""nofollow"">Singleton</a>. In effect, <code>//do stuff</code> can only possibly be called once.</p>
"
"<p>I'm wondering if you can overload an operator and use it without changing the object's original values.</p>

<p>Edited code example: </p>

<pre><code>class Rational{
public:
   Rational(double n, double d):numerator_(n), denominator_(d){};
   Rational(){}; // default constructor
   double numerator() const { return numerator_; } // accessor
   double denominator() const { return denominator_; } // accessor
private:
    double numerator_;
    double denominator_;
};

const Rational operator+(const Rational&amp; a, const Rational&amp; b)
{
      Rational tmp;
      tmp.denominator_ = (a.denominator() * b.denominator());
      tmp.numerator_ = (a.numerator() * b.denominator());
      tmp.numerator_ += (b.numerator() * a.denominator());
      return tmp;
}
</code></pre>

<p>I made the accessors const methods, but I'm still getting a privacy error for every tmp.denominator_ / numerator_.</p>
","87234","","<p>Maybe I'm missing something, but why don't you just take out the code that modifies the arguments?</p>

<pre><code>const Rational Rational::operator+(Rational&amp; num)
{
      Rational tmp;
      tmp.denominator_ = (denominator_*num.denominator_);
      //numerator_*=num.denominator_;
      //num.numerator_*=denominator_;
      tmp.numerator_ = (numerator_+num.numerator_);
      return tmp;
}
</code></pre>

<p>This would be caught earlier by being <a href=""http://www.parashift.com/c++-faq-lite/const-correctness.html"" rel=""nofollow"">const-correct</a>.</p>

<p>That means your function signature should be this:</p>

<pre><code>Rational Rational::operator+(const Rational&amp; num) const
</code></pre>

<p>Then you will get errors because you are modifying const objects. The way your operators are written now is generally considered incorrect.</p>

<p>When you add <code>2 + 3</code>, neither 2 nor 3 changes: they are const.</p>

<h3>Edit</h3>

<p>Sorry, I missed the actual math part. Here are a few things:</p>

<p>As a member function (what I have above), do this:</p>

<pre><code>// Note that I use lhs and rhs to refer to the left-hand
// and right-hand sides of an operation. As a member function
// my left-hand side is implicitly `this`.
Rational Rational::operator+(const Rational&amp; rhs) const
{
    Rational temp;

    temp.denominator_ = (denominator() * rhs.denominator());
    temp.numerator_ = (numerator() * rhs.denominator());
    temp.numerator_ += (denominator() * rhs.numerator());
    return temp;
}
</code></pre>

<p>As a global function, do this:</p>

<pre><code>Rational operator+(const Rational&amp; lhs, const Rational&amp; rhs)
{
    Rational temp;

    temp.denominator_ = (lhs.denominator() * rhs.denominator());
    temp.numerator_ = (lhs.numerator() * rhs.denominator());
    temp.numerator_ += (lhs.denominator() * rhs.numerator());

    return temp;
}
</code></pre>

<p>The issue here is you'll get access violations: your member variables are private to the class. You need to let the compiler know that it is okay if this function handles your class's private variables by making the function a friend of the class:</p>

<pre><code>class Rational
{
public:
    friend Rational operator+(const Rational&amp; lhs, const Rational&amp; rhs);
}
</code></pre>
"
"<p>What is difference between <code>%d</code> and <code>%u</code> when printing pointer addresses?</p>

<p>For example:</p>

<pre><code>int a=5;
// check the memory address
printf(""memory add=%d\n"", &amp;a); // prints ""memory add=-12""
printf(""memory add=%u\n"", &amp;a); // prints ""memory add=65456""
</code></pre>

<p>Please define.</p>
","87234","","<p>You can find a list of formatting escapes on <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/printf/"">this page</a>.</p>

<p><code>%d</code> is a signed integer, while <code>%u</code> is an unsigned integer. Pointers (when treated as numbers) are usually non-negative.</p>

<p>If you actually want to display a pointer, use the <code>%p</code> format specifier.</p>
"
"<pre><code>/*/ comment here
do some thing.
/*/
do some thing.
//*/
</code></pre>

<p>Why people write code like that? Is this a good practice?</p>
","87234","","<p>It's usually only used when testing something out for the moment. That is, you should never commit code like that to version control, because it can be confusing.</p>

<p>For example, if you are testing two different computation methods, you can use this to switch between them. Personally I have rarely done this, if at all.</p>

<p><hr /></p>

<p>For those that don't know, you can toggle between the two code sections by adding one forward slash:</p>

<pre><code>/*/ comment here
do some thing.
/*/
do some thing else.
//*/

//*/ comment here
do some thing.
/*/
do some thing else.
//*/
</code></pre>
"
"<p>I've got a class :</p>

<pre><code>class base
{
public :
 base &amp; operator +=(const int value) = 0;
 // base operator + (const int val) = 0; // HOW DO I DO THIS ?
};
</code></pre>

<p>And a child class that derives from it</p>

<pre><code>class derived : public base
{
public :
 derived() : m_val(0) {}
 derived(const derived &amp; val) : m_val(val.m_val) {}
 base &amp; operator = (const derived&amp; value) // POSSIBLE TO RETURN A REFERENCE TO BASE
 { m_val = value.m_val; return *this; }
 base &amp; operator +=(const int val)
 { m_val += val; return *this; }
 /* operator + overload here */
 // base operator + (...) // IMPOSSIBLE TO RETURN A VALUE
protected :
int m_val;
};
</code></pre>

<p>I really really need to have a operator + defined in the base class - which in the mean time needs to remain abstract. I find it hard to achieve as a typical operator + returns a value, while an abstract class can't be instantiated - so I found myself in a bit of a catch #22 situation. 
Is there a valid solution to this ?</p>

<p>Regards</p>
","87234","","<p>I'm replying to your question <a href=""http://stackoverflow.com/questions/1159641/abstract-operator/1161273#1161273"">here</a>. (When you can, delete that ""answer"" and edit your OP)</p>

<p>You should take a look at <a href=""http://www.cplusplus.com/reference/std/iterator/advance/"" rel=""nofollow""><code>std::advance</code></a>, defined in the header <a href=""http://www.cplusplus.com/reference/std/iterator/"" rel=""nofollow""><code>&lt;iterator&gt;</code></a>.</p>

<pre><code>int DoStuff(iterator &amp;it)
{
    iterator a = it;
    std::advance(a, 2);

    // (...)
    return 0;
}
</code></pre>

<p>If I'm misunderstanding your question, forgive me :P</p>
"
"<p>I am working in a class ""A"" that requires very high performance and am trying to work out the implications either way.</p>

<p>If I inherit this new class ""B"", the memory profile of ""A"" should increase by that much.  </p>

<p>If I include just a ptr to ""B"" as a member variable in ""A"", then would I be correct in thinking that, as long as ""B"" is on the heap (ie new'd up) then ""A"" will remain as small as it is other than the new ptr reference.  Is there something else that I haven't thought of?</p>

<p>It is preferable architecture wise for me to inherit ""B"", however it may be preferable performance wise to just stick with it as a member variable.</p>
","87234","","<p>Have you profiled this and determined it will be an issue? Or are you just guessing? If inheriting is preferable and cleaner, do it the way. Later, if it turns out that the other method might be faster, do that, profile both, and determine which is faster.</p>

<p>However, I am confused. Inheriting from things does not increase the size of the class, except those members of the base class. In fact, having a pointer-to-base and inheriting from the base have very different behaviors! How would virtual functions work?</p>

<p>Also, size shouldn't slow your program down. Pass by references, and use <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/ptr%5Fcontainer/doc/ptr%5Fcontainer.html"" rel=""nofollow"">pointer container</a>'s and <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/smart%5Fptr/smart%5Fptr.htm"" rel=""nofollow"">smart pointer</a>'s and you shouldn't see a performance loss no matter what the size.</p>
"
"<p>What is the compatible ""int"" datatype in C++ that can resize itself to 4 bytes on 32bit &amp; 8 bytes on 64bit windows?</p>

<p>Although INT_PTR works fine but it reduces the readability as well as its description tells us to use it for pointer arithmetic.</p>

<p>Thanks</p>
","87234","","<p>The standard does not mention specific size requirements, only that each integral type must provide at least as much storage as the type before it. So <code>int</code> must hold as much as a <code>short</code>, and so on. You're better off specifying what you need them for.</p>

<p>If you're looking for integers that do not change size based on the operating environment, take a look at the <a href=""http://www.boost.org/doc/libs/1_39_0/libs/integer/index.html"" rel=""nofollow"">Boost Integer Library</a>, or the C99/C++11 header <code>&lt;cstdint&gt;</code>. This contains types such as <code>uint32_t</code>/<code>int32_t</code> and <code>uintmax_t</code>/<code>intmax_t</code>.</p>

<p>Most importantly, based off your question, it has: <code>uintptr_t</code>/<code>intptr_t</code>. These are guaranteed to have the correct size to hold a pointer on your platform.</p>
"
"<p>One of the thing that has been confusing for me while learning C++ (and Direct3D, but that some time ago) is when you should use a pointer member in a class. For example, I can use a non-pointer declaration:</p>

<pre><code>private:
    SomeClass instance_;
</code></pre>

<p>Or I could use a pointer declaration</p>

<pre><code>private:
   Someclass * instance_
</code></pre>

<p>And then use new() on it in the constructor. </p>

<p>I understand that if SomeClass could be derived from another class, a COM object or is an ABC then it should be a pointer. Are there any other guidelines that I should be aware of?</p>
","87234","","<p>Allocate it on the stack if you can, from the free-store if you have to. There is a <a href=""http://stackoverflow.com/questions/1064325/why-not-use-pointers-for-everything-in-c"">similar question</a> here, where you will find all the ""why's"".</p>

<p>The reason you see lots of pointer usage when it comes to games and stuff is because DirectX is a COM interface, and in honesty, most games programmers from back in the day aren't really C++ programmers, they are C-with-classes programmers, and in C pointer usage is very common.</p>
"
"<p>I'm trying to use the boost library in my code but get the following linker errors under Sparc Solaris platform.</p>

<p>The problem code can essentially be summarised to:</p>

<pre><code>#include &lt;boost/algorithm/string.hpp&gt;

std::string xparam;

... 
xparam = boost::to_lower(xparam);
</code></pre>

<p>The linker error is:</p>

<pre><code>LdapClient.cc:349: no match for `std::string&amp; = void' operator
/opt/gcc-3.2.3/include/c++/3.2.3/bits/basic_string.h:338: candidates are: std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; std::basic_string&lt;_CharT, _Traits, _Alloc&gt;::operator=(const std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;, _Alloc = std::allocator&lt;char&gt;]
/opt/gcc-3.2.3/include/c++/3.2.3/bits/basic_string.h:341:                 std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; std::basic_string&lt;_CharT, _Traits, _Alloc&gt;::operator=(const _CharT*) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;, _Alloc = std::allocator&lt;char&gt;]
/opt/gcc-3.2.3/include/c++/3.2.3/bits/basic_string.h:344:                 std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; std::basic_string&lt;_CharT, _Traits, _Alloc&gt;::operator=(_CharT) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;, _Alloc = std::allocator&lt;char&gt;]
gmake: *** [LdapClient.o] Error 1
</code></pre>

<p>Any ideas?</p>
","87234","","<p><a href=""http://www.boost.org/doc/libs/1%5F39%5F0/doc/html/boost/algorithm/to%5Flower.html"" rel=""nofollow""><code>boost::to_lower</code></a> does not return a copy of the string, it operates on the variable passed into the function. For some examples, <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/doc/html/string%5Falgo/usage.html"" rel=""nofollow"">read this</a>.</p>

<p>So no need to reassign:</p>

<pre><code>boost::to_lower(xparam);
</code></pre>

<p>You will get an error because you are trying to assign the string to the value <code>void</code>.</p>

<p>If you want to make a copy of it, use the copy version:</p>

<pre><code>std::string xparamLowered = boost::to_lower_copy(xparam);
</code></pre>
"
"<p>I'm trying to iterator over some directories containing approximately 3000 images. I load the image. If the image is loaded I release it. 
That is the smallest program that I can write to reproduce the error. </p>

<p>After loading and releasing 124 images the program stops loading images. I think this a <strong>memory</strong> issue but I don't understand what exactly causes the program to stop loading images. </p>

<p>I'm using <strong>OpenCV</strong> on my <strong>Mac</strong>. I don't know how exactly I can figure out which version I'm using. </p>

<p>Here is the Code from my project.</p>

<pre><code>bool FaceDetectionStrategy::detectFace(std::string imagePath) {

   IplImage *img = cvLoadImage(imagePath.c_str(), CV_LOAD_IMAGE_COLOR);
   if (img) {
      std::cout &lt;&lt; ""Image loaded "" &lt;&lt; imagePath &lt;&lt; std::endl;
      cvReleaseImage(&amp;img);
   } else {
      std::cout &lt;&lt; ""Image not loaded "" &lt;&lt; imagePath &lt;&lt; std::endl;
   }
return true;
</code></pre>

<p>}</p>

<p>This method is called for every image in the directorys I'm iterating through. After 124 images the if(img) part evaluates to false and the else branch is executed. If I try to load images from other parts of the program later on they also won't load.</p>

<p><strong>Edit</strong> it is not a memory issue. Mac Os standard max open files is 256 after changing it to 512 I can open 251 images. so it seems that OpenCV doesn't closes the image files after loading them. </p>
","87234","","<p>Behavior concerning memory rarely has to do with a consistent number, in my experience. The only way it could be that consistent is if there is some sort of internal limit in <code>cvLoadImage</code> that happens to be the not-very-common number 124. But your logic seems fine to me, that your images should be released.</p>

<p>More likely, since I assume your directories aren't changing between tests, that 125th image is bad.</p>

<p>Have you verified that the image you are trying to load actually exists? If it does (which it probably does), check that the image file format is <a href=""http://www.cs.iit.edu/~agam/cs512/lect-notes/opencv-intro/opencv-intro.html#SECTION00052000000000000000"" rel=""nofollow"">supported by OpenCV</a>. If that is also true, make sure the file is not corrupted by opening it with another editor.</p>

<p>You can have OpenCV <a href=""http://opencv.willowgarage.com/documentation/error%5Fhandling%5Fand%5Fsystem%5Ffunctions.html"" rel=""nofollow"">help you out with errors</a>. Use <a href=""http://opencv.willowgarage.com/documentation/error%5Fhandling%5Fand%5Fsystem%5Ffunctions.html#cvGetErrStatus"" rel=""nofollow""><code>cvGetErrStatus()</code></a> to check if there was an error, then use <a href=""http://opencv.willowgarage.com/documentation/error%5Fhandling%5Fand%5Fsystem%5Ffunctions.html#cvErrorStr"" rel=""nofollow""><code>cvErrorStr()</code></a> to get a textual description of it. You can do something like this:</p>

<pre><code>// I would recommend putting this in a file, like CVUtility.h

#include &lt;exception&gt;

void check_CV_Error(void)
{
    int errorCode = cvGetErrStatus();
    if (errorCode) // I'm assuming 0 means no reportable error
    {
        throw std::runtime_error(cvErrorStr(errorCode));
        // std::cerr &lt;&lt; cvErrorStr(errorCode);
        // ^ if you would rather not use exceptions
    }
}
</code></pre>

<p>Your code then becomes:</p>

<pre><code>bool FaceDetectionStrategy::detectFace(std::string imagePath) {

   IplImage *img = cvLoadImage(imagePath.c_str(), CV_LOAD_IMAGE_COLOR);
   if (img) {
      std::cout &lt;&lt; ""Image loaded "" &lt;&lt; imagePath &lt;&lt; std::endl;
      cvReleaseImage(&amp;img);
   } else {
      std::cout &lt;&lt; ""Image not loaded "" &lt;&lt; imagePath &lt;&lt; std::endl;
      check_CV_Error(); // find reason for error
   }
return true;
</code></pre>

<p>And that will throw an exception for you to catch and log, and possibly react on. (Or print the error to console if you use the <code>std::cerr</code> version)</p>
"
"<p>I know that it's not safe to throw exceptions from destructors, but is it ever unsafe to throw exceptions from constructors?  </p>

<p>e.g. what happens for objects that are declared globally?  A quick test with gcc and I get
an abort, is that always guaranteed?  What solution would you use to cater for that situation?</p>

<p>Are there any situations where constructors can throw exceptions and not leave things how we expect.</p>

<p>EDIT:  I guess I should add that I'm trying to understand under what circumstances I could get a resource leak.  Looks like the sensible thing to do is manually free up resources we've obtained part way through construction before throwing the exception.  I've never needed to throw exceptions in constructors before today so trying to understand if there are any pitfalls.</p>

<p>i.e. Is this also safe?</p>

<pre><code>class P{
  public:
    P() { 
       // do stuff...

       if (error)
          throw exception
    }
}

dostuff(P *p){
 // do something with P
}

... 
try {
  dostuff(new P())
} catch(exception) {

}
</code></pre>

<p>will the memory allocated to the object P be released?</p>

<p>EDIT2: Forgot to mention that in this particular case dostuff  is storing the reference to P in an output queue.  P is actually a message and dostuff takes the message, routes it to the appropriate output queue and sends it.  Essentially, once dostuff has hold of it, it gets released later in the innards of dostuff.  I think I want to put an autoptr around P and call release on the autoptr after dostuff to prevent a memory leak, would that be correct?</p>
","87234","","<p>Throwing exceptions from a constructor is a <a href=""http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.2"" rel=""nofollow"">good thing</a>. When something fails in a constructor, you have two options:</p>

<ul>
<li>Maintain a ""zombie"" state, where the class exists but does nothing, or</li>
<li>Throw an exception.</li>
</ul>

<p>And maintaining zombie classes can be quite a hassle, when the real answer should have been, ""this failed, now what?"".</p>

<p>According to the Standard at 3.6.2.4:</p>

<blockquote>
  <p>If construction or destruction of a non-local static object ends in throwing an uncaught exception, the result is to call terminate (18.6.3.3).</p>
</blockquote>

<p>Where terminate refers to <a href=""http://en.cppreference.com/w/cpp/error/terminate"" rel=""nofollow""><code>std::terminate</code></a>.</p>

<hr>

<p>Concerning your example, no. This is because you aren't using <a href=""http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"" rel=""nofollow"">RAII concepts</a>. When an exception is thrown, the stack will be unwound, which means all objects get their destructor's called as the code gets to the closest corresponding <code>catch</code> clause.</p>

<p>A pointer doesn't have a destructor. Let's make a simple test case:</p>

<pre><code>#include &lt;string&gt;

int main(void)
{
    try
    {
        std::string str = ""Blah."";
        int *pi = new int;

        throw;

        delete pi; // cannot be reached
    }
    catch(...)
    {
    }
}
</code></pre>

<p>Here, <code>str</code> will allocate memory, and copy ""Blah."" into it, and <code>pi</code> will be initialized to point to an integer in memory.</p>

<p>When an exception is thrown, stack-unwinding begins. It will first ""call"" the pointer's destructor (do nothing), then <code>str</code>'s destructor, which will free the memory that was allocated to it.</p>

<p>If you use RAII concepts, you'd use a smart pointer:</p>

<pre><code>#include &lt;memory&gt;
#include &lt;string&gt;

int main(void)
{
    try
    {
        std::string s = ""Blah."";
        std::auto_ptr&lt;int&gt; pi(new int);

        throw;

        // no need to manually delete.
    }
    catch(...)
    {
    }
}
</code></pre>

<p>Here, <code>pi</code>'s destructor will call <code>delete</code> and no memory will be leaked. This is why you should always wrap your pointers, and is the same reason we use <code>std::vector</code> rather than manually allocating, resizing, and freeing pointers. (Cleanliness and Safety)</p>

<h3>Edit</h3>

<p>I forgot to mention. You asked this:</p>

<blockquote>
  <p>I think I want to put an autoptr around P and call release on the autoptr after dostuff to prevent a memory leak, would that be correct?</p>
</blockquote>

<p>I didn't state it explicitly, and only implied it above, but the answer is <strong>no</strong>. All you have to do is place it inside of <code>auto_ptr</code> and when the time comes, it will be deleted automatically. Releasing it manually defeats the purpose of placing it in a container in the first place.</p>

<p>I would also suggest you look at more advanced smart pointers, such as those in <a href=""http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/smart_ptr.htm"" rel=""nofollow"">boost</a>. An extraordinarily popular one is <a href=""http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/shared_ptr.htm"" rel=""nofollow""><code>shared_ptr</code></a>, which is <a href=""http://en.wikipedia.org/wiki/Reference_counting"" rel=""nofollow"">reference counted</a>, making it suitable for storage in containers and being copied around. (Unlike <code>auto_ptr</code>. Do <em>not</em> use <code>auto_ptr</code> in containers!)</p>
"
"<p>Right now I'm writing a program that will determine the value of a hand of cards. five in total. i have a cardHand object. I'm planning to write an object that compares two objects together in order to determine which hand has a higher value. the two objects that will be compared are objects that contain the possible hand values (one pair, three of a kind... etc).</p>

<p>would stackoverflow see this as a fit method of OOP?</p>

<p>PS: i do know that the algorithm is floating around on the internet but im trying to do this by my self first for the XP.</p>
","87234","","<p>What you'll want to do is something like this:</p>

<ul>
<li>Create a card class. Add an <code>operator&lt;</code> to this class so you can determine the sorting of individual cards.</li>
<li>Create a card collection (hand) class that stores a collection of these cards. Define an operator&lt; for this class as well, to determine the sorting of hands.</li>
</ul>

<p>If you store your cards in an <a href=""http://www.cplusplus.com/reference/stl/multiset/"" rel=""nofollow""><code>std::multiset</code></a> in the hand, your cards will group themselves together automatically.</p>

<p>That is, if you insert <code>2, 7, 3, 4, 3</code> they will be in this order: <code>2, 3, 3, 4, 7</code>. This will help you determine things like pairs and tuplets.</p>
"
"<p>Why this code does <strong>not</strong> cause memory leaks?</p>

<pre><code>int iterCount = 1000;
int sizeBig = 100000;
for (int i = 0; i &lt; iterCount; i++)
{
   std::auto_ptr&lt;char&gt; buffer(new char[sizeBig]);
}
</code></pre>

<p>WinXP sp2, Compiler : BCB.05.03</p>
","87234","","<p>Because you're (un)lucky. <code>auto_ptr</code> calls <code>delete</code>, not <code>delete []</code>. This is undefined behavior.</p>

<p>Try doing something like this and see if you get as lucky:</p>

<pre><code>struct Foo
{
    char *bar;
    Foo(void) : bar(new char[100]) { }
    ~Foo(void) { delete [] bar; }
}

int iterCount = 1000;
int sizeBig = 100000;
for (int i = 0; i &lt; iterCount; i++)
{
   std::auto_ptr&lt;Foo&gt; buffer(new Foo[sizeBig]);
}
</code></pre>

<p>The idea here is that your destructor for <code>Foo</code> will not be called.</p>

<p><hr /></p>

<p>The reason is something like this: When you say <code>delete[] p</code>, the implementation of <code>delete[]</code> is suppose to go to each element in the array, call its destructor, then free the memory pointed to by p. Similarly, <code>delete p</code> is suppose to call the destructor on p, then free the memory.</p>

<p><code>char</code>'s don't have a destructor, so it's just going to delete the memory pointed to by p. In my code above, it is <strong>not</strong> going to destruct each element in the array (because it's not calling <code>delete[]</code>), so some Foo's will leave their local bar variable un-deleted.</p>
"
"<p>I'm kind of wondering about this, if you create a texture in memory in DirectX with the CreateTexture function:</p>

<pre><code>HRESULT CreateTexture(
  UINT Width,
  UINT Height,
  UINT Levels,
  DWORD Usage,
  D3DFORMAT Format,
  D3DPOOL Pool,
  IDirect3DTexture9** ppTexture,
  HANDLE* pSharedHandle
);
</code></pre>

<p>...and pass in <code>D3DFMT_UNKNOWN</code> format what is supposed to happen exactly? If I try to get the surface of the first or second level will it cause an error? Can it fail? Will the graphics device just choose a random format of its choosing? Could this cause problems between different graphics card models/brands?</p>
","87234","","<p>I just tried it out and it does not fail, mostly</p>

<p>When <code>Usage</code> is set to <code>D3DUSAGE_RENDERTARGET</code> or <code>D3DUSAGE_DYNAMIC</code>, it consistently came out as <code>D3DFMT_A8R8G8B8</code>, no matter what I did to the back buffer format or other settings. I don't know if that has to do with my graphics card or not. My guess is that specifying unknown means, ""pick for me"", and that the 32-bit format is easiest for my card.</p>

<p>When the usage was <code>D3DUSAGE_DEPTHSTENCIL</code>, it failed consistently.</p>

<p>So my best conclusion is that specifying <code>D3DFMT_UNKNOWN</code> as the format gives DirectX the choice of what it should be. Or perhaps it always just defaults to <code>D3DFMT_A8R8G8B</code>.</p>

<p>Sadly, I can't confirm any of this in any documentation anywhere. :|</p>
"
"<p>Is this correct ?
This is compiled with g++ (3.4) sucessfully.</p>

<pre>
int main()
{
    int x = 12;
    char pz[x]; 
}
</pre>
","87234","","<p>Here's your combination answer of all these other ones:</p>

<p>Your code right now is <strong>not</strong> standard C++. It <strong>is</strong> standard C99. This is because C99 allows you to declare arrays dynamically that way. To clarify, this is also standard C99:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int x = 0;

    scanf(""%d"", &amp;x);

    char pz[x]; 
}
</code></pre>

<p>This is <strong>not</strong> standard anything:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    int x = 0;
    std::cin &gt;&gt; x;
    char pz[x]; 
}
</code></pre>

<p>It cannot be standard C++ because that required constant array sizes, and it cannot be standard C because C does not have <code>std::cin</code> (or namespaces, or classes, etc...)</p>

<p>To make it standard C++, do this:</p>

<pre><code>int main()
{
    const int x = 12; // x is 12 now and forever...
    char pz[x]; // ...therefore it can be used here
}
</code></pre>

<p>If you want a dynamic array, you <em>can</em> do this:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    int x = 0;
    std::cin &gt;&gt; x;

    char *pz = new char[x];

    delete [] pz;
}
</code></pre>

<p>But you should do this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    int x = 0;
    std::cin &gt;&gt; x;

    std::vector&lt;char&gt; pz(x);
}
</code></pre>
"
"<p>I'm writing a Vector3D class that calls a static method on a VectorMath class to perform a calculation. When I compile, I get this:</p>

<pre>
bash-3.1$ g++ VectorMath.cpp Vector3D.cpp
/tmp/cc5cAPia.o: In function `main':
Vector3D.cpp:(.text+0x4f7): undefined reference to 'VectorMath::norm(Vector3D*)'
collect2: ld returned 1 exit status
</pre>

<p>The code:</p>

<p><b>VectorMath.h:</b></p>

<pre><code>#ifndef VECTOR3D_H
#include ""Vector3D.h""
#endif

class VectorMath {
    public:
    static Vector3D* calculatePerpendicularVector(Vector3D*, Vector3D*);
    static Vector3D* norm(Vector3D*);
    static double length(Vector3D*);
};
</code></pre>

<p><b>VectorMath.cpp</b></p>

<pre><code>#include ""VectorMath.h""
Vector3D* norm(Vector3D* vector) { // can't be found by linker
    // do vector calculations
    return new Vector3D(xHead, yHead, zHead, xTail, yTail, zTail);
}
// other methods
</code></pre>

<p><b>Vector3D.cpp</b></p>

<pre><code>#include ""Vector3D.h""
#include ""VectorMath.h""
// ...
// vector implementation
// ...
int main(void) {
    Vector3D* v = new Vector3D(x, y, z);
    Vector3D* normVector = VectorMath::norm(v); // error here
}
</code></pre>

<p>Why can't the linker find the <code>VectorMath::norm</code> method? At first glance I'd think that I'd need to declare norm like this:</p>

<pre><code>Vector3D* VectorMath::norm(Vector3D* vector) {
</code></pre>

<p>but that doesn't help either...</p>
","87234","","<p>You're missing this:</p>

<pre><code>//VectorMath.cpp
#include ""VectorMath.h""

             |
             V - here
Vector3D* VectorMath::norm(Vector3D* vector)
{
    ...
}
</code></pre>

<p>The <code>norm</code> function is part of <code>VectorMath::</code>. Without that, you just have a free function.</p>

<p><hr /></p>

<p>This is more about your design, but why are you using pointers to everything? This is much cleaner:</p>

<pre><code>class VectorMath {
    public:
    static Vector3D norm(const Vector3D&amp;);
};
</code></pre>

<p>Take references, you're in C++ so don't write C code. What happens when I call this?</p>

<pre><code>VectorMath::norm(0); // null
</code></pre>

<p>It will either crash, you have to put in a check, in which case, what should it return? This is all cleaned up by using references.</p>

<p>Also, why not just make these members of the <code>Vector3D</code> class?</p>

<pre><code>Vector3D* v = new Vector3D(x, y, z);
v-&gt;norm(); // normalize would be better, in my opinion
</code></pre>

<p>Lastly, stack-allocate things. Your code right now has a memory leak:</p>

<pre><code>int main(void) {
    Vector3D* v = new Vector3D(x, y, z);
    Vector3D* normVector = VectorMath::norm(v); 

    // delete v;
    // ^ you're not deleting it!
}
</code></pre>

<p>Change it to this, and use <a href=""http://en.wikipedia.org/wiki/Resource%5FAcquisition%5FIs%5FInitialization"">RAII</a> concepts:</p>

<pre><code>int main(void) {
    Vector3D v(x, y, z);
    Vector3D* normVector = VectorMath::norm(v);

    // delete v;
    // ^ you're not deleting it!
}
</code></pre>

<p>And by making <code>norm</code> a member function you end up with the very clean code:</p>

<pre><code>int main(void) {
    Vector3D v(x, y, z);
    Vector3D normVector(v.norm());
}
</code></pre>

<p>No pointers, no leaks, all sexy.</p>
"
"<p>I am programming in windows c++.
I want to know which is the fasted method to draw a DIB onto Screen.
The image maybe stretched.</p>

<p>Faster than StretchDIBits, Faster than SetDIBitsToDevice.
Faster than StretchBits.</p>

<p>and with high stretch quality.</p>

<p>Many thanks!</p>
","87234","","<p>The API function <a href=""http://msdn.microsoft.com/en-us/library/dd145121%28VS.85%29.aspx"" rel=""nofollow""><code>StretchDIBits</code></a> will take advantage of hardware, I think. Other than that, take a look at <a href=""http://msdn.microsoft.com/en-us/library/dd183370%28VS.85%29.aspx"" rel=""nofollow""><code>BitBlt</code></a> / <a href=""http://msdn.microsoft.com/en-us/library/ms940373.aspx"" rel=""nofollow""><code>StretchBlt</code></a>.</p>

<p>Also, there are some <a href=""http://stackoverflow.com/questions/tagged/stretchdibits"">other questions</a> concerning <code>StretchDIBits</code> that you might take a look at, if you take that route.</p>

<p><hr /></p>

<p>If you're unsatisfied by these methods, I don't know what else to tell you. Your CPU can only do so much. Make sure you're caching results of operations when you can and only <a href=""http://msdn.microsoft.com/en-us/magazine/cc163558.aspx"" rel=""nofollow"">updating what you need</a>. Look into <a href=""http://www.opengl.org/"" rel=""nofollow"">OpenGL</a> or <a href=""http://www.microsoft.com/games/en-US/aboutgfw/Pages/directx10.aspx"" rel=""nofollow"">DirectX</a> to take full advantage of your graphics card.</p>
"
"<p>I'm a newbie to C++. I'm trying to have a char pointer as an out parameter for a function. But the changes made in the function are not reflected in the main function. What am I doing wrong?</p>

<pre><code>void SetName( char *pszStr )
{
    char* pTemp = new char[10];
    strcpy(pTemp,""Mark"");
    pszStr = pTemp;
}

int _tmain(int argc, _TCHAR* argv[])
{
    char* pszName = NULL;
    SetName( pszName );
    cout&lt;&lt;""Name - ""&lt;&lt;*pszName&lt;&lt;endl;
    delete pszName;
    return 0;
}
</code></pre>
","87234","","<p>Your pointer is being copied onto the stack, and you're assigning the stack pointer. You need to pass a pointer-to-pointer if you want to change the pointer:</p>

<pre><code>void SetName( char **pszStr )
{
    char* pTemp = new char[10];
    strcpy(pTemp,""Mark"");
    *pszStr = pTemp; // assign the address of the pointer to this char pointer
}

int _tmain(int argc, _TCHAR* argv[])
{
    char* pszName = NULL;
    SetName( &amp;pszName ); // pass the address of this pointer so it can change
    cout&lt;&lt;""Name - ""&lt;&lt;*pszName&lt;&lt;endl;
    delete pszName;
    return 0;
}
</code></pre>

<p>That will solve your problem. </p>

<hr>

<p>However, there are other problems here. Firstly, you are dereferencing your pointer before you print. This is incorrect, your pointer is a pointer to an array of characters, so you want to print out the entire array:</p>

<pre><code>cout&lt;&lt;""Name - ""&lt;&lt;pszName&lt;&lt;endl;
</code></pre>

<p>What you have now will just print the first character. <a href=""http://stackoverflow.com/questions/1217173/how-to-have-a-char-pointer-as-an-out-parameter-for-c-function/1217219#1217219"">Also</a>, you need to use <code>delete []</code> to delete an array:</p>

<pre><code>delete [] pszName;
</code></pre>

<hr>

<p>Bigger problems, though, are in your design.</p>

<p>That code is C, not C++, and even then it's not standard. Firstly, the function you're looking for is <code>main</code>:</p>

<pre><code>int main( int argc, char * argv[] )
</code></pre>

<p>Secondly, you should use <a href=""http://www.parashift.com/c++-faq-lite/references.html"">references</a> instead of pointers:</p>

<pre><code>void SetName(char *&amp; pszStr )
{
    char* pTemp = new char[10];
    strcpy(pTemp,""Mark"");
    pszStr = pTemp; // this works because pxzStr *is* the pointer in main
}

int main( int argc, char * argv[] )
{
    char* pszName = NULL;
    SetName( pszName ); // pass the pointer into the function, using a reference
    cout&lt;&lt;""Name - ""&lt;&lt;pszName&lt;&lt;endl;
    delete pszName;
    return 0;
}
</code></pre>

<p>Aside from that, it's usually better to just return things if you can:</p>

<pre><code>char *SetName(void)
{
    char* pTemp = new char[10];
    strcpy(pTemp,""Mark"");
    return pTemp;
}

int main( int argc, char * argv[] )
{
    char* pszName = NULL;
    pszName = SetName(); // assign the pointer
    cout&lt;&lt;""Name - ""&lt;&lt;pszName&lt;&lt;endl;
    delete pszName;
    return 0;
}
</code></pre>

<p>There is something that makes this all better. C++ has a <a href=""http://en.cppreference.com/w/cpp/string/basic_string"">string class</a>:</p>

<pre><code>std::string SetName(void)
{
    return ""Mark"";
}

int main( int argc, char * argv[] )
{
    std::string name;

    name = SetName(); // assign the pointer

    cout&lt;&lt;""Name - ""&lt;&lt; name&lt;&lt;endl;

    // no need to manually delete
    return 0;
}
</code></pre>

<p>If course this can all be simplified, if you want:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

std::string get_name(void)
{
    return ""Mark"";
}

int main(void)
{
    std::cout &lt;&lt; ""Name - "" &lt;&lt; get_name() &lt;&lt; std::endl;        
}
</code></pre>

<p>You should work on your formatting to make things more readable. Spaces inbetween your operators helps:</p>

<pre><code>cout&lt;&lt;""Name - ""&lt;&lt;pszName&lt;&lt;endl;

cout &lt;&lt; ""Name - "" &lt;&lt; pszName &lt;&lt; endl;
</code></pre>

<p>Just like spaces in between English words helps, sodoesspacesbetweenyouroperators. :)</p>
"
"<p>I'm writing a Windows console application in C++ and would like to return zero on success and a meaningful error code on failure (i.e., <code>S_OK</code> should return 0, and <code>E_OUTOFMEMORY</code> should return a different return value than <code>E_FAIL</code> and so on). Is the following an okay approach?:</p>

<pre><code>int wmain(int argc, wchar_t *argv[])
{
    HRESULT hr = DoSomething();
    return (int) hr;
}
</code></pre>

<p>Or is there a better way? Maybe a standard Win32 API function or macro that I'm forgetting or failing to find?</p>
","87234","","<p>The ""better way"" is to use a C++ style cast:</p>

<pre><code>HRESULT hr = DoSomething();
return static_cast&lt;int&gt;(hr);
</code></pre>

<p>Otherwise, <a href=""http://stackoverflow.com/questions/1218355/how-to-convert-win32-hresult-to-int-return-value/1218361#1218361"">like Steve said</a>, it's just an integer. It is defined as a <code>long</code>, not an <code>int</code>, but instead of casting from <code>HRESULT</code> to <code>long</code> to <code>int</code>, you can obviously just do it in one maneuver.</p>

<p>(That is to say, <code>windows.h</code> makes the assumption that <code>long</code> will be a 32-bit integer, which the C &amp; C++ standard's do not guarantee. But that's just how things go, I suppose.)</p>

<p><hr /></p>

<p>Even better is that this does not require a cast at all.</p>
"
"<p>I have a class like this</p>

<pre><code>class MyClass 
{
    int Identifier;
    int Context;
    int Data;
}
</code></pre>

<p>and I plan to store it in a STL container like</p>

<pre><code>vector&lt;MyClass&gt; myVector;
</code></pre>

<p>but I will need to access it either by the extenal Index (using <code>myVector[index]</code>); and the combination of  <code>Identifier</code> and <code>Context</code> which in this case I would perform a search with something like</p>

<pre><code>vector&lt;MyClass&gt;::iterator myIt;
for( myIt = myVector.begin(); myIt != myVector.end(); myIt++ )
{
    if( ( myIt-&gt;Idenfifier == target_id ) &amp;&amp;
        ( myIt-&gt;Context == target_context ) )
        return *myIt; //or do something else...
}
</code></pre>

<p>Is there a better way to store or index the data?</p>
","87234","","<p>We need to know your usage. <em>Why</em> do you need to be able to get them by index, and how often do you need to search the container for a specific element.</p>

<p>If you store it in an <a href=""http://www.cplusplus.com/reference/stl/set/"" rel=""nofollow""><code>std::set</code></a>, your search time with be O(ln n), but you cannot reference them by index.</p>

<p>If you use an <a href=""http://www.cplusplus.com/reference/stl/vector/"" rel=""nofollow""><code>std::vector</code></a>, you can index them, but you have to use <a href=""http://www.cplusplus.com/reference/algorithm/find/"" rel=""nofollow""><code>std::find</code></a> to get a specific element, which will be O(n).</p>

<p>But if you need an index to pass it around to other things, you could use a pointer. That is, use a set for faster look-up, and pass pointers (not index's) to specific elements.</p>
"
"<p>I've started to pick up this pattern:</p>

<pre><code>template&lt;typename T&gt;
struct DefaultInitialize
{
   DefaultInitialize():m_value(T()){}
   // ... conversions, assignments, etc ....
};
</code></pre>

<p>So that when I have classes with primitive members, I can set them to be initialized to 0 on construction:</p>

<pre><code>struct Class
{
  ...
  DefaultInitialize&lt;double&gt; m_double;
  ...
};
</code></pre>

<p>The reason I do this is to avoid having to remember to initialize the member in each constructor (if there are multiple constructors). I'm trying to figure out if:</p>

<ul>
<li>This is a valid pattern?</li>
<li>I am using the right terminology?</li>
</ul>
","87234","","<p>Seems like a lot of work to avoid having to type <code>m_double(0)</code>. I think it's harder to understand at first glance, but it does seem fine as long as everything is implemented properly.</p>

<p>But is it worth it? Do you really want to have to <code>#include ""DefaultInitialize.h""</code> everywhere?</p>

<p><hr /></p>

<p>To clarify, basically, you're:</p>

<ul>
<li>Making your compile times longer because of the includes.</li>
<li>Your code base larger because you have to manage the deceptively simple <code>DefaultInitialize</code> class</li>
<li>Increase the time it takes other people to read your code. If you have a member of a class that's a <code>double</code>, that's natural to me, but when I see <code>DefaultInitialize</code>, I have to learn what that is and why it was created</li>
</ul>

<p>All that because you don't like to type out a constructor. I understand that it seems very nice to not have to do this, but most worth-while classes I've ever written tend to need to have a constructor written anyway.</p>

<p>This is certainly only my opinion, but I think most other people will agree with it. That is: it would be handy to not have to explicitly initialize members to 0, but the alternative (your class) isn't worth it.</p>

<p>Not to mention that in C++0x, you can do this;</p>

<pre><code>class Foo
{
private:
    int i = 0; // will be initialized to 0
}
</code></pre>
"
"<p>What's the most compact way to compute the number of lines of a file?
I need this information to create/initialize a matrix data structure.</p>

<p>Later I have to go through the file again and store the information inside a matrix.</p>

<p><strong>Update:</strong> Based on Dave Gamble's. But why this doesn't compile?
Note that the file could be very large. So I try to avoid using container
to save memory. </p>

<pre><code>#include &lt;iostream&gt;      
#include &lt;vector&gt;        
#include &lt;fstream&gt;       
#include &lt;sstream&gt;       
using namespace std;     


int main  ( int arg_count, char *arg_vec[] ) {
    if (arg_count !=2 ) {
        cerr &lt;&lt; ""expected one argument"" &lt;&lt; endl;
        return EXIT_FAILURE;      
    }

    string line;
    ifstream myfile (arg_vec[1]);

    FILE *f=fopen(myfile,""rb"");
    int c=0,b;
    while ((b=fgetc(f))!=EOF) c+=(b==10)?1:0;
    fseek(f,0,SEEK_SET);


    return 0;
}
</code></pre>
","87234","","<p>If the reason you need to ""go back again"" is because you cannot continue without the size, try re-ordering your setup.</p>

<p>That is, read through the file, storing each line in a <code>std::vector&lt;string&gt;</code> or something. Then you have the size, along with the lines in the file:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main(void)
{
    std::fstream file(""main.cpp"");
    std::vector&lt;std::string&gt; fileData;

    // read in each line
    std::string dummy;
    while (getline(file, dummy))
    {
    	fileData.push_back(dummy);
    }

    // and size is available, along with the file
    // being in memory (faster than hard drive)
    size_t fileLines = fileData.size();

    std::cout &lt;&lt; ""Number of lines: "" &lt;&lt; fileLines &lt;&lt; std::endl;
}
</code></pre>

<p><hr /></p>

<p>Here is a solution without the container:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main(void)
{
    std::fstream file(""main.cpp"");
    size_t fileLines = 0;    

    // read in each line
    std::string dummy;
    while (getline(file, dummy))
    {
    	++fileLines;
    }

    std::cout &lt;&lt; ""Number of lines: "" &lt;&lt; fileLines &lt;&lt; std::endl;
}
</code></pre>

<p>Though I doubt that's the most efficient way. The benefit of this method was the ability to store the lines in memory as you went.</p>
"
"<p>I'm having a really nasty problem with some code that I've written.  I found someone else that had the same problem on stackoverflow and I tried the solutions but none worked for me.</p>

<p>I typedef several common STL types that I'm using and none of the others have any problem except when I try to typedef a map.
I get a ""some_file.h:83: error: expected initializer before '&lt;' token"" error when including my header in a test program.</p>

<p>Here's the important part of the header(some_file.h):</p>

<pre><code>#ifndef SOME_FILE_H
#define SOME_FILE_H
// some syntax-correct enums+class prototypes
typedef std::string str;
typedef std::vector&lt;Column&gt; col_vec;
typedef col_vec::iterator col_vec_i;
typedef std::vector&lt;Row&gt; row_vec;
typedef row_vec::iterator row_vec_i;
typedef std::vector&lt;str&gt; str_vec;
typedef str_vec::iterator str_vec_i;
typedef std::vector&lt;Object&gt; obj_vec;
typedef obj_vec::iterator obj_vec_i;
typedef std::map&lt;Column, Object&gt; col_obj_map; // error occurs on this line
typedef std::pair&lt;Column, Object&gt; col_obj_pair;
</code></pre>

<p>The includes in some_file.cpp are:</p>

<pre><code>#include &lt;utility&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;cc++/file.h&gt;
#include ""some_file.h""
</code></pre>

<p>The test file simply includes string, vector, and my file in that order.  It has a main method that just does a hello world sort of thing.</p>

<p>The funny thing is that I quickly threw together a templated class to see where the problem was (replacing the ""<code>std::map&lt;Column...</code>"" with ""<code>hello&lt;Column...</code>"") and it worked without a problem.</p>

<p>I've already created the operator overload required by the map if you're using a class without a '<code>&lt;</code>' operator.</p>
","87234","","<p>Is there a <code>#include &lt;map&gt;</code> somewhere in your header file?</p>

<p>Put that in there to at least see if it works. You should be doing that anyway.</p>
"
"<p>In C, automatic variables, if uninitialized, hold a garbage value. However, consider the following program:</p>

<pre><code>int main(){
 signed char term;
 (char)term--;
 printf(""%d\n"",term);
}
</code></pre>

<p>It prints a value of '7'. If I don't do a <code>(char)term--</code>, it prints a value of '8'. So, it definitely doesn't hold a garbage value. Isn't this contradictory?</p>
","87234","","<p>That's garbage. You get 8 as garbage, and subtract to get 7.</p>

<p>This is what undefined behavior is. Just because you keep getting 8 doesn't mean it's well-defined. Try doing more complex things in your code. Add variables above and below your <code>char</code>.</p>

<p><hr /></p>

<p>About your ""test"", you say:</p>

<blockquote>
  <p>However, the consistency is hard to overlook, considering that garbage should be random.</p>
</blockquote>

<p>You need to check your assumptions. ""garbage should be random"" says who? According to what should the garbage be random? The only way garbage will be random is if the system periodically goes through memory and assigns random numbers to it.</p>

<p>When we say ""random"", we mean we don't know what it will be. That doesn't make it non-deterministic. These are computers. If you tell them to do the same thing over and over, it will do the same thing <em>over and over</em>.</p>

<p>Your compiler and settings keep producing the same code that ends up giving you these garbage values. Deterministic, yet you cannot rely on this behavior: ""random"".</p>

<p>Also, 1-800 didn't mean for you to take this like you did. ""8"" does not necessarily denote garbage, as in the way things are set up your compiler fills them with 8. What he means is 8 is just as garbage as any other number.</p>
"
"<p>Thanks for all the response.</p>

<p>I reformatted my question to understand the state of the member pointer after the containg class constructor throws an exception</p>

<p>Again my example class :)</p>

<pre><code>class Foo
{
public:
    Foo()
    {
       int error = 0;
        p = new Fred;

        throw error;  // Force throw , trying to understand what will happen to p
    }

   ~Foo()
    {
       if (p)
       {
           delete p;
           p = 0;
       }
     }
private:
   Fred* p;
};

int main()
{
      try
      {
         Foo* lptr = new Foo;
      }
      catch (...)
      {}
}
</code></pre>

<p>The consturctor for class foo would throw an exception for some random reason. I understand that the desturctor of foo will never be called but in this case will the destructor for p get called?</p>

<p>what difference it makes to have p as a boost smart pointer than a raw pointer to fred.</p>

<p>Thanks.</p>
","87234","","<p>There is a <a href=""http://stackoverflow.com/questions/1197566/is-it-ever-not-safe-to-throw-an-exception-in-a-constructor"">similar question here</a> that covers what your asking.</p>

<p>In this case, if the call to <code>new</code> fails, then the memory for the pointer is guaranteed to be freed. If the call succeeds, and the constructor throws after that, you will have a memory leak.</p>

<p>The destructor of the class will not be called, because the object was never fully constructed. There are two ways to fix this.</p>

<p>1) </p>

<p>Have exceptions fully managed in the constructor:</p>

<pre><code>class Foo
{
public:
    Foo()
    try
    {
        p = new p;

        throw /* something */; 
    }
    catch (...)
    {
       delete p;

       throw; //rethrow. no memory leak
    }
private:
    int *p;
};
</code></pre>

<p>2)</p>

<p>Or use a smart pointer. When a constructor is entered, all of its members have been constructed. And because when a constructor throws, and objects members have been constructed, they must be destructed. And a smart pointer fixes that:</p>

<pre><code>class Foo
{
public:
    Foo() :
    p(new int)
    {
        throw /* something */; 
    }
private:
    std::auto_ptr&lt;int&gt; p;
};
</code></pre>
"
"<p>Ok... I have this struct and comparison function-</p>

<pre><code>struct Edge
{
          char point1;  
          char point2;  
          int weight;   

          bool operator&lt;( const Edge&amp; rhs ) const
          {
	          return( weight &lt; rhs.weight );
          }
}; //end Edge

bool compareEdge( const Edge&amp; lhs, const Edge&amp; rhs )
{
      return( lhs.weight &lt; rhs.weight );
}
</code></pre>

<p>I have a vector declared as...</p>

<pre><code>vector&lt;Edge&gt; edges;
</code></pre>

<p>Finally, I try to sort using the &lt; operator...</p>

<pre><code>sort( edges.begin(), edges.end() );
</code></pre>

<p>and I get the following error in Visual Studio 2005...</p>

<pre><code>------ Build started: Project: RadakovichLab6, Configuration: Debug Win32 ------ Compiling... graph.cpp c:\program files\microsoft visual studio 8\vc\include\algorithm(2981) : error C2678: binary '=' : no operator found which takes a left-hand operand of type 'const Edge' (or there is no acceptable conversion)
c:\documents and settings\jake\my documents\visual studio 2005\projects\radakovichlab6\graph.h(25): could be 'Edge &amp;Edge::operator =(const Edge &amp;)'
while trying to match the argument list '(const Edge, Edge)'
c:\program files\microsoft visual studio 8\vc\include\algorithm(2997) : see reference to function template instantiation 'void std::_Insertion_sort1&lt;_BidIt,Edge&gt;(_BidIt,_BidIt,_Ty*)' being compiled
with
[
    _BidIt=std::_Vector_const_iterator&lt;Edge,std::allocator&lt;Edge&gt;&gt;,
    _Ty=Edge
]
c:\program files\microsoft visual studio 8\vc\include\algorithm(3105) : see reference to function template instantiation 'void std::_Insertion_sort&lt;_RanIt&gt;(_BidIt,_BidIt)' being compiled
with
[
    _RanIt=std::_Vector_const_iterator&lt;Edge,std::allocator&lt;Edge&gt;&gt;,
    _BidIt=std::_Vector_const_iterator&lt;Edge,std::allocator&lt;Edge&gt;&gt;
]
c:\program files\microsoft visual studio 8\vc\include\algorithm(3112) : see reference to function template instantiation 'void std::_Sort&lt;std::_Vector_const_iterator&lt;_Ty,_Alloc&gt;,__w64 int&gt;(_RanIt,_RanIt,_Diff)' being compiled
with
[
    _Ty=Edge,
    _Alloc=std::allocator&lt;Edge&gt;,
    _RanIt=std::_Vector_const_iterator&lt;Edge,std::allocator&lt;Edge&gt;&gt;,
    _Diff=__w64 int
]
c:\documents and settings\jake\my documents\visual studio 2005\projects\radakovichlab6\graph.cpp(107) : see reference to function template instantiation 'void std::sort&lt;std::_Vector_const_iterator&lt;_Ty,_Alloc&gt;&gt;(_RanIt,_RanIt)' being compiled
with
[
    _Ty=Edge,
    _Alloc=std::allocator&lt;Edge&gt;,
    _RanIt=std::_Vector_const_iterator&lt;Edge,std::allocator&lt;Edge&gt;&gt;
] c:\program files\microsoft visual studio 8\vc\include\algorithm(2988) : error C2678: binary '=' : no operator found which takes a left-hand operand of type 'const Edge' (or there is no acceptable conversion)
c:\documents and settings\jake\my documents\visual studio 2005\projects\radakovichlab6\graph.h(25): could be 'Edge &amp;Edge::operator =(const Edge &amp;)'
while trying to match the argument list '(const Edge, const Edge)' c:\program files\microsoft visual studio 8\vc\include\algorithm(2989) : error C2678: binary '=' : no operator found which takes a left-hand operand of type 'const Edge' (or there is no acceptable conversion)
c:\documents and settings\jake\my documents\visual studio 2005\projects\radakovichlab6\graph.h(25): could be 'Edge &amp;Edge::operator =(const Edge &amp;)'
while trying to match the argument list '(const Edge, Edge)' Generating Code... Compiling... main.cpp Generating Code... Build log was saved at ""file://c:\Documents and Settings\Jake\My Documents\Visual Studio 2005\Projects\RadakovichLab6\Debug\BuildLog.htm"" RadakovichLab6 - 3 error(s), 0 warning(s)
========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========
</code></pre>

<p>The question is in the first line of the error.  I get this error whether I use the overloaded &lt; operator, or pass the comparison function to the std::sort function.  The Edge structure's default assignment operator should suffice, I would think, because there is no dynamically allocated memory.  If anyone has any insight I would be grateful. </p>

<p>full code...</p>

<pre><code>        #include &lt;list&gt;
        #include &lt;map&gt;
        #include &lt;queue&gt;
        #include &lt;vector&gt;
        #include &lt;algorithm&gt;
        #include &lt;iostream&gt;

        using namespace std;

        //the Edge and aGraph together represent the adjacency list
        //representation of a graph.
        struct Edge
        {
            char point1;  //this represents the endpoint of an edge
            char point2;  
            int weight;   //this is the weight of the edge

            bool operator&lt;( const Edge&amp; rhs ) const
            {
            	return( weight &lt; rhs.weight );
            }
        }; //end Edge

        class Graph
        {
        public:
            //Default constructor
            Graph();

            //This method inputs an edge into a graph.
            void inputEdge( char pointA, char pointB, int wt )
            {
                //used to input the edges of the graph
            Edge anEdge;

            //prepare for insertion into list
            anEdge.point1 = pointA;
            anEdge.point2 = pointB;
            anEdge.weight = wt;

            edges.push_back( anEdge );

            //insert edge into the adjacency list.
            aGraph[pointA].push_front( pointB );

            //insert the opposite direction into the
            //adjacency list.
            aGraph[pointB].push_front( pointA )
             }

             //This...
             void bfs();

            //This prints a graph and is used only for debugging purposes.
            void printGraph() const
            {

             list&lt;char&gt;::const_iterator listIter;
             map&lt;char, list&lt;char&gt;&gt;::const_iterator mapIter;

             for( mapIter = aGraph.begin(); 
        	  mapIter != aGraph.end();
        	  mapIter++ )
             {
        	    for( listIter = mapIter-&gt;second.begin();
                         listIter != mapIter-&gt;second.end();
                         listIter++ )
        	   {
        		     cout &lt;&lt; mapIter-&gt;first &lt;&lt; "" "" &lt;&lt; *listIter &lt;&lt; endl;
        	   } //end for
             } //end for


             sort( edges.begin(), edges.end() );

             vector&lt;Edge&gt;::const_iterator vectIt;

             for( vectIt = edges.begin();
                  vectIt != edges.end();
                  vectIt++ )
             {
        	    cout &lt;&lt; vectIt-&gt;point1 &lt;&lt; "" "" &lt;&lt; vectIt-&gt;point2 &lt;&lt; "" "" &lt;&lt; vectIt-&gt;weight &lt;&lt; endl;
              } //end for
         } //end printGraph


        private:
            //This is the adjacency list
            map&lt;char, list&lt;char&gt;&gt; aGraph;

            //This is a list of edges and their weights.
            vector&lt;Edge&gt; edges;
        };  //end Graph

int main()
{

    Graph myGraph;

    myGraph.inputEdge( 'O', 'A', 2 );
    myGraph.inputEdge( 'O', 'B', 5 );
    myGraph.inputEdge( 'O', 'C', 4 );
    myGraph.inputEdge( 'A', 'B', 2 );
    myGraph.inputEdge( 'A', 'D', 7 );
    myGraph.inputEdge( 'B', 'D', 4 );
    myGraph.inputEdge( 'B', 'E', 3 );
    myGraph.inputEdge( 'C', 'B', 1 );
    myGraph.inputEdge( 'C', 'E', 4 );
    myGraph.inputEdge( 'E', 'D', 1 );
    myGraph.inputEdge( 'D', 'T', 5 );
    myGraph.inputEdge( 'E', 'T', 7 );
    myGraph.inputEdge( 'G', 'Z', 8 );

    myGraph.printGraph();

    cout &lt;&lt; endl &lt;&lt; endl;

    system(""PAUSE"");
    return 0;
} //end main
</code></pre>

<p>Here is the code... </p>
","87234","","<p>You're working with a <code>const vector</code>, which cannot be sorted. (Or changed).</p>

<p>This is because your function is <code>const</code>:</p>

<pre><code>void printGraph() const
</code></pre>

<p>Remove the <code>const</code> so members of your class can be modified (and therefore sorted).</p>
"
"<p>I have some code in Image.cpp:  </p>

<pre><code>Image::Image( int width, int height, int depth ) : m_sFileName(0)  
{  
...  
}  

and in Image.h:  
class Image: public DrawAble, public RenderAble  
{  
...  
private :  
    std::string *m_sFileName;  
};
</code></pre>

<p>My question is: what is happening with <code>m_sFilename</code> in the first line? I guess it is set to NULL but what's the point of doing it that way. Would it be the same to do:  </p>

<pre><code>Image::Image( int width, int height, int depth )  
{  
    m_sFileName(0);  
...  
}
</code></pre>
","87234","","<p>The first uses what's called an <a href=""http://www.parashift.com/c++-faq-lite/ctors.html"" rel=""nofollow"">initialization list</a>.</p>

<p>When you enter the body of the constructor, all of the classes members must have been constructed (so they can be used). So if you have this:</p>

<pre><code>class Foo
{
public:
    Foo()
    : str() // this is implicit
    {
        str = ""String."";
    }
private:
    std::string str;
};
</code></pre>

<p>So, <code>str</code> gets constructed, then assigned. Better would have been:</p>

<pre><code>class Foo
{
 public:
    Foo()
    : str(""String."")
    {
    }
private:
    std::string str;
};
</code></pre>

<p>So that <code>str</code> gets directly constructed. This does not make a difference in your case because pointers have no constructor.</p>

<p>It is generally considered good practice to use an initialization list over running code in the constructor. The <em>initialization list</em> should be used for <em>initializing</em>, the constructor should be used for running code.</p>

<p>Also, why use a pointer to string? If you want a string, use a string; not a pointer to string. Chances are, you actually want a string.</p>

<p><hr /></p>

<p>More about initializer lists:</p>

<p>Initializer lists have more uses than just initializing members of the class. They can be used to pass arguments into base constructors:</p>

<pre><code>class Foo
{
public:
    Foo(int i) { /* ... */ }
}

class Bar
    : public Foo
{
public:
    Bar()
    : Foo(2) // pass 2 into Foo's constructor.
             // There is no other way of doing this.
    {
        /* ... */
    }
};
</code></pre>

<p>Or constant members:</p>

<pre><code>class Foo
{
public:
    Foo()
    : pi(3.1415f)
    {
        pi = 3.1415f; // will not work, pi is const.
    }
private:
    const float pi;
};
</code></pre>

<p>Or references:</p>

<pre><code>class Foo
{
public:
    Foo(int&amp; i)
    : intRef(i) // intRef refers to the i passed into this constructor
    {
        intRef = i; // does *not* set intRef to refer to i!
                    // rather, it sets i as the value of
                    // the int intRef refers to.
    }
private:
    int &amp;intRef;
};
</code></pre>
"
"<p>I've read everything I could find on this topic, including a couple of very helpful discussions on this site, the NASA coding guidelines and Google C++ guidelines.  I even bought the ""physical C++ design"" book recommended on here (sorry, forgot the name) and got some useful ideas from that.  Most sources seem to agree - header files should be self-contained, i.e. they include what they need so that a cpp file could include the header without including any others and it would compile.  I also get the point about forward declaring rather than including whenever possible.</p>

<p>That said, how about if <code>foo.cpp</code> includes <code>bar.h</code> and <code>qux.h</code>, but it turns out that <code>bar.h</code> itself includes <code>qux.h</code>?  Should <code>foo.cpp</code> then avoid including <code>qux.h</code>?  Pro: cleans up <code>foo.cpp</code> (less ""noise"").  Con: if someone changes bar.h to no longer include <code>qux.h</code>, <code>foo.cpp</code> mysteriously starts failing to compile.  Also causes the dependency between <code>foo.cpp</code> and <code>qux.h</code> not to be obvious.</p>

<p>If your answer is ""a cpp file should #include every header it needs"", taken to its logical conclusion that would mean that pretty much every cpp file has to <code>#include &lt;string&gt;, &lt;cstddef&gt;</code> etc. since most code will end up using those, and if you're not supposed to rely on some other header including them, your cpp needs to include them explicitly.  That seems like a lot of ""noise"" in the cpp files.</p>

<p>Thoughts?</p>

<p>Previous discussions:</p>

<p><a href=""http://stackoverflow.com/questions/188449/what-are-some-techniques-for-limiting-compilation-dependencies-in-c-projects"">http://stackoverflow.com/questions/188449/what-are-some-techniques-for-limiting-compilation-dependencies-in-c-projects</a></p>

<p><a href=""http://stackoverflow.com/questions/181921/your-preferred-cc-header-policy-for-big-projects"">http://stackoverflow.com/questions/181921/your-preferred-cc-header-policy-for-big-projects</a></p>

<p><a href=""http://stackoverflow.com/questions/51561/how-do-i-automate-finding-unused-include-directives"">http://stackoverflow.com/questions/51561/how-do-i-automate-finding-unused-include-directives</a></p>

<p>ETA: Inspired by previous discussions on here, I've written a Perl script to successively comment out each 'include' and 'using', then attempt to recompile the source file, to figure out what's not needed.  I've also figured out how to integrate it with VS 2005, so you can double-click to go to ""unused"" includes.  If anyone wants it let me know...very much experimental right now though.</p>
","87234","","<p>I think that you should still include both files. This helps with maintaining the code.</p>

<pre><code>// Foo.cpp

#include &lt;Library1&gt;
#include &lt;Library2&gt;
</code></pre>

<p>I can read that and easily see which libraries it uses. If <code>Library2</code> used <code>Library1</code>, and it was transformed to this:</p>

<pre><code>// Foo.cpp

#include &lt;Library2&gt;
</code></pre>

<p>But I still saw <code>Library1</code> code, I might be slightly confused. It's not hard to guess that some other library must be including it, but it's still a thought process that has to occur.</p>

<p>Being explicit means I don't have to guess, even for an extra micro second of compilation.</p>
"
"<p>I have a constructor that takes some arguments.  I had assumed that they were constructed in the order listed, but in one case it appears they were being constructed in reverse resulting in an abort. When I reversed the arguments the program stopped aborting.  This is an example of the syntax I'm using.  The thing is, a_ needs to be initialized before b_ in this case.  Can you guarantee the order of construction? </p>

<p>e.g.</p>

<pre><code>class A
{
  public:
    A(OtherClass o, string x, int y) :
      a_(o), b_(a_, x, y) { }

    OtherClass a_;
    AnotherClass b_;
};
</code></pre>
","87234","","<p>To quote the standard, for clarification:</p>

<blockquote>
  <p>12.6.2.5</p>
  
  <p>Initialization shall proceed in the following order:</p>
  
  <p><strong>...</strong></p>
  
  <ul>
  <li>Then, nonstatic data members shall be initialized in the order they were declared in the class definition
  (again regardless of the order of the mem-initializers).</li>
  </ul>
  
  <p><strong>...</strong></p>
</blockquote>
"
"<p>I have a <code>std::string</code> which could be a string or could be a value (such as <code>0</code>).</p>

<p>What is the best or easiest way to convert the <code>std::string</code> to <code>int</code> with the ability to fail? I want a C++ version of C#'s <code>Int32.TryParse</code>.</p>
","87234","","<p>Use <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/conversion/lexical%5Fcast.htm"">boost::lexical_cast</a>. If the cast cannot be done, it will <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/conversion/lexical%5Fcast.htm#bad%5Flexical%5Fcast"">throw an exception</a>.</p>

<pre><code>#include &lt;boost/lexical_cast.hpp&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main(void)
{
    std::string s;
    std::cin &gt;&gt; s;

    try
    {
        int i = boost::lexical_cast&lt;int&gt;(s);

        /* ... */
    }
    catch(...)
    {
        /* ... */
    }
}
</code></pre>

<p><hr /></p>

<p>Without boost:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main(void)
{
    std::string s;
    std::cin &gt;&gt; s;

    try
    {
        std::stringstream ss(s);

        int i;
        if ((ss &gt;&gt; i).fail() || !(ss &gt;&gt; std::ws).eof())
        {
            throw std::bad_cast();
        }

        /* ... */
    }
    catch(...)
    {
        /* ... */
    }
}
</code></pre>

<p><hr /></p>

<p>Faking boost:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

template &lt;typename T&gt;
T lexical_cast(const std::string&amp; s)
{
    std::stringstream ss(s);

    T result;
    if ((ss &gt;&gt; result).fail() || !(ss &gt;&gt; std::ws).eof())
    {
        throw std::bad_cast();
    }

    return result;
}

int main(void)
{
    std::string s;
    std::cin &gt;&gt; s;

    try
    {
        int i = lexical_cast&lt;int&gt;(s);

        /* ... */
    }
    catch(...)
    {
        /* ... */
    }
}
</code></pre>

<p><hr /></p>

<p>If you want no-throw versions of these functions, you'll have to catch the appropriate exceptions (I don't think <code>boost::lexical_cast</code> provides a no-throw version), something like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

template &lt;typename T&gt;
T lexical_cast(const std::string&amp; s)
{
    std::stringstream ss(s);

    T result;
    if ((ss &gt;&gt; result).fail() || !(ss &gt;&gt; std::ws).eof())
    {
    	throw std::bad_cast();
    }

    return result;
}

template &lt;typename T&gt;
bool lexical_cast(const std::string&amp; s, T&amp; t)
{
    try
    {
    	// code-reuse! you could wrap
    	// boost::lexical_cast up like
    	// this as well
    	t = lexical_cast&lt;T&gt;(s);

    	return true;
    }
    catch (const std::bad_cast&amp; e)
    {
    	return false;
    }
}

int main(void)
{
    std::string s;
    std::cin &gt;&gt; s;

    int i;
    if (!lexical_cast(s, i))
    {
    	std::cout &lt;&lt; ""Bad cast."" &lt;&lt; std::endl;
    }	
}
</code></pre>
"
"<p>Below is my func. I call it with</p>

<pre><code>if(try_strtol(v, rhs))
</code></pre>

<p>and RHS = ""15\t// comment""</p>

<pre><code>bool try_strtol(int64_t &amp;v, const string&amp; s)
{
	try
	{
		std::stringstream ss(s);
		if ((ss &gt;&gt; v).fail() || !(ss &gt;&gt; std::ws).eof())
			throw std::bad_cast();
		return true;
	}
	catch(...)
	{
		return false;
	}
}
</code></pre>

<p>It returns false, i except true with v=15. How do i fix this?</p>
","87234","","<p>If you want it to return a boolean, just do this:</p>

<pre><code>bool try_strtol(int64_t &amp;v, const string&amp; s)
{
    std::stringstream ss(s);
    return (ss &gt;&gt; v).fail() || !(ss &gt;&gt; std::ws).eof();
}
</code></pre>

<p>And it's failing because it's a bad cast. Were you hoping the comment would be ignored?</p>
"
"<p>So according to cplusplus.com when you set the format flag of an output stream to scientific notation via</p>

<p><code>
of.setf(ios::scientific)
</code></p>

<p>you should see 3 digits plus and a sign in the exponent.  However, I only seem to get 2 in my output.  Any ideas?  Compiled on Mac OS using GCC 4.0.1.</p>

<p>Here's the actual code I am using:</p>

<pre><code>of.setf(ios::scientific);
of.precision(6);
for (int i=0;i&lt;dims[0];++i) {
    for (int j=0;j&lt;dims[1];++j) {
	of &lt;&lt; setw(15) &lt;&lt; data[i*dims[1]+j];					
    }
    of &lt;&lt; endl;
}
</code></pre>

<p>and an example line of output:</p>

<pre><code>   1.015037e+00   1.015037e+00   1.395640e-06  -1.119544e-06  -8.333264e-07
</code></pre>

<p>Thanks</p>
","87234","","<p>I'm getting 3 in MSVC++08 and g++ 4.4.0 with this code:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

typedef float NumberType;

double generate_number(void)
{
    return static_cast&lt;NumberType&gt;(std::rand()) / RAND_MAX;
}

void print_number(NumberType d)
{
    std::cout &lt;&lt; std::setw(15) &lt;&lt; d &lt;&lt; std::endl;
};

int main(void)
{
    std::vector&lt;NumberType&gt; data;

    std::generate_n(std::back_inserter(data), 10, generate_number);

    // print
    std::cout.setf(std::ios::scientific);
    std::cout.precision(6);
    std::for_each(data.begin(), data.end(), print_number);
}
</code></pre>

<p>You can easily change the number type it uses. It gives me three places with both <code>float</code> and <code>double</code>, and the standard says nothing on the actual formatting, so I'd go with <a href=""http://stackoverflow.com/questions/1257182/only-2-digits-in-exponent-in-scientific-ofstream/1257266#1257266"">mgb's answer</a>.</p>
"
"<p>I saw someone using this </p>

<pre><code>void methodA(const int*&amp; var);
</code></pre>

<p>in one answer, but couldn't understand what the argument means.</p>

<p>AFAIK:</p>

<ul>
<li><p><code>const int var</code> => const value which can't be changed</p></li>
<li><p><code>const int* var</code> => pointer to int which is const i.e *var can't be changed but var can be changed</p></li>
<li><p><code>const int&amp; var</code> => reference to const int i.e value of var can't be changed</p></li>
</ul>

<p>What does <code>const int*&amp; var</code> mean, and is <code>const int&amp; *var</code> also possible?</p>

<p>Can you please give some example as well, like what can be done and what can't be done with it?</p>

<p>UPDATE :</p>

<p>I am not sure if I am thinking right way, but I began to think reference as alias of the variable that was pass as argument, so
const int * p;
methodA(p) => here we are passing p as const int * but we dont know if this is pass by value or what until we see the definition of method A,</p>

<p>so if methodA is like this
methodA(const int * &amp; p2) ==> here p2 is another name to p, i.e. p and p2 are same from now on
and if methodA(const int* p2) ==> here p2 is passed as value i.e p2 is just local to this method,</p>

<p>please correct me if I am thinking wrong way ? If yes, I might need to study some more about this ? Can you please point some nice references ?</p>

<p>UPDATE 2
If some beginner like me want to know more about this thing, you can use <strong>c++decl /</strong> <strong>cdecl program</strong>, which I just discovered to very useful from <a href=""http://stackoverflow.com/questions/859634/c-pointer-to-array-array-of-pointers-disambiguation/859676#859676"">here</a></p>

<pre><code>$ c++decl
Type `help' or `?' for help
c++decl&gt; explain const int&amp;* p
declare p as pointer to reference to const int
c++decl&gt; explain const int*&amp; p
declare p as reference to pointer to const int
</code></pre>

<p>But as every one here pointed, first example isnt legal in C++.</p>

<p>Thanks</p>
","87234","","<p>It is a reference to a pointer to an int that is const.</p>

<p>There is another post somewhat related, actually, <a href=""http://stackoverflow.com/questions/859634/c-pointer-to-array-array-of-pointers-disambiguation/859676#859676"">here</a>. My answer gives a sorta of general algorithm to figuring these things out.</p>

<p>This: <code>const int&amp; *var</code> has no meaning, because you cannot have a pointer to reference.</p>

<p>If the const's and pointers are getting in the way, remember you can typedef these things:</p>

<pre><code>typedef int* IntPointer;
typedef const IntPointer ConstIntPointer;

void foo(ConstIntPointer&amp;); // pass by reference
void bar(const ConstIntPointer&amp;); // pass by const reference
void baz(ConstIntPointer); // pass by value
</code></pre>

<p>Might make it easier to read.</p>

<p><hr /></p>

<p>If you need more help on C++, <a href=""http://www.parashift.com/c++-faq-lite/"">read this</a>. More specifically, <a href=""http://www.parashift.com/c++-faq-lite/references.html"">references</a>.</p>

<p>References as variables do <em>not</em> take space:</p>

<pre><code>int i; // takes sizeof(int)
int*pi = &amp;i; // takes sizeof(int*)

int&amp; ri = i; // takes no space.
             // any operations done to ri
             // are simply done to i
</code></pre>

<p>References as parameters use pointers to achieve the end effect:</p>

<pre><code>void foo(int&amp; i)
{
    i = 12;
}

void foo_transformed(int *i)
{
    *i = 12;
}

int main()
{
    int i;

    foo(i); // same as:
    foo_transformed(&amp;i); // to the compiler (only sort of)
}
</code></pre>

<p>So it's actually passing the address of <code>i</code> on the stack, so takes <code>sizeof(int*)</code> space on the stack. But don't start thinking about references as pointers. They are <em>not</em> the same.</p>
"
"<p>I am working on some legacy code which opens a file and adds binary data to the file:</p>

<pre><code>    std::ifstream mInFile;

    #ifdef WINDOWS
        miWindowsFileHandle = _sopen(filename.c_str(), O_RDONLY , SH_DENYWR, S_IREAD);
    #endif

    mInFile.open(filename.c_str(), std::ios_base::binary);
</code></pre>

<p>For some reason the code opens the file twice. Is this because _sopen is used to lock the file in windows? </p>

<p>If so, how come std::ifstream::open doesn't lock the file?</p>

<p>Is there a way to check if a windows file handle has already been closed?</p>
","87234","","<p>It opens twice because the first one opens it, and locks it. Then fstream opens it again (somewhat contradictory to the intent of the previous statement.) </p>

<p>On how to just lock the file, <a href=""http://stackoverflow.com/questions/839856/using-stdfstream-how-to-deny-access-read-and-write-to-the-file"">check this question out</a>.</p>
"
"<pre><code> typedef std::map&lt;int, MyObject*&gt; MyMap;
 MyMap* myMap = new MyMap;
 // ...
 myMap-&gt;insert( MyMap::value_type( 0, objectOfType_MyObject ) );
</code></pre>

<p>Why does my code crash with a stack trace going down to </p>

<pre><code> std::less&lt;int&gt;::operator()
</code></pre>

<p>? </p>

<p>I understand that if I use a custom key class that I must provide a comparator, but this is an int.</p>

<p>I've never used maps before and it's probably a dumb question but I've been stuck on this for ages now.</p>

<p>Thanks</p>
","87234","","<p>This code works (compiles &amp; runs) for me:</p>

<pre><code>#include &lt;map&gt;

class MyObject
{ };

int main(void)
{
    typedef std::map&lt;int, MyObject*&gt; MyMap;

    MyMap *myMap = new MyMap;
    MyObject *obj = new MyObject;

    myMap-&gt;insert(MyMap::value_type(0, obj));

    delete obj;
    delete myMap;
}
</code></pre>

<p>So the problem lies in the details (<code>// ...</code> or what <code>MyObject</code> can do) or elsewhere. You can probably fix things up a bit to help. Try to stack allocate things when you can. Do you actually need a pointer to a map? I suggest you don't:</p>

<pre><code>#include &lt;map&gt;

class MyObject
{ };

int main(void)
{
    typedef std::map&lt;int, MyObject*&gt; MyMap;

    MyMap myMap;
    MyObject *obj = new MyObject;

    myMap.insert(MyMap::value_type(0, obj));

    delete obj;
}
</code></pre>

<p>And do you actually need to store pointers to object, or objects? </p>

<pre><code>#include &lt;map&gt;

class MyObject
{ };

int main(void)
{
    typedef std::map&lt;int, MyObject&gt; MyMap;

    MyMap myMap;

    myMap.insert(MyMap::value_type(0, MyObject()));
}
</code></pre>

<p>Much smaller, and almost impossible to get memory leaks. If you <em>do</em> need to store pointers, for polymorphic behavior, check out <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/ptr%5Fcontainer/doc/headers.html"">boost::ptr_container library</a>, which has a <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/ptr%5Fcontainer/doc/ptr%5Fmap%5Fadapter.html"">map adapter that stores pointers</a>.</p>
"
"<p>Which STL container would fit my needs best? I basically have a 10 elements wide container in which I continually <code>push_back</code> new elements while <code>pop_front</code> ing the oldest element (about a million time). </p>

<p>I am currently using a <code>std::deque</code> for the task but was wondering if a <code>std::list</code> would be more efficient since I wouldn't need to reallocate itself (or maybe I'm mistaking a <code>std::deque</code> for a <code>std::vector</code>?). Or is there an even more efficient container for my need?</p>

<p>P.S. I don't need random access</p>
","87234","","<p>Since there are a myriad of answers, you might be confused, but to summarize:</p>

<p>Use a <a href=""http://en.cppreference.com/w/cpp/container/queue""><code>std::queue</code></a>. The reason for this is simple: it is a FIFO structure. You want FIFO, you use a <code>std::queue</code>.</p>

<p>It makes your intent clear to anybody else, and even yourself. A <a href=""http://en.cppreference.com/w/cpp/container/list""><code>std::list</code></a> or <a href=""http://en.cppreference.com/w/cpp/container/deque""><code>std::deque</code></a> does not. A list can insert and remove anywhere, which is not what a FIFO structure is suppose to do, and a <code>deque</code> can add and remove from either end, which is also something a FIFO structure cannot do.</p>

<p>This is why you should use a <code>queue</code>.</p>

<p>Now, you asked about performance. Firstly, always remember this important rule of thumb: <strong>Good code first, performance last.</strong></p>

<p>The reason for this is simple: people who strive for performance before cleanliness and elegance almost always finish last. Their code becomes a slop of mush, because they've abandoned all that is good in order to really get nothing out of it.</p>

<p>By writing good, readable code first, most of you performance problems will solve themselves. And if later you find your performance is lacking, it's now easy to add a profiler to your nice, clean code, and find out where the problem is.</p>

<p>That all said, <code>std::queue</code> is only an adapter. It provides the safe interface, but uses a different container on the inside. You can choose this underlying container, and this allows a good deal of flexibility.</p>

<p>So, which underlying container should you use? We know that <code>std::list</code> and <code>std::deque</code> both provide the necessary functions (<code>push_back()</code>, <code>pop_front()</code>, and <code>front()</code>), so how do we decide?</p>

<p>First, understand that allocating (and deallocating) memory is not a quick thing to do, generally, because it involves going out to the OS and asking it to do something. A <code>list</code> has to allocate memory every single time something is added, and deallocate it when it goes away.</p>

<p>A <code>deque</code>, on the other hand, allocates in chunks. It will allocate less often than a <code>list</code>. Think of it as a list, but each node can hold multiple nodes. (Of course, I'd asuggest that you <a href=""http://en.wikipedia.org/wiki/Double-ended_queue"">really learn how it works</a>.)</p>

<p>So, with that alone a <code>deque</code> should perform better, because it doesn't deal with memory as often. Mixed with the fact you're handling data of constant size, it probably won't have to allocate after the first pass through the data, whereas a list will be constantly allocating and deallocating.</p>

<p>A second thing to understand is <a href=""http://lamarca.org/anthony/caches.html"">cache performance</a>. Going out to RAM is slow, so when the CPU really needs to, it makes the best out of this time by taking a chunk of memory back with it, into cache. Because a <code>deque</code> allocates in memory chunks, it's likely that accessing an element in this container will cause the CPU to bring back the rest of the container as well. Now any further accesses to the <code>deque</code> will be speedy, because the data is in cache.</p>

<p>This is unlike a list, where the data is allocated one at a time. This means that data could be spread out all over the place in memory, and cache performance will be bad.</p>

<p>So, considering that, a <code>deque</code> should be a better choice. This is why it is the default container when using a <code>queue</code>. That all said, this is still only a (very) educated guess: you'll have to profile this code, using a <code>deque</code> in one test and <code>list</code> in the other to really know for certain.</p>

<p>But remember: get the code working with a clean interface, then worry about performance.</p>

<p>John raises the concern that wrapping a <code>list</code> or <code>deque</code> will cause a performance decrease. Once again, he nor I can say for certain without profiling it ourselves, but chances are that the compiler will inline the calls that the <code>queue</code> makes. That is, when you say <code>queue.push()</code>, it will really just say <code>queue.container.push_back()</code>, skipping the function call completely.</p>

<p>Once again, this is only an educated guess, but using a <code>queue</code> will not degrade performance, when compared to using the underlying container raw. Like I've said before, use the <code>queue</code>, because it's clean, easy to use, and safe, and if it really becomes a problem profile and test.</p>
"
"<p>I am writing an application which does a lot of manipulation with <strong>decimal</strong> numbers (e.g. 57.65). As multiplications and divisions quickly erode their accuracy, I would like to store the numbers in a class which preserves their accuracy after manipulation, rather than rely on float and double.</p>

<p>I am talking about something like this:</p>

<pre><code>class FloatingPointNumber {
private:
    long m_mantissa;
    int m_dps; // decimal points
    // so for example 57.65 would be represented as m_mantissa=5765, m_dps=2
public:
    // Overloaded function for addition
    FloatingPointNumber operator+(FloatingPointNumber n);
    // Other operator overloads follow
}
</code></pre>

<p>While it is possible for me to write such a class, it feels a bit like reinventing the wheel and I am sure that there must be some library class somewhere which does this (although this does not seem to exist in STL).</p>

<p>Does anybody know of such a library? Many thanks.</p>
","87234","","<p>There is a list of libraries <a href=""http://en.wikipedia.org/wiki/Arbitrary-precision%5Farithmetic#Libraries"" rel=""nofollow"">here</a>.</p>

<p>I have never tried any of them so I can't recommend a single one, however <a href=""http://en.wikipedia.org/wiki/GNU%5FMulti-Precision%5FLibrary"" rel=""nofollow"">this one</a> is part of the GNU Project so it can't be half bad.</p>
"
"<p>If I have a prototype that looks like this:</p>

<pre><code>function(float,float,float,float)
</code></pre>

<p>I can pass values like this:</p>

<pre><code>function(1,2,3,4);
</code></pre>

<p>So if my prototype is this:</p>

<pre><code>function(float*);
</code></pre>

<p>Is there any way I can achieve something like this?</p>

<pre><code>function( {1,2,3,4} );
</code></pre>

<p>Just looking for a lazy way to do this without creating a temporary variable, but I can't seem to nail the syntax.</p>
","87234","","<p>This is marked both C and C++, so you're gonna get radically different answers.</p>

<p>If you are expecting four parameters, you can do this:</p>

<pre><code>void foo(float f[])
{
    float f0 = f[0];
    float f1 = f[1];
    float f2 = f[2];
    float f3 = f[3];
}

int main(void)
{
    float f[] = {1, 2, 3, 4};
    foo(f);
}
</code></pre>

<p>But that is rather unsafe, as you could do this by accident:</p>

<pre><code>void foo(float f[])
{
    float f0 = f[0];
    float f1 = f[1];
    float f2 = f[2];
    float f3 = f[3];
}

int main(void)
{
    float f[] = {1, 2}; // uh-oh
    foo(f);
}
</code></pre>

<p>It is usually best to leave them as individual parameters. Since you shouldn't be using raw arrays anyway, you can do this:</p>

<pre><code>#include &lt;cassert&gt;
#include &lt;vector&gt;

void foo(std::vector&lt;float&gt; f)
{
    assert(f.size() == 4);

    float f0 = f[0];
    float f1 = f[1];
    float f2 = f[2];
    float f3 = f[3];
}

int main(void)
{
    float f[] = {1, 2, 3, 4};
    foo(std::vector&lt;float&gt;(f, f + 4)); // be explicit about size

    // assert says you cannot do this:
    foo(std::vector&lt;float&gt;(f, f + 2));
}
</code></pre>

<p>An improvement, but not much of one. You could use <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/doc/html/array.html""><code>boost::array</code></a>, but rather than an error for mismatched size, they are initialized to 0:</p>

<pre><code>#include &lt;boost/array.hpp&gt;

void foo(boost::array&lt;float, 4&gt; f)
{
    float f0 = f[0];
    float f1 = f[1];
    float f2 = f[2];
    float f3 = f[3];
}

int main(void)
{
    boost::array&lt;float, 4&gt; f = {1, 2, 3, 4};
    foo(f);

    boost::array&lt;float, 4&gt; f2 = {1, 2}; // same as = {1, 2, 0, 0}
    foo(f2);
}
</code></pre>

<p>This will all be fixed in C++0x, when initializer list constructors are added:</p>

<pre><code>#include &lt;cassert&gt;
#include &lt;vector&gt;

void foo(std::vector&lt;float&gt; f)
{
    assert(f.size() == 4);

    float f0 = f[0];
    float f1 = f[1];
    float f2 = f[2];
    float f3 = f[3];
}

int main(void)
{
    foo({1, 2, 3, 4}); // yay, construct vector from this

    // assert says you cannot do this:
    foo({1, 2});
}
</code></pre>

<p>And probably <code>boost::array</code> as well:</p>

<pre><code>#include &lt;boost/array.hpp&gt;

void foo(boost::array&lt;float, 4&gt; f)
{
    float f0 = f[0];
    float f1 = f[1];
    float f2 = f[2];
    float f3 = f[3];
}

int main(void)
{
    foo({1, 2, 3, 4});

    foo({1, 2}); // same as = {1, 2, 0, 0} ..? I'm not sure,
                 // I don't know if they will do the check, if possible.
}
</code></pre>
"
"<p>I am speaking in Standard, K&amp;R C.</p>

<p>Given:</p>

<pre><code>const char a[] = {1, 2, 3};
const char *p = NULL;
</code></pre>

<p>Are these two statements equivalent:</p>

<ol>
<li><p><code>*p = a;</code></p></li>
<li><p><code>p = a;</code></p></li>
</ol>

<p>Each of them would be on the third line of the snippet.</p>

<p>1 and 2 certainly don't look the same.</p>

<p>What's the difference between the two then?</p>
","87234","","<p>The first dereferences a null pointer, and tries to assign it the address of the array. This will be a compiler error, because <code>char != char []</code>. If it weren't, it would likely crash.</p>

<p>The second sets <code>p</code> to point to the the array.</p>
"
"<p>I came across this:
<a href=""http://stackoverflow.com/questions/66882/simplest-way-to-check-if-two-integers-have-same-sign"">http://stackoverflow.com/questions/66882/simplest-way-to-check-if-two-integers-have-same-sign</a></p>

<p>How can this be extended to more than two numbers (not necessarily integers)? Say, check if 4 numbers have the same sign (+ve or -ve).</p>

<p>I don't want to use bit operations as far as possible ... only logical conditions.</p>

<p>Thanks.</p>
","87234","","<p>This is a generic implementation. This will check if the elements of a container all share the same property.</p>

<p>One version returns an iterator to the first mismatched element, the concise version only returns true or false.</p>

<p>Because it's generic, you can also check if they are all even numbers, for example:</p>

<pre><code>// shared_property.hpp
#ifndef SHARED_PROPERTY_HPP
#define SHARED_PROPERTY_HPP

// checks if all elements share a single property
// if one element does not share a property,
// it returns an iterator to that element
template &lt;typename Iter, typename Func&gt;
Iter share_property(Iter first, Iter last, Func func)
{
    for(; first != last; ++first)
    {
    	if (!func(*first))
    	{
    		// differs
    		break;
    	}
    }

    return first;
}

// only indicates if all elements share a property
template &lt;typename Iter, typename Func&gt;
bool share_property_concise(Iter first, Iter last, Func func)
{
    return share_property(first, last, func) == last;
}

#endif
</code></pre>

<p>Example program:</p>

<pre><code>#include ""shared_property.hpp""

#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

typedef std::vector&lt;int&gt; container;

void negative_test(void)
{
    container negatives;
    negatives.push_back(-1);
    negatives.push_back(-2);
    negatives.push_back(-3);

    if (share_property_concise(negatives.begin(), negatives.end(),
    	std::bind2nd(std::less&lt;int&gt;(), 0)))
    {
    	std::cout &lt;&lt; ""All elements are less than 0."" &lt;&lt; std::endl;
    }
    else
    {
    	std::cout &lt;&lt; ""Not all elements are less than 0."" &lt;&lt; std::endl;
    }
}

bool is_even(int i)
{
    return i % 2 == 0;
}

void even_test(void)
{
    container evens;
    evens.push_back(2);
    evens.push_back(4);
    evens.push_back(10);

    if (share_property_concise(evens.begin(), evens.end(),
    	is_even))
    {
    	std::cout &lt;&lt; ""All elements are even."" &lt;&lt; std::endl;
    }
    else
    {
    	std::cout &lt;&lt; ""Not all elements are even."" &lt;&lt; std::endl;
    }
}


int main(void)
{
    negative_test();	
    even_test();
}
</code></pre>

<p>It also works well for filtering containers based off a property:</p>

<pre><code>#include ""shared_property.hpp""

#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

typedef std::vector&lt;int&gt; container;

template &lt;typename Iter, typename OutIter, typename Func&gt;
Func filter_container(Iter first, Iter last, OutIter out, Func func)
{
    first = share_property(first, last, func);
    while (first != last)
    {
    	*out++ = *first++;

    	first = share_property(first, last, func);
    }

    return func;
};

int make_number(void)
{
    return std::rand() % 20 - 10;
}

void find_negatives(void)
{
    container numbers;
    std::generate_n(std::back_inserter(numbers), 20, make_number);

    container negatives;
    filter_container(numbers.begin(), numbers.end(), std::back_inserter(negatives),
    	std::bind2nd(std::greater&lt;int&gt;(), 0));

    std::cout &lt;&lt; ""List: "" &lt;&lt; std::endl;
    std::copy(numbers.begin(), numbers.end(),
    	std::ostream_iterator&lt;int&gt;(std::cout, ""\n""));
    std::cout &lt;&lt; std::endl;

    std::cout &lt;&lt; ""Negatives:"" &lt;&lt; std::endl;
    std::copy(negatives.begin(), negatives.end(),
    	std::ostream_iterator&lt;int&gt;(std::cout, ""\n""));
}

int main(void)
{
    std::srand(static_cast&lt;unsigned&gt;(std::time(0)));

    find_negatives();	
}
</code></pre>

<p><hr /></p>

<h3>Consistency</h3>

<p>This algorithm will test a set for consistency:</p>

<pre><code>// consistent_property.hpp
#ifndef CONSISTENT_PROPERTY_HPP
#define CONSISTENT_PROPERTY_HPP

#include &lt;boost/logic/tribool.hpp&gt;

// checks if all elements consistently pass/fail a property
// if it returns indeterminate, then the results are mixed,
// otherwise all results pass or failed as indicated
template &lt;typename Iter, typename Func&gt;
boost::logic::tribool consistent_property(Iter first, Iter last, Func func)
{
    bool result = func(*first++);

    for(; first != last; ++first)
    {
    	if (func(*first) != result)
    	{
    		// differs
    		return boost::logic::indeterminate;
    	}
    }

    return result;
}

#endif
</code></pre>

<p>This will check if a property is consistent throughout a container, not if it just holds true. That is, it will return false if all the elements do not pass the property, true if they all do (same result as <code>share_property_concise</code>), and indeterminate if the result is mixed.</p>

<p>Here is an example:</p>

<pre><code>#include ""consistent_property.hpp""

#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

typedef std::vector&lt;int&gt; container;

void check_sign(void)
{
    container positives;
    positives.push_back(1);
    positives.push_back(2);
    positives.push_back(3);

    boost::logic::tribool result =
    	consistent_property(positives.begin(), positives.end(),
    	std::bind2nd(std::greater&lt;int&gt;(), 0));

    if (boost::logic::indeterminate(result))
    {
    	std::cout &lt;&lt; ""Mixed signs."" &lt;&lt; std::endl;
    }
    else if (result)
    {
    	std::cout &lt;&lt; ""All positive."" &lt;&lt; std::endl;
    }
    else
    {
    	std::cout &lt;&lt; ""All negative."" &lt;&lt; std::endl;
    }
}

int main(void)
{
    check_sign();
}
</code></pre>

<p>Lastly, I provide a functor that can get a less specific result to consistency. While the above will tell if the consistency failed, passed, or was mixed, using this functor with <code>share_property</code> will only determine if the set is consistent, or mixed. You cannot deduce in which way it was consistent.</p>

<p>This is probably the simplest solution to the original problem. To have the same sign, without the need to know what that sign is, can be done this way, giving a quick &amp; simple result; either they are all the same sign or not.</p>

<p>Add the following to <code>consistent_property.hpp</code>:</p>

<pre><code>// the functor to determine if the property that all elements
// in a set share, is the property that they all pass or fail
// a secondary property. there is no way to deduce what the
// status was (if they all passed or all failed), only if
// all the elements were consistent. true indicates consistency,
// false indicates lack thereof
template &lt;typename T, typename Func&gt;
class consistent_shared_property_binder
{
public:
    consistent_shared_property_binder(const Func&amp; func) :
    _func(func)
    {
    }

    bool operator()(const T&amp; t)
    {
    	bool result = _func(t);

    	static bool status = result; // only initialized first run

    	return status == result;
    }

private:
    Func _func;
};

// bind a function to the functor
template &lt;typename T, typename Func&gt;
consistent_shared_property_binder&lt;T, Func&gt; consistent_property(Func func)
{
    return consistent_shared_property_binder&lt;T, Func&gt;(func);
}
</code></pre>

<p>And the example program:</p>

<pre><code>#include ""consistent_property.hpp""
#include ""shared_property.hpp""

#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

typedef std::vector&lt;int&gt; container;

bool is_positive(int i)
{
    return i &gt; 0; 
}

void check_sign_anonymous(void)
{
    container positives;
    positives.push_back(-1);
    positives.push_back(-2);
    positives.push_back(-3);

    if (share_property_concise(positives.begin(), positives.end(),
    	consistent_property&lt;int&gt;(is_positive)))
    {
    	std::cout &lt;&lt; ""All the same sign."" &lt;&lt; std::endl;
    }
    else
    {
    	std::cout &lt;&lt; ""Mixed signs."" &lt;&lt; std::endl;
    }
}

int main(void)
{
    check_sign_anonymous();
}
</code></pre>

<p>And I think I'm done. :P</p>

<p>(Note: If anyone sees a better way to do something, or a bug, please tell me!)</p>
"
"<p>i'm using templated unions to both assure myself that i always get a 64-bit field for pointers (even on 32-bit machines since there is transmission of data to a 64-bit machine occurring) and to save both the user and myself casting.</p>

<pre><code>template &lt;typename type&gt; union lrbPointer
{
    uint64_t intForm;
    type ptrForm; //assumed that type is a pointer type
};

//usage
lrbPointer&lt;int*&gt; myPointer;
int integers[4];
myPointer.ptrForm = integers;
myPointer.intForm += 2; //making it easy to jump by less then sizeof(int)
</code></pre>

<p>this is working well for me, but i would really love to find a way to make a default member. so that the user does not need to use a .ptrForm after the pointer they wish to use.</p>
","87234","","<p>You can use a conversion operator, along with a constructor, so you can transfer between the types:</p>

<pre><code>template &lt;typename PtrType&gt;
union IntPointer
{
    uint64_t intForm;
    PtrType ptrForm;

    IntPointer(PtrType ptr) :
    ptrForm(ptr)
    {
    }

    operator PtrType(void) const
    {
        return ptrForm;
    }
};

int main(void)
{
    IntPointer&lt;float*&gt; f = new float; // constructor

    float *theFloat = f; // conversion operator

    delete theFloat;
}
</code></pre>

<p>That said, I think your treading on thin ground. :|</p>
"
"<p>I have this snippet of code here. The intention is to make a copy of initialData. Since I am not modifying initialData in any way, I figure that I should pass it as a const reference. However, I keep getting this message when compiling.</p>

<blockquote>
  <p>.\src\Scene\SceneAnimationData.cpp(23)
  : error C2662:
  'SceneTrackerData::getRect' : cannot
  convert 'this' pointer from 'const
  SceneTrackerData' to 'SceneTrackerData
  &amp;'</p>
</blockquote>

<pre><code>#include ""SceneTrackerData.h""

void SceneAnimationData::SetupData(const SceneTrackerData &amp;initialData)
{
    // getRect(), points() and links() all return const pointers
    CloneRect(initialData.getRect());
    ClonePoints(initialData.points()-&gt;values());
    CloneLinks(initialData.links()-&gt;values());
}

void SceneAnimationData::CloneRect(const QGraphicsRectItem * initialRect) 
{
    if (initialRect != NULL)
    {
    	QPointF position = initialRect-&gt;scenePos();
    	QRectF rect = initialRect-&gt;rect();

    	initialRect = new QGraphicsRectItem(rect);
    	initialRect-&gt;setPos(position);
    }
}

void SceneAnimationData::CloneLinks(const QList&lt;QGraphicsLineItem*&gt; links) 
{
    links_ = new QList&lt;QGraphicsLineItem*&gt;(*links);
}

void SceneAnimationData::ClonePoints(const QList&lt;QGraphicsEllipseItem*&gt; points) 
{
    points_ = new QList&lt;QGraphicsEllipseItem*&gt;(*points);
}
</code></pre>
","87234","","<p>Without the definition of <code>SceneTrackerData</code>, it's hard to say, but likely that function (<code>SceneTrackerData::getRect</code>) is not marked as const.</p>

<p>That is, what is (guessing):</p>

<pre><code>const Rect&amp; SceneTrackerData::getRect(void)
</code></pre>

<p>Should be:</p>

<pre><code>const Rect&amp; SceneTrackerData::getRect(void) const 
                        //                     ^
                        //                     |
                        // does not logically modify the object
</code></pre>
"
"<p>I use a pointer to specify some kind of ""shared memory"" which I use to
exchange data between different processes/threads. Now I would like to have
a hex dump of the content of the shared buffer. Does anyone know how to do that?</p>

<p>thanks,
R</p>
","87234","","<p>On Windows, you can use <a href=""http://msdn.microsoft.com/en-us/library/ms680553%28VS.85%29.aspx"" rel=""nofollow""><code>ReadProcessMemory</code></a>. I do not know the Linux equivalent.</p>
"
"<p>The questions says it all:</p>

<pre><code>...
int ndigit[10];
...//fill in the array with 0s

while((c = getchar()) != EOF)
    if(c &gt;= '0' &amp;&amp; c &lt;= '9')
         ++ndigit[c - '0']; //&lt;== unable to understand this part
</code></pre>

<p>supposedly, the array stores incoming digit chars from the input stream...</p>
","87234","","<p>The character 0 is different from the number 0.</p>

<p>In ASCII, the character '0' is at position <a href=""http://www.asciitable.com/"" rel=""nofollow"">48</a>. The standard guarantees that in the character encoding, the numbers must be sequential (I do not know where in the standard this is said). That is, just like 1 comes after 0, '1' will come after '0'. Therefore, if you have entered '0', and you want to get 0, subtract '0' from it. '1' minus '0' will have a difference of 1. And so on.</p>
"
"<blockquote>
  <p><strong>Possible Duplicates:</strong><br />
  <a href=""http://stackoverflow.com/questions/1118705/call-a-function-named-in-a-string-variable-in-c"">call a function named in a string variable in c</a><br />
  <a href=""http://stackoverflow.com/questions/801070/dynamically-invoking-any-function-by-passing-function-name-as-string"">Dynamically invoking any function by passing function name as string</a>  </p>
</blockquote>

<p>I have certain functions.. say,</p>

<pre><code>double fA1B1C1( .. ) {
         ...
}

double fA2B2C3( .. ) {
         ...
}

double (*fptr)( .. );

fptr myfunc;
</code></pre>

<p>These functions are already defined. </p>

<p>So when the user inputs the string ""A2B2C2"", it is got into a variable and converted to ""fA2B2C2""</p>

<pre><code>myfunc = formatted_string; // DOES NOT WORK
</code></pre>

<p>But the above syntax does not work. Even typecasting it does not work.</p>

<pre><code>myfunc = (fptr) formatted_string // DOES NOT WORK
</code></pre>

<p>But if I hard code it as</p>

<p><code>myfunc = fA2B2C2</code> (or) <code>myfunc = &amp;fA2B2C2</code>, it works pefectly.</p>

<p>Where am I going wrong?</p>

<p>EDIT::</p>

<pre><code>I tried creating a hash table and a lookup function. Like

create_hashEntry(hashtable, string, formatted_string);
// string = ""A1B1C1; formatted_string = ""fA1B1C1""
</code></pre>

<p>then the look up function</p>

<pre><code>myfunc lookup_func(char *string) {
       return(get_hashEntry(hahstable, string));
}
</code></pre>

<p>This also failed to work.</p>
","87234","","<p>Read the <a href=""http://stackoverflow.com/questions/1118705/call-a-function-named-in-a-string-variable-in-c"">duplicate</a>, you'll find your answer.</p>

<p>I wanted to add, though, that this comes from a misunderstanding of how the program works.</p>

<p>These functions are at addresses in memory. Strings are not addresses. The names of functions, in code, are synonymous with their address. At runtime, having a string is really just having a pointer to some place in memory with characters. This has no relation to anything done at compile time, like function names.</p>

<p>Some languages include meta-data about the program, which means they <em>do</em> carry information about functions, their names, parameters, etc... at run time. C++ is not one of these languages.</p>

<p>This is why most answers will be a sort of simulation of this meta data: functions will be stored, and at run time you can use the string to peek into the table. </p>
"
"<p>Is it possible to stringify a character in a preprocessor macro without it including the (')s</p>

<p>example:</p>

<pre><code>#define S(name, chr)  const char * name = #name chr
</code></pre>

<p>usage:</p>

<pre><code>S(hello, 'W'); //should expand to 'const char * hello = ""helloW""
</code></pre>

<p>Thanks a bunch!,
Andrew</p>
","87234","","<p>Here are three ways. None use a single-quoted char, though:</p>

<pre><code>#include &lt;iostream&gt;

#define S1(x, y) (#x #y)
#define S2(x, y) (#x y)
#define S3(x, y) (x y)

int main(void)
{
    std::cout &lt;&lt; S1(hello, W) &lt;&lt; std::endl;
    std::cout &lt;&lt; S2(hello, ""W"") &lt;&lt; std::endl;
    std::cout &lt;&lt; S3(""hello"", ""W"") &lt;&lt; std::endl;
};
</code></pre>

<p>All output:</p>

<blockquote>
  <p>helloW</p>
</blockquote>
"
"<p>I'm writing a radix sort algorithm using queues and I would like to have a STL queue allocate space before I start adding things to the queue so that I can avoid constant dynamic resizing operations. </p>

<p>Even though this doesn't exist, I want something with the effect of...</p>

<pre><code>queue&lt;int&gt; qs(N);
for(int i=0;i&lt;N;++i)
  qs.push(rand());
</code></pre>

<p>in such a way that it will not dynamically allocate any memory during the loop.</p>

<p>The actual code in question...</p>

<pre><code>void radix_sort()
{
// Biggest number?
int max=-1;
for(int i=0;i&lt;N;++i)
	if(a[i]&gt;max)
		max = a[i];

// How many digits in it
int maxdigits=1;
while(max /= 10) maxdigits++;

// Create some buckets.
deque&lt;int&gt; b[10];
for(int i=0;i&lt;10;++i)
	b[i] = deque&lt;int&gt;(N);

int div=1;
// Radix Sort by digits
for(int d=1;d&lt;=maxdigits;++d)
{
	if(d&gt;1)
		div*=10;

	// Queue
	for(int i=0;i&lt;N;++i)
		b[ (a[i]/div) % 10 ].push_front(a[i]);

	// Dequeue
	int k=0;	
	for(int q=0;q&lt;10;++q)
		while(b[q].size() &gt; 0)
		{
			a[k++] = b[q].back();
			b[q].pop_back();
		}
}
}
</code></pre>
","87234","","<p>Chances are this is not a problem. <code>Deque</code>'s allocate in chunks anyway, so you'll probably only reallocate a few times. Have you determined this to be a bottleneck?</p>

<p>Anyway, the standard does not give an accessor to the `queue''s container, because that would defeat the purpose of encapsulation.</p>

<p>If you're really worried, pool allocate. This means preallocate the memory upfront, so when the container asks for memory, it's already there. I can't really go over allocators and kin, that would be overkill for an SO answer, but look up <a href=""http://www.google.com/search?q=c%2B%2B+allocator"">allocators on Google</a>.</p>

<p>Basically, you can tell your container where to get it's memory from. Normally, this is the default allocator, which uses new and delete.</p>

<p><a href=""http://www.boost.org/"">Boost</a> provides a <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/pool/doc/index.html"">pool allocator</a>, and it would go something like this:</p>

<pre><code>#include &lt;list&gt;
#include &lt;queue&gt;

// pool
#include &lt;boost/pool/pool_alloc.hpp&gt;

// helpful typedef's
typedef boost::fast_pool_allocator&lt;int&gt; BoostIntAllocator;
typedef boost::singleton_pool&lt;boost::fast_pool_allocator_tag, sizeof(int)&gt; BoostIntAllocatorPool;

int main(void)
{
    // specify the list as the underlying container, and inside of that,
    // specify fast_pool_allocator as the allocator. by default, it preallocates
    // 32 elements.
    std::queue&lt;int, std::list&lt;int, BoostIntAllocator &gt; &gt; q;

    /* No memory allocations take place below this comment */

    for (int i = 0; i &lt; 31; ++i)
    {
    	q.push(i);
    }

    /* End no allocation */

    // normally, the memory used by the singleton will
    // not be free'd until after the program is complete, 
    // but we can purge the memory manually, if desired:
    BoostIntAllocatorPool::purge_memory();
};
</code></pre>

<p>The pool allocates the memory up-front, so no actual memory allocation is done during <code>push()</code>/<code>pop()</code>.</p>

<p>I used a <code>list</code> instead of a <code>deque</code> because it is simpler. Normally, a <a href=""http://stackoverflow.com/questions/1262808/which-stl-container-should-i-use-for-a-fifo/1263122#1263122""><code>deque</code> is superior to a <code>list</code></a>, but with an allocator, the things that gave the <code>deque</code> it's advantage, like cache-performance and allocation cost, no longer exist. Therefore, a <code>list</code> is much simpler to use.</p>

<p>You can also use a <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/circular%5Fbuffer/doc/circular%5Fbuffer.html"">circular buffer</a>, like such:</p>

<pre><code>#include &lt;queue&gt;

// ring
#include &lt;boost/circular_buffer.hpp&gt;

int main(void)
{
    // use a circular buffer as the container. no allocations take place,
    // but be sure not to overflow it. this will allocate room for 32 elements.
    std::queue&lt;int, boost::circular_buffer&lt;int&gt; &gt; q(boost::circular_buffer&lt;int&gt;(32));

    /* No memory allocations take place below this comment */

    for (int i = 0; i &lt; 31; ++i)
    {
    	q.push(i);
    }

    /* End no allocation */
};
</code></pre>
"
"<p>How do I implement no-op macro in C++?</p>

<pre><code>#include &lt;iostream&gt;   

#ifdef NOOP       
    #define conditional_noop(x) what goes here?   
#else       
    #define conditional_noop(x) std::cout &lt;&lt; (x)   
#endif   
int main() {       
    conditional_noop(123);   
}
</code></pre>

<p>I want this to do nothing when NOOP is defined and print ""123"", when NOOP is not defined.</p>
","87234","","<p>Like others have said, leave it blank.</p>

<p>A trick you should use is to add <code>(void)0</code> to the macro, forcing users to add a semicolon after it:</p>

<pre><code>#ifdef NOOP       
    #define conditional_noop(x) (void)0
#else       
    #define conditional_noop(x) std::cout &lt;&lt; (x); (void)0
#endif
</code></pre>

<p>In C++, <code>(void)0</code> does nothing. <a href=""http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.5"" rel=""nofollow"">This article explains</a> other not-as-good options, as well as the rationale behind them.</p>
"
"<p>As the function accepted by <a href=""http://www.cplusplus.com/reference/algorithm/for%5Feach/"" rel=""nofollow"">for_each</a> take only one parameter (the element of the vector), I have to define a <code>static int sum = 0 </code>  somewhere so that It can be accessed 
after calling the for_each . I think this is awkward. Any better way to do this (still use for_each) ?</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;

static int sum = 0;
void add_f(int i )
{
    sum += i * i;

}
void test_using_for_each()
{
    int arr[] = {1,2,3,4};
    vector&lt;int&gt; a (arr ,arr + sizeof(arr)/sizeof(arr[0]));

    for_each( a.begin(),a.end(), add_f);
    cout &lt;&lt; ""sum of the square of the element is  "" &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>

<p>In Ruby, We can do it this way:</p>

<pre><code>sum = 0
[1,2,3,4].each { |i| sum += i*i}   #local variable can be used in the callback function
puts sum    #=&gt; 30
</code></pre>

<p><strong>Would you please show more examples how <code>for_each</code> is typically used in practical programming (not just print out each element)?</strong> Is it possible use <code>for_each</code> simulate 'programming pattern' like map and inject in Ruby (or map /fold in Haskell).</p>

<pre><code>#map in ruby 
&gt;&gt; [1,2,3,4].map  {|i| i*i} 
=&gt; [1, 4, 9, 16]

#inject in ruby 
[1, 4, 9, 16].inject(0)  {|aac ,i| aac +=i}  #=&gt; 30
</code></pre>

<p>EDIT: Thank you all. I have learned so much from your replies. We have so many ways to do the same single thing in C++ , which makes it a little bit difficult to learn. But it's interesting :)</p>
","87234","","<p><code>for_each</code> returns (a copy of) the functor that it was using. So, something like this:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

template &lt;typename T&gt;
class square_accumulate
{
public:
    square_accumulate(void) :
      _sum(0)
      {
      }

      const T&amp; result(void) const
      {
    	  return _sum;
      }

      void operator()(const T&amp; val)
      {
    	  _sum += val * val;
      }

private:
    T _sum;
};

int main(void)
{
    int arr[] = {1,2,3,4};
    std::vector&lt;int&gt; a (arr ,arr + sizeof(arr)/sizeof(arr[0]));

    int sum = std::for_each(a.begin(), a.end(), square_accumulate&lt;int&gt;()).result();

    std::cout &lt;&lt; ""sum of the square of the element is "" &lt;&lt; sum &lt;&lt; std::endl;
}
</code></pre>

<p>As demonstrated by other answers, though, <a href=""http://www.cplusplus.com/reference/std/numeric/accumulate/"" rel=""nofollow""><code>std::accumulate</code></a> is the best way to go.</p>
"
"<p>I have a lot of functions(huge list) defined and compiled. And I use function pointers to call and execute the functions by sending arguments dynamically during runtime.  It is an iterative process involving more than hundred thousand function calls every iteration. I want to know which is the efficient way of calling an compiled function. I feel my way is slower. </p>
","87234","","<p>The only way you can speed up function calls is if the compiler knows what function it will be calling.</p>

<p>That is, something like:</p>

<pre><code>void foo(void)
{
    /* do some stuff */
}

int main(void)
{
    foo();
}
</code></pre>

<p>Could be inlined to:</p>

<pre><code>int main(void)
{
    /* do some stuff */
}
</code></pre>

<p>But if the compiler doesn't know which one to call:</p>

<pre><code>void foo(void)
{
    /* do some stuff */
}

void bar(void)
{
    /* do some other stuff */
}

typedef void(*Function)(void);

int main(void)
{
    Function func = /* choose a function at runtime */
    func();
}
</code></pre>

<p>The compiler cannot possibly predict which function will be called, and therefore cannot inline it.</p>

<p>If your compiler supports it, you might try using <a href=""http://msdn.microsoft.com/en-us/library/6xa169sk%28VS.71%29.aspx"" rel=""nofollow""><code>__fastcall</code></a>, but you need to profile your code and see if it made a positive difference.</p>

<p>This one level of indirection isn't going to make a huge difference. Profile your code and find where the real slowdowns are.</p>
"
"<p>I have ID values of the type <code>unsigned int</code>. I need to map an Id to a pointer in <strong><em>constant time</em></strong>. </p>

<p><hr /></p>

<p><strong>Key Distribution:</strong></p>

<p>ID will have a value in the range of 0 to uint_max. Most of keys will be clustered into a single group, but there will be outliers.</p>

<p><hr /></p>

<p><strong>Implementation:</strong></p>

<ul>
<li><p>I thought about using the C++ ext hash_map stuff, but I've heard their performance isn't too great when keys have a huge potential range. </p></li>
<li><p>I've also thought of using some form of chained lookup (equivalent to recursively subdividing the range into C chucks). If there are no keys in a range, that range will point to NULL.</p>

<p>N = Key Range</p>

<p>Level 0 (divided into C = 16, so 16 pieces) = [0, N/16), [N/16, 2*(N/16)), ...</p>

<p>Level 1 (divided into C = 16, so 16 * 16 pieces) = ...</p></li>
</ul>

<p><hr /></p>

<p>Does anyone else have ideas on how this mapping can be more efficiently implemented?</p>

<p><strong>Update:</strong></p>

<p>By constant, I just meant each key lookup is not significantly influenced by the # of values in the item. I did not mean it had to be a single op.</p>
","87234","","<p>Use a hash map (<a href=""http://www.boost.org/doc/libs/1%5F36%5F0/doc/html/unordered.html"" rel=""nofollow""><code>unordered_map</code></a>). This gives ~O(1) look-up times. You ""heard"" it was bad, but did you try it, test it, and determine it to be a problem? If not, use a hash map. </p>

<p>After your code gets close to completion, profile it and determine if the look-up times are the main cause of slowness in your program. Chances are, it won't be.</p>
"
"<p>I'm currently reviewing a very old C++ project and see lots of code duplication there.</p>

<p>For example, there is a class with 5 MFC message handlers each holding 10 identical lines of code. Or there is a 5-line snippet for a very specific string transformation every here and there. Reducing code duplication is not a problem in these cases at all.</p>

<p>But I have a strange feeling that I might be misunderstanding something and that there was originally a reason for this duplication.</p>

<p>What could be a valid reason for duplicating code?</p>
","87234","","<p>The only ""valid"" thing I can see this arising from is when those lines of code were different, then converged to the same thing through subsequent edits. I've had this happen to me before, but none too frequently.</p>

<p>This is, of course, when it's time to factor out this common segment of code into new functionality.</p>

<p>That said, I can't think of any reasonable way to justify duplicate code. Look at why it's bad.</p>

<p>It's bad because a change in one place requires a change in multiple places. This is increased time, with a chance of bugs. By factoring it out, you maintain the code in a single, working location. After all, when you write a program you don't write it twice, why would a function be any different?</p>
"
"<p>I'm using a vector of pointers to objects. These objects are derived from a base class, and are being dynamically allocated and stored.</p>

<p>For example, I have something like:</p>

<pre><code>vector&lt;Enemy*&gt; Enemies;
</code></pre>

<p>and I'll be deriving from the Enemy class and then dynamically allocating memory for the derived class, like this:</p>

<pre><code>enemies.push_back(new Monster());
</code></pre>

<p>What are things I need to be aware of to avoid memory leaks and other problems?</p>
","87234","","<p><a href=""http://en.cppreference.com/w/cpp/container/vector""><code>std::vector</code></a> will manage the memory for you, like always, but this memory will be of pointers, not objects.</p>

<p>What this means is that your classes will be lost in memory once your vector goes out of scope. For example:</p>

<pre><code>#include &lt;vector&gt;

struct base
{
    virtual ~base() {}
};

struct derived : base {};

typedef std::vector&lt;base*&gt; container;

void foo()
{
    container c;

    for (unsigned i = 0; i &lt; 100; ++i)
        c.push_back(new derived());

} // leaks here! frees the pointers, doesn't delete them (nor should it)

int main()
{
    foo();
}
</code></pre>

<p>What you'd need to do is make sure you delete all the objects before the vector goes out of scope:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;vector&gt;

struct base
{
    virtual ~base() {}
};

struct derived : base {};

typedef std::vector&lt;base*&gt; container;

template &lt;typename T&gt;
void delete_pointed_to(T* const ptr)
{
    delete ptr;
}

void foo()
{
    container c;

    for (unsigned i = 0; i &lt; 100; ++i)
        c.push_back(new derived());

    // free memory
    std::for_each(c.begin(), c.end(), delete_pointed_to&lt;base&gt;);
}

int main()
{
    foo();
}
</code></pre>

<p>This is difficult to maintain, though, because we have to remember to perform some action. More importantly, if an exception were to occur in-between the allocation of elements and the deallocation loop, the deallocation loop would never run and you're stuck with the memory leak anyway! This is called exception safety and it's a critical reason why deallocation needs to be done automatically.</p>

<p>Better would be if the pointers deleted themselves. Theses are called smart pointers, and the standard library provides <a href=""http://en.cppreference.com/w/cpp/memory/unique_ptr""><code>std::unique_ptr</code></a> and <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr""><code>std::shared_ptr</code></a>.</p>

<p><code>std::unique_ptr</code> represents a unique (unshared, single-owner) pointer to some resource. This should be your default smart pointer, and overall complete replacement of any raw pointer use.</p>

<pre><code>auto myresource = /*std::*/make_unique&lt;derived&gt;(); // won't leak, frees itself
</code></pre>

<p><code>std::make_unique</code> is missing from the C++11 standard by oversight, but you can make one yourself. To directly create a <code>unique_ptr</code> (not recommended over <code>make_unique</code> if you can), do this:</p>

<pre><code>std::unique_ptr&lt;derived&gt; myresource(new derived());
</code></pre>

<p>Unique pointers have move semantics only; they cannot be copied:</p>

<pre><code>auto x = myresource; // error, cannot copy
auto y = std::move(myresource); // okay, now myresource is empty
</code></pre>

<p>And this is all we need to use it in a container:</p>

<pre><code>#include &lt;memory&gt;
#include &lt;vector&gt;

struct base
{
    virtual ~base() {}
};

struct derived : base {};

typedef std::vector&lt;std::unique_ptr&lt;base&gt;&gt; container;

void foo()
{
    container c;

    for (unsigned i = 0; i &lt; 100; ++i)
        c.push_back(make_unique&lt;derived&gt;());

} // all automatically freed here

int main()
{
    foo();
}
</code></pre>

<p><code>shared_ptr</code> has reference-counting copy semantics; it allows multiple owners sharing the object. It tracks how many <code>shared_ptr</code>s exist for an object, and when the last one ceases to exist (that count goes to zero), it frees the pointer. Copying simply increases the reference count (and moving transfers ownership at a lower, almost free cost). You make them with <code>std::make_shared</code> (or directly as shown above, but because <code>shared_ptr</code> has to internally make allocations, it's generally more efficient and technically more exception-safe to use <code>make_shared</code>).</p>

<pre><code>#include &lt;memory&gt;
#include &lt;vector&gt;

struct base
{
    virtual ~base() {}
};

struct derived : base {};

typedef std::vector&lt;std::shared_ptr&lt;base&gt;&gt; container;

void foo()
{
    container c;

    for (unsigned i = 0; i &lt; 100; ++i)
        c.push_back(std::make_shared&lt;derived&gt;());

} // all automatically freed here

int main()
{
    foo();
}
</code></pre>

<p>Remember, you generally want to use <code>std::unique_ptr</code> as a default because it's more lightweight. Additionally, <code>std::shared_ptr</code> can be constructed out of a <code>std::unique_ptr</code> (but not vice versa), so it's okay to start small.</p>

<p>Alternatively, you could use a container created to store pointers to objects, such as a <a href=""http://www.boost.org/libs/ptr_container/doc/ptr_container.html""><code>boost::ptr_container</code></a>:</p>

<pre><code>#include &lt;boost/ptr_container/ptr_vector.hpp&gt;

struct base
{
    virtual ~base() {}
};

struct derived : base {};

// hold pointers, specially
typedef boost::ptr_vector&lt;base&gt; container;

void foo()
{
    container c;

    for (int i = 0; i &lt; 100; ++i)
        c.push_back(new Derived());

} // all automatically freed here

int main()
{
    foo();
}
</code></pre>

<p>While <code>boost::ptr_vector&lt;T&gt;</code> had obvious use in C++03, I can't speak of the relevance now because we can use <code>std::vector&lt;std::unique&lt;T&gt;&gt;</code> with probably little to no comparable overhead, but this claim should be tested.</p>

<p>Regardless, <em>never explicitly free things in your code</em>. Wrap things up to make sure resource management is dealt with automatically. You should have no raw owning pointers in your code.</p>

<p>As a default in a game, I would probably go with <code>std::vector&lt;std::shared_ptr&lt;T&gt;&gt;</code>. We expect sharing anyway, it's fast enough until profiling says otherwise, it's safe, and it's easy to use.</p>
"
"<p>This is a really easy question I'm sure but I'd appreciate the help. :)</p>

<p>Here's my variable in the .h file:</p>

<pre><code>map&lt;int, map&lt;int, map&lt;int, CString&gt;*&gt;*&gt; batch;
</code></pre>

<p>Here's me trying to assign a value:</p>

<pre><code>((*((*(batch[atoi(transnum)]))[1]))[atoi(*docnum)]) = page;
</code></pre>

<p>I added some extra parentheses while trying to figure this out in order to make sure the derefs were being processed in the right order - unfortunately, it still doesn't work. My application just crashes when running this line. I have it wrapped in a try {} catch {}, but no exception appears to be thrown. I don't use C++ very often and am wondering whether someone can tell me what I'm doing incorrectly.</p>

<p><strong>Here's the relationship I'm trying to model:</strong> </p>

<p><em>List of <strong>transaction numbers</strong> (integers), needs to be ordered by key.</em></p>

<p><em>For each transaction number, I have two <strong>types</strong> of documents, Payments and Invoices (buckets represented by 0 and then 1 respectively in my data struct above)</em></p>

<p><em>In each type bucket, there can be <strong>one or more documents</strong>, These documents need to be ordered by id (docid)</em></p>

<p><em>Each docid links to a string that consists of a comma-delimited list of files on the file system for processing.</em></p>

<p>If you think there's a better data structure to use, I'd be interested to hear it.</p>

<p><strong>EDIT:</strong> I know there are many better ways to do this. The scenario was that I was handed a heap of horrible MFC-riddled C++ code and told to have something done yesterday. It basically boiled down to getting the data structure in there, loading it up and then outputting it somewhere else. I was just trying to pound it out quickly when I asked this question. I appreciate the design suggestions though. </p>
","87234","","<p>First, <code>typedef</code> these things, and it becomes much easier:</p>

<pre><code>typedef std::map&lt;int, CString&gt; page_map;
typedef std::map&lt;int, page_map&gt; document_map;
typedef std::map&lt;int, document_map&gt; batch_map;

batch_map batch;
</code></pre>

<p>Note that you should almost always prefer he stack to dynamically allocating. Secondly, you're doing too much in a line!</p>

<pre><code>int transNumber = atoi(transnum);
int docNumber = atoi(*docnum); // why is docnum a pointer?

batch[transNumber ][1][docNumber] = page;
</code></pre>

<p>Now if you need to debug you can easily check those values, and it's easier to see where you'd make mistakes.</p>

<p>I think with more information we could make this work a lot more simply. I can't think of why on Earth you'd need something like this.</p>
"
"<p>I know this is quite a ridiculous question but this is quite confusing and irritating, as something that <em>should</em> work simply is not. I'm using Code Blocks with the GCC compiler and I am trying to simply create a string variable in my class</p>

<pre><code>#ifndef ALIEN_LANGUAGE
#define ALIEN_LANGUAGE

#include &lt;string&gt;

class Language
{
    public:

    private:
        string str;
};

#endif
</code></pre>

<p>Strange enough, my compiler halts me with an error saying this:</p>

<pre><code>C:\Documents and Settings\...|11|error: `string' does not name a type|
||=== Build finished: 1 errors, 0 warnings ===|
</code></pre>

<p>For some reason, it is unable to find the class ""string"" which for some reason, my main.cpp is able to detect ""#include "" while my language class is not able for some reason.</p>

<p>This is the main I wrote quickly just to see it main itself is able to see the string file:</p>

<pre><code>//main.cpp

#include &lt;iostream&gt;
#include &lt;string&gt;
#include ""alien_language.h""

using namespace std;

int main()
{
    string str;

    return 0;
}
</code></pre>

<p>Does anyone know what's going on?</p>
","87234","","<p><code>using namespace std;</code></p>

<p>That's what's going on.</p>

<p>You don't have <code>std::</code> prefixing the string in your class. Everything in the standard library is in the namespace <code>std</code>.</p>

<p>It is generally regarded as bad practice to use <code>using namespace std;</code>, by the way. For more information on why and what to do instead, check out this question: <a href=""http://stackoverflow.com/questions/1265039/using-std-namespace"">Using std Namespace</a>.</p>
"
"<p>Can a constructor call be evaluated to a boolean if the bool() operator is overloaded?</p>

<pre><code>class A
{
  public:
  A() {};
  operator bool() const { return true; }
}

main()
{
  if (A a = A())
  {
  // do stuff
  }
}
</code></pre>

<p>Is the above code valid, or do I need to implement main like:</p>

<pre><code>int main(int argc, const char* argv[])
{
A a();
if (a)
  {
  // do stuff
  }
}
</code></pre>

<p>This code is going to wind up all over the place in my code base, so less lines, increased legibility, and reduced scope are important, and would be improved by this.</p>

<p>Any ideas?</p>
","87234","","<p>If you're trying to indicate failure, why not <a href=""http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.2"" rel=""nofollow"">throw an exception</a>?</p>

<pre><code>#include &lt;stdexcept&gt;

class Foo
{
public:
    Foo(void)
    {
        if (/* something bad D: */)
        {
            throw std::runtime_error(""Couldn't open file, etc..."");
        }
    }
}

int main(void)
{
    try
    {
        Foo f;
        // do stuff with f
    }
    catch (std::exception&amp; e)
    {
        std::cerr &lt;&lt; ""Error: "" &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}
</code></pre>
"
"<p>References in C++ are a conveneint construct that allow us to simplify the following C code:</p>

<pre><code>f(object *p){
  //do something
}

int main(){
  object* p = (object*) calloc(sizeof(object));
  f(p);
}
</code></pre>

<p>to </p>

<pre><code>f(object&amp; o){
  //do something
}

int main(){
  object o = object();
  f(o);
}
</code></pre>

<p>Shared pointers are another convenience in C++ that simplify memory management. However, I am not sure how to pass a <code>shared_ptr</code> to a function like <code>f(object&amp; o)</code> which accepts arguments by reference? </p>

<pre><code>f(object&amp; o){
  //do something
}

int main(){
  shared_ptr&lt;object&gt; p (new object());
  f(*p);
}
</code></pre>

<p>Will the shared pointer be incremented when its object is passed by reference to a function?</p>
","87234","","<p>Take a <code>shared_ptr</code> by value, and the reference count will increase. This is easier when you <code>typedef</code> it:</p>

<pre><code>typedef boost:shared_ptr&lt;object&gt; object_ptr;

void foo(object_ptr obj)
{
    obj-&gt;/* stuff*/;
    obj.reset(); //only resets this local copy, that means:
                 // reduce reference count (back to 1), and
                 // set obj to point at null.
}

int main(void)
{
    object_ptr obj(new object());
    foo(obj);
}
</code></pre>

<p>Keep in mind references are aliases. When you pass by reference, you're not passing pointers, copies, etc..., you're aliasing another object. (In reality they are implemented as pointers):</p>

<pre><code>typedef boost:shared_ptr&lt;object&gt; object_ptr;

void foo(object_ptr&amp; obj)
{
    obj.reset(); // the references was never increased, since a copy has not
                 // been made, this *is* obj in main. so the reference 
                 // goes to 0, and obj is deleted
}

int main(void)
{
    object_ptr obj(new object);
    foo(obj); // after this, obj has been reset!
}
</code></pre>

<p>Always remember to be <code>const</code> correct, to prevent errors:</p>

<pre><code>typedef boost:shared_ptr&lt;object&gt; object_ptr;

void foo(const object_ptr&amp; obj)
{
    obj.reset(); // cannot do! 
}

int main(void)
{
    object_ptr obj(new object);
    foo(obj);
}
</code></pre>

<p>I think you should prefer to pass smart pointers as references when possible, to avoid extraneous increments and decrements (and copies and whatnot).</p>
"
"<pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
{
        float s;
        s = 10 / 3;
        cout &lt;&lt; s &lt;&lt; endl;
        cout.precision(4);
        cout &lt;&lt; s &lt;&lt; endl;
        return 0;

}
</code></pre>

<p>Why the output does not show 3.333 but only 3 ??</p>
","87234","","<p>The correct way to do a constant float division is:</p>

<pre><code>s = 10.f / 3.f; // one of the operands must be a float
</code></pre>

<p>Without the <code>f</code> suffix, you are doing <code>double</code> division, giving a warning (from <code>float</code> to <code>double</code>).</p>

<p>You can also cast one of the operands:</p>

<pre><code>s = static_cast&lt;float&gt;(10) / 3; // use static_cast, not C-style casts
</code></pre>

<p>Resulting in the correct division.</p>
"
"<p>I have a global pointer variable</p>

<pre><code>char* pointer = new char[500];
/* some operations... */
</code></pre>

<p>there is a seperate FreeGlobal() function that does free up the pointer as below:</p>

<pre><code>delete[] pointer;
</code></pre>

<p>First time when the function is called, it actually frees up the memory and now the pointer is a bad pointer. But when we call this more than once, it throws an exception. </p>

<p>Is there a way to check the pointer variable before calling delete [] again? What are the work arounds? Is this a bad practice?</p>

<p>Thank you. </p>
","87234","","<p>I would suggest you actually fix your code. Double deleting something is a terrible thing to do. Rather than make hackish routines to let this happen, fix the real problem: no more double deletes.</p>

<p>Find out why you're deleting something twice, and stop it from happening. This would probably be easier if you weren't using global variables. If you need a global resource, use a singleton.</p>

<p>Additionally, use a <code>std::vector&lt;char&gt;</code>, or <code>boost::array&lt;char, 100&gt;</code>, so you don't need to worry about memory. You can't accidentally delete something twice if you don't have to worry about (or access to) deleting it.</p>
"
"<p>The title pretty much says it all, do you prefer to see something like t_byte* (where t_byte would be a typedef for unsigned char) or unsigned char* in code? I'm leaning towards t_byte in my own libraries, but have never worked on a large project where this approach was taken, and am wondering about pitfalls.</p>

<p>Regards,
Dan O.</p>
","87234","","<p>Besides your awkward naming convention, I think that might be okay. Keep in mind boost does this for you, to help with cross-platform-ability:</p>

<pre><code>#include &lt;boost/integer.hpp&gt;

typedef boost::uint8_t byte_t;
</code></pre>

<p>Note that usually type's are suffixed with <code>_t</code>, as in <code>byte_t</code>.</p>
"
"<p>In my application, I need a hash map mapping strings to a large number of static objects.  The mappings remain fixed for the duration of the application.  Is there an easy way to pre-generate the mappings at compile time rather than building it element-by-element when the application starts? </p>
","87234","","<p>Look up <a href=""http://www.gnu.org/software/gperf/"" rel=""nofollow"">gperf</a>, it generates code for you that will perfectly hash.</p>
"
"<p>I would like to do this:</p>

<pre><code>class Derived;

class Base {
    virtual Derived f() = 0;
};

class Derived : public Base {
};
</code></pre>

<p>Of course this doesn't work since I can't return an incomplete type. But neither can I define Derived before base, since I can't inherit from an incomplete type either. I figure that I could use templates as a workaround (using Derived as a template argument to Base), but it seems a really ugly way of doing things. Might there be another way?</p>

<p>Elaboration: I'm writing a raytracer, and each Shape class has a function which returns its bounding box. However, I've made the BBox a subclass of Shape, so I can visualize it. Is this bad design?</p>
","87234","","<p>You could use a pointer (or a reference):</p>

<pre><code>class Derived;

class Base {
    virtual Derived *f() = 0;
};

class Derived : public Base {
};
</code></pre>

<p>But this is code smell to me. Why should anybody inheriting from this class need to know about another derived class? In fact, why should the base class be concerned with it's derivee's?</p>

<p>For your situation, you'll need to notice things that mgiht be a signal for bad design. Although it makes sense that your bounding box would derive from <code>Shape</code>, keep in mind, since <code>Shape</code> has a function that returns a bounding box, a bounding box will have a function that returns itself.</p>

<p>I'm not sure the best solution, but you could make <code>BBox</code> a separate class altogether, and perhaps give it a function akin to: <code>Shape *as_shape(void) const</code>, which would construct a <code>class Box : public Shape</code> with the same dimensions as the bounding box.</p>

<p>I still feel there is a better way, but I'm out of time for now, I'm sure someone else will think of a better solution.</p>
"
"<p>I need to find an element position in an std::vector to use it for referencing an element in <em>another</em> vector:</p>

<pre><code>int find( const vector&lt;type&gt;&amp; where, int searchParameter )
{
    for( int i = 0; i &lt; where.size(); i++ ) {
       if( conditionMet( where[i], searchParameter ) ) {
           return i;
       }
    }
    return -1;
}
// caller:
const int position = find( firstVector, parameter );
if( position != -1 ) {
    doAction( secondVector[position] );
}
</code></pre>

<p>however <code>vector::size()</code> returns <code>size_t</code> which corresponds to an <code>unsigned int</code> type that can't directly store <code>-1</code>. How do I signal that the element is not found in a vector when using <code>size_t</code> instead of <code>int</code> as an index?</p>
","87234","","<p>Something like this, I think. <code>find_if_counted.hpp</code>:</p>

<pre><code>#ifndef FIND_IF_COUNTED_HPP
#define FIND_IF_COUNTED_HPP

#include &lt;algorithm&gt;

namespace find_if_counted_impl
{
    template &lt;typename Func&gt;
    struct func_counter
    {
    	explicit func_counter(Func&amp; func, unsigned &amp;count) :
    	_func(func),
    	_count(count)
    	{
    	}

    	template &lt;typename T&gt;
    	bool operator()(const T&amp; t)
    	{
    		++_count;

    		return _func(t);
    	}

    private:
    	Func&amp; _func;
    	unsigned&amp; _count;
    };
}

// generic find_if_counted,
// returns the index of the found element, otherwise returns find_if_not_found
const size_t find_if_not_found = static_cast&lt;size_t&gt;(-1);

template &lt;typename InputIterator, typename Func&gt;
size_t find_if_counted(InputIterator start, InputIterator finish, Func func)
{
    unsigned count = 0;
    find_if_counted_impl::func_counter&lt;Func&gt; f(func, count);

    InputIterator result = find_if(start, finish, f);

    if (result == finish)
    {
    	return find_if_not_found;
    }
    else
    {
    	return count - 1;
    }
}

#endif
</code></pre>

<p>Example:</p>

<pre><code>#include ""find_if_counted.hpp""
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

typedef std::vector&lt;int&gt; container;

int rand_number(void)
{
    return rand()  % 20;
}

bool is_even(int i)
{
    return i % 2 == 0;
}

int main(void)
{
    container vec1(10);
    container vec2(10);

    std::generate(vec1.begin(), vec1.end(), rand_number);
    std::generate(vec2.begin(), vec2.end(), rand_number);

    unsigned index = find_if_counted(vec1.begin(), vec1.end(), is_even);

    if (index == find_if_not_found)
    {
    	std::cout &lt;&lt; ""vec1 has no even numbers."" &lt;&lt; std::endl;
    }
    else
    {
    	std::cout &lt;&lt; ""vec1 had an even number at index: "" &lt;&lt; index &lt;&lt;
    		"" vec2's corresponding number is: "" &lt;&lt; vec2[index] &lt;&lt; std::endl;
    }
}
</code></pre>

<p>Though I feel like I'm doing something silly... :X Any corrections are welcome, of course.</p>
"
"<p>I am trying to write an if statement but cannot find the proper expression form to use. I'm thinking of writing something like this:</p>

<pre><code>if ( var != type(int) )
</code></pre>

<p>However, I am unsure exactly how to go about doing this, and this method does not work.</p>

<p>Am I at least thinking along the right lines?</p>
","87234","","<p>It sounds like you're trying to overload a function:</p>

<pre><code>void foo(int i)
{
    // stuff
}

void foo(float f)
{
    // stuff
}

int main(void)
{
    int i = 10;
    float f = 1.0f;

    foo(i); // calls foo(int)
    foo(f); // calls foo(float)
}
</code></pre>

<p>If you want <code>int</code>-special behavior and then something else in all other cases, you can use templates:</p>

<pre><code>template &lt;typename T&gt;
void foo(T t)
{
    // T is something
}

template &lt;&gt;
void foo(int i)
{
    // for int's only
}

int main(void)
{
    int i = 10;
    float f = 1.0f;
    double d = 2.0;

    foo(i); // calls specialized foo
    foo(f); // calls generic foo
    foo(d); // calls generic foo
}
</code></pre>

<p><hr /></p>

<p>According to your comment (<em>""Task at hand is a simple program: Take two user inputted integers and add them. Restrict input to integer only. I can do it in Python and I am thinking too along those lines. if num1 != type(int): print ""You did not enter an integer, please enter a integer."" else: continue""</em>), you want something like this:</p>

<pre><code>#include &lt;iostream&gt;

int main(void)
{
    int i;
    std::cin &gt;&gt; i;

    if (std::cin.fail())
    {
    	std::cout &lt;&lt; ""Not valid!"" &lt;&lt; std::endl;
    }
    else
    {
    	// ...
    }
}
</code></pre>

<p>This will notify invalid input such as ""@#$"", ""r13"", but does <strong>not</strong> catch cases such as ""34fg"", ""12$#%"", because it will read the <code>int</code>, and stop at ""fg"" and ""$#%"", respectively.</p>

<p>To check that, you will have to read in a line of input, and then try to convert that line into the type you want. (<em>Thanks, litb</em>). That means your question is more <a href=""http://stackoverflow.com/questions/1243428/convert-string-to-int-with-bool-fail-in-c/"">like this question</a>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main(void)
{
    std::string input;
    std::getline(std::cin, input);

    std::stringstream ss(input);
    int i;
    ss &gt;&gt; i;

    if (ss.fail() || !(ss &gt;&gt; std::ws).eof())
    {
    	std::cout &lt;&lt; ""Not valid!"" &lt;&lt; std::endl;
    }
    else
    {
    	// ...
    }
}
</code></pre>

<p>This does the following: get input, and put it into a <code>stringstream</code>. Then after parsing the <code>int</code>, stream out any remaining white space. After that, if <code>eof</code> is false, this means there are left-over characters; the input was invalid.</p>

<p>This is much easier to use wrapped in a function. In the other question, the cast was re-factored away; in this question we're using the cast, but wrapping the input along with it. </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

bool parse_int(int&amp; i)
{
    std::string input;
    std::getline(std::cin, input);

    std::stringstream ss(input);
    ss &gt;&gt; i;

    return !(ss.fail() || !(ss &gt;&gt; std::ws).eof());
}

int main(void)
{
    int i;

    if (!parse_int(i))
    {
    	std::cout &lt;&lt; ""Not valid!"" &lt;&lt; std::endl;
    }
    else
    {
    	// ...
    }
}
</code></pre>

<p>Or more generically:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

template &lt;typename T&gt;
bool parse_type(T&amp; t)
{
    std::string input;
    std::getline(std::cin, input);

    std::stringstream ss(input);
    ss &gt;&gt; t;

    return !(ss.fail() || !(ss &gt;&gt; std::ws).eof());
}

int main(void)
{
    int i;

    if (!parse_type(i))
    {
    	std::cout &lt;&lt; ""Not valid!"" &lt;&lt; std::endl;
    }
    else
    {
    	// ...
    }
}
</code></pre>

<p>This let's you parse other types with error checking.</p>

<p><hr /></p>

<p>If you're okay with exceptions, using <code>lexical_cast</code> (either from boost, or ""faked"", see the other question linked in-code [same as above link]), your code would look something like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

/* Faked lexical-cast from question:
http://stackoverflow.com/questions/1243428/convert-string-to-int-with-bool-fail-in-c/
*/
template &lt;typename T&gt;
T lexical_cast(const std::string&amp; s)
{
    std::stringstream ss(s);

    T result;
    if ((ss &gt;&gt; result).fail() || !(ss &gt;&gt; std::ws).eof())
    {
    	throw std::bad_cast(""Bad cast."");
    }

    return result;
}


template &lt;typename T&gt;
T parse_type(void)
{
    std::string input;
    std::getline(std::cin, input);

    return lexical_cast&lt;T&gt;(input);
}

int main(void)
{
    try
    {
    	int i = parse_type&lt;int&gt;();
    	float f = parse_type&lt;float&gt;();
    }
    catch (const std::exception&amp; e)
    {
    	std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}
</code></pre>

<p>I don't think boost has a no-throw version of lexical cast, so we can make a true/false rather than exception version of this code by catching <code>bad_cast</code>'s, as follows. Once again, this works with either <code>boost</code> or a custom lexical cast. (Anything that does a lexical cast and throws <code>bad_cast</code>):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

/* Faked lexical-cast from question:
http://stackoverflow.com/questions/1243428/convert-string-to-int-with-bool-fail-in-c/
*/
template &lt;typename T&gt;
T lexical_cast(const std::string&amp; s)
{
    std::stringstream ss(s);

    T result;
    if ((ss &gt;&gt; result).fail() || !(ss &gt;&gt; std::ws).eof())
    {
    	throw std::bad_cast(""Bad cast."");
    }

    return result;
}


template &lt;typename T&gt;
bool parse_type(T&amp; t)
{
    std::string input;
    std::getline(std::cin, input);

    try
    {
    	t = lexical_cast&lt;T&gt;(input);

    	return true;
    }
    catch (const std::bad_cast&amp; e)
    {
    	return false;
    }
}

int main(void)
{
    int i;
    if (!parse_type(i))
    {
    	std::cout &lt;&lt; ""Bad cast."" &lt;&lt; std::endl;
    }
}
</code></pre>

<p>Now it's back to a <code>bool</code> result, except we avoid code duplication by using existing <code>lexical_cast</code> functions.</p>

<p>You can of course choose which method you would like to use.</p>
"
"<pre><code>C:\Projects\Logs\RTC\MNH\Debug  
C:\Projects\Logs\FF
</code></pre>

<p>Is there an expression/string that would say go back until you find ""Logs"" and open it? (assuming you were always below it)</p>

<p>The <strong>same</strong> executable is run out of ""Debug"", ""MNH"" or ""FF"" at different times, the executable always should save it's log files into ""Logs"".</p>

<p>What expression would get there WITHOUT referring to the entire path C:\Projects\Logs?</p>

<p>Thanks.</p>
","87234","","<p>You might have luck using the <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/libs/filesystem/doc/index.htm"" rel=""nofollow""><code>boost::filesystem</code></a> library.</p>

<p>Without a compiler (and ninja-copies from boost documentation), something like:</p>

<pre><code>#include &lt;boost/filesystem.hpp&gt;

namespace boost::filesystem = fs;

bool contains_folder(const fs::path&amp; path, const std::string&amp; folder)
{
    // replace with recursive iterator to check within
    // sub-folders. in your case you just want to continue
    // down parents paths, though
    typedef fs::directory_iterator dir_iter;

    dir_iter end_iter; // default construction yields past-the-end
    for (dir_iter iter(path); iter != end_iter; ++iter)
    {
        if (fs::is_directory(iter-&gt;status()))
        {
            if (iter-&gt;path().filename() == folder)
            {
                return true;
            }
        }
    }

    return false;
}

fs::path find_folder(const fs::path&amp; path, const std::string&amp; folder)
{
    if (contains_folder(path, folder))
    {
        return path.string() + folder;
    }

    fs::path searchPath = path.parent_path();
    while (!searchPath.empty())
    {
        if (contains_folder(searchPath, folder))
        {
            return searchPath.string() + folder;
        }

        searchPath = searchPath.parent_path();
    }

    return """":
}

int main(void)
{
    fs::path logPath = find_folder(fs::initial_path(), ""Log"");

    if (logPath.empty())
    {
        // not found
    }
}
</code></pre>

<p>For now this is completely untested :)</p>
"
"<pre><code>BITMAPINFO bmi;
memset(&amp;bmi,0,sizeof(BITMAPINFO));
bmi.bmiHeader.biSize			= sizeof(BITMAPINFOHEADER);
bmi.bmiHeader.biWidth			=m_pImg-&gt;GetWidth();
bmi.bmiHeader.biHeight			=m_pImg-&gt;GetHeight();
bmi.bmiHeader.biPlanes			= 1;
//if(	m_pImg-&gt;GetInfo()-&gt;biBitCount!=16)	
//{
//	bmi.bmiHeader.biBitCount	= 	m_pImg-&gt;GetInfo()-&gt;biBitCount;
//}
//else 
//{
//ASSERT((m_pImg-&gt;GetInfo())-&gt;bmiHeader-&gt;biBitCount == 24);
bmi.bmiHeader.biBitCount=24;
bmi.bmiHeader.biCompression		= BI_RGB;
if (bmi.bmiHeader.biSizeImage == 0)
	bmi.bmiHeader.biSizeImage =
	WidthBytes(bmi.bmiHeader.biWidth,bmi.bmiHeader.biBitCount) * bmi.bmiHeader.biHeight;
if(bmi.bmiHeader.biClrUsed == 0 &amp;&amp; bmi.bmiHeader.biBitCount &lt;16)
	bmi.bmiHeader.biClrUsed=DWORD(1 &lt;&lt;bmi.bmiHeader.biBitCount);
m_nNewSize=bmi.bmiHeader.biSizeImage;

if(m_hbmCanvasBitmap!=NULL)
{
	DeleteObject(m_hbmCanvasBitmap);
	m_hbmCanvasBitmap=NULL;
	m_pCanvasBits=NULL;
}
//	创建直接与DC相关联的位图
m_hbmCanvasBitmap=CreateDIBSection(m_hDC, &amp;bmi, DIB_RGB_COLORS,(void**)&amp;m_pCanvasBits, NULL, NULL);
</code></pre>

<p>// after CreateDIBSection
I found the error code is 8, no enough resource.</p>

<p>How can I avoid this error?
I pass width: 3500 height 2500
many thanks!</p>
","87234","","<p>There simply isn't enough memory to complete your command. You can't ""fix"" it as is, except to try and break some memory boundary.</p>

<p>Rather, you need to split whatever image your working on into manageable sizes, so they can be swapped in and out.</p>
"
"<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;

using namespace std;

struct Point
{
    int x;
    int y;
    Point(int x, int y) :
        x(x),
        y(y)
    {}
};

int main()
{
    vector&lt;Point&gt; points;
    points.push_back(Point(1, 2));
    points.push_back(Point(4, 6));

    vector&lt;int&gt; xs;

    for(vector&lt;Point&gt;::iterator it = points.begin();
        it != points.end();
        ++it)
    {
        xs.push_back(it-&gt;x);
    }

    copy(xs.begin(), xs.end(), ostream_iterator&lt;int&gt;(cout, "" ""));
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>I'm wondering how I would achieve the same result as the for loop above using an STL algorithm?  I've tried a few things using for_each, but wasn't able to get it to work.</p>
","87234","","<p>You wouldn't use <a href=""http://www.cplusplus.com/reference/algorithm/for%5Feach/"" rel=""nofollow""><code>std::for_each</code></a>, but rather <a href=""http://www.cplusplus.com/reference/algorithm/transform/"" rel=""nofollow""><code>std::transform</code></a> (you're transforming a point into a single number.)</p>

<p>For example:</p>

<pre><code>#include &lt;algorithm&gt; // transform resides here
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

struct Point
{
    int x;
    int y;

    Point(int x, int y) :
    x(x),
    y(y)
    {
    }
};

int point_to_int(const Point&amp; p)
{
    return p.x;
}

int main()
{
    std::vector&lt;Point&gt; points;
    points.push_back(Point(1, 2));
    points.push_back(Point(4, 6));

    std::vector&lt;int&gt; xs;
    std::transform(points.begin(), points.end(),
    	std::back_inserter(xs), point_to_int);

    std::copy(xs.begin(), xs.end(),
    	std::ostream_iterator&lt;int&gt;(std::cout, "" ""));

    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Because you know the size of the container you'll be transforming, you might get a slight performance improvement from the following. I also find it more readable:</p>

<pre><code>std::vector&lt;int&gt; xs;
xs.reserve(points.size());
std::transform(points.begin(), points.end(),
        std::back_inserter(xs), point_to_int);
</code></pre>

<p>And with <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/doc/html/lambda.html"" rel=""nofollow""><code>boost::lambda</code></a> along with <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/libs/bind/bind.html"" rel=""nofollow""><code>boost::bind</code></a>:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

#include &lt;boost/bind.hpp&gt;
#include &lt;boost/lambda/lambda.hpp&gt;

struct Point
{
    int x;
    int y;

    Point(int x, int y) :
    x(x),
    y(y)
    {
    }
};

int main()
{
    using namespace boost;

    std::vector&lt;Point&gt; points;
    points.push_back(Point(1, 2));
    points.push_back(Point(4, 6));

    std::vector&lt;int&gt; xs;
    xs.reserve(points.size());
    std::transform(points.begin(), points.end(),
    	std::back_inserter(xs), bind(&amp;Point::x, lambda::_1));

    std::copy(xs.begin(), xs.end(),
    	std::ostream_iterator&lt;int&gt;(std::cout, "" ""));

    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Removes the need to specify a function elsewhere. This keeps the code close to the calling site, and generally improves readability.</p>

<p>In C++0x, it will simply be:</p>

<pre><code>std::transform(points.begin(), points.end(),
	std::back_inserter(xs), [](const Point&amp; p){ return p.x; } );
</code></pre>

<p>(To the best of my knowledge, anyway)</p>
"
"<p>Where can I go to get information about the size of, say, <code>unsigned int</code> compiling under <code>gcc</code> for Mac OS X (both 32 and 64 bits)? In general I'd love to have a resource I can go to with a compiler/settings/platform/type and be able to look up how big that type will be. Does anyone know of such a thing?</p>

<p>Update: Thanks for all the responses. I was hoping to have something more along the lines of a static table somewhere instead of a piece of code I'd have to write and run on every machine.</p>
","87234","","<p>Generic method of sambowry's method (C++):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

template &lt;typename T&gt;
void print_sizeof(void)
{
    std::cout &lt;&lt; ""sizeof("" &lt;&lt;
        typeid(T).name() &lt;&lt; "") == "" &lt;&lt;
        sizeof(T) &lt;&lt; std::endl;
}

int main(void)
{
    print_sizeof&lt;short&gt;();
    print_sizeof&lt;unsigned int&gt;();
    print_sizeof&lt;long&gt;();
    print_sizeof&lt;long long&gt;();
    print_sizeof&lt;uint64_t&gt;();
}
</code></pre>

<p>Note the compiler isn't required to give you an actual string for name, but most do.</p>
"
"<p><strong>** Sorry for the confusion regarding numCars in the original post. I modified the code to be consistent with the original ****</strong></p>

<p>The following academic program is a simplified version of the original problem but it focuses on the issue that I have yet to resolve. There are 2 classes and a main method to this problem and the 2 classes consist of a Dealer class and a Car class. The Dealer class has a private Car* pointer that is initialized to a dynamic array in the Dealer's constructor. The error occurs in the main method when the Dealer's addCar method is invoked.
In the main method I intentionally pass the Dealer variable to the addCar(Dealer&amp; d) method to mimic the structure of the original application. The addCar method then invokes the Dealer's addCar(const Car&amp; car) method where the access violation occurs when I execute cars[numCars++]=car; Can you explain why cars[numCars++]=car results in an access violation</p>

<pre><code>/**********************************Dealer.h**************************/
#include &amp;lt;cstdlib&amp;gt;
#include ""Car.h""

using namespace std;

class Dealer
{
    public:
    	Dealer(int maxCars = DEFAULT_MAX_CARS)
</code></pre>

<p>:numCars(0)
{cars = new Car[maxCars];}</p>

<pre><code>    	~Dealer(){delete [] cars;}

    	int getTotalCars() const { return numCars;}

    	void addCar(const Car&amp; car)
    	{		
    		 cars[numCars++] = car; // Access Violation
    	}

    	Car* begin(){return cars;};

    	Car* end(){ return cars + numCars;}
</code></pre>

<p>setNumCars(int count){numCars = count;} </p>

<pre><code>    private:
    	static const int DEFAULT_MAX_CARS = 10;
    	Car* cars;
    	int numCars;
};

/**********************************Car.h**********************/
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;


class Car{
    public:

    	Car()
    		: year(0), make(""""), model("""")
    	{}

    	Car(int year, string make, string model)
    		: year(year), make(make), model(model)
    	{}		

    	string getMake() const {return make;}
    	void setMake(string make){this-&gt;make=make;}

    	string getModel() const {return model;}
    	void setModel(string model){this-&gt;model=model;}

    	int getYear() const {return year;}
    	void setYear(int year){this-&gt;year=year;}

    private:
    	int year;
    	string make;
    	string model;		
};


ostream&amp; operator&lt;&lt; (ostream&amp; out, const Car&amp; car)
{
    out &lt;&lt; car.getYear() &lt;&lt; "" "" &lt;&lt; car.getMake() &lt;&lt; "" "" &lt;&lt; car.getModel();
    return out;
}

/**********************************Main.cpp**********************/
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include ""Dealer.h""

using namespace std;

void addCar(Dealer&amp; d);

int main(int argc, char *argv[])
{
    Dealer d;

    addCar(d);	

    system(""PAUSE"");
    return EXIT_SUCCESS;
}

void addCar(Dealer&amp; d)
{
    d = Dealer();

    d.addCar(Car(2007, ""Honda"", ""Civic""));

    cout &lt;&lt; d.getTotalCars() &lt;&lt; "" total cars"" &lt;&lt; endl;
}
</code></pre>
","87234","","<p>You're not initializing <code>numCars</code> anywhere, you should set it to 0:</p>

<pre><code>Dealer(int maxCars = DEFAULT_MAX_CARS) :
numCars(0)
{
    cars = new Car[maxCars];
}
</code></pre>

<p>Do you have to use raw pointers? Why not wrap it up and use <code>std::vector</code> instead?</p>
"
"<p>Consider an example like this:</p>

<pre><code>if (flag)
  for (condition)
    do_something();
else
  for (condition)
    do_something_else();
</code></pre>

<p>If <code>flag</code> doesn't change inside the <code>for</code> loops, this should be semantically equivalent to:</p>

<pre><code>for (condition)
  if (flag)
    do_something();
  else
    do_something_else();
</code></pre>

<p>Only in the first case, the code might be much longer (e.g. if several <code>for</code> loops are used or if <code>do_something()</code> is a code block that is mostly identical to <code>do_something_else()</code>), while in the second case, the flag gets checked many times.</p>

<p>I'm curious whether current C++ compilers (most importantly, g++) would be able to optimize the second example to get rid of the repeated tests inside the <code>for</code> loop. If so, under what conditions is this possible?</p>
","87234","","<p>I'm sure if the compiler can determine that the flag will remain constant, it can do some shufflling:</p>

<pre><code>const bool flag = /* ... */;
for (..;..;..;)
{
    if (flag)
    {
        // ...
    }
    else
    {
        // ...
    }
}
</code></pre>

<p>If the <code>flag</code> is not <code>const</code>, the compiler cannot necessarily optimize the loop, because it can't be sure <code>flag</code> won't change. It can if it does static analysis, but not all compilers do, I think. <code>const</code> is the sure-fire way of telling the compiler the flag won't change, after that it's up to the compiler.</p>

<p>As usual, profile and find out if it's really a problem.</p>
"
"<p>Source: <a href=""http://milw0rm.org/papers/145"" rel=""nofollow"">http://milw0rm.org/papers/145</a></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
 char scode[]=""\x31\xc0\xb0\x01\x31\xdb\xcd\x80"";
 (*(void(*) ()) scode) ();
}
</code></pre>

<p>This papers is tutorial about shellcode on Linux platform, however it did not explain how the following statement ""<code>(*(void(*) ()) scode) ();</code>"" works. I'm using the book ""The C Language Programming Reference, 2ed by Brian.W.Kernighan, Dennis.M.Ritchie"" to lookup for an answer but found no answer. May someone can point to the right directions, maybe a website, another C reference book where I can find an answer. </p>
","87234","","<p>A <code>typedef</code> helps:</p>

<pre><code>// function that takes and returns nothing
typedef void(*generic_function)(void);

// cast to function
generic_function f = (generic_function)scode;

// call
(*f)();

// same thing written differently:
// call
f();
</code></pre>
"
"<p>I would like to use unmanaged C++.</p>

<p>The following code:</p>

<pre><code>#include""string.h""
std::string nodename[100]; 
</code></pre>

<p>Gives me the following compilation error:</p>

<blockquote>
  <p>'std' : is not a class or namespace
  name</p>
</blockquote>
","87234","","<p>Try something like:</p>

<pre><code>#include &lt;string&gt;

int main(void)
{
    std::string nodeName[100];
}
</code></pre>

<p>It's just <code>string</code>, not <code>string.h</code>.</p>
"
"<p>Here is an abstract of my code.  I'm trying to use glutSpecialFunc to tell glut to use my KeyPress function</p>

<pre><code>class Car : public WorldObject
{
public:
 void KeyPress(int key, int x, int y)
 {
 }

 Car()
 {
  glutSpecialFunc(&amp;Car::KeyPress); // C2664 error
 }
}
</code></pre>

<p>The error message I get is:</p>

<pre><code>Error 1 error C2664: 'glutSpecialFunc' : cannot convert parameter 1 from 'void (__thiscall Car::* )(int,int,int)' to 'void (__cdecl *)(int,int,int)' c:\users\thorgeir\desktop\programmingproject1\quickness\quickness\car.cpp 18 Quickness
</code></pre>
","87234","","<p>Your function is a member of a class. When you do something like <code>Car c; c.drive()</code>, that <code>drive()</code> function needs a car to work with. That is the <code>this</code> pointer. So glut can't call that function if it doesn't have a car to work on, it's expecting a free function.</p>

<p>You could make your function <code>static</code>, which would mean the function does not operate on a car. glut will then be able to call it, however I assume you want to manipulate a car. The solution is to make the function pass it's call onto an object, like this:</p>

<pre><code>void key_press(int key, int x, int y)
{
    activeCar-&gt;KeyPress(key, x, y);
}
</code></pre>

<p>Where <code>activeCar</code> is some globally accessible pointer to car. You can do this with some sort of <code>CarManager</code> singleton.</p>

<p>CarManager keeps track of the active car being controlled, so when a key is pressed you can pass it on: <code>CarManager::reference().active_car().KeyPress(key, x, y)</code>.</p>

<p>A singleton is an object that has only one globally accessible instance. It is outside the scope of the answer, but you can Google for various resources on creating one. Look up Meyers Singleton for a simple singleton solution.</p>

<p>A different approach is to have a sort of InputManager singleton, and this manager will keep track of a list of objects it should notify of key presses. This can be done in a few ways, the easiest would be something like this:</p>

<pre><code>class InputListener;

class InputManager
{
public:
    // ...

    void register_listener(InputListener *listener)
    {
        _listeners.push_back(listener);
    }

    void unregister_listener(InputListener *listener)
    {
        _listeners.erase(std::find(_listeners.begin(), _listeners.end(), listener));
    }

   // ...

private:
    // types
    typedef std::vector&lt;InputListener*&gt; container;        

    // global KeyPress function, you can register this in the constructor
    // of InputManager, by calling glutSpecialFunc
    static void KeyPress(int key, int x, int y)
    {
        // singleton method to get a reference to the instance
        reference().handle_key_press(key, x, y);
    }

    void handle_key_press(int key, int x, int y) const
    {
        for (container::const_iterator iter = _listeners.begin();
             iter != _listenders.end(), ++iter)
        {
            iter-&gt;KeyPress(key, x, y);
        }
    }

    container _listeners;
};

class InputListener
{
public:
    // creation
    InputListener(void)
    {
        // automatically add to manager
        InputManager::reference().register_listener(this);
    }

    virtual ~InputListener(void)
    {
        // unregister
        InputManager::reference().unregister_listener(this);
    }

    // this will be implemented to handle input
    virtual void KeyPress(int key, int x, int y) = 0;
};

class Car : public InputListener
{
    // implement input handler
    void KeyPress(int key, int x, int y)
    {
        // ...
    }
};
</code></pre>

<p>Of course feel free to ask more questions if this doesn't make sense.</p>
"
"<p>I'm having a lot of trouble getting my priority queue to recognize which parameter it should sort by. I've overloaded the less than operator in my custom class but it doesn't seem to use it. Here's the relevant code:</p>

<p>Node.h</p>

<pre><code>class Node
{   
public:
    Node(...);
    ~Node();
    bool operator&lt;(Node &amp;aNode);
...
}
</code></pre>

<p>Node.cpp</p>

<pre><code>#include ""Node.h""
bool Node::operator&lt;(Node &amp;aNode)
{
    return (this-&gt;getTotalCost() &lt; aNode.getTotalCost());
}
</code></pre>

<p>getTotalCost() returns an int</p>

<p>main.cpp</p>

<pre><code>priority_queue&lt;Node*, vector&lt;Node*&gt;,less&lt;vector&lt;Node*&gt;::value_type&gt; &gt; nodesToCheck;
</code></pre>

<p>What am I missing and/or doing wrong?</p>
","87234","","<p>You need to make your parameter <code>const</code>, because as of now you're giving it a non-cost reference, which means you might modify the object you're comparing with. (Which you aren't, and probably shouldn't).</p>

<p>You're not being const-correct. Your <code>operator&lt;</code> doesn't make modifications to the Node, so the function should be const:</p>

<pre><code>bool operator&lt;(const Node &amp;aNode) const;
</code></pre>

<p>After that, if you have trouble calling the <code>getTotalCost()</code> function, it's likely that it is not const as well. Mark it as const if it's not already:</p>

<pre><code>int getTotalCost(void) const;
</code></pre>

<p>Your code is now (more) const-correct.</p>

<p>On a side note, binary operators are usually implemented outside the class:</p>

<pre><code>class Node
{
public:
    // ...

    int getTotalCost(void) const;

    // ...
};

bool operator&lt;(const Node&amp; lhs, const Node&amp; rhs)
{
    return lhs.getTotalCost() &lt; rhs.getTotalCost();
}
</code></pre>
"
"<p>I would prefer if these problems found are more oriented to c++...</p>
","87234","","<p>You could pick up the book <a href=""http://rads.stackoverflow.com/amzn/click/193184108X"" rel=""nofollow"">AI Techniques for Game Programming</a>, it walks you through many AI programs. I don't have any other AI books so I can't compare this to anything, but it's well-written and understandable.</p>
"
"<p>How to use the <a href=""http://en.wikipedia.org/wiki/Windows_API"">Windows API</a> in <a href=""http://en.wikipedia.org/wiki/MinGW"">MinGW</a>?</p>
","87234","","<p><a href=""http://osix.net/modules/article/?id=670"">This</a> seems to be a good resource to take a look at.</p>
"
"<p>I have sets S1 = {s11,s12,s13), S2 = {s21,s22,s23) and so on till SN.I need to generate all the permutations consisting elements of S1,S2..SN.. such that there is only 1 element from each of the sets.</p>

<p>For eg: </p>

<pre><code>S1 = {a,b,c}
S2 = {d,e,f}
S3 = {g,h,i}
</code></pre>

<p>My permuations would be:</p>

<pre><code>{a,d,g}, {a,d,h}, {a,d,i}, {a,e,g}, {a,e,h}....
</code></pre>

<p>How would I go about doing it? (I could randomly go about picking up 1 from each and merging them, but that is even in my knowledge a bad idea).</p>

<p>For the sake of generality assume that there are 'n' elements in each set. I am looking at implementing it in C. <em>Please note that 'N' and 'n' is not fixed.</em></p>
","87234","","<p>If they are in a container, just iterate through each:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int set1[] = {1, 2, 3};
    int set2[] = {4, 5, 6};
    int set3[] = {7, 8, 9};

    for (unsigned i = 0; i &lt; 3; ++i)
    {
        for (unsigned j = 0; j &lt; 3; ++j)
        {
            for (unsigned k = 0; k &lt; 3; ++k)
            {
                printf(""(%d, %d, %d)"", set1[i], set2[j], set3[k]);
            }
        }
    }

    return 0;
}
</code></pre>
"
"<p>We are designing a p2p applications using c++ which transmits voice to other peer using UDP. </p>

<p>We are <strong>capturing a mic signal in a buffer</strong> in the thread which captures voice for one second in the <code>while</code> loop. For <strong>every second voice captured</strong> in buffer it <strong>splits it into packets</strong> and <strong>sends to the other peer</strong>. Now I need a proper data structure at the destination which is copes real time transmission. Same data structure I am going to use for screen capturing.  Here are two approaches using queue I thought of</p>

<ul>
<li><p>Implementing a queue using a linked list which maintains a queue of <code>OneSecVoice</code> objects or <code>Image</code> object in case of image. </p></li>
<li><p>Implementing a queue using static array of <code>OneSecVoice</code> or <code>Image</code> objects</p></li>
</ul>

<p><code>OneSecVoice/Image</code> objects will contain a <strong>total number of packets</strong>, packets <strong>buffer</strong> for that particular <code>Image/OneSecVoice</code>.</p>

<p>As its a real time one thread will <strong>continuously scan for queue</strong> and <strong>take out latest complete</strong> <code>Image/OneSecVoice</code> by popping the <code>Image/OneSecVoice</code> from queue. </p>

<p>So which  to chose <strong>Implementing a queue using a linked list</strong> or <strong>Implementing a queue using static array</strong>. </p>

<p>Me and my friend are having fight over this so we decided to post here.</p>
","87234","","<p>Don't implement either. Use pre-existing implementations in the standard library:</p>

<pre><code>std::queue&lt;T, std::list&lt;T&gt; &gt;
std::queue&lt;T, std::deque&lt;T&gt; &gt; // uses deque by default, by the way
</code></pre>

<p>You can typedef these to make swapping the two very easy:</p>

<pre><code>template &lt;typename T&gt;
struct queue_list
{
    typedef typename std::queue&lt;T, std::list&lt;T&gt; &gt; value_type;
}

template &lt;typename T&gt;
struct queue_array
{
    typedef typename std::queue&lt;T, std::deque&lt;T&gt; &gt; value_type;
}

typedef queue_list&lt;the_type&gt;::value_type container_type; // use one
typedef queue_array&lt;the_type&gt;::value_type container_type;
</code></pre>

<p>Now profile and find which is better. Likely the array will have better performance, for cache. </p>

<p>You can use <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/libs/pool/doc/index.html"" rel=""nofollow"">boost's pool allocator</a> to try to get the benefit of a list's quick insertion and removal, along with an array's cache performance:</p>

<pre><code>typedef typename std::queue&lt;T, std::list&lt;T, boost::pool_allocator&lt;T&gt; &gt; &gt; value_type;
</code></pre>

<p>Another structure to try is <a href=""http://www.boost.org/doc/libs/1%5F37%5F0/libs/circular%5Fbuffer/doc/circular%5Fbuffer.html"" rel=""nofollow""><code>boost::circular_buffer</code></a>, as <a href=""http://stackoverflow.com/questions/1551333/data-structures-for-real-time-applications/1551426#1551426"">suggested by fnieto</a>:</p>

<pre><code>template &lt;typename T&gt;
struct queue_buffer
{
    typedef typename std::queue&lt;T, boost::circular_buffer&lt;T&gt; &gt; value_type;
}
</code></pre>
"
"<p>can power function be used to calulate the power of very large values like pow(200,200).
also can it be used for long long int values ... pow(long long int,long long int).</p>

<p>i am getting this error
/sources/tested.cpp: In function 'int main()':</p>

<p>/sources/tested.cpp:16: error: call of overloaded 'pow(long long int&amp;, long long int&amp;)' is ambiguous</p>

<p>/usr/include/bits/mathcalls.h:154: note: candidates are: double pow(double, double)</p>

<p>/usr/lib/gcc/i486-linux/4.0.1/../../../../include/c++/4.0.1/cmath:360: 
note:                 long double std::pow(long double, int)</p>

<p>/usr/lib/gcc/i486-linux/4.0.1/../../../../include/c++/4.0.1/cmath:356: note:                 float std::pow(float, int)</p>

<p>/usr/lib/gcc/i486-linux/4.0.1/../../../../include/c++/4.0.1/cmath:352: note:                 double std::pow(double, int)
/usr/lib/gcc/i486-linux/4.0.1/../../../../include/c++/4.0.1/cmath:348: note:                 long double std::pow(long double, long double)</p>

<p>/usr/lib/gcc/i486-linux/4.0.1/../../../../include/c++/4.0.1/cmath:344: note:                 float std::pow(float, float)</p>
","87234","","<p>If you're looking to do arbitrary precision math, you'll need to get a library for it. Likely, your platform doesn't have data types large enough to do so natively. Check out <a href=""http://gmplib.org/"" rel=""nofollow"">GNU MP</a>.</p>
"
"<p>I generally prefer constness, but recently came across a conundrum with const iterators that <strike>shakes my const attitude</strike> annoys me about them:</p>

<pre><code>MyList::const_iterator find( const MyList &amp; list, int identifier )
{
    // do some stuff to find identifier
    return retConstItor; // has to be const_iterator because list is const
}
</code></pre>

<p>The idea that I'm trying to express here, of course, is that the passed in list cannot/willnot be changed, but once I make the list reference const I then have to use 'const_iterator's which then prevent me from <strike>doing anything with</strike> modifing the result (which makes sense). </p>

<p>Is the solution, then, to give up on making the passed in container reference const, or am I missing another possibility?</p>

<p>This has always been my secret reservation about const: That even if you use it correctly, it can create issues that it shouldn't where there is no good/clean solution, though I recognize that this is more specifically an issue between const and the iterator concept.</p>

<p>Edit: I am very aware of why you cannot and should not return a non-const iterator for a const container. My issue is that while I want a compile-time check for my container which is passed in by reference, I still want to find a way to pass back the position of something, and use it to modify the non-const version of the list. As mentioned in one of the answers it's possible to extract this concept of position via ""advance"", but messy/inefficient. </p>
","87234","","<p>If you're changing the data directed by the iterator, you're changing the list.</p>

<blockquote>
  <p>The idea that I'm trying to express here, of course, is that the passed in list cannot/willnot be changed, but once I make the list reference const I then have to use 'cons_iterator's which then prevent me from doing anything with the result.</p>
</blockquote>

<p>What is ""dong anything""? Modifying the data? That's changing the list, which is contradictory to your original intentions. If a list is const, it (and ""it"" includes its data) is constant.</p>

<p>If your function were to return a non-const iterator, it would create a way of modifying the list, hence the list wouldn't be const.</p>
"
"<p>[<em>Original title referred to 'sizeof function'.</em>]</p>

<p>I tried these and they all worked:</p>

<pre>
char *p;

printf(""Size of *p is %d\n"",sizeof(*p));  //result =1
printf(""Size of  p is %d\n"",sizeof( p));  //result =4
printf(""Size of  p is %d\n"",sizeof(&p));  //result =4
</pre>

<p>I wonder why the first printf is 1, the 2nd and 3rd is 4?
So what arguments can sizeof can actually take?</p>
","87234","","<p>It takes a type.</p>

<p><code>sizeof(char)</code> is always one. The variable <code>p</code> itself is a pointer, and on your platform that has a size of 4. Then you do <code>&amp;p</code>, or a pointer to a pointer, which also has a size of 4.</p>

<p>On most modern desktop systems, a 32-bit architecture will have 4 byte pointers, while a 64-bit architecture will have 8 byte pointers.</p>

<p><code>sizeof</code> itself is a keyword, resolved at compile-time, not a function. In C99, arrays can be variable length, and sizeof will wait until run-time to resolve this size.</p>
"
"<p>How can I overload the <code>operator &lt;&lt;</code>.
The purpose of the overloaded operator is to do:
<code>cout &lt;&lt; ptr-&gt;info</code> and not receive the memory address but Display the maker year and model of that node's info section.</p>

<p>Example:</p>

<pre><code>template &lt;class DataType&gt;
struct Node {
DataType info;
Node&lt;DataType&gt; *next;
};
</code></pre>

<p>In each info section of the Node there will be a struct like this:</p>

<pre><code>struct Car {
    string maker;
    string year;
    string model;
}
</code></pre>

<p>So far I have this but it doesn't seems to work:</p>

<pre><code>friend ostream &amp;operator &lt;&lt; ( ostream &amp;output, Node&lt;DataType&gt; &amp;rlist ) { //Overloaded &lt;&lt;
    output &lt;&lt; rlist-&gt;info.make &lt;&lt; endl;
    output &lt;&lt; rlist-&gt;info.year &lt;&lt; endl;
    output &lt;&lt; rlist-&gt;info.price &lt;&lt; endl; 

    return output;
}
</code></pre>

<p>When I compile with g++ I get this error:</p>

<pre><code>LinkedList.cpp: In member function ‘void LinkedList&lt;DataType&gt;::EscribaUltimo() [with DataType = CarType]’:
main.cpp:37:   instantiated from here
LinkedList.cpp:15: error: no match for ‘operator&lt;&lt;’ in ‘std::cout &lt;&lt; ptr-&gt;Node&lt;CarType&gt;::info’
</code></pre>
","87234","","<p>Although I'm a bit confused, because you're actual main code is missing. I'm going to assume you have a node, from traversing the link, and now want to print it:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std; // not recommended, but useful
                     // in snippets

// T is usually used, but this is of course up to you
template &lt;class T&gt; 
struct Node
{
    typedef T value_type; // a usual typedef

    value_type info;
    Node&lt;value_type&gt; *next;
};

struct Car
{
    string maker;
    string year;
    string model;
}; // you had a missing ;, probably copy-paste error

// this creates a node. normally you'd want this to be
// wrapped into a list class (more on this later)
template &lt;typename T&gt;
Node&lt;T&gt; *createNode(const T&amp; info = T())
{
    // allocate node
    Node&lt;T&gt; *result = new Node&lt;T&gt;;
    result-&gt;info = info;
    result-&gt;next = 0; // no next

    return result; // returning a pointer means
                   // whoever gets this is
                   // responsible for deleting it!
}

// this is the output function for a node
template &lt;typename T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; sink, const Node&lt;T&gt;&amp; node)
{
    // note that we cannot assume what node contains!
    // rather, stream the info attached to the node
    // to the ostream:
    sink &lt;&lt; node.info;

    return sink;
}

// this is the output function for a car
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; sink, const Car&amp; car)
{
    // print out car info
    sink &lt;&lt; ""Make: "" &lt;&lt; car.maker &lt;&lt;
            ""\nYear: "" &lt;&lt; car.year &lt;&lt;
            ""\nModel: "" &lt;&lt; car.model &lt;&lt; std::endl;

    return sink;
}

int main(void)
{
    // a car list
    typedef Node&lt;Car&gt; CarList;

    // a couple cars
    Car car1 = {""Dodge"", ""2001"", ""Stratus""};
    Car car2 = {""GMan's Awesome Car Company"", ""The future"", ""The best""};

    CarList *head = createNode(car1); // create the first node
    head-&gt;next = createNode(car2);

    // now traverse the list
    CarList *iter = head;
    for (; iter != 0; iter = iter-&gt;next)
    {
        // output, dereference iterator to get the actual node
        std::cout &lt;&lt; ""Car: "" &lt;&lt; *iter &lt;&lt; std::endl;
    }

    // dont forget to delete!
    iter = head;
    while (iter)
    {
        // store next
        CarList *next = iter-&gt;next;

        // delete and move on
        delete iter;
        iter = next;
    }
}
</code></pre>

<p>Now, if you don't have to create your own linked list, use the standard link list instead, it simplifies your task immensely:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;list&gt;
#include &lt;string&gt;

using namespace std;

struct Car
{
    string maker;
    string year;
    string model;
};


// this is the output function for a car
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; sink, const Car&amp; car)
{
    // print out car info
    sink &lt;&lt; ""Make: "" &lt;&lt; car.maker &lt;&lt;
            ""\nYear: "" &lt;&lt; car.year &lt;&lt;
            ""\nModel: "" &lt;&lt; car.model &lt;&lt; std::endl;

    return sink;
}

int main(void)
{
    // a car list
    typedef std::list&lt;Car&gt; CarList;

    // a couple cars
    Car car1 = {""Dodge"", ""2001"", ""Stratus""};
    Car car2 = {""GMan's Awesome Car Company"", ""The future"", ""The best""};

    CarList cars;
    cars.push_back(car1);
    cars.push_back(car2);

    // now traverse the list (copy to ostream)
    std::copy(cars.begin(), cars.end(),
             std::ostream_iterator&lt;Car&gt;(std::cout,""\n""));

    // delete done automatically in destructor
}
</code></pre>

<p>Hope this helps.</p>
"
"<p>I'm making a template wrapper around std::set. Why do I get error for Begin() function declaration?</p>

<pre><code>template &lt;class T&gt;
class CSafeSet
{
    public:
        CSafeSet();
        ~CSafeSet();

        std::set&lt;T&gt;::iterator Begin();

    private:
        std::set&lt;T&gt; _Set;
};
</code></pre>

<p>error: type ‘std::set, std::allocator&lt;_CharT> >’ is not derived from type ‘CSafeSet’</p>
","87234","","<p>Try <a href=""http://pages.cs.wisc.edu/~driscoll/typename.html"">typename</a>:</p>

<pre><code>template &lt;class T&gt;
class CSafeSet
{
    public:
        CSafeSet();
        ~CSafeSet();

        typename std::set&lt;T&gt;::iterator Begin();

    private:
        std::set&lt;T&gt; _Set;
};
</code></pre>

<p>You need typename there because it is dependent on the template T. More information in the link above the code. Lot's of this stuff is made easier if you use typedef's:</p>

<pre><code>template &lt;class T&gt;
class CSafeSet
{
    public:
        typedef T value_type;
        typedef std::set&lt;value_type&gt; container_type;
        typedef typename container_type::iterator iterator_type;
        typedef typename container_type::const_iterator const_iterator_type;

        CSafeSet();
        ~CSafeSet();

        iterator_type Begin();

    private:
        container_type _Set;
};
</code></pre>

<p>On a side note, if you want to be complete you need to allow CSafeSet to do the same thing as a <a href=""http://www.cplusplus.com/reference/stl/set/"">set could</a>, which means using a custom comparer and allocator:</p>

<pre><code>template &lt;class T, class Compare = std::less&lt;T&gt;, class Allocator = std::allocator&lt;T&gt; &gt;
class CSafeSet
{
    public:
        typedef T value_type;
        typedef Compare compare_type;
        typedef Allocator allocator_type;

        typedef std::set&lt;value_type, compare_type, allocator_type&gt; container_type;
        typedef typename container_type::iterator iterator_type;
        typedef typename container_type::const_iterator const_iterator_type;

        // ...
}
</code></pre>

<p>And a last bit of advice, if you are going to create a wrapper around a class, try to follow the same naming conventions as where the class came from. That is, your <code>Begin()</code> should probably be <code>begin()</code> (And personally I think C before a class name is strange but that one is up to you :])</p>
"
"<p>Please I have this code which gives me many errors:</p>

<pre><code>//Neuron.h File
#ifndef Neuron_h
#define Neuron_h
#include ""vector""
class Neuron
{
private:
 vector&lt;double&gt;lstWeights;
public:
 vector&lt;double&gt; GetWeight();

};
#endif

//Neuron.cpp File
#include ""Neuron.h""
vector&lt;double&gt; Neuron::GetWeight()
{
 return lstWeights;
}
</code></pre>

<p>Could any one tell me what is wrong with it?</p>
","87234","","<p>It's:</p>

<pre><code>#include &lt;vector&gt;
</code></pre>

<p>You use angle-brackets because it's part of the <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow"">standard library</a>, """" with just make the compiler look in other directories first, which is unnecessarily slow. And it is located in the namespace <code>std</code>:</p>

<pre><code>std::vector&lt;double&gt;
</code></pre>

<p>You need to qualify your vector in the correct namespace:</p>

<pre><code>class Neuron
{
private:
 std::vector&lt;double&gt;lstWeights;
public:
 std::vector&lt;double&gt; GetWeight();

};

std::vector&lt;double&gt; Neuron::GetWeight()
</code></pre>

<p>Made simpler with typedef's:</p>

<pre><code>class Neuron
{
public:
    typedef std::vector&lt;double&gt; container_type;

    const container_type&amp; GetWeight(); // return by reference to avoid
                                       // unnecessary copying

private: // most agree private should be at bottom
    container_type lstWeights;
};

const Neuron::container_type&amp; Neuron::GetWeight()
{
 return lstWeights;
}
</code></pre>

<p>Also, don't forget to be <a href=""http://www.parashift.com/c++-faq-lite/const-correctness.html"" rel=""nofollow"">const-correct</a>:</p>

<pre><code>const container_type&amp; GetWeight() const; // const because GetWeight does
                                         // not modify the class
</code></pre>
"
"<p>I'd like to have a private static constant for a class (in this case a shape-factory).
I'd like to have something of the sort.</p>

<pre><code>class A {
   private:
      static const string RECTANGLE = ""rectangle"";
}
</code></pre>

<p>Unfortunately I get all sorts of error from the C++ (g++) compiler, such as:</p>

<blockquote>
  <p>ISO C++ forbids initialization of
  member ‘RECTANGLE’ </p>
  
  <p>invalid in-class initialization of static data member of non-integral type ‘std::string’ </p>
  
  <p>error: making ‘RECTANGLE’ static</p>
</blockquote>

<p>This tells me that this sort of member design is not compliant with the standard. How do you have a private literal constant (or perhaps public) without having to use a #define directive (I want to avoid the uglyness of data globality!)</p>

<p>Any help is appreciated. Thanks.</p>
","87234","","<p>This is just extra information, but if you really want the string in a header file, try something like:</p>

<pre><code>class foo
{
public:
    static const std::string&amp; RECTANGLE(void)
    {
        static const std::string str = ""rectangle"";

        return str;
    }
};
</code></pre>

<p>Though I doubt that's recommended. </p>
"
"<p>I need to code a class that recieves a collection with any number of elements of any 'primitive' type. I also need to be able to know the type of each member (or at least the size of the type).
The purpose of this class is to serialize the elements to store them in a file in fixed length registers.</p>

<p>Is this posible?</p>

<p>I know that C++ is statically typed and that there's no common parent regarding inheritance (such as Object in Java). So, I cannot recieve an array or a vector, as all the elements should have the same type.</p>

<p>I also thought of an array of pointers, but in such way I wouldn't know the elements type or its size.</p>

<p>Any ideas?</p>

<p>PS: couldn't find similar question, but if it exists, please redirectme.</p>
","87234","","<p>If you're ok with boost, either use Boost.Any like <a href=""http://stackoverflow.com/questions/1564240/polymorph-collection-in-c/1564285#1564285"">Jim stated</a>, or go all the way and just use their <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/libs/serialization/doc/index.html"" rel=""nofollow"">serialization library</a>.</p>
"
"<p>What is the proper way to convert a <code>FILETIME</code> structure into <code>__int64</code>? Can you please tell me?</p>
","87234","","<p>I don't think you're suppose to: ""Do not cast a pointer to a <code>FILETIME</code> structure to either a <code>ULARGE_INTEGER*</code> or <code>__int64*</code> value because it can cause alignment faults on 64-bit Windows.""</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/ms724284%28VS.85%29.aspx"">Source.</a></p>

<p>If you really wanted it would be something like:</p>

<pre><code>__int64 to_int64(FILETIME ft)
{
    return static_cast&lt;__int64&gt;(ft.dwHighDateTime) &lt;&lt; 32 | ft.dwLowDateTime;
}

FILETIME ft = // ...
__int64 t = to_int64(ft);
</code></pre>

<p>But something like:</p>

<pre><code>FILETIME ft = // ...
__int64 t = *reinterpet_cast&lt;__int64*&gt;(&amp;ft);
</code></pre>

<p>Is bad.</p>
"
"<p>Given the following function templates:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;utility&gt;

struct Base { };
struct Derived : Base { };

// #1
template &lt;typename T1, typename T2&gt;
void f(const T1&amp; a, const T2&amp; b)
{
};

// #2
template &lt;typename T1, typename T2&gt;
void f(const std::vector&lt;std::pair&lt;T1, T2&gt; &gt;&amp; v, Base* p)
{
};
</code></pre>

<p>Why is it that the following code always invokes overload #1 instead of overload #2?</p>

<pre><code>int main()
{
    std::vector&lt;std::pair&lt;int, int&gt; &gt; v;
    Derived derived;

    f(100, 200);  // clearly calls overload #1
    f(v, &amp;derived);         // always calls overload #1

    return 0;
}
</code></pre>

<p>Given that the second parameter of <code>f</code> is a derived type of <code>Base</code>, I was hoping that the compiler would choose overload #2 as it is a better match than the generic type in overload #1.</p>

<p>Are there any techniques that I could use to rewrite these functions so that the user can write code as displayed in the <code>main</code> function (i.e., leveraging compiler-deduction of argument types)?</p>
","87234","","<blockquote>
  <p>Given that the second parameter of f is a derived type of Base</p>
</blockquote>

<p>It's convertible to such, but it is a Derived*. The first template function requires no conversions, and the second requires one, therefore it chooses the first.</p>

<p>This chooses the second:</p>

<pre><code>f(v, static_cast&lt;Base*&gt;(&amp;derived));
</code></pre>

<p>On a side note, <code>main</code> returns an <code>int</code>.</p>
"
"<p>When writing a header library (like <a href=""http://www.boost.org/"" rel=""nofollow"">Boost</a>), can one define free-floating (non-method) functions without (1) bloating the generated binary and (2) incurring ""unused"" warnings?</p>

<p>When I define a function in a header that's included by multiple source files which in turn is linked into the same binary, the linker complains about redefinitions. One way around this is to make the functions static, but this reproduces the code in each translation unit (BTW, can linkers safely dereplicate these?). Furthermore, this triggers compiler warnings about the function being unused.</p>

<p>I was trying to look for an example of a free-floating function in Boost, but I couldn't find one. Is the trick to contain everything in a class (or template)?</p>
","87234","","<p>You can use the <code>inline</code> keyword:</p>

<pre><code>inline void wont_give_linker_errors(void)
{
    // ...
}
</code></pre>
"
"<p>After having some problems with these two linker errors on <a href=""http://stackoverflow.com/questions/1549093/lnk2019-lnk1120-errors-when-splitting-my-code-in-multiple-files"">SO</a>, I have them again. However, this time the source seems to lie at another point.</p>

<p>compiler error shows that it cannot find a function with signature <code>""""public: unsigned int __thiscall MyClass::myFunction&lt;unsigned int&gt;(int)const ""</code>.</p>

<p>However, moving the contents of <code>myClass.cpp</code> to <code>main.cpp</code> works. Don't know why (all other content of <code>myClass.cpp</code> doesn't have this problem. (other functions are not templated).</p>

<p><code>myClass.h</code></p>

<pre><code>#ifndef X
#define X
class MyClass {
public:
    template&lt;class T&gt;
    T myFunction (int someArgument) const;
};
#endif
</code></pre>

<p><code>myClass.cpp</code></p>

<pre><code>#include ""myClass.h""
template&lt;class T&gt;
T MyClass::myFunction (int someArgument) const {
    return T();
}
</code></pre>

<p><code>main.cpp</code></p>

<pre><code>#include ""myClass.h""
int main () {
    MyClass a();
    a.myFunction&lt;unsigned int&gt;(42);
    return 0;
}
</code></pre>

<p>What can I do to fix this problem?</p>
","87234","","<p>Because in main.cpp, the compiler can find the definition of the template function.</p>

<p>Templates cannot be compiled, the compiler needs to be able to see the definition of the file, and it's can't see across files.</p>

<p>Either include myClass.cpp in myClass.h, or just define everything in the header.</p>
"
"<p>From this thread</p>

<p><a href=""http://www.codeguru.com/forum/showthread.php?p=1863547"" rel=""nofollow"">http://www.codeguru.com/forum/showthread.php?p=1863547</a></p>

<p>It seems this cannot be done with:</p>

<pre><code>#pragma comment(linker, ""/out:mycool.exe"")
</code></pre>

<p>Is there some simple way this can be done without having to use project settings, make files etc?</p>

<p>Added:</p>

<p>Why do I want to do this.
Well this gets into another subject which is probably my next question - working with the IDE.
I have to provide <em>many</em> examples in one project. They are simple single files that demonstrate different ways of doing things and each one should really be a different executable EXample1.exe, Example2.exe.</p>

<p>I only want to paste the source code or hand someone a SINGLE file with everything needed to make the example executable (on a web forum for example. I do not want to attach a 3.6MB project folder just to get a different executable name!</p>
","87234","","<p>Compiling transcends source code. Source code only exists, and something has to take it and make something of it. Anything you do in source code is really just going to be a directive to the compiler. You might as well use project settings. This stuff isn't standard, because the standard only covers behavior and definitions of source code, not compilers.</p>

<p>g++ takes the output file as a parameter: <code>g++ -o myexe.exe main.cpp</code>. What should it do if it comes across a ""output should be this!"" directive in the source code?</p>

<p>Same with cl (Visual Studio), it passes the output setting into the command line.</p>

<p>Not to say it's impossible, but I doubt it's worth it to try and come up with a way to do it, let alone make it standard.</p>
"
"<p>I found the below code through Google. It almost does what I want it to do, except it doesn't provide a way to indicate the precision like '%.*f' does in C-type format strings. Also, it doesn't provide anything further than 5 decimal places. Am I going to have to stick with C strings and snprintf?</p>

<pre><code>#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;

template &lt;class T&gt;
std::string to_string(T t, std::ios_base &amp; (*f)(std::ios_base&amp;))
{
  std::ostringstream oss;
  oss &lt;&lt; f &lt;&lt; t;
  return oss.str();
}

int main()
{
  std::cout&lt;&lt;to_string&lt;double&gt;(3.1415926535897931, std::dec)&lt;&lt;std::endl;
  return 0;
}
</code></pre>
","87234","","<p>C++ wouldn't be successful if it couldn't do something C could.</p>

<p>You need to check out <a href=""http://www.cplusplus.com/reference/iostream/manipulators/"" rel=""nofollow"">manipulators</a>.</p>

<p>If you want C-style formatting (which I do prefer, it's more terse), check out <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/libs/format/index.html"" rel=""nofollow"">Boost.Format</a>.</p>
"
"<p>I have a doubt regarding how can we check whether a pointer passed to a function is allocated with memory or not in C ?</p>

<p>I have wriiten my own function in C which accepts a character pointer - <strong>buf</strong> [pointer to a buffer] and size - <strong>buf_siz</strong> [buffer size]. Actually before calling this function user has to create a buffer and allocate it memory of buf_siz. </p>

<p>Since there is a chance that user might forget to do memory allocation and simply pass the pointer to my function I want to check this. So is there any way I can check in my function to see if the pointer passed is really allocated with buf_siz amount of memory .. ??</p>

<p><strong><em>EDIT1:</strong> It seems there is no standard library to check it .. but is there any dirty hack to check it .. ??</em></p>

<p><strong><em>EDIT2:</strong> I do know that my function will be used by a good C programmer ... But I want to know whether can we check or not .. if we can I would like to hear to it ..</em></p>

<p><strong>Conclusion: So it is impossible to check if a particular pointer is allocated with memory or not within a function</strong></p>
","87234","","<p>You cannot check, except some implementation specific hacks.</p>

<p>Pointers have no information with them other than where they point. The best you can do is say ""I know how this particular compiler version allocates memory, so I'll dereference memory, move the pointer back 4 bytes, check the size, makes sure it matches..."" and so on. You cannot do it in a standard fashion, since memory allocation is implementation defined. Not to mention they might have not dynamically allocated it at all.</p>

<p>You just have to assume your client knows how to program in C. The only un-solution I can think of would be to allocate the memory yourself and return it, but that's hardly a small change. (It's a larger design change.)</p>
"
"<p>I am experimenting with my first cross-platform application that needs to run on Linux Redhat 5.3 and also on Windows XP/Vista/7.</p>

<p>As some OSes will run x86 or 64, I am wondering about what data types to declare.</p>

<p>I don't want to use any libraries to achieve cross-platform portability; I would like to experiment by myself first.</p>

<p>If I need a int, should I declare int32 or int64 or just int?</p>

<p>If I was to compile on a 64-bit OS and use an int32 then the would the data be truncated to a 32 bit value so I would lose some data?</p>

<p>I am wondering how I should declare if I run on different OSes with different architectures.</p>

<p>Just a final question: Are there any good tutorials on a website that can anyone recommend on cross-platform issues?</p>

<p>Many thanks,</p>
","87234","","<p>If you need an integer, type <code>int</code>, and so on. If you need to make assumptions about what a data type can hold (such as, you require that it has 32 bits), check out <a href=""http://en.wikipedia.org/wiki/Stdint.h"" rel=""nofollow"">stdint.h</a></p>

<p>As long as you make sure you aren't making assumptions about what a data type can hold, you'll be in good shape. The moment you do something like assume a data type will hold n bits, you're into implementation defined land, where you need to make sure it works on both platforms.</p>
"
"<p>I want to convert a C-style string into a byte-vector.
A working solution would be converting each character manually and pushing it on the vector. However, I'm not satisfied with this solution and want to find a more elegant way.</p>

<p>One of my attempts was the following:</p>

<pre><code>std::vector&lt;byte&gt; myVector;
&amp;myVector[0] = (byte)""MyString"";
</code></pre>

<p>which bugs and gets me an</p>

<blockquote>
  <p>error C2106: '=': left operand must be l-value </p>
</blockquote>

<p>What is the correct way to do this?</p>
","87234","","<p>The most basic thing would be something like:</p>

<pre><code>const char *cstr = ""bla""
std::vector&lt;char&gt; vec(cstr, cstr + strlen(cstr));
</code></pre>

<p>Of course, don't calculate the length if you know it.</p>

<p>The more common solution is to use the <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""nofollow""><code>std::string</code></a> class:</p>

<pre><code>const char *cstr;
std::string str = cstr;
</code></pre>
"
"<p>How I can have variable number of parameters in my function in C++.</p>

<p>Analog in C#:</p>

<pre><code>public void Foo(params int[] a) {
    for (int i = 0; i &lt; a.Length; i++)
        Console.WriteLine(a[i]);
}

public void UseFoo() {
    Foo();
    Foo(1);
    Foo(1, 2);
}
</code></pre>

<p>Analog in Java:</p>

<pre><code>public void Foo(int... a) {
    for (int i = 0; i &lt; a.length; i++)
        System.out.println(a[i]);
}

public void UseFoo() {
    Foo();
    Foo(1);
    Foo(2);
}
</code></pre>
","87234","","<p>Aside from the other answers, if you're just trying to pass an array of integers, why not:</p>

<pre><code>void func(const std::vector&lt;int&gt;&amp; p)
{
    // ...
}

std::vector&lt;int&gt; params;
params.push_back(1);
params.push_back(2);
params.push_back(3);

func(params);
</code></pre>

<p>You can't call it in parameter, form, though. You'd have to use any of the variadic function listed in your answers. C++0x will allow variadic templates, which will make it type-safe, but for now it's basically memory and casting.</p>

<p>You could emulate some sort of variadic parameter->vector thing:</p>

<pre><code>// would also want to allow specifying the allocator, for completeness
template &lt;typename T&gt; 
std::vector&lt;T&gt; gen_vec(void)
{
    std::vector&lt;T&gt; result(0);
    return result;
}

template &lt;typename T&gt; 
std::vector&lt;T&gt; gen_vec(T a1)
{
    std::vector&lt;T&gt; result(1);

    result.push_back(a1);

    return result;
}

template &lt;typename T&gt; 
std::vector&lt;T&gt; gen_vec(T a1, T a2)
{
    std::vector&lt;T&gt; result(1);

    result.push_back(a1);
    result.push_back(a2);

    return result;
}

template &lt;typename T&gt; 
std::vector&lt;T&gt; gen_vec(T a1, T a2, T a3)
{
    std::vector&lt;T&gt; result(1);

    result.push_back(a1);
    result.push_back(a2);
    result.push_back(a3);

    return result;
}

// and so on, boost stops at nine by default for their variadic templates
</code></pre>

<p>Usage:</p>

<pre><code>func(gen_vec(1,2,3));
</code></pre>
"
"<p>Here is what I mean trying to do</p>

<pre><code> double x=1.1402
 double pow=1/3;
 std::pow(x,pow) -1;
</code></pre>

<p>result is 0 but I expect 0.4465</p>

<p>the equation is  <code>(1 + x) ^3= 1.1402</code>, find <code>x</code>.</p>
","87234","","<p>1/3 is 0. That's integer division.</p>

<p>Try:</p>

<pre><code>double pow = 1.0 / 3.0;
</code></pre>

<p>For:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;

int main(void)
{
 double x = 1.1402;
 double pow = 1.0/3.0;
 std::cout &lt;&lt; std::pow(x, pow) - 1;

}
</code></pre>
"
"<p>Can accessing (for read only) memory freed cause an access violation, and, if so, under what circumstances?</p>
","87234","","<p>You're asking ""can"" and not ""will"", so your answer is yes. It is undefined behavior to point to memory not owned by your program, therefore anything could happen.</p>

<p>Will it? Depends. That is very OS specific. You might be able to get away with it, but obviously you cannot depend on this. Trying to dereference it could cause an exception, because the OS has reclaimed the memory for it's own uses. (again, OS specific).</p>
"
"<p>I know its possible to do something like this with Windows:</p>

<pre><code>MessageBox(hWnd, ""Yes, No, or Cancel?"", ""YNCB_YESNOCANCEL);
</code></pre>

<p>But how do I react to what the user pressed (like closing the window if they clicked ""yes"")?</p>
","87234","","<p><a href=""http://msdn.microsoft.com/en-us/library/ms645505%28VS.85%29.aspx"" rel=""nofollow""><code>MessageBox</code></a> will return a integer referring to the button pressed. From the previous link:</p>

<pre><code>Return Value
    IDABORT      Abort button was selected.
    IDCANCEL     Cancel button was selected.
    IDCONTINUE   Continue button was selected.
    IDIGNORE     Ignore button was selected.
    IDNO         No button was selected.
    IDOK         OK button was selected.
    IDRETRY      Retry button was selected.
    IDTRYAGAIN   Try Again button was selected.
    IDYES        Yes button was selected.
</code></pre>

<p>So something like:</p>

<pre><code>int result = MessageBox(hWnd, ""Save work?"", MB_YESNOCANCEL);
if (result == IDOK)
{
    // ...
}
else if (result == IDNO)
{
    // ...
}
else // cancel
{
    // ...
}
</code></pre>
"
"<p>EDIT: After even more code modification, the error is still there, modified code shown:</p>

<p><code>KeyDown()</code>:</p>

<pre><code>const int input_bit_num = 0x8000;
char keys[256];
bool KeyDown(int key)
{
    return (keys[key] &amp; input_bit_num) != 0;
}
</code></pre>

<p><code>PollKeyboard()</code>:</p>

<pre><code>LPDIRECTINPUTDEVICE8 di_keyboard;
void PollKeyboard()
{
    long result = di_keyboard-&gt;GetDeviceState(sizeof(keys), (LPVOID)&amp;keys);
    char para[16];
    itoa(result, para, 17);
        if(result != DI_OK) MessageBox(NULL, para, ""ERROR"", MB_OK);

}
</code></pre>

<p>When I try to put MessageBox within a <code>KeyDown()</code> if statement (as seen below in the game loop), the MessageBox simply coninues to appear even if I stop pressing the key, ie: I press , the ""Would you like to quit?"" message box appears, I say no, It disappears and then instantly reappears, as if I were still holding the  key.</p>

<p>This is my loop:</p>

<pre><code>void GameRun(HWND hWnd) //called once every frame
{
    PollKeyboard();
    if(GetTickCount - start &gt;= 30)
    {
        if(KeyDown(DIK_LEFT))
            MoveLeft();
        if(KeyDown(DIK_RIGHT))
            MoveRight();
    }

    if(d3ddev-&gt;BeginScene())
    {
        //rendering
    }

    if(KeyDown(DIK_ESCAPE))
    {
        //any MessageBox()
        int result = MessageBox(hWnd, ""I'm causing so much trouble!"", ""IMMORTAL"", MB_YESNOCANCEL);
        if(result == IDYES)
            //end
    }
}
</code></pre>

<p>EDIT: The catch in <code>PollKeyboard()</code> displays the sequence <code>53gd6bcc</code>, I could not, however, find the error code it corresponds to.</p>

<p>EDIT: After another test, I saw that even if the MessageBox is not within a KeyDown() if statement, the glitch still occurs.</p>

<p>EDIT: After a bit more testing, it appears that MessageBox itself is causing the glitch.</p>
","87234","","<p>Because the sample code works, something else in your program is causing the bug. Try moving bits of the code below into your own until it works, then you will know which section of code was culprit.</p>

<h3>Sample Code</h3>

<p>Alright, huge code block coming up. This code works correctly for me. (Escape, along with all other keys successfully activate and deactivate). It's large, commented, and explains things fairly well. Try this, if it works, we'll examine other parts of your program, if not, I can only leave you with ""Good luck"", and take what you want:</p>

<pre><code>// DirectInput
#define DIRECTINPUT_VERSION 0x0800
#include&lt;dinput.h&gt;

// Standard stuff
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

// Link from code, MSVC specific, could be done in project settings
#pragma comment(lib, ""dinput8.lib"")
#pragma comment(lib, ""dxguid.lib"")

// Utility lexical_cast, use Boost if possible.
// Simple replacement, converts a stream-able `T`
// to a string
template &lt;typename T&gt;
const std::string lexical_cast(const T&amp; pValue)
{
    std::stringstream ss;
    ss &lt;&lt; pValue;

    return ss.str();
}

// Utility function + macro to execute DirectX code with exceptions.
// Kinda ugly, but helpful for us.
void check_error(HRESULT pResult, const std::string&amp; pFuncName)
{
    // DI_OK == S_OK, but S_OK is more general, so we'll use that
    if (pResult != S_OK)
    {
    	throw std::runtime_error(""Error executing: "" + pFuncName +
    							""! Returned: "" + lexical_cast(pResult));
    }
}

// Macro, makes calling the function easier. It is wrapped in
// an `if` statement for reasons outlined in:
// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.5
#define CHECK_ERROR(x) if (true) { check_error(x, #x); } else (void)0

// The above gives the warning:
// ""warning C4127: conditional expression is constant"", disable below:
#pragma warning(disable: 4127)

// Manages input
class input_manager
{
public:
    // Constants
    static const int NumberKeys = 256;

    // Creation
    input_manager(void)
    {
    	// Create input and keyboard (like I said, ugly macro, but helpful :] )
    	CHECK_ERROR(DirectInput8Create(GetModuleHandle(NULL), DIRECTINPUT_VERSION,
    		IID_IDirectInput8, reinterpret_cast&lt;void**&gt;(&amp;_input), 0));


    	CHECK_ERROR(_input-&gt;CreateDevice(GUID_SysKeyboard, &amp;_keyboard, 0));
    	CHECK_ERROR(_keyboard-&gt;SetDataFormat(&amp;c_dfDIKeyboard));
    	CHECK_ERROR(_keyboard-&gt;Acquire());
    }

    ~input_manager(void)
    {
    	// Free resources. Note: Many programmers
    	// unnecessarily wrap this stuff in
    	// `if (_keyboard !=0)`, and then
    	// `_keyboard = 0`. This is completely unnecessary,
    	// because destructors are only run one time.

    	// Also, I can assume they are valid, because if they
    	// weren't, we wouldn't be here (an exception would have
    	// been thrown)

    	_keyboard-&gt;Unacquire();
    	_keyboard-&gt;Release();
    	_input-&gt;Release();

    	// Also, if we wrapped this into a nice RAII class, we wouldn't
    	// be forced to write a destructor, but this is outside the scope.
    	// Feel free to ask how; additionally, since we're on the topic, if you'd
    	// like more tips handling input (I've written PLENTY of input managers)
    	// I'm free for asking about things like testing for triggers rather than pressed
    	// (""was it pressed, regardless if it's being held now"" versus
    	// ""is it being pressed""), etc.
    }

    // Operations
    void update(void)
    {
    	CHECK_ERROR(_keyboard-&gt;GetDeviceState(NumberKeys, reinterpret_cast&lt;void*&gt;(&amp;_keys)));
    }

    // Query
    bool key_pressed(int pKey) const
    {
    	return test_key(pKey);
    }

    // Might wrap into an operator[] for convenience.

private:
    // Constants
    static const int PressMask = 0x80;

    // Sorry for the confusion, but indeed, with
    // `char`s the mask is simply 0x80.

    // Utility
    bool test_key(int pKey) const
    {
    	return (_keys[pKey] &amp; PressMask) != 0;
    }

    // Members
    LPDIRECTINPUT8 _input;
    LPDIRECTINPUTDEVICE8 _keyboard;

    char _keys[NumberKeys];
};

void test_keys(const input_manager&amp; input)
{
    bool anyPressed = false;

    for (unsigned i = 0; i &lt; input_manager::NumberKeys; ++i)
    {
    	if (input.key_pressed(i))
    	{
    		std::cout &lt;&lt; ""Pressing: "" &lt;&lt; i &lt;&lt; std::endl;

    		anyPressed = true;
    	}
    }

    if (!anyPressed)
    {
    	std::cout &lt;&lt; ""No keys pressed."" &lt;&lt; std::endl;
    }
}

void execute(void)
{
    input_manager input;

    std::cout &lt;&lt; ""Press Q to quit."" &lt;&lt; std::endl;

    bool running = true;
    while (running)
    {
    	input.update();

    	if (input.key_pressed(DIK_Q))
    	{
    		running = false;
    	}

    	test_keys(input);

    	Sleep(0); // give some processor time
    }
}

int main(void)
{
    // Place real code in an execute function, so main
    // is clean and ready to catch exceptions:
    try
    {
    	execute();
    }
    catch (const std::exception&amp; e)
    {
    	// Error!
    	std::cerr &lt;&lt; ""Unhandled exception:"" &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}
</code></pre>

<h3>Old suggestion:</h3>

<p>Try catching the return value from GetDeviceState:</p>

<pre><code>HRESULT result =                              // v Prefer C++-style casts
    di_keyboard-&gt;GetDeviceState(sizeof(keys), reinterpret_cast&lt;void*&gt;(&amp;keys);

if (result != DI_OK)
{
    // uh-oh
    std::cout &lt;&lt; result &lt;&lt; std::endl;
}
</code></pre>

<p>Compare it against the <a href=""http://doc.51windows.net/Directx9%5FSDK/?url=/Directx9%5FSDK/input/ref/ifaces/idirectinputdevice9/getdevicestate.htm"" rel=""nofollow"">table here</a>.</p>

<h3>Old Semi-Answer:</h3>

<p>Shortly after editing in the code in the Extra Stuff section, I realized the error, sorry I didn't catch it earlier. You're testing the wrong bit :)</p>

<p>Observe:</p>

<pre><code>//                                     v HERE! Should be 0x8000, not 0x80.
return (GetAsyncKeyState(pKeyCode) &amp; 0x8000) != 0;
</code></pre>

<p>Try that:</p>

<pre><code>int KeyDown(int key)
{
    return (keys[key] &amp; 0x8000);
}
</code></pre>

<p>Also, this should be moved into a constant to avoid magic numbers:</p>

<pre><code>// somewhere, probably in the private section of the class or in a detail namespace:
static const int PushedMask = 0x8000;

// code reads better:
int KeyDown(int key)
{
    return (keys[key] &amp; PushedMask);
}
</code></pre>

<p>Lastly, in C++ you have a <code>bool</code> type, so take advantage of it!</p>

<pre><code>// v here
bool KeyDown(int key)
{
    return (keys[key] &amp; PushedMask);
}
</code></pre>

<p>I know Visual Studio will warn about this conversion from <code>int</code> to <code>bool</code>, so you can get rid of it while also making your intents clearer:</p>

<pre><code>bool KeyDown(int key)
{
    return (keys[key] &amp; PushedMask) != 0; // or == 1, your choice
}
</code></pre>

<h3>Extra Stuff:</h3>

<p>Try the following code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;windows.h&gt;

bool key_pressed(int pKeyCode)
{
    return (GetAsyncKeyState(pKeyCode) &amp; 0x8000) != 0;
}

void test_keys(void)
{
    for (unsigned i = 0; i &lt; 255; ++i)
    {
    	if (key_pressed(i))
    	{
    		std::cout &lt;&lt; ""Pressing: "" &lt;&lt; i &lt;&lt; std::endl;
    	}
    }
}

int main(void)
{
    bool running = true;
    while (running)
    {
    	if (key_pressed(VK_ESCAPE))
    	{
    		running = false;
    	}

    	test_keys();

    	Sleep(0);
    }
}
</code></pre>

<p>This works for me (responds to all keys, quits on escape). Minimal test case for <code>GetAsyncKeyState</code>. If this does <em>not</em> work, please add OS, Keyboard, etc, in your comment.</p>
"
"<p>I am trying to get a double to be a string through stringstream, but it is not working. </p>

<pre><code>std::string MatlabPlotter::getTimeVector( unsigned int xvector_size, double ts ){
    std::string tv;
    ostringstream ss;
    ss &lt;&lt; ""0:"" &lt;&lt; ts &lt;&lt; "":"" &lt;&lt; xvector_size;
    std::cout &lt;&lt; ss.str() &lt;&lt; std::endl;
    return ss.str();
}
</code></pre>

<p>It outputs only ""0:"" on my console...</p>

<p>I'm working on two projects, both with the same problem. I'm posting a different one, which runs into the same problem. It is posted here:<br>
<a href=""http://pastebin.com/m2dd76a63"" rel=""nofollow"">http://pastebin.com/m2dd76a63<br></a>
I have three classes PolyClass.h and .cpp, and the main. The function with the problem is PrintPoly. Can someone help me out? Thanks a bunch!!</p>
","87234","","<p>The following code is 100% correct:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

// removed MatlabPlotter namespace, should have no effect
std::string getTimeVector(unsigned int xvector_size, double ts)
{
    // std::string tv; // not needed
    std::ostringstream ss;
    ss &lt;&lt; ""0:"" &lt;&lt; ts &lt;&lt; "":"" &lt;&lt; xvector_size;

    std::cout &lt;&lt; ss.str() &lt;&lt; std::endl;

    return ss.str();
}

int main(void)
{
    // all work
    // 1:
    getTimeVector(0, 3.1415);

    // 2: (note, prints twice, once in the function, once outside)
    std::cout &lt;&lt; getTimeVector(0, 3.1415) &lt;&lt; std::endl;

    // 3: (note, prints twice, once in the function, once outside)
    std::string r = getTimeVector(0, 3.1415);
    std::cout &lt;&lt; r &lt;&lt; std::endl;
}
</code></pre>

<p>Find where we differ, that's likely your source of error. Because it stops at your double, I'm guessing the double you're trying to print is infinity, NaN (not a number), or some other error state.</p>
"
"<p>I am using c++ to look through 256 counts and write the ASCII representative to a file.</p>

<p>If i use the method of generating a 256 character string then write that string to the file, the file weighs 258bytes.</p>

<pre><code>string fileString = """";

//using the counter to attach the ASCII count to the string.
for(int i = 0; i &lt;= 256; i++)
{
	fileString += i;
}

file &lt;&lt; fileString;
</code></pre>

<p>If i use the method of writing to the file withing the loop, the file is exactly 256bytes.</p>

<pre><code>//using the counter to attach the ASCII count to the string.
for(int i = 0; i &lt;= 256; i++)
{
	file &lt;&lt; (char)i;
}
</code></pre>

<p>Whats going here with the string, what extra information from the string is being written to the file?</p>
","87234","","<p>Both of these create a 256 byte file:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;string&gt;

int main(void)
{
    std::ofstream file(""output.txt"", std::ios_base::binary);
    std::string fileString;

    for(int i = 0; i &lt; 256; i++)
    {
    	fileString += static_cast&lt;char&gt;(i);
    }

    file &lt;&lt; fileString;
}
</code></pre>

<p>And:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;string&gt;

int main(void)
{
    std::ofstream file(""output.txt"", std::ios_base::binary);
    std::string fileString;

    for (int i = 0; i &lt; 256; ++i)
    {
    	file &lt;&lt; static_cast&lt;char&gt;(i);
    }

    file.close();
}
</code></pre>

<p>Note, before you had an off-by-one error, as there is no 256th ASCII character, only 0-255. It will truncate to a char when printed. Also, prefer <code>static_cast</code>.</p>

<p>If you do not open them as binary, it will append a newline to the end. My standard-ess is weak in the field of outputs, but I do know text files are suppose to always have a newline at the end, and it is inserting this for you. I think this is implementation defined, as so far all I can find in the standard is that ""the destructor can perform additional implementation-defined operations.""</p>

<p>Opening as binary, of course, removes all bars and let's you control every detail of the file.</p>

<p><hr /></p>

<p>Concerning Alterlife's concern, you can store 0 in a string, but C-style strings are terminated by 0. Hence:</p>

<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main(void)
{
    std::string result;

    result = ""apple"";
    result += static_cast&lt;char&gt;(0);
    result += ""pear"";

    std::cout &lt;&lt; result.size() &lt;&lt; "" vs ""
    	&lt;&lt; std::strlen(result.c_str()) &lt;&lt; std::endl;
}
</code></pre>

<p>Will print two different lengths: one that is counted, one that is null-terminated.</p>
"
"<p>This is a <em>mad-hack</em>, but I am trying to deliberately cause a segfault at a particular point in execution, so valgrind will give me a stack trace.</p>

<p>If there is a better way to do this please tell me, but I would still be curious to know how to deliberaly cause a segfault, and why my attempt didn't work.</p>

<p>This is my failed attempt:</p>

<pre><code>long* ptr = (long *)0xF0000000;
ptr = 10;
</code></pre>

<p>I thought valgrind should at least pick up on that as a invalid write, even if it's not a segmentation violation. Valgrind says nothing about it.</p>

<p>Any ideas why?</p>

<p><strong>EDIT</strong></p>

<p>Answer accepted, but I still have some up-votes for any suggestions for a more sane way to get a stack trace...</p>
","87234","","<p>Are you missing a <code>*</code> as in <code>*ptr = 10</code>? What you have won't compile.</p>

<p>If it does, somehow, that of course won't cause a seg-fault, since you're just assigning a number. Dereferencing might.</p>

<p>Assuming dereferencing null on your OS results in a segfault, the following should do the trick:</p>

<pre><code>inline void seg_fault(void)
{
    volatile int *p = reinterpret_cast&lt;volatile int*&gt;(0);
    *p = 0x1337D00D;
}
</code></pre>
"
"<p>Let's say I have this C++ code:</p>

<pre><code>void exampleFunction () { // #1
    cout &lt;&lt; ""The function I want to call."" &lt;&lt; endl;
}

class ExampleParent { // I have no control over this class
public:
    void exampleFunction () { // #2
        cout &lt;&lt; ""The function I do NOT want to call."" &lt;&lt; endl;
    }
    // other stuff
};

class ExampleChild : public ExampleParent {
public:
    void myFunction () {
        exampleFunction(); // how to get #1?
    }
};
</code></pre>

<p>I have to inherit from the <code>Parent</code> class in order to customize some functionality in a framework. However, the <code>Parent</code> class is masking the global <code>exampleFunction</code> that I want to call. Is there any way I can call it from <code>myFunction</code>?</p>

<p>(I actually have this problem with calling the <code>time</code> function in the <code>&lt;ctime&gt;</code> library if that makes any difference)</p>
","87234","","<p>Do the following:</p>

<pre><code>::exampleFunction()
</code></pre>

<p><code>::</code> will access the global namespace.</p>

<p>If you <code>#include &lt;ctime&gt;</code>, you should be able to access it in the namespace <code>std</code>:</p>

<pre><code>std::time(0);
</code></pre>

<p>To avoid these problems, place everything in namespaces, and avoid global <code>using namespace</code> directives.</p>
"
"<p>So I have 2 classes, Bullet and Ship, that are dependent on each other, hence circular inclusion. Since I have Ship's interface #included into Bullet's interface, the obvious decision was to forward declare Bullet to Ship.</p>

<p>However, when I first tried this I still got compiler errors. I read up a bit on forward declaration and realized that I was constructing a Bullet in one of Ship's methods, and Bullet's default constructor is member initialized, which (and I may be wrong) wouldn't work because a forward class declaration doesn't allow Ship to see definitions in the interface (i.e. member initialization). </p>

<p>So I decided I could give up the member init and just defined the constructor in Bullet's implementation file, however I still receive the same problem with circular dependency.</p>

<p>The message in particular is <code>invalid use of undefined type struct Bullet</code>.</p>

<p>I could just put the interface for Bullet and Ship in the same file, but that's kind of a last resort. Any assistance regarding this problem is appreciated. Thanks.</p>

<p>Here is the spot where the error occurs:</p>

<pre><code>case SDLK_UP: // Fire
{
    Bullet(*this) fired_bullet; // Create bullet. Line where error occurs.
    fired_bullet.Move(); // Move bullet
    break;
}
</code></pre>

<p>Bullet's default constructor takes an argument of the Ship that is firing the bullet, and that code is in a Ship method.</p>
","87234","","<p>You want:</p>

<pre><code>Bullet fired_bullet(*this);
</code></pre>

<p>But your coupling is very tight. What does Bullet need from Ship, and what does Ship need from bullet?</p>

<p>I assume the bullet needs to know what ship it came from so enemy bullets don't hurt enemy's and vice versa. Perhaps you need a team type?</p>

<pre><code>enum bullet_team
{
    bullet_player,
    bullet_enemy,
}
</code></pre>

<p>And your ships and enemies will only tell the bullet what team they are on, rather than forcing the bullet to keep track of where it came from:</p>

<p>About firing, maybe make a BulletManager singleton. Tell the manager you want to make a bullet at a position X, with team orientation Y, and properties Z, and the manager will take care of it for you.</p>

<pre><code>BulletManager::reference().fire(getPosition(), bullet_player);
</code></pre>
"
"<p>Consider the following code:</p>

<pre><code>class myarray
{
    int i;

    public:
            myarray(int a) : i(a){ }

}
</code></pre>

<p>How can you create an array of objects of myarray on the stack and how can you create an array of objects on the heap?</p>
","87234","","<p>You can create an array of objects on the stack<sup>†</sup> via:</p>

<pre><code>myarray stackArray[100]; // 100 objects
</code></pre>

<p>And on the heap<sup>†</sup> (or ""freestore""):</p>

<pre><code>myarray* heapArray = new myarray[100];
delete [] heapArray; // when you're done
</code></pre>

<p>But it's best not manage memory yourself. Instead, use a <a href=""http://en.cppreference.com/w/cpp/container/vector"">std::vector</a>:</p>

<pre><code>#include &lt;vector&gt;
std::vector&lt;myarray&gt; bestArray(100);
</code></pre>

<p>A vector is a dynamic array, which (by default) allocates elements from the heap.<sup>††</sup></p>

<hr>

<p>Because your class has no default constructor, to create it on the stack you need to let the compiler know what to pass into the constructor:</p>

<pre><code>myarray stackArray[3] = { 1, 2, 3 };
</code></pre>

<p>Or with a vector:</p>

<pre><code>// C++11:
std::vector&lt;myarray&gt; bestArray{ 1, 2, 3 };

// C++03:
std::vector&lt;myarray&gt; bestArray;
bestArray.push_back(myarray(1));
bestArray.push_back(myarray(2));
bestArray.push_back(myarray(3));
</code></pre>

<p>Of course, you could always give it a default constructor:</p>

<pre><code>class myarray
{
    int i;    
public:
    myarray(int a = 0) :
    i(a)
    {}
};
</code></pre>

<hr>

<p>† For the pedants: C++ doesn't really have a ""stack"" or ""heap""/""freestore"". What we have is ""automatic storage"" and ""dynamic storage"" duration. In practice, this aligns itself with stack allocation and heap allocation.</p>

<p>†† If you want ""dynamic"" allocation from the stack, you'd need to define a max size (stack storage is known ahead of time), and then give vector a new allocator so it uses the stack instead.</p>
"
"<p>I have to send mesh data via TCP from one computer to another...  These meshes can be rather large.  I'm having a tough time thinking about what the best way to send them over TCP will be as I don't know much about network programming.</p>

<p>Here is my basic class structure that I need to fit into buffers to be sent via TCP:</p>

<pre><code>class PrimitiveCollection
{
    std::vector&lt;Primitive*&gt; primitives;
};

class Primitive 
{
    PRIMTYPES primType; // PRIMTYPES is just an enum with values for fan, strip, etc...
    unsigned int numVertices;
    std::vector&lt;Vertex*&gt; vertices;
};


class Vertex
{
    float X;
    float Y;
    float Z;
    float XNormal;
    float ZNormal;
};
</code></pre>

<p>I'm using the Boost library and their TCP stuff... it is fairly easy to use.  You can just fill a buffer and send it off via TCP.<br />
However, of course this buffer can only be so big and I could have up to 2 megabytes of data to send.</p>

<p>So what would be the best way to get the above class structure into the buffers needed and sent over the network?  I would need to deserialize on the recieving end also.</p>

<p>Any guidance in this would be much appreciated.</p>

<p><strong>EDIT:</strong>  I realize after reading this again that this really is a more general problem that is not specific to Boost... Its more of a problem of chunking the data and sending it.  However I'm still interested to see if Boost has anything that can abstract this away somewhat.</p>
","87234","","<p>Without anything fancy, from what I remember in my network class:</p>

<ul>
<li>Send a message to the receiver asking what size data chunks it can handle</li>
<li>Take a minimum of that and your own sending capabilities, then reply saying:
<ul>
<li>What size you'll be sending, how many you'll be sending</li>
</ul></li>
<li>After you get that, just send each chunk. You'll want to wait for an ""Ok"" reply, so you know you're not wasting time sending to a client that's not there. This is also a good time for the client to send a ""I'm canceling"" message instead of ""Ok"".</li>
<li>Send until all packets have been replied with an ""Ok""</li>
<li>The data is transfered.</li>
</ul>

<p>This works because TCP guarantees in-order delivery. UDP would require packet numbers (for ordering).</p>

<p>Compression is the same, except you're sending compressed data. (Data is data, it all depends on how you interpret it). Just make sure you communicate how the data is compressed :)</p>

<p>As for examples, all I could dig up was <a href=""http://onegazhang.spaces.live.com/blog/cns!D5E642BC862BA286!825.entry"" rel=""nofollow"">this page</a> and this <a href=""http://stackoverflow.com/questions/720817/boost-sending-files-over-the-network-using-tcp-prefered-method"">old question</a>. I think what you're doing would work well in tandem with <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/libs/serialization/doc/index.html"" rel=""nofollow"">Boost.Serialization</a>.</p>
"
"<p>Ive got a problem that if I have a template class, which in turn has a template method that takes a parameter of another instance of the class (with different template arguments), that it can not access protected or private members of the class passed as a parameter, eg:</p>

<pre><code>template&lt;typename T&gt;class MyClass
{
    T v;
public:
    MyClass(T v):v(v){}

    template&lt;typename T2&gt;void foo(MyClass&lt;T2&gt; obj)
    {
        std::cout &lt;&lt; v     &lt;&lt; "" "";
        //error C2248: 'MyClass&lt;T&gt;::v' : cannot access private member declared in class 'MyClass&lt;T&gt;'
        std::cout &lt;&lt; obj.v &lt;&lt; "" "";
        std::cout &lt;&lt; v + obj.v &lt;&lt; std::endl;
    }
};
int main()
{
    MyClass&lt;int&gt; x(5);
    MyClass&lt;double&gt; y(12.3);
    x.foo(y);
}
</code></pre>

<p>Is there someway to say that methods in MyClass&lt;T&gt; have full access to MyClass&lt;SomeOtherT&gt;?</p>
","87234","","<p>They are different types: templates construct <em>new</em> types from a template.</p>

<p>You have to make other instantiations of your class friends:</p>

<pre><code>template &lt;typename T&gt;class MyClass
{
    T v;
public:
    MyClass(T v):v(v){}

    template&lt;typename T2&gt;void foo(MyClass&lt;T2&gt; obj)
    {
        std::cout &lt;&lt; v     &lt;&lt; "" "";
        std::cout &lt;&lt; obj.v &lt;&lt; "" "";
        std::cout &lt;&lt; v + obj.v &lt;&lt; std::endl;
    }

    // Any other type of MyClass is a friend.
    template &lt;typename U&gt;
    friend class MyClass;

    // You can also specialize the above:
    friend class MyClass&lt;int&gt;; // only if this is a MyClass&lt;int&gt; will the
                               // other class let us access its privates
                               // (that is, when you try to access v in another
                               // object, only if you are a MyClass&lt;int&gt; will
                               // this friend apply)
};
</code></pre>
"
"<p>Storing objects in heterogeneous vector with stack-allocated objects</p>

<p>Hello,</p>

<p>Say I have an abstract class CA, derived into CA1, CA2, and maybe others.</p>

<p>I want to put objects of these derived types into a vector, that I embbed into a class CB. To get polymorphism right, I need to store a vector of pointers:</p>

<pre><code>class CB
{
    std::vector &lt;CA*&gt; v;
};
</code></pre>

<p>Now, say I have the following main function:</p>

<pre><code>int main()
{
    CB b;
    CA1 a1;
    CA2 a2;
    b.Store( a1 );
    b.Store( a2 );
}
</code></pre>

<p>How do I write the method <code>void CB::Store(const CA&amp;)</code> in a simple way, so the stored objects survive when the original objects gets destroyed (which doesn't occur in the simple example above).</p>

<p>My problem is that I need to first copy objects on the heap before copying their adress in the vector, but how can I create an object of a derived type ? Sure, I could use RTTI, and search for all possible types, create and allocate a pointer, and copy (with proper casting) the object into the allocated space before pushing it into the vector. But this seems quite complicated, no ?</p>

<p>Is there a simpler way ?</p>

<p>(And without using dynamic allocation in the main !)</p>
","87234","","<p>Commonly, you will provide a clone function:</p>

<pre><code>struct CA
{
    virtual CA *clone(void) const = 0;
    virtual ~CA() {} // And so on for base classes.
}

struct CA1 : public CA
{
    virtual CA *clone(void) const
    {
        return new CA1(*this);
    }
}

struct CA2 : public CA
{
    virtual CA *clone(void) const
    {
        return new CA2(*this);
    }
}
</code></pre>

<p>This is called a <a href=""http://www.parashift.com/c++-faq-lite/virtual-functions.html"" rel=""nofollow"">virtual constructor</a>, you can construct copies of objects at runtime:</p>

<pre><code>void CB::Store(const CA&amp; pObject)
{
    CA *cloned = pObject.clone();
}
</code></pre>

<p>You should consider using the <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/libs/ptr%5Fcontainer/doc/ptr%5Fcontainer.html"" rel=""nofollow"">Boost.Pointer Container</a> library. Your code would be:</p>

<pre><code>boost::ptr_vector&lt;CA&gt; objects;

void CB::Store(const CA&amp; pObject)
{
    objects.push_back(pObject-&gt;clone());
}
</code></pre>

<p>And now you have no need to manage memory yourself. The library also respects clone functions, and will call it when making copies of your objects. <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/libs/ptr%5Fcontainer/doc/tutorial.html"" rel=""nofollow"">Tutorial here</a>.</p>
"
"<p>I have a std::vector m_vPaths;  I will iterate this vector and call ::DeleteFile(strPath) as I go.  If I successfully delete the file, I will remove it from the vector.  My question is can I get around having to use two vectors?  Is there different data structure that might be better suited for what I need to do?</p>

<p>example:
using iterators almost does what I want, but problem is once you erase using an iterator, all iterators become invalid.</p>

<pre><code> std::vector&lt;std::string&gt; iter = m_vPaths.begin();
    for( ; iter != m_vPaths.end(); iter++) {
        std::string strPath = *iter;
        if(::DeleteFile(strPath.c_str())) {
            m_vPaths.erase(iter);   
                //Now my interators are invalid because I used erase,
                //but I want to continue deleteing the files remaining in my vector.    
        }
    }
</code></pre>

<p>I can use two vectors and I will no longer have a problem, but is there a better, more efficient method of doing what I'm trying to do?</p>

<p>btw, incase it is unclear, m_vPaths is declared like this (in my class):</p>

<pre><code>std::vector&lt;std::string&gt; m_vPaths;
</code></pre>
","87234","","<p>Check out <a href=""http://en.cppreference.com/w/cpp/algorithm/remove""><code>std::remove_if</code></a>:</p>

<pre><code>#include &lt;algorithm&gt; // for remove_if
#include &lt;functional&gt; // for unary_function

struct delete_file : public std::unary_function&lt;const std::string&amp;, bool&gt; 
{
    bool operator()(const std::string&amp; strPath) const
    {
        return ::DeleteFile(strPath.c_str());
    }
}

m_vPaths.erase(std::remove_if(m_vPaths.begin(), m_vPaths.end(), delete_file()),
                m_vPaths.end());
</code></pre>

<p>Use a <a href=""http://en.cppreference.com/w/cpp/container/list""><code>std::list</code></a> to stop the invalid iterators problem, though you lose random access. (And cache performance, in general)</p>

<hr>

<p>For the record, the way you would implement your code would be:</p>

<pre><code>typedef std::vector&lt;std::string&gt; string_vector;
typedef std::vector&lt;std::string&gt;::iterator string_vector_iterator;

string_vector_iterator iter = m_vPaths.begin();
while (iter != m_vPaths.end())
{
    if(::DeleteFile(iter-&gt;c_str()))
    {
        // erase returns the new iterator
        iter = m_vPaths.erase(iter);
    }
    else
    {
        ++iter;
    }
}
</code></pre>

<p>But you should use <a href=""http://en.cppreference.com/w/cpp/algorithm/remove""><code>std::remove_if</code></a> (reinventing the wheel is bad).</p>
"
"<p>I was wondering, if I render a scene using a shader to which I pass in a texture that also happens to be the render target for that scene will it cause any unwanted behaviour?</p>

<p>So basically:</p>

<pre><code>texture t;

shader-&gt;SetTexture(""texture"",t);

device-&gt;SetRenderTarget( 0, t-&gt;surface );

shader-&gt;Begin(""effect"")
// do some more shader stuff

device-&gt;EndScene();
</code></pre>

<p>what will this cause exactly?</p>

<p>If I don't clear the render target before rendering will the texture still work all the same? I just assume the final changes don't get written into the texture until device->End is called?</p>
","87234","","<p>Though I can't point out specifics, I'm pretty sure it's undefined behavior. The method a graphics card uses for shading fragments can vary (do different amounts at a time, etc), but in any practical case, it does more than one fragment at a time. This means you'll be both reading and writing to the same locations, causing race conditions. I don't think it's recommended.</p>
"
"<p>I have to set up a pointer to a library function (<code>IHTMLDocument2::write</code>) which is a method of the class <code>IHTMLDocument2</code>. (for the curious: i have to hook that function with Detours)</p>

<p>I can't do this directly, because of type mismatch, neither can I use a cast (<code>reinterpret_cast&lt;&gt;</code> which is the ""right one"" afaik doesn't work)</p>

<p>Here's what I am doing:</p>

<pre><code>HRESULT (WINAPI *Real_IHTMLDocument2_write)(SAFEARRAY *) = &amp;IHTMLDocument2::write
</code></pre>

<p>Thanks for your help!</p>
","87234","","<p>The pointer to function has the following type:</p>

<pre><code>HRESULT (WINAPI IHTMLDocument2::*)(SAFEARRAY*)
</code></pre>

<p>As you can see, it's qualified with it's class name. It requires an instance of a class to call on (because it is not a static function):</p>

<pre><code>typedef HRESULT (WINAPI IHTMLDocument2::*DocumentWriter)(SAFEARRAY*);

DocumentWriter writeFunction = &amp;IHTMLDocument2::write;

IHTMLDocument2 someDocument = /* Get an instance */;
IHTMLDocument2 *someDocumentPointer = /* Get an instance */;

(someDocument.*writefunction)(/* blah */);
(someDocumentPointer-&gt;*writefunction)(/* blah */);
</code></pre>
"
"<p>I have very little idea what's going in regards to C++ templates, but I'm trying to implement a function that searches a vector for an element satisfying a given property (in this case, searching for one with the name given). My declaration in my .h file is as follows:</p>

<pre><code>template &lt;typename T&gt;
T* find_name(std::vector&lt;T*&gt; v, std::string name);
</code></pre>

<p>When I compile, I get this linker error when I call the function:</p>

<pre><code>Error   1	error LNK2019: unresolved external symbol ""class Item * __cdecl find_name&lt;class Item&gt;(class std::vector&lt;class Item *,class std::allocator&lt;class Item *&gt; &gt;,class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;)"" (??$find_name@VItem@@@@YAPAVItem@@V?$vector@PAVItem@@V?$allocator@PAVItem@@@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z) referenced in function ""public: class Item * __thiscall Place::get_item(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;)"" (?get_item@Place@@QAEPAVItem@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z)	place.obj	Program2
</code></pre>

<p>Again, I'm new to templates so I don't know what's going. All instances I've found of LNK2019 through Google have been about not using the correct libraries, but since this is my own function I don't see why this would be happening.</p>

<p>Also, a related question: Is there a way to make a template parameter so that it has to be a subclass of a certain class, i.e. template?</p>
","87234","","<p>You have to have your template definitions available at the calling site. That means no <code>.cpp</code> files.</p>

<p>The reason is templates cannot be compiled. Think of functions as cookies, and the compiler is an oven.</p>

<p>Templates are only a cookie cutter, because they don't know what type of cookie they are. It only tells the compiler how to make the function when given a type, but in itself, it can't be used because there is no concrete type being operated on. You can't cook a cookie cutter. Only when you have the tasty cookie dough ready (i.e., given the compiler the dough [type])) can you cut the cookie and cook it.</p>

<p>Likewise, only when you actually use the template with a certain type can the compiler generate the actual function, and compile it. It can't do this, however, if the template definition is missing. You have to move it into the header file, so the caller of the function can make the cookie.</p>

<p><img src=""http://img682.imageshack.us/img682/9414/cookiem.png"" alt=""Cookie."" title="""" /></p>
"
"<p>I'm trying to do some opt-3 swapping on my TSP generator for euclidian distances, and since I in many cases have more than ~500 nodes, I need to randomly select at least 1 of the 3 nodes that I want to try swapping.</p>

<p>So basically I need a random-number function that's <strong>fast</strong>. (the normal rand() is way too slow) It doesn't have to be awesome, just good <em>enough</em>.</p>

<p>EDIT:
I forgot to mention, i'm sitting at an environment where I can't add any libraries except the Standard Language Library (such as STL, iostream etc). So no boost =/</p>
","87234","","<p>I'm pretty sure <code>rand()</code> is about as simple and fast as you can get, being a <a href=""http://en.wikipedia.org/wiki/Linear%5Fcongruential%5Fgenerator"">linear congruential generator</a>. It multiplies and adds.</p>

<p>You could use the <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/libs/random/index.html"">Boost random library</a>, which is still probably just as fast and likely has better distribution.</p>

<p>Or use the special formula:</p>

<p><img src=""http://imgs.xkcd.com/comics/random%5Fnumber.png"" alt=""xkcd"" title=""RFC 1149.5 specifies 4 as the standard IEEE-vetted random number."" /></p>
"
"<p>I want to add a GLSL fragment shader to a program of mine, however I have been unable to find comprehensive documentation related to the C language (not C++ or C#). 
Anyone has examples or steps to get the ARB extension for shaders, or some sort of ""hello world"" template? I don't need help on the shaders themselves, just how to get them running into a C program, and more specifically on the commands required.</p>
","87234","","<p><a href=""http://www.lighthouse3d.com/opengl/glsl/index.php?intro"" rel=""nofollow"">This</a> is the tutorial I learned shaders from. If I recall, the tutorial is C friendly. It covers both ARB and OpenGL 2.0 function methods.</p>
"
"<p>The C++ program</p>

<pre><code>#include &lt;complex&gt;
#include &lt;iostream&gt;

int main()
{
  std::complex&lt;double&gt; z(0,2);
  int n = 3;
  std::cout &lt;&lt; z * n &lt;&lt; std::endl;
}
</code></pre>

<p>yields an error: no match for ‘operator*’ in ‘z * n’. Why? </p>

<p>I'm compiling with g++ 4.4.1. Perhaps the compiler is just following the C++ standard, in which case my question is: why does the standard not allow this?</p>
","87234","","<p>This works:</p>

<pre><code>#include &lt;complex&gt;
#include &lt;iostream&gt;

int main()
{
    std::complex&lt;double&gt; z(0,2);
    double n = 3.0; // Note, double
    std::cout &lt;&lt; z * n &lt;&lt; std::endl;
}
</code></pre>

<p>Because complex is composed of doubles, it multiplies with doubles. Looking at the declaration:</p>

<pre><code>template &lt;typename T&gt;
inline complex&lt;T&gt; operator*(const complex&lt;T&gt;&amp;, const T&amp;);
</code></pre>

<p>(The following is thanks to <a href=""http://stackoverflow.com/users/36565/dribeas"">dribeas</a>) The compiler is not allowed to make implicit type conversions during template deduction, so by passing a <code>complex</code> with <strong>T</strong> being <code>double</code>, and then another <strong>T</strong> being <code>int</code>, when trying to match the function treating <strong>T</strong> as <code>double</code> causes the second argument to mis-match, and vice-versa.</p>

<p>For what you want to work, it would have to have a function defined similar to this:</p>

<pre><code>template &lt;typename T, typename U&gt;
inline std::complex&lt;T&gt; operator*(std::complex&lt;T&gt; lhs, const U&amp; rhs)
{
    return lhs *= rhs;
}
</code></pre>

<p>Which allows the function to take differing types, which allows the cast to be done when calling <code>operator*=</code>.</p>
"
"<p>I would like to do something like a simple and quick general console debugger. This small lib should be embedded to the main program.</p>

<p>So I would like to do stuff like this while running the program in console mode:</p>

<p>""input:  print i""
""output: 15.53""
""input:  set color 255""
""input:  print color""
""output: 255""</p>

<p>And both ""i"" and ""color"" would be pre-declared variables in-code. Its not an interpreter, just a handy way to check and modify variables contents.</p>

<p>GDB isn't a valid solution for my problem since I will use this code for computer graphics programs that I will code, so it need to be able to run in ""Release Mode"".</p>

<p>One very simple solution I have found so far is to just make a list of a structs that contains a void pointer, the pointer data type and a string which represents the variable name. But it wouldn't be as automatic as I imagine it could be.</p>

<p>Is there any way to convert a string, lets say ""color"", to obtain the address of the integer variable named color in C++? If not, how could I solve the problem?</p>
","87234","","<p>Variable names are for the programmer, and C++ doesn't store meta-data. (Data about the source code). You cannot access a variable by name at run-time.</p>

<p>That said, you could use something like <a href=""http://www.cplusplus.com/reference/stl/map/"" rel=""nofollow"">std::map</a> or unordered_map (either <a href=""http://en.wikipedia.org/wiki/Unordered%5Fmap%5F%28C%2B%2B%29"" rel=""nofollow"">tr1</a> or <a href=""http://www.boost.org/doc/libs/1%5F38%5F0/doc/html/unordered.html"" rel=""nofollow"">boost</a>), which gives you a key and value. The problem is that the value must be homogeneous in a container. This could be alleviated with the use of <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/doc/html/any.html"" rel=""nofollow"">Boost.Any</a>.</p>
"
"<p>I'm not sure what could be causing this.</p>

<pre><code>==18270== Invalid free() / delete / delete[]
==18270==    at 0x400576A: operator delete(void*) (vg_replace_malloc.c:342)
==18270==    by 0x80537F7: LCD::LCDControl::~LCDControl() (LCDControl.cpp:23)
==18270==    by 0x806C055: main (Main.cpp:22)
==18270==  Address 0x59e92c4 is 388 bytes inside a block of size 712 alloc'd
==18270==    at 0x40068AD: operator new(unsigned int) (vg_replace_malloc.c:224)
==18270==    by 0x8078033: LCD::DrvCrystalfontz::Get(std::string, LCD::LCDControl*, Json::Value*, std::string) (DrvCrystalfontz.cpp:652)
==18270==    by 0x8053F50: LCD::LCDControl::ConfigSetup() (LCDControl.cpp:71)
==18270==    by 0x80539F7: LCD::LCDControl::Start(int, char**) (LCDControl.cpp:31)
==18270==    by 0x806C025: main (Main.cpp:21)
</code></pre>

<p>Here's LCDControl's destructor where delete is called.</p>

<pre><code>LCDControl::~LCDControl() {
    Shutdown();
    for(std::vector&lt;std::string&gt;::iterator it = display_keys_.begin();
        it != display_keys_.end(); it++) {
        Error(""Deleting %s %p"", (*it).c_str(), devices_text_[*it]);
        if(devices_text_.find(*it) != devices_text_.end() &amp;&amp; devices_text_[*it])
            delete devices_text_[*it]; // line 23
    }
    //delete app_;
}
</code></pre>

<p>Here's Crystalfontz::Get()</p>

<pre><code>switch(m-&gt;GetProtocol()) {
    case 1:
        return new Protocol1(name, m, v, config);
        break;
    case 2:
        return new Protocol2(name, m, v, config); // line 652
        break;
    case 3:
        return new Protocol3(name, m, v, config, scab);
        break;
    default:
        Error(""Internal error. Model has bad protocol: &lt;%s&gt;"",
            m-&gt;GetName().c_str());
        break;
</code></pre>

<p>devices_text_: </p>

<pre><code>std::map&lt;std::string, Generic &lt;LCDText&gt;*&gt; devices_text_;
</code></pre>

<p>LCDControl::ConfigSetup(),</p>

<pre><code>void LCDControl::ConfigSetup() {
    if(!CFG_Get_Root()) return;
    Json::Value::Members keys = CFG_Get_Root()-&gt;getMemberNames();

    for(std::vector&lt;std::string&gt;::iterator it = keys.begin(); it != keys.end(); it++ ) {
        if(it-&gt;find(""display_"", 0) != std::string::npos) {
            Json::Value *display = CFG_Fetch_Raw(CFG_Get_Root(), it-&gt;c_str());
            Json::Value *driver = CFG_Fetch_Raw(display, ""driver"");
            if(!driver) {
                Error(""CFG: Must specify driver &lt;%s&gt;"", it-&gt;c_str());
                continue;
            }
            Json::Value *rows = CFG_Fetch_Raw(display, ""rows"", new Json::Value(-1));
            /*if(!rows-&gt;isNumeric() || rows-&gt;asInt() == -1) {
                Error(""Display &lt;%s&gt; requires number of rows to initialize."", it-&gt;c_str());
                delete display;
                delete driver;
                continue;
            }*/
            Json::Value *cols = CFG_Fetch_Raw(display, ""cols"", new Json::Value(-1));
            /*if(!cols-&gt;isNumeric() || rows-&gt;asInt() == -1) {
                Error(""Display &lt;%s&gt; requires number of columns to initialize."", it-&gt;c_str());
                delete display;
                delete driver;
                delete rows;
                continue;
            }*/

            Json::Value *model = CFG_Fetch_Raw(display, ""model"");
            if(driver-&gt;asString() == ""crystalfontz"") {
                if(model) {
                    devices_text_[*it] = DrvCrystalfontz::Get(*it, this,
                        CFG_Get_Root(), model-&gt;asString()); // line 71
                } else {
                    Error(""Device &lt;%s&gt; requires a model."", it-&gt;c_str());
                    delete display;
                    delete driver;
                    delete rows;
                    delete cols;
                    continue;
                }
            } else if(driver-&gt;asString() == ""qt"") {
                devices_text_[*it] = new DrvQt(*it, this, CFG_Get_Root(),
                    rows-&gt;asInt(), cols-&gt;asInt());

            } else if(driver-&gt;asString() == ""pertelian"") {
                //devices_text_[*it] = new DrvPertelian(this, CFG_Get_Root(), rows-&gt;asInt(), cols-&gt;asInt());

            } else
                continue;
            if(model) delete model;
            delete display;
            delete driver;
            delete rows;
            delete cols;
        }

    }

    for(std::map&lt;std::string, Generic&lt;LCDText&gt; *&gt;::iterator it =
        devices_text_.begin(); it != devices_text_.end(); it++) {
        display_keys_.push_back(it-&gt;first);
        Error(""Starting &lt;%s&gt; %p"", it-&gt;first.c_str(), it-&gt;second);
        Generic&lt;LCDText&gt; *device = it-&gt;second;
        device-&gt;CFGSetup(it-&gt;first);
        device-&gt;Connect();
        device-&gt;SetupDevice();
        device-&gt;BuildLayouts();
        device-&gt;StartLayout();
    }
}
</code></pre>
","87234","","<p>Instead of going through the keys, finding it in the map, then deleting it, why not just iterate through the map deleting as you go? I'd make a functor and use <code>for_each</code> (this isn't a guideline or anything, just my opinion),</p>

<pre><code>typedef Generic&lt;LCDText&gt; GenericLCDText;
typedef std::map&lt;std::string, GenericLCDText*&gt; GenericLCDTextMap;
typedef GenericLCDTextMap::value_type GenericLCDTextPair;

struct device_text_deleter : std::unary_function&lt;const GenericLCDTextPair&amp;, void&gt;
{
    void operator()(const GenericLCDTextPair&amp; pPair)
    {
        Error(""Deleting %s %p"", pPair.first.c_str(), pPair.second);

        delete pPair.second;        
    }
}

std::for_each(devices_text_.begin(), devices_text_.end(), device_text_deleter());
_devices.text_.clear(); // optional, removes the deleted pointers. unnecessary
                        // if this is run in the destructor, since map goes away
                        // shortly after
</code></pre>

<p>That said, you're code would be improved by the following:</p>

<pre><code>// typedef's for readability (would be in header, maybe private)
typedef std::vector&lt;std::string&gt; StringVector;
typedef Generic&lt;LCDText&gt; GenericLCDText;
typedef std::map&lt;std::string, GenericLCDText*&gt; GenericLCDTextMap;

for(StringVector::iterator it = display_keys_.begin();
    it != display_keys_.end(); it++)
{
    // find first! otherwise you're looking up the pair every time
    GenericLCDTextMap::iterator pair = devices_text_.find(*it);

    if (p != devices_text_.end())
    {
        // operator-&gt; is overloaded for iterators but might as well use
        // the pair now.
        Error(""Deleting %s %p"", pair-&gt;first.c_str(), pair-&gt;second);

        // no need to check for null, delete null is a-ok
        delete pair-&gt;second;
    }
}
</code></pre>

<p>Hopefully this will make it easier to spot the errors. Make sure any base classes you use have virtual destructors.</p>

<p>Check you haven't added a string in the vector twice (this would be ""fixed"" buy just iterating through the map, though you'll want to find out why duplicates exist in the first place), etc.</p>

<p>I've never tried this before, but maybe add a double delete macro thing (totally untested):</p>

<pre><code>#define DOUBLE_DELETE_GAURD static bool x = false; assert(x == false); x = true;
</code></pre>

<p>Then just add it to your destructor. If you double delete, and the static bool is still around, the assertion will fail. This is completely in undefined la-la land, though.</p>
"
"<p>I've run into some annoying issues with const-correctness in some templated code, that ultimately boils down to the following observation: for some reason, given an STL-ish Container type T, <code>const typename T::pointer</code> does not actually seem to yeild a constant pointer type, even if <code>T::pointer</code> is equivalent to <code>T::value_type*</code>.</p>

<p>The following example illustrates the problem.  Suppose you have a templated function that takes a Container which must meet the STL Random Access Container concept requirements.</p>

<pre><code>template &lt;class Container&gt;
void example(Container&amp; c)
{
    const typename Container::pointer p1 = &amp;c[0]; // Error if c is const
    const typename Container::value_type* p2 = &amp;c[0]; 
}
</code></pre>

<p>Then, if we pass this function a const container...</p>

<pre><code>const std::vector&lt;int&gt; vec(10);
example(vec);
</code></pre>

<p>...we get an invalid conversion from <code>const int*</code> to <code>int*</code>.  But why is <code>const typename Container::pointer</code> not the same as <code>const int*</code> in this example?</p>

<p>Note that if I change <code>const typename Container::pointer</code> to simply <code>typename Container::const_pointer</code> it compiles fine, however, as far as I can tell, the const_pointer typedef is an extension, (I don't see it mentioned in the C++ standard Container Requirements (23.5, Table 65)), and so therefore I don't want to use it.  </p>

<p>So how can I obtain a generic, const-correct pointer type from a container T? (I really can't see how to do this without using boost::mpl::if_ along with type_traits to check if the container is constant...but there must be a less verbose way to do this)</p>

<p>Edit: In case it matters, I'm using gcc 4.3.2 to compile this.</p>
","87234","","<p>This:</p>

<pre><code>typename Container::pointer
</code></pre>

<p>Has the type <code>int*</code> (in our case). I don't know the terminology, so sorry for that, but pointers point to a type. That is, <code>Container::pointer</code> is a pointer to a mutable T, and adding const is only going to make this a const pointer (not a pointer to const), because Container::pointer has already been defined to point to a mutable T.</p>

<p>It seems only <code>const_pointer</code>, either from the class or your own:</p>

<pre><code>typedef const typename Container::value_type* const_pointer
</code></pre>

<p>Will work.</p>
"
"<p>I need a function like <code>Sleep(time);</code> that pauses the program for X milliseconds, but in C++.</p>

<p>Please write which header to add and the function's signature. Thank you!</p>
","87234","","<p>Use <code>std::this_thread::sleep_for</code>:</p>

<pre><code>std::chrono::milliseconds timespan(111605); // or whatever

std::this_thread::sleep_for(timespan);
</code></pre>

<p>There is also the complimentary <code>std::this_thread::sleep_until</code>.</p>

<hr>

<p>Prior to C++11, C++ had no thread concept and no sleep capability, so your solution was necessarily platform dependent. Here's a snippet that defines a <code>sleep</code> function for Windows or Unix:</p>

<pre><code>#ifdef _WIN32
    #include &lt;windows.h&gt;

    void sleep(unsigned milliseconds)
    {
        Sleep(milliseconds);
    }
#else
    #include &lt;unistd.h&gt;

    void sleep(unsigned milliseconds)
    {
        usleep(milliseconds * 1000); // takes microseconds
    }
#endif
</code></pre>

<p>But a much simpler pre-C++11 method is to use <code>boost::this_thread::sleep</code>.</p>
"
"<p>At the moment my solution is to iterate through the map to solve this.</p>

<p>I see there is a <code>upper_bound</code> method which can make this loop faster, but is there a quicker or more succinct way?</p>
","87234","","<p>The end:</p>

<pre><code>m.rbegin();
</code></pre>

<p><a href=""http://en.cppreference.com/w/cpp/container/map"">Maps</a> (and sets) are sorted, so the first element is the smallest, and the last element is the largest. By default maps use <a href=""http://en.cppreference.com/w/cpp/utility/functional/less""><code>std::less</code></a>, but you can switch the comparer and this would of course change the position of the largest element. (For example, using <a href=""http://en.cppreference.com/w/cpp/utility/functional/greater""><code>std::greater</code></a> would place it at <code>begin()</code>.</p>

<p>Keep in mind <code>rbegin</code> returns an iterator. To get the actual key, use <code>m.rbegin()-&gt;first</code>. You <em>might</em> wrap it up into a function for clarity, though I""m not sure if it's worth it:</p>

<pre><code>template &lt;typename T&gt;
inline const typename T::key_type&amp; last_key(const T&amp; pMap)
{
    return pMap.rbegin()-&gt;first;
}

typedef std::map&lt;/* types */&gt; map_type;

map_type myMap;
// populate

map_type::key_type k = last_key(myMap);
</code></pre>
"
"<p>Is boost::object_pool synchronized?</p>
","87234","","<p>C++ doesn't specify anything about thread-safety, so if it isn't mentioned it likely doesn't deal with threading. Sometimes, Boost provides things that can be thread-safe out of the box, this is not one of them.</p>

<p>Wrap access to the pool in a <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/libs/pool/doc/implementation/mutex.html"" rel=""nofollow"">mutex</a>.</p>
"
"<p>I am using C++ to create a string class. I want the class to only accept the data types char and wchar_t and I want the compiler to catch any invalid data types during compile time using #error. I do not like using assert( ). How can I do this?</p>
","87234","","<p>You can use a static assert. Boost <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/doc/html/boost%5Fstaticassert.html"">provides one</a>.</p>

<p>Maybe something like:</p>

<pre><code>#include &lt;boost/type_traits.hpp&gt;
#include &lt;boost/static_assert.hpp&gt;

template &lt;typename T&gt;
class my_string
{
public:
    // ...
private:
    BOOST_STATIC_ASSERT((boost::is_same&lt;T, char&gt;::value ||
                          boost::is_same&lt;T, wchar_t&gt;::value));
};

int main(void)
{
    my_string&lt;char&gt; chstr;
    my_string&lt;wchar_t&gt; wstr;

    // fails
    my_string&lt;int&gt; istr;
}
</code></pre>

<p>If you can't use Boost, you can easily remake static-assert and <code>is_same</code>:</p>

<pre><code>// static assert failure
template &lt;bool Predicate&gt;
struct STATIC_ASSERT_FAILURE;

template &lt;&gt;
struct STATIC_ASSERT_FAILURE&lt;true&gt; {}; // only true is defined

// static assert test
template &lt;unsigned TestResult&gt;
struct static_assert {};

// static assert macro
#define STATIC_ASSERT(x) typedef static_assert&lt; \
                          sizeof(STATIC_ASSERT_FAILURE&lt;(x)&gt;)&gt; \
                          _static_assert_test_

// value is true if T and U are the same type
template &lt;typename T, typename U&gt;
struct is_same
{
    static const bool value = false;
};

template &lt;typename T&gt;
struct is_same&lt;T, T&gt;
{
    static const bool value = true;
};

template &lt;typename T&gt;
class my_string
{
public:
    // ...
private:
    STATIC_ASSERT((is_same&lt;T, char&gt;::value || is_same&lt;T, wchar_t&gt;::value));
};

int main(void)
{
    my_string&lt;char&gt; chstr;
    my_string&lt;wchar_t&gt; wstr;

    // fails
    my_string&lt;int&gt; istr;
}
</code></pre>

<p>Note, if you use a static assert in the same namespace twice, you'll get a name collision. You' have to use a more sophisticated version that uses a macro such as <code>__COUNTER__</code> to generate unique names.</p>

<p>The above works in both GCC 4.4 and Visual Studio 2008.</p>
"
"<p>Using g++ and having linker errors.  I have a simple program in split into two modules: main.cpp and Dice.h Dice.cpp.</p>

<p>main.cpp:</p>

<pre><code>#include &lt;iostream&gt;
#include ""Dice.h""

int main(int argc, char **argv) {

    int dieRoll = Dice::roll(6);
    std::cout&lt;&lt;dieRoll&lt;&lt;std::endl;

    std::cin.get();

    return 0;
}
</code></pre>

<p>Dice.h:</p>

<pre><code>#ifndef DieH
#define DieH

namespace Dice
{
    int roll(unsigned int dieSize);
}

#endif
</code></pre>

<p>Dice.cpp:</p>

<pre><code>#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
#include ""Dice.h""

namespace Dice
{
    int roll(unsigned int dieSize)
    {
    	if (dieSize == 0)
    	{
    		return 0;
    	}
    	srand((unsigned)time(0));
    	int random_int = 0;
    	random_int = rand()%dieSize+1;

    	return random_int;
    }
}
</code></pre>

<p>I compile and link these files using g++ as follows:</p>

<pre><code>g++ -o program main.cpp Dice.cpp
</code></pre>

<p>And I get the following linker error:</p>

<pre><code>Undefined symbols:
""Dice::roll(int)"", referenced from:
  _main in ccYArhzP.o
ld: symbol(s) not found
collect2: ld returned 1 exit status
</code></pre>

<p>I'm completely flummoxed. Any help would be greatly appreciated.</p>
","87234","","<p>Your code is well-formed.</p>

<p>Ensure that your don't have conflicting file names, the files exist and contain what you think they do. For example, perhaps you have a <code>Dice.cpp</code> that's empty, and you're editing a newly created one somewhere else.</p>

<p>Minimize possible discrepancy by removing unnecessary files; only have <code>main.cpp</code>, <code>dice.h</code>, and <code>dice.cpp</code>.</p>

<p>Your errors do not match your code: <code>""Dice::roll(int)""</code>. Observe that this is looking for an <code>int</code>, but your functions take an <code>unsigned int</code>. Make sure your header matches.</p>

<p><hr /></p>

<p>Try the following:</p>

<pre><code>g++ main.cpp -c
</code></pre>

<p>This will generate <code>main.o</code>, the compiled but not-linked code for main. Do the same with <code>dice.cpp</code>:</p>

<pre><code>g++ dice.cpp -c
</code></pre>

<p>You now have two object files that need to be linked together. Do so with:</p>

<pre><code>g++ main.o dice.o
</code></pre>

<p>And see if that works. If not, do the following:</p>

<pre><code>nm main.o dice.o
</code></pre>

<p>This will list all the available symbols in an object, and should give you something like this:</p>

<pre><code>main.o:
00000000 b .bss
00000000 d .ctors
00000000 d .data
00000000 r .eh_frame
00000000 t .text
00000098 t __GLOBAL__I_main
00000069 t __Z41__static_initialization_and_destruction_0ii
         U __ZN4Dice4rollEj
         U __ZNSi3getEv
         U __ZNSolsEPFRSoS_E
         U __ZNSolsEi
         U __ZNSt8ios_base4InitC1Ev
         U __ZNSt8ios_base4InitD1Ev
         U __ZSt3cin
         U __ZSt4cout
         U __ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
00000000 b __ZStL8__ioinit
         U ___gxx_personality_v0
         U ___main
00000055 t ___tcf_0
         U _atexit
00000000 T _main

dice.o:
00000000 b .bss
00000000 d .data
00000000 t .text
00000000 T __ZN4Dice4rollEj
         U _rand
         U _srand
         U _time
</code></pre>

<p>C++ mangles function names, which is why everything looks so weird. (Note, there is no standard way of <a href=""http://en.wikipedia.org/wiki/Name%5Fmangling"" rel=""nofollow"">mangling names</a>, this is how GCC 4.4 does it). </p>

<p>Observe that <code>dice.o</code> and <code>main.o</code> refer to the same symbol: <code>__ZN4Dice4rollEj</code>. If these do not match, that's your problem. For example, if I change part of <code>dice.cpp</code> to be this:</p>

<pre><code>// Note, it is an int, not unsigned int
int roll(int dieSize)
</code></pre>

<p>Then <code>nm main.o dice.o</code> produces the following:</p>

<pre><code>main.o:
00000000 b .bss
00000000 d .ctors
00000000 d .data
00000000 r .eh_frame
00000000 t .text
00000098 t __GLOBAL__I_main
00000069 t __Z41__static_initialization_and_destruction_0ii
         U __ZN4Dice4rollEj
         U __ZNSi3getEv
         U __ZNSolsEPFRSoS_E
         U __ZNSolsEi
         U __ZNSt8ios_base4InitC1Ev
         U __ZNSt8ios_base4InitD1Ev
         U __ZSt3cin
         U __ZSt4cout
         U __ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
00000000 b __ZStL8__ioinit
         U ___gxx_personality_v0
         U ___main
00000055 t ___tcf_0
         U _atexit
00000000 T _main

dice.o:
00000000 b .bss
00000000 d .data
00000000 t .text
00000000 T __ZN4Dice4rollEi
         U _rand
         U _srand
         U _time
</code></pre>

<p>Note, this gives two different symbols. <code>main.o</code> looking for this: <code>__ZN4Dice4rollEj</code> and <code>dice.o</code> containing this <code>__ZN4Dice4rollEi</code>. (The last letter differs).</p>

<p>When trying to compile these mismatched symbols (with <code>g++ main.o dice.o</code>), I get:</p>

<pre><code>undefined reference to `Dice::roll(unsigned int)'
</code></pre>
"
"<p>When the compiler sees this code:</p>

<pre><code>SomeClass foo;
int x = foo.bar;
</code></pre>

<p>What is the process it goes about in retrieving the value of <em>bar</em>? I.e. does it look at some data structure representing the class definition? If so is this data structure generated at compile time or runtime?</p>
","87234","","<p>The compiler has the address of <code>foo</code>. At that address, there is enough space for member variables (<code>sizeof(SomeClass)</code>), which probably includes some padding.</p>

<p>It knows that `bar is at some position in the class (usually the order they were declared, plus some other magic like inheritance), and jumps to that offset.</p>

<p>That is:</p>

<pre><code>struct SomeClass
{
    short s;
    float f;
    int bar;
    char *c;
}

// pseudo-code:
&amp;SomeClass.bar == (&amp;SomeClass) + sizeof(short) + sizeof(float);
</code></pre>

<p>At run-time, it gets that data, and assigns it to <code>x</code></p>
"
"<p>I am confused.</p>

<p>I do this:</p>

<pre><code>#include &lt;vector&gt;

// List iteration
typedef vector&lt;registeredObject&gt;::iterator iterator;
typedef vector&lt;registeredObject&gt;::const_iterator const_iterator;
vector&lt;registeredObject&gt;::iterator begin(void);
vector&lt;registeredObject&gt;::const_iterator begin(void) const;
vector&lt;registeredObject&gt;::iterator end(void);
vector&lt;registeredObject&gt;::const_iterator end(void) const;
</code></pre>

<p>I get errors like: </p>

<pre><code>.: error: ISO C++ forbids declaration of 'vector' with no type
.: error: expected ';' before '&lt;' token
</code></pre>

<p>for each one of the above uses of vector. This code compiles in older CodeWarrior, but XCode complains. What is the issue? </p>

<p>Is there a good reference?</p>

<p>[EDIT] Here is the entire header <a href=""http://www.sheldony.com/header.txt"" rel=""nofollow"">Here</a></p>
","87234","","<p><a href=""http://www.cplusplus.com/reference/stl/vector/"" rel=""nofollow""><code>vector</code></a> is in the namespace <code>std</code>:</p>

<pre><code>typedef std::vector&lt;registeredObject&gt;::iterator iterator;
</code></pre>

<p>Also, why are you defining these types then not using them?</p>

<pre><code>typedef std::vector&lt;registeredObject&gt; container;
typedef container::iterator iterator;
typedef container::const_iterator const_iterator;

iterator begin(void);
const_iterator begin(void) const;
iterator end(void);
const_iterator end(void) const;
</code></pre>

<p>Also consider that perhaps you haven't defined <code>registeredObject</code>. Try with <code>int</code> to make sure.</p>

<p><hr></p>

<p>Now that we see <code>registeredObject</code> is a template parameter, you need <code>typename</code>:</p>

<pre><code>typedef typename std::vector&lt;registeredObject&gt; container;
typedef typename container::iterator iterator;
typedef typename container::const_iterator const_iterator;
</code></pre>

<p><a href=""http://pages.cs.wisc.edu/~driscoll/typename.html"" rel=""nofollow"">Here's why.</a> Don't forget the other things, though. You still need <code>std::</code>, and to actually use your defined types. (This must be fixed in both of your classes.)</p>

<p>Note it is <strong>much</strong> more common to use <code>T</code> as the template type. It's then also common to be generous with your <code>typedef</code>'s:</p>

<pre><code>typedef T value_type;
typedef std::vector&lt;value_type&gt; container;
typedef typename container::iterator iterator;
typedef typename container::const_iterator const_iterator;
</code></pre>

<p>And use these in your class. (i.e., use <code>container mRegistryList;</code> instead)</p>
"
"<p>When I build my project it compiles well, but when Linking it throws huge number of LNK errors! error LNK2001, error LNK2005, error LNK2019 were there in the error list</p>

<pre><code>&gt;Linking...
1&gt;MultiCatAttributeInfo.obj : error LNK2019: unresolved external symbol ""public: class std::vector&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;,class std::allocator&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt; &gt; __thiscall MultiCatItem::value(void)const "" (?value@MultiCatItem@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ) referenced in function ""public: virtual class boost::dynamic_bitset&lt;unsigned long,class std::allocator&lt;unsigned long&gt; &gt; __thiscall MultiCatAttributeInfo::encode(class Item *)"" (?encode@MultiCatAttributeInfo@@UAE?AV?$dynamic_bitset@KV?$allocator@K@std@@@boost@@PAVItem@@@Z)
</code></pre>

<p>how do I overcome this problem? Im using visual studio 2008, my solution has several projects; all give Linking errors like above!!!</p>
","87234","","<p>Well, it looks like you're not linking some files in. Have you checked to make sure you're actually compiling all of your source files?</p>

<p>It's hard to say anything specific without any code.</p>
"
"<p>If I have an array and I need to display how many times the number '12' is created. I'm using a function to go about this. What resources should I look into to find how to exactly tease out this one number and display how many times it is in the array/list? Any help would be greatly appreciated.</p>
","87234","","<p>You can do it by walking through the array, while keeping a tally.</p>

<p>The tally starts at 0, and every time you reach the number you want to track, add one to it. When you're done, the tally contains the number of times the number appeared.</p>

<p>Your function definition would probably look something like this:</p>

<pre><code>int count_elements(int pElement, int pArray[], size_t pSize);
</code></pre>
"
"<p>How do you go about creating a sphere with meshes in Direct-x?  I'm using C++ and the program will be run on windows, only.</p>

<p>Everything is currently rendered through an IDiRECT3DDEVICE9 object.</p>
","87234","","<p>You could use the <a href=""http://doc.51windows.net/Directx9%5FSDK/?url=/directx9%5Fsdk/graphics/reference/d3dx/functions/shape/d3dxcreatesphere.htm"" rel=""nofollow""><code>D3DXCreateSphere</code></a> function.</p>
"
"<p>I think I messed up somehow in my design because I want to keep a vector of various object types. These types all share a common base class. Example:</p>

<pre><code>Class Buick: AmericanCar
{
}

Class Ford: AmericanCar
{
}
</code></pre>

<p>then I did:</p>

<pre><code>vector&lt;AmericanCar*&gt; cars_i_own;
</code></pre>

<p>Now, I have my vector of pointers but I don't have the derived class which is what I need. I thought about adding a GetType/SetType function to the base class and then use a dynamic cast. This is clunky though. Did i use the wrong design for this?</p>
","87234","","<p>Well, what are you trying to do with it? Get the name or cost? You would have something like:</p>

<pre><code>class Car
{
public:
    virtual ~Car(void) {}

    virtual std::string location(void) const = 0;
    virtual std::string name(void) const = 0;
    virtual double cost(void) const = 0;
}

class AmericanCar
{
public:
    virtual ~AmericanCar(void) {}

    virtual std::string location(void) const
    {
        return ""America"";
    }
}

class Buick : public AmericanCar
{
public:
    virtual std::string name(void) const
    {
        return ""Buick"";
    }

    virtual double cost(void) const
    {
        return /* ... */;
    }
}

class Ford : public AmericanCar
{
public:
    virtual std::string name(void) const
    {
        return ""Ford"";
    }

    virtual double cost(void) const
    {
        return /* ... */;
    }
}
</code></pre>

<p>Now you can call these methods polymorphically.</p>

<p>This is somewhat strange, though. You don't need a different class to store names and cost like this:</p>

<pre><code>class Car
{
public:
    Car(const std::string&amp; pLocation,
        const std::string&amp; pName,
        double pCost) :
    mLocation(pLocation),
    mName(pName),
    mCost(pCost)
    {
    }

    const std::string&amp; location(void) const
    {
        return mLocation;
    }

    void location(const std::string&amp; pLocation)
    {
        mLocation = pLocation;
    }

    const std::string&amp; name(void) const
    {
        return mName;
    }

    void name(const std::string&amp; pName)
    {
        mName = pName;
    }

    const double cost(void) const
    {
        return mCost;
    }

    void cost(double pCost)
    {
        mCost = pCost;
    }

private:
    std::string mLocation;
    std::string mName;
    double mCost;
}

// make cars
std::vector&lt;Car&gt; cars;
cars.push_back(Car(""America"", ""Buick"", /* ... */));
</code></pre>
"
"<p>I have the following class CppProperty class that holds value:</p>

<pre><code>template&lt;typename TT&gt;
class CppProperty
{
    TT val;
public:
    CppProperty(void)
    {
    }

    CppProperty(TT aval) : val(aval)
    {
    }

    CppProperty(const CppProperty &amp; rhs)
    {
        this-&gt;val = rhs.val;
    }

    virtual ~CppProperty(void)
    {
    }

    TT operator=(TT aval)
    {
        this-&gt;val = aval;
        return this-&gt;val;
    }

    friend TT operator++(CppProperty &amp; rhs);
    friend TT operator--(CppProperty &amp; rhs);
    friend TT operator++(CppProperty &amp; rhs, int);
    friend TT operator--(CppProperty &amp; rhs, int);

    //template&lt;typename RR&gt;
    //friend RR operator=(RR &amp; lhs, const CppProperty &amp; rhs);
    //friend int &amp; operator=(int &amp; lhs, const CppProperty &amp; rhs);
    //int reinterpret_cast&lt;int&gt;(const CppProperty &amp; rhs);
};
</code></pre>

<p>I want to do assignment like this:</p>

<pre><code>CppProperty&lt;char&gt; myproperty(10);
myproperty++;
int count = myproperty;
</code></pre>

<p>How this can be done? I can't override the operator=. Any help is greatly appreciated! Thank you!</p>
","87234","","<p>You'd need a conversion operator:</p>

<pre><code>operator const TT&amp;(void) const
{
    return val;
}


operator TT&amp;(void)
{
    return val;
}
</code></pre>

<p>There is a brief tutorial on conversion operators <a href=""http://www.learncpp.com/cpp-tutorial/910-overloading-typecasts/"" rel=""nofollow"">here</a>. In short, when the compiler tries to convert a type, it will first look at the right-hand side for an operator that will convert it to the desired type. What we are doing is saying ""Whatever <code>TT</code> is, this class can be converted to it"".</p>

<p>If no operators are found, it looks to see if the left-hand side can be constructed from the right-hand side, and so on. (Until, if it cannot find a conversion, it emits an error.)</p>

<p><hr></p>

<p>You can remove your explicitly defined default constructor if you declare your other constructor like this:</p>

<pre><code>// If not specified, construct with default-constructed type.
CppProperty(TT aval = TT()) : val(aval)
{
}
</code></pre>
"
"<p>leisure/curiosity question as implied in the title.</p>

<p>I personally prefer the new operators as to make code more readable in my opinion.</p>

<p>Which ones do use yourself?  What is your reason for choosing one over the other one?</p>

<p>also Emacs highlights those operators differently so I get more visual feedback when looking at the screen.  I know the old operators can be highlighted as well but the ISO646 highlighted by default</p>
","87234","","<p>Are you referring to the alternative tokens originating from <a href=""http://www.cplusplus.com/reference/clibrary/ciso646/"" rel=""nofollow""><code>iso646.h</code></a>? </p>

<p>They are from C and it's very uncommon to see, therefore likely to be less readable by most. I'm sure if we had been ""raised"" with these keywords they'd be more common, since they read like English better.</p>

<p>Then again, <code>&amp;&amp;</code> lets non-English speakers say ""and"" in their native tongue. (Not that this was a concern in the keywords in the first place.)</p>
"
"<p>Obviously the point of using named constants over magic numbers is for code clarity and for not having to go through code changing numbers throughout.</p>

<p>However, what do you do if you just have a number used just once in a function? Say you have a short member function that uses an object's velocity (which we'll say won't change) to calculate its motion, but this is the only function that uses that velocity. Would you...</p>

<p>A) Give the class a named static constant to use</p>

<p>B) Put a named constant in the function</p>

<p>C) Use the magic number but comment it</p>

<p>D) Other...</p>

<p>I am kind of leaning towards using a magic number and commenting it if the number is ONLY BEING USED ONCE, but I'd like to hear others' thoughts.</p>

<p>Edit: Does putting a named constant in a function called many times and assigning to it have performance implications? If it does I guess the best approach would be to put the constant in a namespace or make it a class variable, etc.</p>
","87234","","<p>Just move it up:</p>

<pre><code>void do_something(void)
{
    const float InitialVelocity = 5.0f;

    something = InitialVelocity;
    // etc.
}
</code></pre>
"
"<p>I port a middle-sized application from C to C++. It doesn't deal anywhere with exceptions, and that shouldn't change.</p>

<p>My (wrong!) understanding of C++ was (until I learned it the hard way yesterday) that the (default) new operator returns a NULL pointer in case of an allocation problem. However, that was only true until 1993 (or so). Nowadays, it throws a std::bad_alloc exception.</p>

<p><strong>Is it possible to return to the old behavior without rewriting everything to using std::nothrow on every single call?</strong></p>
","87234","","<p>You could overload operator new:</p>

<pre><code>#include &lt;vector&gt;

void *operator new(size_t pAmount) // throw (std::bad_alloc)
{
    // just forward to the default no-throwing version.
    return ::operator new(pAmount, std::nothrow);
}

int main(void)
{
    typedef std::vector&lt;int&gt; container;

    container v;
    v.reserve(v.max_size()); // should fail
}
</code></pre>
"
"<p>While considering O(log(N)) for time complexity, what is the base of log?</p>
","87234","","<p>All logarithms are related by some constant. (Hence the <a href=""http://en.wikipedia.org/wiki/Logarithm#Change%5Fof%5Fbase"" rel=""nofollow"">change-of-base formula</a>). Because we generally disregard constants in complexity analysis, the base doesn't matter.</p>

<p>Usually, the base is considered to be 2, when deriving the algorithm. Consider a sort like <a href=""http://en.wikipedia.org/wiki/Merge%5Fsort"" rel=""nofollow"">merge sort</a>. You can construct a <a href=""http://en.wikipedia.org/wiki/Binary%5Ftree#Properties%5Fof%5Fbinary%5Ftrees"" rel=""nofollow"">tree</a> out of it, and the tree has a height of <code>log₂ n</code>, because each node has two branches.</p>
"
"<p>I have a destructor that performs some necessary cleanup (it kills processes).  It needs to run even when SIGINT is sent to the program.  My code currently looks like:</p>

<pre><code>typedef boost::shared_ptr&lt;PidManager&gt; PidManagerPtr
void PidManager::handler(int sig)
{
  std::cout &lt;&lt; ""Caught SIGINT\n"";
  instance_.~PidManagerPtr();  //PidManager is a singleton
  exit(1);
}
//handler registered in the PidManager constructor
</code></pre>

<p>This works, but there seem to be numerous warnings against explicitly calling a destructor.  Is this the right thing to do in this situation, or is there a ""more correct"" way to do it?</p>
","87234","","<p>If that object is a singleton, you don't need to use a shared-pointer. (There's only one!)</p>

<p>If you switch it to <a href=""http://www.cplusplus.com/reference/std/memory/auto%5Fptr/"" rel=""nofollow""><code>auto_ptr</code></a> you can call <code>release()</code> on it. Or perhaps <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/libs/smart%5Fptr/scoped%5Fptr.htm"" rel=""nofollow""><code>scoped_ptr</code></a>, calling <code>reset()</code>.</p>

<p>This all said, I'm 99% certain that <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/exit/"" rel=""nofollow""><code>exit()</code></a> will destruct statically constructed objects. (Which singletons tend to be.) What I do know is that <code>exit()</code> calls the registered <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/atexit/"" rel=""nofollow""><code>atexit()</code></a> functions.</p>

<p>If your singleton is not destructed automatically by exit, the proper thing to do in your case is to make an <code>atexit</code> hook:</p>

<pre><code>void release_singleton(void)
{
    //instance_.release();
    instance_.reset();
}

// in main, probably
atexit(release_singleton);
</code></pre>
"
"<p>I am trying to build/run an old C++ system. I've already been able to built it in Ubuntu 9.10 with g++4.4</p>

<p>Now I'm trying to build in Ubuntu 8.04 with g++4.2. And I am getting the following errors:</p>

<pre><code>stringmap.h:353: erro: ISO C++ forbids declaration of ‘iterator’ with no type
stringmap.h:353: erro: extra qualification ‘stringmap&lt;_Tp&gt;::’ on member ‘iterator’
stringmap.h:353: erro: expected ‘;’ before ‘begin’
stringmap.h:354: erro: ISO C++ forbids declaration of ‘iterator’ with no type
stringmap.h:354: erro: extra qualification ‘stringmap&lt;_Tp&gt;::’ on member ‘iterator’
stringmap.h:354: erro: expected ‘;’ before ‘end’
stringmap.h:386: erro: no ‘typename stringmap&lt;_Tp&gt;::iterator stringmap&lt;_Tp&gt;::begin()’ member function declared in class ‘stringmap&lt;_Tp&gt;’
stringmap.h:386: erro: template definition of non-template ‘typename stringmap&lt;_Tp&gt;::iterator stringmap&lt;_Tp&gt;::begin()’
stringmap.h:398: erro: no ‘typename stringmap&lt;_Tp&gt;::iterator stringmap&lt;_Tp&gt;::end()’ member function declared in class ‘stringmap&lt;_Tp&gt;’
stringmap.h:398: erro: template definition of non-template ‘typename stringmap&lt;_Tp&gt;::iterator stringmap&lt;_Tp&gt;::end()’
In file included from Ccolumn.h:7,
                 from Ccolumn.cpp:1:
intmap.h:395: erro: ISO C++ forbids declaration of ‘iterator’ with no type
intmap.h:395: erro: extra qualification ‘intmap&lt;_Tp&gt;::’ on member ‘iterator’
intmap.h:395: erro: expected ‘;’ before ‘begin’
intmap.h:396: erro: ISO C++ forbids declaration of ‘iterator’ with no type
intmap.h:396: erro: extra qualification ‘intmap&lt;_Tp&gt;::’ on member ‘iterator’
intmap.h:396: erro: expected ‘;’ before ‘end’
intmap.h:429: erro: no ‘typename intmap&lt;_Tp&gt;::iterator intmap&lt;_Tp&gt;::begin()’ member function declared in class ‘intmap&lt;_Tp&gt;’
intmap.h:429: erro: template definition of non-template ‘typename intmap&lt;_Tp&gt;::iterator intmap&lt;_Tp&gt;::begin()’
intmap.h:441: erro: no ‘typename intmap&lt;_Tp&gt;::iterator intmap&lt;_Tp&gt;::end()’ member function declared in class ‘intmap&lt;_Tp&gt;’
intmap.h:441: erro: template definition of non-template ‘typename intmap&lt;_Tp&gt;::iterator intmap&lt;_Tp&gt;::end()’
Ccolumn.cpp: In static member function ‘static void Ccolumn::finish_vector_norm()’:
Ccolumn.cpp:427: erro: ‘class intmap&lt;Ccolumn*&gt;’ has no member named ‘begin’
Ccolumn.cpp:427: erro: ‘class intmap&lt;Ccolumn*&gt;’ has no member named ‘end’
Ccolumn.cpp: In static member function ‘static void Ccolumn::updateCommonColumnNameList(std::string, int)’:
Ccolumn.cpp:461: erro: ‘class intmap&lt;bool&gt;’ has no member named ‘begin’
Ccolumn.cpp:461: erro: ‘class intmap&lt;bool&gt;’ has no member named ‘end’
</code></pre>

<p>Both stringmap and intmap seems to be having the same problem. The lines the are giving the error are:</p>

<pre><code>stringmap&lt;_Tp&gt;::iterator begin();
stringmap&lt;_Tp&gt;::iterator end();
</code></pre>

<p>Here is the code for stringmap.h (its long):</p>

<pre><code>/******************************************************************************

 A hashed associative array.  This version is string-keyed.

 Features:

 - values are templated and hence generic
 - smart sizing and linear probing, based on optimal primes as described at
   http://planetmath.org/encyclopedia/GoodHashTablePrimes.html
 - comes with iterator
 - exists() and defined() calls, a-la perl
 - resizing, both upwards and downwards

******************************************************************************/

#ifndef _STRINGMAP_H__
#define _STRINGMAP_H__

#include &lt;iostream&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

#include ""hash.h""

using namespace std;

// string key special values 
//
#define VACATED ""???""
#define EMPTY ""!!!""

// the following expects a string argument x
//
#define OCCUPIED(x) ((x != EMPTY) &amp;&amp; (x != VACATED))

// the stringmap class
// 
template &lt;class _Tp&gt; class stringmap {
protected:
    vector&lt;string&gt; _keys;
    vector&lt;_Tp&gt; _values;

    unsigned int probe;		// linear probing increment

    unsigned int size;		// array size allocated for storage
    unsigned int size_idx;	// index of current size in hash primes table
    unsigned int minsize;	// min and max array size
    unsigned int maxsize;				

    unsigned int filled;	// used cells in the array

    _Tp undef_val;			// value of template type to return for undefined
    						// index value.

    unsigned int total_lookups;
    unsigned int total_attempts;

    unsigned int hash_func( string );	// the hash function

    // hash table position getter (w/probing).  _set = 1 if the goal is to 
    // set a value (changes behavior for vacated tombstones). basically
    // all of this fanciness enables us to avoid scanning the entire table 
    // when looking for a non-stored key.
    //
    unsigned int index_of( string _key, int _set);	

    void grow();			// grow the table up to the next level
    void shrink();			// shrink the table down to the next level

public:

    unsigned int index_of( string );	// this version assumes _set = 0

    // an iterator
    //
    class iterator {

    protected:

    	// container we are connected to
    	stringmap&lt;_Tp&gt;* parent;

    	int index;	// index into the stringmap

    	// increment index to next populated hash entry (or end)
    	void increment() {
    		if (!parent) return;

    		if (index == parent-&gt;last_index()) 
    			index++;
    		else 
    			for (string key = EMPTY; index &lt; parent-&gt;last_index() &amp;&amp; !OCCUPIED(key); ++index, key = parent-&gt;key_real(index));
    	}

    	// decrement index to next populated hash entry (stops at begin)
    	void decrement () {

    		if (!parent) return;

    		int i = index;
    		for (string key = EMPTY; i &gt; 0 &amp;&amp; !OCCUPIED(key); --i, key = parent-&gt;key_real(i));

    		// only change index if stopping point is populated.
    		if (OCCUPIED(key_real(i))) {
    			index = i;
    		}
    	}


    public:

    	// constructors
    	iterator() : parent(NULL), index(0) {}	
    	iterator(int _index) : parent(NULL), index(_index) {}	
    	iterator(stringmap&lt;_Tp&gt;* _parent) : parent(_parent), index(0) {}
    	iterator(stringmap&lt;_Tp&gt;* _parent, int _index) : parent(_parent), index(_index) {}

    	// iterator scan operations
    	void operator+=(int _n) { for (int i = 0; i &lt; _n; i++) increment(); }
    	void operator-=(int _n) { for (int i = 0; i &lt; _n; i--) decrement(); }
    	void operator--() { decrement(); }
    	void operator--(int) { decrement(); }
    	void operator++() { increment(); }
    	void operator++(int) { increment(); }

    	// comparisons
    	int operator==(const stringmap&lt;_Tp&gt;::iterator&amp; a) { return index == a.index; }
    	int operator!=(const stringmap&lt;_Tp&gt;::iterator&amp; a) { return index != a.index; }
    	int operator&lt;(const stringmap&lt;_Tp&gt;::iterator&amp; a) { return index &lt; a.index; }
    	int operator&gt;(const stringmap&lt;_Tp&gt;::iterator&amp; a) { return index &gt; a.index; }
    	int operator&lt;=(const stringmap&lt;_Tp&gt;::iterator&amp; a) { return index &lt;= a.index; }
    	int operator&gt;=(const stringmap&lt;_Tp&gt;::iterator&amp; a) { return index &gt;= a.index; }
    	int operator==(int _index) { return index == _index; }
    	int operator!=(int _index) { return index != _index; }
    	int operator&lt;(int _index) { return index &lt; _index; }
    	int operator&gt;(int _index) { return index &gt; _index; }
    	int operator&lt;=(int _index) { return index &lt;= _index; }
    	int operator&gt;=(int _index) { return index &gt;= _index; }

    	// value reference (retrieve value from parent class at this pos)
    	_Tp&amp; operator*() {
    		return parent-&gt;value_real(index);
    	}

    	// get the key of the current index (or EMPTY)
    	string get_key() {
    		string key = parent-&gt;key_real(index);

    		if (OCCUPIED(key)) return key;

    		return EMPTY;
    	}

    	// copy
    	void operator=(const stringmap&lt;_Tp&gt;::iterator&amp; a) { 
    		index = a.index; 
    		parent = a.parent;
    	}

    	// misc
    	void set_parent(stringmap&lt;_Tp&gt;* _parent) { parent = _parent; }

    };

    /* iterator ENDS */

    friend class iterator; // iterators can see our privates

    // copy constructor
    //
    stringmap(const stringmap&lt;_Tp&gt;&amp; from) {

    	_keys = from._keys;
    	_values = from._values;

    	probe = from.probe;
    	size = from.size;
    	size_idx = from.size_idx;
    	minsize = from.minsize;
    	maxsize = from.maxsize;

    	filled = from.filled;
    	undef_val = from.undef_val;

    	// start efficiency off anew
    	total_lookups = 0;
    	total_attempts = 0;
    }

    // almost do-nothing constructor. just init to sane defaults.
    stringmap(_Tp _undef_val) :
    	_keys(PRIMES[0], EMPTY),				
    	_values(PRIMES[0], _undef_val),
    	size_idx(0),
    	minsize(PRIMES[0]),
    	maxsize(PRIMES[MAX_PRIME_IDX]),
    	undef_val(_undef_val),
    	filled(0),
    	total_attempts(0),
    	total_lookups(0) {  

    	// init size stuff
    	// 
    	size = PRIMES[size_idx];

    	// initialize probe interval
    	//
    	probe = int(size/4) + 1;
    }

    // constructor without max or min size
    stringmap(int _startsize, _Tp _undef_val) : 
    	_keys(0, EMPTY),				
    	_values(0 , _undef_val),
    	minsize(PRIMES[0]),
    	maxsize(PRIMES[MAX_PRIME_IDX]),
    	undef_val(_undef_val),
    	filled(0) { 

    	// init size stuff
    	// 
    	size_idx = nearest_prime_index(_startsize);
    	size = PRIMES[size_idx];

    	// init vectors
    	//
    	_keys.resize(size, EMPTY);
    	_values.resize(size, _undef_val);

    	// initialize probe interval
    	//
    	probe = int(size/4) + 1;

    	// init statistics stuff
    	//
    	total_attempts = 0;
    	total_lookups = 0;
    }

    // full constructor
    stringmap(int _minsize, int _maxsize, int _startsize, _Tp _undef_val) : 
    	_keys(0, EMPTY),				
    	_values(0 , _undef_val),
    	minsize(_minsize),
    	maxsize(_maxsize),
    	undef_val(_undef_val),
    	filled(0) { 

    	// init size stuff
    	// 
    	size_idx = nearest_prime_index(_startsize);
    	size = PRIMES[size_idx];

    	// init vectors
    	//
    	_keys.resize(size, EMPTY);
    	_values.resize(size, _undef_val);

    	// initialize probe interval
    	//
    	probe = int(size/4) + 1;

    	// init statistics stuff
    	//
    	total_attempts = 0;
    	total_lookups = 0;
    }

    _Tp&amp; get( string );			// get the value at a string key index
    _Tp&amp; set( string, _Tp ); 	// set the value at a string key index

    // remove an element by its id, and return it (or undef)
    _Tp remove( string );

    // remove an element pointed to by iterator. 
    _Tp remove( stringmap&lt;_Tp&gt;::iterator );

    // remove an element given by real array location
    _Tp remove_real ( int );

    // ""real"" array accessors for key and value.  
    //
    string key_real( int idx ) { assert(idx &lt; size &amp;&amp; idx &gt;= 0); return _keys[idx]; }
    _Tp&amp; value_real( int idx ) { assert(idx &lt; size &amp;&amp; idx &gt;= 0); return _values[idx]; }

    // see if a key exists
    //
    int exists( string key ) { return ( OCCUPIED(_keys[index_of(key)])); }

    // see if a value exists
    //
    int defined( string key ) { return (exists(key) &amp;&amp; (_values[index_of(key)] != undef_val)); }

    // get the value at a string key index.  actually, this gets a value 
    // ref, and even more importantly, if you try to get a non-existant 
    // location, it will be created and set to undef_val! this allows you to
    // do things like map[new_key] = blah instead of calling set() !!
    //
    _Tp&amp; operator[]( string );	// takes key, returns template object type (ref)

    // the only thing ""tricky"" this has to do is copy the vectors.  all other 
    // variables carry straight over.
    stringmap&lt;_Tp&gt;&amp; operator=(stringmap&lt;_Tp&gt; from) {

    	_keys = from._keys;
    	_values = from._values;

    	probe = from.probe;
    	size = from.size;
    	size_idx = from.size_idx;
    	minsize = from.minsize;
    	maxsize = from.maxsize;

    	filled = from.filled;
    	undef_val = from.undef_val;

    	// start efficiency off anew
    	total_lookups = 0;
    	total_attempts = 0;

    	return *this;
    }

    // some useful accessors
    // 
    int get_size() { return size; }
    int get_filled() { return filled; }

    // get the capacity of the underlying vectors
    //
    int get_capacity() { return _keys.capacity(); }

    // first and last occupied indices.  the iterator makes use of this.
    //
    int first_index();
    int last_index();

    // see how efficient this stringmap is. optimal return value is 1. if you 
    // have properly initialized the size, then you should get a value 
    // somehere around 1.7.
    //
    float get_efficiency() {
    	if (total_lookups) {
    		return ((float)total_attempts/(float)total_lookups); 
    	}

    	return 1;
    }

    /* iterator accessors */

    stringmap&lt;_Tp&gt;::iterator begin();
    stringmap&lt;_Tp&gt;::iterator end();
};

// find the first occupied index (or 0 if none)
//
template &lt;class _Tp&gt; 
int stringmap&lt;_Tp&gt;::first_index( ) {

    if (filled &gt; 0) {
    	for (int i = 0; i &lt; size; i++)
    		if (OCCUPIED(_keys[i])) return i;
    } 

    return 0;
}

// find the last occupied index (or 0 if none)
//
template &lt;class _Tp&gt; 
int stringmap&lt;_Tp&gt;::last_index( ) {

    if (filled &gt; 0) {
    	for (int i = size - 1; i &gt; 0; i--) 
    		if (OCCUPIED(_keys[i])) return i;
    } 

    return 0;
}

// return a begin iterator
//
template &lt;class _Tp&gt; 
typename stringmap&lt;_Tp&gt;::iterator stringmap&lt;_Tp&gt;::begin( ) {

    if (filled == 0) {
    	return stringmap&lt;_Tp&gt;::iterator(this, -1);
    } else {
    	return stringmap&lt;_Tp&gt;::iterator(this, first_index());
    }
}

// return an end iterator
//
template &lt;class _Tp&gt; 
typename stringmap&lt;_Tp&gt;::iterator stringmap&lt;_Tp&gt;::end( ) {

    if (filled == 0) {
    	return stringmap&lt;_Tp&gt;::iterator(this, -1);
    } else {
    	return stringmap&lt;_Tp&gt;::iterator(this, last_index() + 1);
    }
}

// the string hash function.  stolen from Kevin's code.
//
template &lt;class _Tp&gt;
unsigned int stringmap&lt;_Tp&gt;::hash_func( string k) {
    unsigned long h = 0;
    char const *p = k.c_str();

    while( *p ) {
    	h = (h&lt;&lt;4) + *p++;
    	unsigned long g = h &amp; 0xF0000000L;
    	if( g ) h ^= g &gt;&gt; 24;
    	h &amp;= ~g;
    }

    return h % size;
}

// get the index of a key in the hash table, taking into account
// collisions. performs linear probing.
//
template &lt;class _Tp&gt; 
unsigned int stringmap&lt;_Tp&gt;::index_of ( string _key ) {

    return index_of(_key, 0);	// this is only a ""get"" lookup
}

// actual implementation of above, with the following addition:
// if we are setting, we stop at vacated tombstones (-2) in addition to just
// tombstones (-1)
//
template &lt;class _Tp&gt; 
unsigned int stringmap&lt;_Tp&gt;::index_of ( string _key, int set ) {

    // run the key through the hash function to get the starting index
    //
    unsigned int index = hash_func(_key);

    // increment while the current index is not free or does not have 
    // the given key stored at it
    //
    int attempts = 1;

    // our chaining depends on whether or not we are seeking to add a new 
    // element to the hash.
    //
    if (set) {
    	int vacated = -1;
    	while (_keys[index] != _key &amp;&amp; _keys[index] != EMPTY &amp;&amp; attempts &lt; size) {

    		// if we found a vacated spot, ""bookmark"" it
    		if (_keys[index] == VACATED &amp;&amp; vacated == -1) vacated = index;

    		// keep going
    		index = (index + probe) % size;
    		attempts++;
    	}

    	// if we didn't find the key but found a vacated position, use the 
    	// vacated position.
    	//
    	if (attempts &lt; size &amp;&amp; !OCCUPIED(_keys[index]) &amp;&amp; vacated != -1) {

    		index = vacated;
    	}

    } else {
    	while (_keys[index] != _key &amp;&amp; _keys[index] != EMPTY &amp;&amp; attempts &lt; size) {
    		index = (index + probe) % size;
    		attempts++;
    	}
    }

    // full hash table if this is false!
    assert(attempts &lt;= size);

    // keep track of lookup statistics
    //
    total_lookups++;
    total_attempts += attempts;

    return index;
}

// get a value from the hash vector.  returns the _Tp-typed undef value for 
// keys which are not found
//
template &lt;class _Tp&gt;
_Tp&amp; stringmap&lt;_Tp&gt;::get ( string _key ) {

    unsigned int index = index_of(_key);

    return _values[index];
}

// []-style get, which also does a set for accessing un-defined ""indices""
//
template &lt;class _Tp&gt;
_Tp&amp; stringmap&lt;_Tp&gt;::operator[]( string _key ) {

    unsigned int index = index_of(_key);

    if (!OCCUPIED(_keys[index])) {

    	// have to return this, as set could be setting at a different index
    	// and we need a ref to the value at the correct index
    	//
    	return set(_key, undef_val);
    }

    return _values[index];
}

// remove an entry from the hash vector
//
template &lt;class _Tp&gt;
_Tp stringmap&lt;_Tp&gt;::remove ( string _key ) {

    unsigned int index = index_of(_key);

    return remove_real(index);
}

// remove an entry from the hash vector by table index, rather than key
//
template &lt;class _Tp&gt;
_Tp stringmap&lt;_Tp&gt;::remove_real( int index ) {

    string key = _keys[index];
    _Tp value = undef_val;

    // make sure something is here
    if (OCCUPIED(key)) {

    	// grab the value
    	value = _values[index];

    	// clear the spot
    	//
    	_values[index] = undef_val;
    	_keys[index] = VACATED;			// ""vacated"" tombstone

    	// decrease filled count
    	filled--;

    	// check for table resize
    	if (((float)filled/(float)size) &lt; 0.25) {
    		shrink();

    		// calculate a new index for returning ref
    		index = index_of(key);
    	}
    }

    return value;
}

// set a value in the hash vector
// 
template &lt;class _Tp&gt;
_Tp&amp; stringmap&lt;_Tp&gt;::set ( string _key, _Tp _val ) {

    unsigned int index = index_of(_key, 1);

    string key = _keys[index];

    // overwrite old value
    // 
    _values[index] = _val;

    // if new spot, see if we should grow. (EMPTY or VACATED)
    // 
    if ( !OCCUPIED(key) ) { 

    	// first mark this spot with our key
    	_keys[index] = _key;

    	// increase filled count
    	filled++;

    	// check for table resize
    	//
    	if (((float)filled/(float)size) &gt; 0.75) {

    		grow();

    		// calculate a new index for returning ref
    		index = index_of(_key);
    	}
    } 

    return _values[index];
}

// grow the hash vector
//
template &lt;class _Tp&gt;
void stringmap&lt;_Tp&gt;::grow() {

    // do nothing if there is no larger prime
    //
    if (PRIMES[size_idx+1] == 0) return;

    unsigned int nextsize = PRIMES[size_idx+1];

    // do nothing if we've hit our size limit
    if (nextsize &gt; maxsize) return;

    // otherwise do the resize
    // 
    size_idx++;
    unsigned int old_size = size;
    size = nextsize;

    // copy the old vectors
    //
    vector &lt;string&gt; old_keys = _keys;
    vector &lt;_Tp&gt; old_values = _values;

    // resize keys and vals; set new half to defaults
    //	
    _keys.resize(size, EMPTY);
    _values.resize(size, undef_val);

    // clear out old portion (~ 1st half)
    //
    unsigned int i;
    for (i = 0; i &lt; old_size; i++) {
    	_keys[i] = EMPTY;
    	_values[i] = undef_val;
    }

    // new probe interval
    //
    probe = int(size/4) + 1;

    // hash old keys and values into resized vector
    //
    for (i = 0; i &lt; old_size; i++) {

    	if (OCCUPIED(old_keys[i])) {  // ignore all tombstoned entries
    		unsigned int index = index_of(old_keys[i]);
    		_keys[index] = old_keys[i];
    		_values[index] = old_values[i];
    	}
    }

    // unquote this to care about resizing overhead in efficiency stats
    //
    total_attempts += old_size; // at least this many ops in the copying
    total_lookups -= old_size;	// these aren't ""external"" lookups
}

// shrink the hash vector
// 
template &lt;class _Tp&gt; 
void stringmap&lt;_Tp&gt;::shrink () {

    // do nothing if there is no smaller prime
    //
    if (size_idx == 0) return;

    unsigned int nextsize = PRIMES[size_idx-1];

    // do nothing if we've hit our size limit
    if (nextsize &lt; minsize) return;

    // otherwise do the resize
    // 
    size_idx--;
    unsigned int old_size = size;
    size = nextsize;

    // copy the old vectors
    //
    vector &lt;string&gt; old_keys = _keys;
    vector &lt;_Tp&gt; old_values = _values;

    // resize keys and vals
    //	
    _keys.resize(size, EMPTY);
    _values.resize(size, undef_val);

    // set to defaults
    //
    unsigned int i;
    for (i = 0; i &lt; size; i++) {
    	_keys[i] = EMPTY;
    	_values[i] = undef_val;
    }

    // new probe interval
    //
    probe = int(size/4) + 1;

    // hash old keys and values into resized vector
    //
    for (i = 0; i &lt; old_size; i++) {

    	if (OCCUPIED(old_keys[i])) {  // ignore all tombstoned entries
    		unsigned int index = index_of(old_keys[i]);
    		_keys[index] = old_keys[i];
    		_values[index] = old_values[i];
    	}
    }

    // unquote this to care about resizing overhead in efficiency stats
    //
    total_attempts += old_size; // at least this many ops in the copying
    total_lookups -= old_size;	// these aren't ""external"" lookups
}



#endif
</code></pre>
","87234","","<p>You need typename:</p>

<pre><code>typename stringmap&lt;_Tp&gt;::iterator begin();
typename stringmap&lt;_Tp&gt;::iterator end();
</code></pre>

<p>The reason being being that <code>iterator</code> is dependent on what _Tp is, so the compiler can't be sure it's a <a href=""http://pages.cs.wisc.edu/~driscoll/typename.html"" rel=""nofollow"">typename</a> unless you tell it. I'd recommend <code>typedef</code>'s to get that stuff out of the way:</p>

<pre><code>typedef stringmap&lt;_Tp&gt; container_type;
typedef typename container_type::iterator iterator_type;

iterator_type begin();
iterator_type end();
</code></pre>

<p>Also, keep in mind that an underscore followed by a capital letter is reserved for the compiler, and yours looks especially common for compilers to use. I'd recommend simply using <code>T</code>. It's much more common in user-created code, and easier to read.</p>
"
"<p>Is there a linked list in C++ that I could just #include? Or do I need to create my own if I want to use one?</p>
","87234","","<p>As <a href=""http://stackoverflow.com/questions/1735324/is-there-a-linked-list-predefined-library-in-c/1735329#1735329"">daniel notes</a>, yes, <a href=""http://en.cppreference.com/w/cpp/container/list"" rel=""nofollow""><code>std::list</code></a>. Usage would be:</p>

<pre><code>#include &lt;list&gt;
// ...
std::list&lt;int&gt; listOfInts;
listOfInts.push_back(1);
// ...
</code></pre>

<p>And so on.</p>

<p>You can find a complete list of STL classes <a href=""http://www.sgi.com/tech/stl/table_of_contents.html"" rel=""nofollow"">here</a>. The section you're after is 3.2, Container classes. Another useful reference of the C++ Standard Library is <a href=""http://en.cppreference.com/w/cpp/container"" rel=""nofollow"">here</a>.</p>
"
"<p>I'm trying to understand the differences between C and C++ with regards to void pointers. the following compiles in C but not C++ (all compilations done with gcc/g++ -ansi -pedantic -Wall):</p>

<pre><code>int* p = malloc(sizeof(int));
</code></pre>

<p>Because <code>malloc</code> returns <code>void*</code>, which C++ doesn't allow to assign to <code>int*</code> while C does.</p>

<p>However, here:</p>

<pre><code>void foo(void* vptr)
{
}


int main()
{
    int* p = (int*) malloc(sizeof(int));
    foo(p);
    return 0;
}
</code></pre>

<p>Both C++ and C compile it with no complain. Why?</p>

<p>K&amp;R2 say:</p>

<blockquote>
  <p>Any pointer to an object may be
  converted to type void * without loss
  of information. If the result is
  converted back to the original pointer
  type, the original pointer is
  recovered.</p>
</blockquote>

<p>And this pretty sums all there is about <code>void*</code> conversions in C. What does C++ standard dictate?</p>
","87234","","<p>In C, pointer conversions to and from <code>void*</code> were always implicit.</p>

<p>In C++, conversions from <code>T*</code> to <code>void*</code> are implicit, but <code>void*</code> to anything else requires a cast.</p>
"
"<p>What's the easiest way to concatenate strings defined in macros.
i.e. The pseudo code I'm looking for would be like:</p>

<pre><code>#define ROOT_PATH ""/home/david/""
#define INPUT_FILE_A ROOT_PATH+""data/inputA.bin""
#define INPUT_FILE_B ROOT_PATH+""data/inputB.bin""
...
#define INPUT_FILE_Z ROOT_PATH+""data/inputZ.bin""
</code></pre>

<p>The only way I know of is to use strcat in the code, or using the string class and then the c_str method, but it can get messy when I have lots of input files. I'd like to just use INPUT_FILE_A, etc. directly and not have lots of local variables. Is there a good way to do this?</p>

<p>Thanks.</p>
","87234","","<p>The compiler will automatically concatenate adjacent strings:</p>

<pre><code>#define ROOT_PATH ""/home/david/""
#define INPUT_FILE_A ROOT_PATH ""data/inputA.bin""
</code></pre>

<p>Or more generic:</p>

<pre><code>#define INPUT_FILE_DETAIL(root,x) root #x
#define INPUT_FILE(x) INPUT_FILE_DETAIL(ROOT_PATH ""data/"", x)
</code></pre>
"
"<p>I have a game engine to work on as part of a class. Currently, its rendering is frame-rate dependent and one requirement is to move to a timer-based dependency.  I am not sure how to determine where it is relying on frame-rates.  I'm not sure what to look for.  I realize I'm going to need to somehow incorporate a timer (GetTickCount?) to accomplish this, but I'm not sure how frequent to update that, either. </p>

<p>I'm not looking to be handed code, just some helpful guidelines possibly?  </p>
","87234","","<p>Imagine you have a very simple game, where it's just a ball moving across the screen. Without time-based updates, it moves as fast as you update.</p>

<p>What you want to do is find out how much time has elapsed (in a fraction. I usually measure in seconds, so physics equations match better.) When updating, instead of something like this:</p>

<pre><code>ballPosition += ballVelocity
</code></pre>

<p>You'd have this:</p>

<pre><code>ballPosition += ballVelocity * timeElapsed
</code></pre>

<p>What this means is that for higher frame rates, <code>timeElapsed</code> will be lower, which consequently moves the ball less. Lower frame rates means that <code>timeElapsed</code> will be greater, and the ball will move more per-frame.</p>

<p>In the end, the ball will move the same distance independent on frame rate. A 60 FPS update rate makes <code>timeElapsed</code> equal <code>0.01666667f</code>, while a 30 FPS update rate would make it <code>0.03333333f</code> . You can see how at 60 FPS, the elapsed time is half of 30 FPS, but because it's twice as fast, it's the same number.</p>

<p>I usually pass <code>timeElapsed</code> as an argument to any functions that are time-dependent. A nice consequence of doing it this way is you can slow down or speed up your game by multiplying the elapsed time by a value. You can also apply that to individual components. It also plays well if you switch to a frame-limiting model instead, because you're effectively just forcing <code>timeElapsed</code> to be a constant. Pseudo-code:</p>

<pre><code>while (gameRunning)
{
    const float timeElapsed =
                    timer.elapsed(); // elapsed returns the number of seconds
                                     // passed since it was last called

    // GlobalTimeScale is 1 for normal time
    game.update(timeElapsed * GlobalTimeScale);
    game.draw();
}
</code></pre>

<p>To get the time, <a href=""http://msdn.microsoft.com/en-us/library/ms724408%28VS.85%29.aspx""><code>GetTickCount</code></a> should work. You might also take a look at <a href=""http://msdn.microsoft.com/en-us/library/ms644904%28VS.85%29.aspx""><code>QueryPerformanceCounter</code></a> for higher precision, though it can have issues with multiple cores.</p>
"
"<p>Is it safe to cast a UINT64 to a float?  I realize that UINT64 does not hold decimals, so my float will be whole numbers.  However, my function to return my delta-time returns a UINT64, which isn't a very useful type for the function I'm currently working with.  I'm assuming a simple static_cast&lt;float>(uint64value) will not work?</p>
","87234","","<p>You might try performing your arithmetic in a <code>long double</code> or <code>double</code> first:</p>

<pre><code>typedef long double real_type
real_type x = static_cast&lt;real_type&gt;(long1);
real_type y = static_cast&lt;real_type&gt;(long2);

real_type z = x / y;
float result = static_cast&lt;float&gt;(real_type);
</code></pre>
"
"<p>I am trying to initialize a hashtable. when i do the stock's operator= overload is called.
I am not sure what i need to do in this function? </p>
","87234","","<p>Your assignment operator is incorrect. The signature needs to be:</p>

<pre><code>stock&amp; operator=(const stock&amp; pRhs)
</code></pre>

<p>Secondly, you need to delete first, then capture data. What you have now just delete's NULL. Lastly, you should should <code>s</code>'s data, not set to NULL.</p>

<p><hr></p>

<p>Here's how to implement <code>operator=</code>. You need to first make sure any data you hold is free'd. After that, copy the right-hand side.</p>

<p>I don't see a <code>clear()</code> function, but what you want to do is take the code in your destructor, and move it to a public <code>clear()</code> function. Now all your destructor does is call this function, and it let's you clear the hash map at other times too (without duplicating code).</p>

<p>A typical naive method is something like the following: (I'm not going to give you the <em>actual</em> code, just something similar):</p>

<pre><code>// note, T is the type being copied. remember, this is just
// generic helper code, it's up to you to fill in your blanks

// returns a reference, common, allows chaining: a = b = c
T&amp; operator=(const T&amp; pRhs) // rhs stands for right-hand-side
{
    if (this != &amp;pRhs) // avoid self-copy
    {
        clear(); // important! free resources before we copy

        // code to copy pRhs. this
        // is dependent on your class
    }
}
</code></pre>

<p>The lines that read ""code to copy pRhs"" will be replaced by the <em>same code</em> in your copy constructor. But we cannot call the copy-constructor! This means you'll end up copy-pasting that code, and you should <strong>never</strong> copy-paste code. This is because code duplication is a bad thing. You might try to alleviate this issue by creating a private <code>copy()</code> function, and having both the copy-constructor and <code>operator=</code> call this function instead, but this isn't optimal, and can look messy.</p>

<p>However, there is a better way. It requires you create a <code>swap()</code> function for your class. What this function is responsible for doing is swapping two classes by swapping all their member variables:</p>

<pre><code>#include &lt;algorithm&gt; // for std::swap

// somewhere in the class:
void swap(T&amp; pRhs)
{
    // obviously the variable names depend on your class
    std::swap(someVariable, pRhs.someVariable);

    // and so on for all the variables in the class
}
</code></pre>

<p>You can now logically swap two classes by calling <code>classA.swap(classB)</code>. You also need a working copy-constructor. What we're going to do is let the compiler make a copy for us, using the copy-constructor, then kill two birds with one stone and swap with it. Here's what I mean:</p>

<pre><code>T&amp; operator=(const T&amp; pRhs)
{
    if (this != &amp;pRhs)
    {
        T temp = pRhs; // copy using copy-constructor
        swap(temp); // swap with the copy
    }
}
</code></pre>

<p>And that's it! By making a copy, the compiler will use our copy-constructor; this is what avoids the code duplication.</p>

<p>The second part is to <code>swap</code> with that copy. We give the copy all our stuff, and take it's stuff. We are now the copy (the copy is done).</p>

<p>The last thing is to make sure all our resources get released. Before we were calling <code>clear()</code>, but now it's done automatically. This is because <code>temp</code> needs to be destructed before the function ends. So the compiler does that for us, but remember <em>we swapped our stuff for temp</em>. What this means is the compiler will end up deallocating our old data, while we keep the copied data.</p>

<p>And that is how to implement <code>operator=</code>. Feel free to ask questions, of course.</p>
"
"<p>I'm trying to use <code>iphlpapi</code> (<code>GetAdapterInfo</code>) and am having trouble compiling the code.  I have <code>iphlpapi.h</code> from SDK 7 and have added the appropriate path to the include files in visual studio.</p>

<p>I get the following error...</p>

<blockquote>
  <p>c:\program files\microsoft sdks\windows\v7.0\include\ifdef.h(154) : error C2146: syntax error : missing ';' before identifier 'NET_IFTYPE'</p>
</blockquote>

<p>The lines in ifdef where this occurs are shown below.</p>

<pre><code>typedef NET_LUID IF_LUID, *PIF_LUID;
typedef ULONG NET_IFINDEX, *PNET_IFINDEX;       // Interface Index (ifIndex)
typedef UINT16 NET_IFTYPE, *PNET_IFTYPE;        // Interface Type (IANA ifType)
</code></pre>
","87234","","<p>According to <a href=""http://msdn.microsoft.com/en-us/library/aa365872%28VS.85%29.aspx"" rel=""nofollow"">this page</a>, it looks as though you might need to make sure <code>winsock2.h</code> is included first. I'm guessing that it defines some of those types.</p>

<p>Also, the MSDN page for <code>NET_LUID</code> says it requires Vista at a minimum. Make sure that's true.</p>
"
"<p>Here is the little code snippet:</p>

<pre><code>class A
{
public:
    A(int value) : value_(value)
    {
    	cout &lt;&lt;""Regular constructor"" &lt;&lt;endl;
    }

    A(const A&amp; other)	: value_(other.value_)	
    {
    	cout &lt;&lt;""Copy constructor"" &lt;&lt;endl;
    }

private:
    int value_;
};
int main()
{
    A a = A(5);
}
</code></pre>

<p>I assumed that output would be ""Regular Constructor"" (for RHS) followed by ""Copy constructor"" for LHS. So I avoided this style and always declared variable of class as <code>A a(5);</code>.  But to my surprise in the code above copy constructor is never called (Visual C++ 2008)</p>

<p>Does anybody know if this behavior is a result of compiler optimization, or some documented (and portable) feature of C++? Thanks.</p>
","87234","","<p>From another comment: ""So by default I should not rely on it (as it may depend on the compiler)""</p>

<p>No, it does not depend on the compiler, practically anyway. Any compiler worth a grain of sand won't waste time constructing an A, then copying it over.</p>

<p>In the standard it explicitly says that it is completely acceptable for <code>T = x;</code> to be equivalent to saying <code>T(x);</code>. (§12.8.15, pg. 211) Doing this with <code>T(T(x))</code> is obviously redundant, so it removes the inner <code>T</code>.</p>

<p>To get the desired behavior, you'd force the compiler to default construct the first A:</p>

<pre><code>A a;
// A is now a fully constructed object,
// so it can't call constructors again:
a = A(5);
</code></pre>
"
"<p>I am trying to add the returned value from the <code>test()</code> function into a variable result, but <code>+=</code> does not seem to work. I get the error ""invalid variable initialization"".
I also tried replacing <code>i++</code> to <code>i+=</code> which didnt work either. Maybe I'm totally wrong and should use a while loop instead? I'm quite lost..</p>

<p>I want 'result' to look something like this:</p>

<pre><code>var result = no no no 0no 0no no;
</code></pre>

<p>etc (with no whitespace, of course).</p>

<p>Any help much appreciated! Thanks</p>

<pre><code>function test(no){

            if (no &lt;= 15){              
                return '0' + parseInt(no);
            }

            else {              
                return parseInt(no); 
            }       
}


        for(i = 0; i &lt; pics.length; i++){

            var b = pics[i].value;

            var result += test(b);

        }
</code></pre>
","87234","","<p>Every time your loop starts, <code>var result</code> goes away. You need to move it outside the loop:</p>

<pre><code>var result = ''; // lives outside loop
for(i = 0; i &lt; pics.length; i++)
{
    var b = pics[i].value;
    result += test(b);
}
</code></pre>
"
"<p>I know Windows uses LLP instead of the LP data model, but is there a predefined variable or something? on OS X/Linux you can use <code>__LP64__</code>.</p>
","87234","","<p>I don't know if such variable, but you can test for <code>_MSC_VER</code>, which will be defined in Visual Studio. You can then assume an LLP model. If that ever changes in the future, you can use the value of <code>_MSC_VER</code> to test against compiler versions.</p>

<p>If you're looking for standard sized types, check out <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/libs/integer/index.html"" rel=""nofollow"">boost::integer</a>, which defines fixed-bit-sized integer types.</p>
"
"<p>If I'm creating an abstract base class, and the classes derived from it are going to have some of the same data members, is it better practice to make those members private in the abstract base class and give protected access to them? Or to not bother and just put the data members in the derived classes. This is in C++.</p>
","87234","","<p>If the data belongs to the derived class, let the derived class do what it wants to contain that data.</p>

<p>By placing that data in the base class (not privately), you force every derived class to have it. The derived classes shouldn't be forced to do anything <em>unless</em> they need to fill out the data member, for example. The base class defines what derived classes must do, not how they should do it.</p>

<p>If you find there might be a common theme, you can make a derived class that has those members and implementations, which is then intended to be the base class for those that want to use it. For example:</p>

<pre><code>struct car
{
    virtual ~car(){}

    virtual unsigned year(void) const = 0;
    virtual const std::string make(void) const = 0;
}

// Dodge cars can feel free to derive from this instead, it's just a helper
struct dodge_car
{
    virtual ~car(){}

    virtual unsigned year(void) const = 0;

    const std::string make(void) const
    {
        static const std::string result = ""Dodge"";
        return result;
    }

}
</code></pre>

<p>And so on. But you see, any derived classes still have the choice of implementing the entire car interface. This also improves code cleanliness. By keeping your interface a real interface, implementation details won't get in the way.</p>

<p>Any variables your base class uses should be private, because derived classes don't need to know how it works, in the same way users of your derived class don't need to know how the internals of the derived class work.</p>
"
"<p>I need help with pointers and memory management.</p>

<p>I need to store different objects, all derived from the same base class, and have been using an array to do this but it is causing a segmentation fault when the array is populated with different objects.  </p>

<p>My program works fine when the array is full of objects of the same derived type.  When the array is populated with different objects it works as it is supposed to through the object stored at the first position but then when it switches to output the second object it gives me the segmentation fault.  I know that this is a memory access issue but I am unclear how I'm supposed to manage a variable amount of objects dependent on user input.</p>

<p>thx,
nmr</p>
","87234","","<p>Make sure the pointers you're pushing on the stack are dynamically allocated. The following will fail:</p>

<pre><code>std::vector&lt;Base*&gt; objects;

void make_one(void)
{
    Derived d;

    objects.push_back(&amp;d);
}
</code></pre>

<p>Because when the function ends, the class pointed to by <code>&amp;d</code> will be deallocated. This is alleviated by dynamically allocating the objects:</p>

<pre><code>std::vector&lt;Base*&gt; objects;

void make_one(void)
{
    Derived *d = new Derived;

    objects.push_back(d); // a-ok
}
</code></pre>

<p>Just remember to go through the vector when you're done, and call <code>delete</code> on them:</p>

<pre><code>struct deleter
{
    template &lt;typename T&gt;    
    void operator()(T* pObject) const
    {
        delete pObject;
    }

}

std::for_each(objects.begin(), objects.end(), deleter());
</code></pre>

<p>If you can use boost, there is a <a href=""http://www.boost.org/doc/libs/1%5F41%5F0/libs/ptr%5Fcontainer/doc/ptr%5Fcontainer.html"">pointer container library</a> that will do this for you. Note, you cannot use <code>auto_ptr</code> and try to let it do it for you; <code>auto_ptr</code>'s don't play well with containers.</p>

<p>Also, make sure your base classes have virtual destructors:</p>

<pre><code>struct base
{
    virtual ~base(void) {} // important!
}
</code></pre>

<p>If they are not, calling <code>delete</code> on a base class will run the base constructor only, leaking any resources the derived class might of had. By making it virtual, the compiler can jump to the correct destructor.</p>
"
"<p>Let say I am designing an interface, to return the name of the child class. Note that, for different instance of a child class, their name shall remain the same. </p>

<p>For speed and memory efficient, I would say 3rd method signature is probably the best (based on some comment from <a href=""http://stackoverflow.com/questions/801209/c-char-vs-stdstring"">http://stackoverflow.com/questions/801209/c-char-vs-stdstring</a>)</p>

<pre><code>virtual const std::string&amp; name2() const = 0;
</code></pre>

<p>I was wondering is there any better alternative?</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;string&gt;

class baby_interface {
public:
    virtual const char* name0() const = 0;
    virtual std::string name1() const = 0;
    virtual const std::string&amp; name2() const = 0;
};

class baby : public baby_interface {
public:
    virtual const char* name0() const
    {
        return ""My Baby"";
    }

    virtual std::string name1() const
    {
        return ""My Baby"";
    }

    virtual const std::string&amp; name2() const
    {
        return std::string(""My Baby"");
    }
};

int main()
{
    baby b;

    // Refer to same char array address.
    printf(""%x\n"", b.name0());
    printf(""%x\n\n"", b.name0());

    // Refer to different char array address.
    printf(""%x\n"", b.name1().c_str());
    printf(""%x\n\n"", b.name1().c_str());

    // Refer to same char array address.
    printf(""%x\n"", b.name2().c_str());
    printf(""%x\n\n"", b.name2().c_str());
    getchar();
}
</code></pre>
","87234","","<p>It can be if you do it correctly. What you have now is undefined:</p>

<pre><code>virtual const std::string&amp; name2() const
{
    return std::string(""My Baby""); // constructs temporary string!
}
</code></pre>

<p>You're returning a reference to a temporary. For this to work, it must be an l-value. You could make it static:</p>

<pre><code>virtual const std::string&amp; name2() const
{
    static const std::string result = ""My Baby"";
    return result;
}
</code></pre>

<p>Or a member of the class, etc. Now it returns a usable variable.</p>

<p>I don't have much experience in what's common, but I'd guess number one is common if these interfaces are being used between modules. (i.e., the interface as allocated from a shared library/dll). This is because the implementation of strings is likely differ between compilers, and sometimes even different versions of the same compiler. If the program was made with one implementation, while the derived's was made in another, transferring between the two could fail.</p>

<p>By using a <code>const char *</code> (which is the same in all compilers), you avoid that. However, <code>const char *</code> can look unsightly to some.</p>

<p>The second options seems to be what I would use, because forcing derived classes to make a static/l-value variable might not be what you should do. The copy is likely to be very quick anyway.</p>
"
"<p>I just had a hell of a project doing simple operations on C++, then when I was almost completely done with the project I found out that all this stupid tasks required just a portion of boost. This was quite frustrating and let me wondering how many of these annoying problems could be solved with a single function of the boost libraries.</p>

<p>So the question is, is there any cheat sheet for the boost libraries? I mean, that I can say right away, I should look at this part of boost to solve the problem. Most of the times the description that appear in the <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/"" rel=""nofollow"">main page</a> of boost doesn't even explain what it is intented or, specially for somebody whose not use to all these C++ specific words.</p>
","87234","","<p>Well, looking at the library list <a href=""http://www.boost.org/doc/libs/1%5F40%5F0/"" rel=""nofollow"">here</a> or <a href=""http://www.boost.org/doc/libs/1%5F41%5F0/libs/libraries.htm"" rel=""nofollow"">here</a> are how I familiarized myself with boost. Just click through each so you can get a general idea of what the libraries can do. Then if you ever need something you might recall that functionality was in boost.</p>

<p>I suppose you could also try searching the <a href=""http://www.google.com/search?q=site%3Aboost.org"" rel=""nofollow"">site with Google</a> for the keywords you're trying to use on a particular problem.</p>

<p>Throwing away code after you've written it is hard to do, but the right thing to do. Coincidentally, I asked a question yesterday, and after implementing the whole thing, someone found it in boost. I just source controlled it, then deleted it. Think of it as a learning exercise :)</p>
"
"<p>I talked to my instructor the other day and asked him this question. He told me that I could go for smaller projects, but I'm starting a chess program and I was wondering what Stack Overflow thinks about this issue. Should I include all headers into one file, or separate them?</p>
","87234","","<p>I just want to add that, yes this is normally a bad idea, but it can be useful on occasion. Never for entire projects though.</p>

<p>For example, I recently wrote a utility to perform a stack dump on windows. There were 4 common headers I was going to include, so I made (in a <code>detail</code> folder, a convention <strike>I stole form boost</strike> use) a <code>windows.hpp</code>, which included those four. The implementations could then use that header to easily get the necessary functions.</p>

<p>While it might not carry the same weight as a mega-includes-480-headers header, it <em>was</em> a grouping of a handful of common headers, and it was quite helpful. the key thing here is it was a small collection of <strong>related</strong> headers, used in a portion of the code.</p>
"
"<p>I am trying to do something like this:</p>

<pre><code>template &lt;typename T,bool Strong=true&gt;
class Pointer {...};

template &lt;typename T&gt;
typedef Pointer&lt;T,false&gt; WeakPointer;
</code></pre>

<p>But this is a compile error (""a typedef template is illegal"" VC).</p>

<p>I am trying to avoid doing this using inheritance, beacuse that's more unnecessary work (rewriting constructors, operator =, back-and-forth casting, friendship...).</p>

<p>Any ideas?</p>
","87234","","<p>C++0x will alleviate this issue, but as it stands you cannot.</p>

<p>The common work-around is this:</p>

<pre><code>template &lt;typename T,bool Strong=true&gt;
class Pointer {...};

template &lt;typename T&gt;
struct WeakPointer
{
    typedef Pointer&lt;T,false&gt; value_type;
};
</code></pre>

<p>So instead of:</p>

<pre><code>typedef WeakPointer&lt;int&gt; WeakInt;
</code></pre>

<p>You get:</p>

<pre><code>typedef WeakPointer&lt;int&gt;::value_type WeakInt;
</code></pre>
"
"<p><strong>Problem fixed! Thanks a lot for the constructive suggestions!</strong></p>

<p>I am unable to figure out what is the mistake in the following code. Is there something wrong with the way I am doing includes?</p>

<pre><code>// This is utils.h
#ifndef UTILS_H
#define UTILS_H

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

typedef pair&lt;int,int&gt; ii;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ii&gt; vii;
typedef vector&lt;vii&gt; vvii;
typedef stack&lt;int&gt; si;
typedef queue&lt;int&gt; qi;

#define tr(c,i) for(typeof((c).begin()) i = (c).begin() ; i!=(c).end() ; ++i )
#define all(c) (c).begin(),(c).end()
#define cpresent(c,x) (find(all(c),x) != (c).end())

#endif

// ==============================================================
// Below is main.cpp

#include ""utils.h""

int main() {
    vi v;
}
</code></pre>

<p>On compiling ""g++ main.cpp""  I get the following error message:</p>

<p>utils.h:13: error: expected initializer before ‘&lt;’ token
utils.h:14: error: expected initializer before ‘&lt;’ token
utils.h:15: error: expected initializer before ‘&lt;’ token
utils.h:16: error: expected initializer before ‘&lt;’ token
utils.h:17: error: expected initializer before ‘&lt;’ token
utils.h:18: error: expected initializer before ‘&lt;’ token
main1.cpp: In function ‘int main()’:
main1.cpp:4: error: ‘vi’ was not declared in this scope
main1.cpp:4: error: expected `;' before ‘v’</p>

<p>What is wrong with this code? The utils.h used to work fine some time back when I did not have the #ifndefs in it.</p>
","87234","","<p><code>vector</code> and the like are contained in the namespace <code>std::</code>. Do <strong>not</strong> use <code>using namespace std;</code> in a header file. Otherwise everyone that includes it gets all of <code>std::</code> whether intended or not.</p>

<p>On a side note, if this is a utility header intended to be included in other files, you might wrap up those types and <code>#define</code>'s in a namespace. Note <code>#define</code>'s don't respect namespaces, so you'd prefix them instead:</p>

<pre><code>namespace utility
{
    // ...
    typedef std::queue&lt;int&gt; qi;

    // most would recommend this be in CAPS
    #define utility_tr(c,i) for(typeof((c).begin()) i = (c).begin() ; i!=(c).end() ; ++i )
    // ...    
}
</code></pre>
"
"<p>Which naming convention is more preferable in C++? The `underscore' method or the camelCase method?
I have coded in Java for a while and I am used to the camelCase naming conventions. 
Which one is more prevalent?</p>

<p>Also, while defining a class, is there any preferred ordering of private/public/protected variables/methods?<br>
Are friends usually put in the end?<br>
What about typedefs, do they come at the top of the class definition?  </p>

<p>Thanks,
Ajay G.</p>
","87234","","<p>I prefer to take the boost route, and match the standard library. That means <code>lower_case_names</code>. I like that my code reads consistent with respect to the STL.</p>
"
"<p>Looks like a stupid question. But comment to my <a href=""http://stackoverflow.com/questions/1787856/what-is-the-element-value-in-an-uninitialized-vector/1787863#1787863"">answer</a> to one of the SO question made me to think again.</p>

<p>[ comment says, capacity need not be zero for empty vector]</p>

<p>By default my answer would be 0 as there are no elements inside vector. It makes sense to keep the capacity as 0 and  on the first allocation it can be increased without any performance hits.</p>

<p>But standard does not say anything one this.  ( I checked in Josuttis book as well). </p>

<p>Is it purely implementation specific? Does any STL vendor use some arbitrary number as capcity for the empty vector?  </p>

<p>Any thoughts...</p>
","87234","","<p>The capacity can be whatever the implementors feel is correct or necessary.</p>

<p>It should also be noted it's never ""safe"" to assume you know the current <code>capacity()</code> without a call to that function. If you reserve 10 elements, the implementor is of free to allocate one hundred if it so wants to. Or 11, 42 (preferred) or just 10.</p>
"
"<p>In my SDL program, I am using a map construct to simulate an ""infinite"" array of objects within a certain class. The code manages to compile fine, but when I run the program, as soon as one of the functions using the maps is trigger, the program crashes, returning a value of 3.</p>

<p>So, here's exactly what I'm doing:</p>

<pre><code>class MyClass
{
     public:
           int MyFunction();
     protected:
           std::map&lt; int, MyObject &gt; MyMap;
}

int MyClass::MyFunction()
{
     ...
     int i;

     if( MyMap.empty() )
     {
          i = 1;
     }
     else
     {
         i = MyMap.size() + 1;
     }

     MyMap[ i ] = PreviouslyDefinedObject;

     return i;

}
</code></pre>

<p>When MyFunction() is called from a MyClass object, the crash occurs. It seems to happen whenever anything of use is done with MyMap: it crashes if you comment out the penultimate line and just try to return i, and it crashes if you just set i = 1 and then assign an object to MyMap[i]</p>

<p>This is the first time I've ever used a map, so I'm not certain I'm using them right. Is this a basic mistake somewhere? Can anyone point me in the right direction? Cheers.</p>
","87234","","<p>Maps are used to associate a key with a value. If you're looking for an array, you should use a <a href=""http://www.cplusplus.com/reference/stl/vector/"" rel=""nofollow""><code>vector</code></a>. It will do a better job of simulating an ""infinite array"" than a map, because a map isn't an array.</p>

<p>Note you can allocate <em>a lot</em> of elements with a vector, usually. If you're really trying to simulate a large array, I'd recommend wrapping up a vector of vectors. With some math, you could create an <code>operator[]</code> for it that indexes into the correct array, to the correct element.</p>

<p>As for your code, there really isn't enough information to determine why it should be crashing, you'd have to try to create a minimal program for us to compile or look at.</p>
"
"<p>I am working on a C++ project on macOS X 10.6.2 with xcode.</p>

<p>I tried to compile my code on windows and do not have any problem, I guess Linux is working but I don't have one with me right now.</p>

<p>My problem is xcode do not accept this kind of instruction :</p>

<pre><code>struct direction {
double x;
double y;
double z;
double t; };

typedef struct direction direction;
</code></pre>

<p>Here is my error :</p>

<blockquote>
  <p>/Users/sbarbier/dev/xcode/Infographie/TP9-RayTracing/RayTracing-Direction.h:22:0     /Users/sbarbier/dev/xcode/Infographie/TP9-RayTracing/RayTracing-Direction.h:22: error: changes meaning of 'direction' from 'typedef struct direction direction'</p>
</blockquote>

<p>I am using GCC4.2 and haven't change anything. This code works on every platform, can any one help me ?</p>
","87234","","<p>This isn't C. In C, to use a <code>struct</code> you had to use the keyword <code>struct</code>:</p>

<pre><code>struct some_struct{ int i; };
struct some_struct myStruct;
</code></pre>

<p>This was alleviated like this, commonly:</p>

<pre><code>typedef struct { int i; } some_struct;
some_struct myStruct;
</code></pre>

<p>In C++ this is not required. <code>direction</code> already has a type, then you're trying to make a new type of the same name, and that's bad. Take out your entire <code>typedef</code>, it isn't needed.</p>
"
"<p>Is it possible to know the object instance name / variable name from within a class method? For example:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

class Foo {
     public:
          void Print();
};

void Foo::Print() {
     // what should be ????????? below ?
     // cout &lt;&lt; ""Instance name = "" &lt;&lt; ?????????;
}

int main() {
    Foo a, b;
    a.Print();
    b.Print();
    return 0;
}
</code></pre>
","87234","","<p>No. Variable names are for the programmer, the compiler sees addresses.</p>

<p>Other languages that provide meta-data/reflection about their program might provide this functionality, C++ isn't one of those languages.</p>
"
"<p>How to remove spaces from a string object in C++.<br>
For example, how to remove leading and trailing spaces from the below string object.  </p>

<pre><code>//Original string: ""         This is a sample string                    ""
//Desired string: ""This is a sample string""
</code></pre>

<p>The string class, as far as I know, doesn't provide any methods to remove leading and trailing spaces.  </p>

<p>To add to the problem, how to extend this formatting to process extra spaces between words of the string. For example,</p>

<pre><code>// Original string: ""          This       is         a sample   string    "" 
// Desired string:  ""This is a sample string""
</code></pre>

<p>Using the string methods mentioned in the solution, I can think of doing these operations in two steps.</p>

<ol>
<li>Remove leading and trailing spaces.</li>
<li>Use <strong>find_first_of, find_last_of, find_first_not_of, find_last_not_of and substr</strong>, repeatedly at word boundaries to get desired formatting.</li>
</ol>
","87234","","<p>It's called trimming. You want to use <code>find_first_not_of</code> to get the index of the first non-whitespace character, then <code>find_last_not_of</code> to get the index from the end that isn't whitespace. With these, use <code>substr</code> to get the sub-string with no surrounding whitespace.</p>

<p>In response to your edit, I don't know the term but I'd guess something along the lines of ""reduce"", so that's what I called it. :) (Note, I've changed the white-space to be a parameter, for flexibility)</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

std::string trim(const std::string&amp; str,
                 const std::string&amp; whitespace = "" \t"")
{
    const auto strBegin = str.find_first_not_of(whitespace);
    if (strBegin == std::string::npos)
        return """"; // no content

    const auto strEnd = str.find_last_not_of(whitespace);
    const auto strRange = strEnd - strBegin + 1;

    return str.substr(strBegin, strRange);
}

std::string reduce(const std::string&amp; str,
                   const std::string&amp; fill = "" "",
                   const std::string&amp; whitespace = "" \t"")
{
    // trim first
    auto result = trim(str, whitespace);

    // replace sub ranges
    auto beginSpace = result.find_first_of(whitespace);
    while (beginSpace != std::string::npos)
    {
        const auto endSpace = result.find_first_not_of(whitespace, beginSpace);
        const auto range = endSpace - beginSpace;

        result.replace(beginSpace, range, fill);

        const auto newStart = beginSpace + fill.length();
        beginSpace = result.find_first_of(whitespace, newStart);
    }

    return result;
}

int main(void)
{
    const std::string foo = ""    too much\t   \tspace\t\t\t  "";
    const std::string bar = ""one\ntwo"";

    std::cout &lt;&lt; ""["" &lt;&lt; trim(foo) &lt;&lt; ""]"" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""["" &lt;&lt; reduce(foo) &lt;&lt; ""]"" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""["" &lt;&lt; reduce(foo, ""-"") &lt;&lt; ""]"" &lt;&lt; std::endl;

    std::cout &lt;&lt; ""["" &lt;&lt; trim(bar) &lt;&lt; ""]"" &lt;&lt; std::endl;
}
</code></pre>

<p>Result:</p>

<pre>
[too much               space]  
[too much space]  
[too-much-space]  
[one  
two]  
</pre>

<p>Though if you can <a href=""http://www.boost.org/doc/html/string_algo.html"">Boost</a>, I'd recommend it.</p>
"
"<p>I've been programming in C++ for a few years, and I've used STL quite a bit and have created my own template classes a few times to see how it's done.</p>

<p>Now I'm trying to integrate templates deeper into my OO design, and a nagging thought keeps coming back to me: They're just a macros, really... You could implement (rather UGLY) auto_ptrs using #defines, if you really wanted to.</p>

<p>This way of thinking about templates helps me understand how my code will actually work, but I feel that I must be missing the point somehow. Macros are meant evil incarnate, yet ""template metaprogramming"" is all the rage.</p>

<p>So, what ARE the real distinctions? and how can templates avoid the dangers that #define leads you into, like</p>

<ul>
<li>Inscrutable compiler errors in
places where you don't expect them?</li>
<li>Code bloat? </li>
<li>Difficulty in tracing code?</li>
<li>Setting Debugger Breakpoints?</li>
</ul>
","87234","","<p>On a very basic level, yes, template's are just macro replacements. But you're skipping out on <em>a lot</em> of things by thinking about it that way.</p>

<p>Consider template specialization, which to my knowledge you can't simulate with macro's. Not only does that allow, well, special implementation for certain types, it's one of the key parts in template meta-programming:</p>

<pre><code>template &lt;typename T&gt;
struct is_void
{
    static const bool value = false;
}

template &lt;&gt;
struct is_void&lt;void&gt;
{
    static const bool value = true;
}
</code></pre>

<p>Which in itself is just one example of the <a href=""http://www.boost.org/doc/libs/1%5F41%5F0/libs/type%5Ftraits/doc/html/index.html"" rel=""nofollow"">many things you can do</a>. Templates themselves are Turing-complete.</p>

<p>This ignores the very basic things, such as scope, type-safety, and that macro's are messier.</p>
"
"<p>Is there a way to have a return value from the function that I pass to foreach.</p>

<p>For ex:
I have,</p>

<pre><code>void myfunction (int i) 
{
        cout &lt;&lt; "" "" &lt;&lt; i;
}

vector&lt;int&gt; myvector;
myvector.push_back(10);
for_each (myvector.begin(), myvector.end(), myfunction);
</code></pre>

<p>Lets say, I want to count the number of elements in the vector using some rule, I want to have a return value from myFunction, is this possible? </p>
","87234","","<p><code>for_each</code> will return a copy of the functor you passed it. This means you could do this:</p>

<pre><code>template &lt;typename T&gt;
class has_value
{
    has_value(const T&amp; pValue) : mValue(pValue), mFlag(false) {}

    void operator()(const T&amp; pX)
    {
        if (pX == mValue)
            mFlag = true;
    }

    operator bool(void) const { return mFlag; }
private:
    T mValue;
    bool mFlag;
};

bool has_seven = std::for_each(myvector.begin(), myvector.end(), has_value&lt;int&gt;(7));
</code></pre>

<p>For example. But for counting and the like, check out <a href=""http://www.cplusplus.com/reference/algorithm/""><code>algorithm</code></a> and see if your function already exists. (Like <a href=""http://www.cplusplus.com/reference/algorithm/count/""><code>count</code></a>)</p>
"
"<p>I'm trying to find the equivalent of int myArray[n], except I don't know what n is without input.</p>

<p>Is the following code supposed to work? (I need to use kmalloc instead of malloc).</p>

<pre><code>int * pages;
//... later, after we find out n...
pages = (int *)kmalloc(npages * sizeof(int));
</code></pre>

<p>Debugging using gdb, the value pages[0] doesn't seem to be 0 - is this expected?</p>
","87234","","<p>Yes. Memory is not initialized, you just get a pointer to your chunk of memory.</p>

<p>You'll need to <a href=""http://www.cplusplus.com/reference/clibrary/cstring/memset/"" rel=""nofollow""><code>memset</code></a> to initialize it:</p>

<pre><code>memset(pages, 0, npages * sizeof(int));
</code></pre>

<p>Also, unless I'm mistaken <code>kmalloc</code> takes a <a href=""http://people.nl.linux.org/ftp/pub/anoncvs/kernelnewbies/documents/kdoc/kernel-api/r2415.html"" rel=""nofollow"">second parameter</a>, the type of memory to allocate.</p>
"
"<p>Need advice here: which of the STL container's operations are considered read-only? Take <code>vector&lt;int&gt;</code> as example, would it be safe to say that any operation that does not alter the underlying int data is read-only? I am writing a multi-threaded program, but not too sure if it is thread-safe to pass container by reference/pointer.</p>

<p>Between, will the same rules apply to basic_string as well? Any recommended resource that helps for quickly gaining understanding on internal mechanism of STL container? Thanks.</p>
","87234","","<p>The Standard says nothing on the safety of containers, by the way. But a method marked with <code>const</code> is guaranteed to not modify the container.*</p>

<p>If thread's will be reading and writing to the data at the same time, you'll need to synchronize them.</p>

<p>*<em>Logically modify, that is. Though I don't know any containers off-hand, any mutable members can change in const methods.</em></p>
"
"<p>Let's say I want to store a vector of LPD3DXSPRITE objects.  The line to declare this code would be <code>std::vector&lt;LPD3DXSPRITE&gt; sprites;</code>  I should be able to create my sprite with:</p>

<pre><code>LPD3DXSPRITE sprite = NULL;
D3DXCreateSprite(myRenderingDevice, &amp;sprite);
</code></pre>

<p>Finally, I should be able to add this to the vector like so:</p>

<pre><code>sprites.push_back(sprite);
</code></pre>

<p>At least with my understanding, that should be plausible.  However, this compiles but gives runtime errors.  Why is this?  Am I going about it wrong?  How might I fix it?</p>

<p><strong>edit:</strong></p>

<p>This may be helpful as well.  The call stack yields for this function that <code>vector&lt;ID3DXSprite *, std::allocator&lt;ID3DXSprite *&gt;&gt;::push_back(ID3DXSprite * const &amp;_Val=0x0036fd38</code> is what is called.  This is not the vector that it was passed.<br>
However, LPD3DXSPRITE is just a typedef for ID3DXSprite *.  Could this bring anything to light?</p>
","87234","","<p>After looking through your code, I found the problem. Something to look at when you get any breaks in your application is the ""Autos"" tab or the Locals tab. Here you'll notice something about the <code>this</code> pointer: it's null!</p>

<p>That means the instance that <code>AddSprite</code> is being called on doesn't exist. This is your <code>SpriteManager</code>, which I see is a singleton. In your main, you don't create an instance of it.</p>

<p>I had to do a couple things to get it working. I included <code>""LudoRenderer/SpriteManager.h""</code> in <code>Main.cpp</code>, and added the <code>CreateInstance</code> call:</p>

<pre><code>SpriteManager::CreateInstance();
</code></pre>

<p>The only problem with this was that you had declared your constructor/destructor private, like other singletons, but never defined them, so I did that as well:</p>

<pre><code>SpriteManager::SpriteManager(){}
SpriteManager::~SpriteManager(){}
</code></pre>

<p>After those changes, it ""worked"". That's in quotes because your problem is solved, but there is another error later in the code <code>m_GameManager-&gt;SetWagon(m_Wagon);</code>.</p>

<p>Here, <code>m_GameManager</code> is not initialized. I uncommented <code>m_GameManager = GameManager::GetInstance();</code> on line 43 in <code>LudoEngine.cpp</code>, which put us in the same problem as before, no <code>CreateInstance</code> is ever called. I added the necessary header in main, called the create method. This fixed the problem, and your engine ran (cool demo, too!)</p>

<p>There was a crash on exit, in <code>ErrorLogger::LogError</code>, because <code>ErrorLogger</code> was null. It was being called in <code>LudoMemory</code>'s destructor, but I'll leave this one for you. :)</p>

<p>Now, two tips I tihnk that would help. The first is about the issue we're solving. Normally, singletons will create themselves if they aren't already. I'd change your singleton <code>GetInstance</code> to something like this:</p>

<pre><code>static T *GetInstance ( )
{
    if (!m_Singleton) // or == NULL or whatever you prefer
    {
        CreateInstance();
    }

    return m_Singleton; // not sure what the cast was for
}
</code></pre>

<p>This will force creation of the singleton if it hasn't been already. Now, if you'd like users to call <code>CreateInstance</code> before trying to <code>GetInstance</code>, you could add some sort of warning:</p>

<pre><code>static T *GetInstance ( )
{
    if (!m_Singleton) // or == NULL or whatever you prefer
    {
        CreateInstance();
        std::cerr &lt;&lt; ""Warning, late creation of singleton!"" &lt;&lt; std::endl;

        // or perhaps:
        ErrorLogger::GetInstance()-&gt;
                        LogError(L""Warning, late creation of singleton!"");
    }

    return m_Singleton;
}
</code></pre>

<p>Since that leaves out the important information ""which singleton?"", you could always try to add typeinfo to it:</p>

<pre><code>#include &lt;typeinfo&gt;

// ...

std::cerr &lt;&lt; ""Warning, late creation of singleton: ""
          &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
</code></pre>

<p>To try to get some type names in there.</p>

<p>And lastly, it's okay to <code>delete 0</code>, your checked delete macro is not needed.</p>

<p>To clarify, you have <code>LUDO_SAFE_DELETE</code>, which checks if it's not null before it calls delete. In C++, deleting null has no effect, so your check isn't needed. All instances of your safe delete could be replaced with just your LUDO_DELETE.</p>
"
"<p>I am trying to create a list object, with the iterator class nested inside to understand how it works.
In some method, I am trying to return an iterator object but it doesn't work.
I created an example to show the problem :</p>

<pre><code>// CLASS A
template &lt;class T&gt;
class A
{
    public:
    	class B;
    	A(){}
};

// CLASS B
template &lt;class T&gt;
class A&lt;T&gt;::B
{
    private:
    	int varB;

    public:
    	B(B&amp; b);
    	B(const int&amp;);
    	B returnThis();
};

template &lt;class T&gt;
A&lt;T&gt;::B::B(const int&amp; value)
{
    varB = value;
}

template &lt;class T&gt;
A&lt;T&gt;::B::B(B&amp; b)
{
    varB = b.varB;
}

template &lt;class T&gt;
A&lt;T&gt;::B A&lt;T&gt;::B::returnThis()
{
    return *this;
}

// MAIN

void main()
{
    A&lt;int&gt;::B classB(10);
}
</code></pre>

<p>The error is near those lines:</p>

<pre><code>template &lt;class T&gt;
A&lt;T&gt;::B A&lt;T&gt;::B::returnThis()
</code></pre>

<p>The compiler tells me I am missing a ; before A::B::returnThis()</p>

<p>I am trying to solve this problem for days and I can't find a way to make it work...
I would really appreciate some help.
Thanks in advance!</p>
","87234","","<p>You need <code>typename</code>:</p>

<pre><code>typename A&lt;T&gt;::B
</code></pre>

<p>To indicate to the compiler that <code>A&lt;T&gt;::B</code> is a type. Here's a <a href=""http://pages.cs.wisc.edu/~driscoll/typename.html"">good explanation</a> why. </p>

<p>What <code>B</code> is depends on what <code>A&lt;T&gt;</code> is, this is called dependency. Any time you are getting a type out of a class or struct, and it's dependent on a template, you'll need to use <code>typename</code>.</p>
"
"<p>I want to learn more C++... Usually I make a for loop to parse argv, and I wind up with a bunch a C-style strings.  I want to do something similar in C++, but preferably without reading from /proc/whatever.  At first, I tried to convert the C-style string to a C++ style string without results... The frustrating bit is that everyone on SO seems to want to know how to go the other way, which is what c_str() is for.  What's a good C++ way to do this (ie parse argv)? </p>

<p>Also, one note, I'm looking for a unix style answer, all the techniques for conversion I've seen have to do with Windows, which I'm completely uniterested in.</p>
","87234","","<p>I'm not sure I fully understand the question.</p>

<p>The cleanest method I know to get all the arguments in an easy to use array is:</p>

<pre><code>std::vector&lt;std::string&gt; v(argv, argv + argc);
</code></pre>

<p>But if you're looking for a way to really parse the data, check out <a href=""http://www.boost.org/doc/libs/1%5F41%5F0/doc/html/program%5Foptions.html"">Boost.ProgramOptions</a>.</p>
"
"<p>I am working on a small game using C++, and I used Eclipse CDT's class generator. It created a .h file with the class definitions and a .cpp file that included body-less methods for said class. </p>

<p>So if I followed the template, I'd have a .cpp file filled with the methods declarations, and a .cpp file with method bodies. However, I can't include a .cpp file within another. </p>

<p>So what is the convention in C++ with classes and include files? What I did was fill in the method bodies right under the class declaration in the .h file, and deleted the .cpp file. </p>
","87234","","<p>I'm not quite sure I understand. The header files defines what the class is and can do, and you include that into any source files that need to use the class.</p>

<p>The source file implements how the class does its action.</p>

<p>However, you <em>can</em> include a <code>.cpp</code> into another (you can include anything into anything), but you don't need to.</p>
"
"<p>Is there anyway to read a known number of bytes, directly into an std::string, without creating a temporary buffer to do so?</p>

<p>eg currently I can do it by</p>

<pre><code>boost::uint16_t len;
is.read((char*)&amp;len, 2);
char *tmpStr = new char[len];
is.read(tmpStr, len);
std::string str(tmpStr, len);
delete[] tmpStr;
</code></pre>
","87234","","<p><code>std::string</code> has a <code>resize</code> function you could use, or a constructor that'll do the same:</p>

<pre><code>boost::uint16_t len;
is.read((char*)&amp;len, 2);

std::string str(len, '\0');
is.read(&amp;str[0], len);
</code></pre>

<p>This is untested, and I don't know if strings are mandated to have contiguous storage.</p>
"
"<p>Should be a newbie question...</p>

<p>I have existing code in an existing class, A, that I want to extend in order to override an existing method, A::f().</p>

<p>So now I want to create class B to override f(), since I don't want to just change A::f() because other code depends on it.</p>

<p>To do this, I need to change A::f() to a virtual method, I believe.</p>

<p>My question is besides allowing a method to be dynamically invoked (to use B's implementation and not A's) are there any other implications to making a method virtual?  Am I breaking some kind of good programming practice?  Will this affect any other code trying to use A::f()?</p>

<p>Please let me know.</p>

<p>Thanks,
jbu</p>

<p>edit: my question was more along the lines of is there anything wrong with making someone else's method virtual?  even though you're not changing someone else's implementation, you're still having to go into someone's existing code and make changes to the declaration.</p>
","87234","","<p>There are other ways of accomplishing your goal. Does it make sense for <code>B</code> to be an <code>A</code>? For example, it makes sense for a Cat to be an Animal, but not for a Cat to be a Dog. Perhaps both A and B should derive from a base class, if they are related.</p>

<p>Is there just common functionality you can factor out? It sounds to me like you'll never be using these classes polymorphically, and just want the functionality. I would suggest you take that common functionality out and then make your two separate classes.</p>

<p>As for cost, if you're using A ad B directly, the compile will by-pass any virtual dispatching and just go straight to the functions calls, as if they were never virtual. If you pass a <code>B</code> into a place expecting `A1 (as a reference or pointer), then it will have to dispatch.</p>
"
"<p>I thought a C string can be initialized with one and only one quoted string. I just wonder how is this correct?</p>

<pre><code>char const help_message [] =   
   ""Usage: %s [options] files ...\n""   
   ""\n""   
   ""Options include:\n""   
   "" --verbose -v    Be verbose\n""   
   "" --help -h       Print this help message\n""   
   "" --output -o     Specify output file\n""     
   ""\n"" ;   

 printf (help_message, argv [0]) ;
</code></pre>
","87234","","<p>The <a href=""http://en.wikipedia.org/wiki/C%5Fsyntax#String%5Fliteral%5Fconcatenation"">compiler</a> will automatically concatenate adjacent strings.</p>

<p>This can be quite useful to increase readability, as in your example, or with some preprocessor functions:</p>

<pre><code>#define LOG(x) printf(""%s"", ""Logging: "" x)

LOG(""HeyHey"");
</code></pre>

<p>Pretty contrived example, but gets the point across.</p>
"
"<pre><code>  try {
        int* p = 0;
        *p = 1;
    } catch (...) {
        cout &lt;&lt; ""null pointer."" &lt;&lt; endl;
    }
</code></pre>

<p>I tried to catch the exception like this but it doesn't work,any help?</p>
","87234","","<p>You cannot. De-referencing a null-pointer is a system thing.</p>

<p>On Linux, the OS raises signals in your application. Take a look at <a href=""http://www.cplusplus.com/reference/clibrary/csignal/"">csignal</a> to see how to handle signals. To ""catch"" one, you'd hook a function in that will be called in the case of <code>SIGSEGV</code>. Here you could try to print some information before you gracefully terminate the program.</p>

<p>Windows uses <a href=""http://msdn.microsoft.com/en-us/library/ms680657%28VS.85%29.aspx"">structured-exception-handling</a>. You could use the instristics <code>__try/__except</code>, as outlined in the previous link. The way I did it in a certain debug utility I wrote was with the function <a href=""http://msdn.microsoft.com/en-us/library/5z4bw5h5%28VS.80%29.aspx""><code>_set_se_translator</code></a> (because it closely matches hooks). In Visual Studio, make sure you have SEH enabled. With that function, you can hook in a function to call when the system raises an exception in your application; in your case it would call it with <code>EXCEPTION_ACCESS_VIOLATION</code>. You can then throw an exception and have it propagate back out as if an exception was thrown in the first place.</p>
"
"<p>I have created a function to flip a square 2d array horizontally, so the first row is moved to the last, the second row is moved to the second from the last and so on.  </p>

<p>Here is the function:</p>

<pre><code>void flipMatrix(int size, int matrix[ROWS][COLS]) {
    int row, col;

    int temp[ROWS][COLS];

    for (row=0; row &lt; size; row++) {
    	for (col=0; col &lt; size; col++) {
    		temp[(size - 1)-row][col] = matrix[row][col];
    	}
    }

    //A simple function that copies the temp array to matrix, so that  
    //I can then print the matrix array
    copyArray(size, matrix, temp);
}
</code></pre>

<p>I know that this is very inefficient, but I am pretty new to C++.  I was wondering how I would adapt this to be more efficient, maybe by returning a pointer?  I'm also wondering if there is a way to do this without creating a temporary array?  </p>

<p>I should also note, I am trying to do this without using the STL.  </p>

<p>Thanks for the help.</p>
","87234","","<p>You can use <a href=""http://www.cplusplus.com/reference/algorithm/swap/"" rel=""nofollow""><code>std::swap</code></a> and just swap the values in-place:</p>

<pre><code>void flipMatrix(int size, int matrix[ROWS][COLS])
{
    for (int row = 0; row &lt; ROWS; ++row)
    {
        for (col=0; col &lt; COLS / 2; ++col) // half the column, lest you undo it
        {
            std::swap(matrix[ROWS - row - 1][col], matrix[row][col]);
        }
    }
}
</code></pre>

<p>Swap is defined in <a href=""http://www.cplusplus.com/reference/algorithm/"" rel=""nofollow""><code>&lt;algorithm&gt;</code></a>. If you really can't use STL, swap is simple enough to implement:</p>

<pre><code>template &lt;typename T&gt;
void swap(T&amp; pA, T&amp; pB)
{
    T temp = pA;
    pA = pB;
    pB = temp;
}
</code></pre>
"
"<p>Each time I have seen the catch all statement:</p>

<pre><code>try 
{
  // some code 
}
catch (...)
{

}
</code></pre>

<p>it has <strong>always</strong> been an abuse.   </p>

<p>The arguments against using cache all clauses are obvious. It will catch  <em>anything</em> including OS generated exceptions such as access violations.
Since  the exception handler can't know what it's dealing with,  in most cases the exceptions will  manifest as obscure log messages or some incoherent message box. </p>

<p>So <code>catch(...)</code> seems inherently evil.  </p>

<p>But it is still implemented in C++ and other languages (Java, C#) implements similar mechanisms. So is there some cases when its usage is justified?</p>
","87234","","<p><code>catch(...)</code> has been useful for me in two circumstances, both of which are unjustified (I can't even remember the second)</p>

<p>The first is my overall application safety. While throwing exceptions that don't derive from <code>std::exception</code> is a No-No, I have one just in case in my <code>main()</code> function:</p>

<pre><code>int execute(void); // real program lies here

int main(void)
{
    try
    {
        return execute();
    }
    catch(const std::exception&amp; e)
    {
        // or similar
        std::cerr &lt;&lt; ""Unhandled exception: "" &lt;&lt; e.what() &lt;&lt; std::endl;
        return EXIT_FAILURE;
    }
    catch(...)
    {
        std::cerr &lt;&lt; ""Unknown exception!"" &lt;&lt; std::endl;
        return EXIT_FAILURE;
    }
}
</code></pre>

<p>Now, it's only there ""just in case"", and it's not <em>really</em> justified. There should be no reason to ever enter that catch clause, as that would mean somebody has done a Bad Thing. Observe how useless the statement really is; ""Something bad happened, no clue what!"" It's only a step above just crashing in the first place.</p>

<p>The second use might be in destructors or some other function that needs to do manual management before letting the exception propagate. That's not really a justification either, as things should clean themselves up safely with RAII. But I may have used it once or twice for some reason I can't recall, and I can't see a reason to ever do so again.</p>
"
"<p>I'm reading a file in C++ using streams, specifically, fstream, not ifstream.</p>

<pre><code>blah blah blah\n
blah blah\n
blah blah blah blah \n
end
</code></pre>

<p>This repeats over and over with</p>

<ol>
<li>varble number of blah's in each line,</li>
<li>constant number of lines between each end, end is the delimiter here</li>
</ol>

<p>I want to read one set of data, then store it in a character array, in a C style structure.  I started by trying to use getline() but the delimter can only be one character, not three.  I obviously can't try to read a set number of bytes using just read(), as the number will be different for each set.  </p>

<p>So I'm torn over what the easiest (and most robust) thing to do here is.  Should I call getline until I find an 'end' string, while appending each string over and over?  </p>

<p>I tried a 2D char array but I copying to it was kind of a pain.  Can I use strncpy here? I don't think this worked</p>

<pre><code>char buf[10][10];
strncpy(buf[1], ""blah blah"",10);
</code></pre>

<p>I have a few ideas here, but I'm just not sure which one (or the one I haven't though of) is the best.</p>

<p>EDIT:
So this is for a networking application, so the size of the char array (or string) should always be the same.  Also, there should be no pointers in the structure.  </p>

<p>Related question: is the way that a char array and a std::string are stored in memory the same?  I always though there was some overhead with std::string.</p>
","87234","","<p>Well, you said ""in a C style structure"", but perhaps you can just use <a href=""http://www.cplusplus.com/reference/string/"" rel=""nofollow""><code>std::string</code></a>?</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main(void)
{
    std::fstream file(""main.cpp"");
    std::vector&lt;std::string&gt; lines;

    std::string line;
    while (getline(file, line))
    {
    	if (line == ""end"")
    	{
    		break;
    	}

    	std::cout &lt;&lt; line &lt;&lt; std::endl;
    	lines.push_back(line);
    }

    // lines now has all the lines up-to
    // and not including ""end""

/* this is for reading the file
end

some stuff that'll never get printed
or addded blah blah
*/
};
</code></pre>
"
"<p>In C and C++ <code>assert</code> is a <em>very</em> heavyweight routine, writing an error to <code>stdout</code> and terminating the program. In our application we have implemented a much more robust replacement for assert and given it its own macro. Every effort has been made to replace <code>assert</code> with our macro, however there are still many ways <code>assert</code> can be reintroduced (e.g., from internal third-party libraries, naïve injection, etc.)</p>

<p>Any suggestions on how we can reduce, limit or even eradicate uses of <code>assert</code>? The best answer will be one the compiler can catch for us so we don't have to babysit the code base as much as we do currently.</p>
","87234","","<p>I'm not sure I really understand the problem, actually. Asserts are only expensive if they go off, which is fine anyway, since you're now in an exception situation.</p>

<p><code>assert</code> is only enabled in debug builds, so use the release build of a third-party library. But really, asserts shouldn't be going off every moment.</p>
"
"<p>Is there any way to get Intellisense in Visual C++ for Visual Studio 2005?</p>

<p>I'm trying to get the Boost libraries to load up with intellisense and in the object browser/class view.</p>

<p>I installed the binary for Windows with the <a href=""http://www.boostpro.com/download"" rel=""nofollow"">BoostPro installer</a> (BoostPro 1.40.0 Installer).</p>

<p>I'm not certain that it comes with the source code however, which may be required to make Intellisense work in VS2005.  </p>
","87234","","<p><a href=""http://www.boost.org/"" rel=""nofollow"">Boost</a> is <a href=""http://sourceforge.net/projects/boost/files/boost/1.41.0/"" rel=""nofollow"">open source</a>, and mostly header only. Just make sure IntelliSense knows the directory where boost resides so it can explore it.</p>

<p>As an un-answer, you might try out <a href=""http://www.wholetomato.com/"" rel=""nofollow"">Visual Assist X</a>, which works far better and has more features that Visual Studio's IS.</p>

<p>To make sure Intellisense can find boost, just make sure Boost is in the include directories (under Project Properties->C/C++->Additional Include Directories). Maybe move it to the top. After that, close your instance of Visual Studio, and search the a <code>*.ncb</code> file near your project, and delete it. This will cause IntelliSense to refresh. This should hopefully be enough for it to assist you. (You have to include boost headers into your source files with <code>#include</code> for IntelliSense to consider it)</p>

<p>Keep in mind boost has some very complex parts that IS will choke on, but should still provide the names.</p>
"
"<p>How to compute the output for the recursive functions ? I know recursion invokes a stack, but am confusing while solving some aptitude question.  </p>

<p>Given the following code snippet:</p>

<pre><code>#include &lt;stdio.h&gt;

void fun(int a){
 if(a&gt;0){
	fun(--a);
	printf(""%d "",a);
	fun(--a);
	printf(""%d "",a);
 }
return;
}

int main(void){
  int  num = 5;
  fun(num);
return 0;
}
</code></pre>

<p>This is not any home work assignment but I am unable to solve such question under exam condition.<strong>(Theoretical exam without Compiler)</strong></p>

<p>What is the standard way to solve such question ? Please explain with a small example.Any pointer in the right direction or some web link will be welcomed.</p>
","87234","","<p>You have to be the compiler and computer. Write down the stack as you go:</p>

<blockquote>
  <p>Enter main, call fun with 5.
  In fun, 5 is greater than 0, so
  I first decrement 5 to 4, then call fun again</p>
</blockquote>

<p>Here if you are writing, I would move to the side and ""start a new stack""</p>

<blockquote>
  <p>I enter fun with 4, which is greater than 0
  I decrement 4 to 3, then call fun again</p>
</blockquote>

<p>Repeat</p>

<blockquote>
  <p>I enter fun with 3, which is greater than 0
  I decrement 3 to 2, then call fun again</p>
</blockquote>

<p>Repeat again</p>

<blockquote>
  <p>I enter fun with 2, which is greater than 0
  I decrement 2 to 1, then call fun again</p>
</blockquote>

<p>And once more</p>

<blockquote>
  <p>I enter fun with 1, which is greater than 0
  I decrement 1 to 0, then call fun again</p>
</blockquote>

<p>And enter for the last time, this time</p>

<blockquote>
  <p>I enter fun with 0, which is <strong>not</strong> greater than 0
  I return</p>
</blockquote>

<p>Now you go back to where you were:</p>

<blockquote>
  <p>I enter fun with 1, which is greater than 0
  I decrement 1 to 0, then call fun again
  <em>I print out 0</em></p>
</blockquote>

<p>On print commands, write that in yet another space, which now only contains ""0"". continue the function:</p>

<blockquote>
  <p>I enter fun with 1, which is greater than 0
  I decrement 1 to 0, then call fun again
  I print out 0
  <em>I decrement 0 to -1 and call fun again</em></p>
</blockquote>

<p>Here's another stack, but -1 is not greater than 0, so it does nothing. We go back into the function:</p>

<blockquote>
  <p>I enter fun with 1, which is greater than 0
  I decrement 1 to 0, then call fun again
  I print out 0
  I decrement 0 to -1 and call fun again
  <em>I print out -1</em></p>
</blockquote>

<p>And we finish this stack. We go back to an older stack (we just finished entering fun with 1, so look for the stack that ends with ""decrement to 1 and call fun again""):</p>

<blockquote>
  <p>I enter fun with 2, which is greater than 0
  I decrement 2 to 1, then call fun again
  <em>I print out 1</em>
  <em>I decrement 1 to 0, then call fun again</em></p>
</blockquote>

<p>Calling <code>fun(0)</code> does nothing, so we return and continue:</p>

<blockquote>
  <p>I enter fun with 2, which is greater than 0
  I decrement 2 to 1, then call fun again
  I print out 1
  I decrement 1 to 0, then call fun again
  I print out 0</p>
</blockquote>

<p>Then we go to the next oldest stack (we just finished entering fun with 2, so look for the stack that ends with ""decrement to 2 and call fun again""):</p>

<blockquote>
  <p>I enter fun with 3, which is greater than 0
  I decrement 3 to 2, then call fun again
  <em>I print out 2</em>
  <em>I decrement 2 to 1, then call fun again</em></p>
</blockquote>

<p>Here's an important time saver! We've already called <code>fun(1)</code> once before, there's no need to really go through it again. What did <code>fun(1)</code> print out? Look up and you'll see it added ""0-1"" to the output, so save time and just append that.</p>

<p>This continues until you have finished. It's a lot of work, but writing down your current stacks is the easiest way to complete it. For the sake of trying to keep this already long answer short, the rest is up to you. :)</p>
"
"<p>Is there're way to pass boost::tuple to printf()? </p>
","87234","","<p>Not directly, because <code>printf</code> requires certain format specifiers. You'd need to print each element out at a time.</p>

<p>You might make a template function that iterates over the elements of the tuple, printing them out. <a href=""http://stackoverflow.com/questions/1198260/iterate-over-tuple"">This question</a> address that. That said, that again won't work unless each element can be printed out with <code>printf</code>.</p>

<p>Rather, why not use <code>iostream</code> instead? Then you can just say <code>std::cout &lt;&lt; theTuple</code>.</p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/1173208/what-is-the-best-practice-for-combating-the-console-closing-issue"">What is the Best Practice for Combating the Console Closing Issue?</a>  </p>
</blockquote>

<p>How do you keep the console from closing after the program is done in C? When I try to search for it I find lots of stuff about C++ and other languages, but nothing for C. Also, even for C++ there doesn't seem to be a definitive answer.</p>

<p>So could someone please let me know what the simplest way (doesn't need to be super elegant) way to keep the console open after a C program is done running?</p>
","87234","","<p>Console applications are meant to be run from the console. If you do that, after running you'll be left with your console window, and can easily view the output of your program.</p>

<p>You can use something like <code>getchar()</code> to force the application to wait for a key-press.</p>
"
"<p>I'm wondering if a class's member function should be const if it calls other functions that modify its data members. A good example would be a public member function that uses private member functions to do the brunt of the work.</p>

<pre><code>void Foo::Show() const { // Doesn't directly modify data members in this function
    ShowPig(); // One or all of these functions modify data members
    ShowCow();
    ShowBar();
}
</code></pre>

<p>Maybe not the best example, but you get the idea.</p>
","87234","","<p>If a function calls functions that modify certain data, then it should be said that the function itself modifies data. It just happens to be abstracted.</p>

<p>So no, that function should not be const.</p>
"
"<p>I was wondering if it is possible to iterate over arguments passed to a variadic macro in C99 or using any GCC extensions ?</p>

<p>For e.g. is it possible to write a generic macro that takes a structure and its fields passed as arguments and prints offset of each field within the structure ?</p>

<p>Something like this:</p>

<pre>
struct a {
    int a;
    int b;
    int c;
};

/* PRN_STRUCT_OFFSETS will print offset of each of the fields 
   within structure passed as the first argument.
*/

int main(int argc, char *argv[])
{
    PRN_STRUCT_OFFSETS(struct a, a, b, c);

    return 0;
}
</pre>
","87234","","<p>This is the best I can think of, with standard C:</p>

<pre><code>#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;

// prints a single offset
#define PRN_STRUCT_OFFSET(x, a) printf(""&amp;"" #x ""."" #a "" = %d\n"", offsetof(x, a));

// prints a struct with one member
#define PRN_STRUCT_OFFSETS_1(x, a) PRN_STRUCT_OFFSET(x, a)

// prints a struct with two members
#define PRN_STRUCT_OFFSETS_2(x, a, b) \
            PRN_STRUCT_OFFSET(x, a) \
            PRN_STRUCT_OFFSET(x, b)

// and so on until some N.
// Boost.Preprocessor might help here, I'm not sure

struct some_struct
{
    int a;
    void* c;
};

int main(void)
{
    PRN_STRUCT_OFFSETS_2(struct some_struct, a, c);

    return 0;
}
</code></pre>
"
"<p>I'm not exactly a C++ newbie, but I have had little serious dealings with it in the past, so my knowledge of its facilities is rather sketchy.</p>

<p>I'm writing a quick proof-of-concept program in C++ and I need a dynamically sizeable buffer of binary data. That is, I'm going to receive data from a network socket and I don't know how much there will be (although not more than a few MB). I could write such a buffer myself, but why bother if the standard library probably has something already? I'm using VS2008, so some Microsoft-specific extension is just fine by me. I only need four operations:</p>

<ul>
<li>Create the buffer</li>
<li>Write data to the buffer (binary junk, not zero-terminated)</li>
<li>Get the written data as a char array (together with its length)</li>
<li>Free the buffer</li>
</ul>

<p>What is the name of the class/function set/whatever that I need?</p>

<p><strong>Added:</strong> Several votes go to <code>std::vector</code>. All nice and fine, but I don't want to push several MB of data byte-by-byte. The socket will give data to me in few-KB large chunks, so I'd like to write them all at once. Also, at the end I will need to get the data as a simple char*, because I will need to pass the whole blob along to some Win32 API functions unmodified.</p>
","87234","","<p>You want a <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow""><code>std::vector</code></a>:</p>

<pre><code>typedef std::vector&lt;char&gt; buffer_type;
buffer_type myData;
</code></pre>

<p><code>vector</code> will automatically allocate and deallocate its memory for you. Use <code>push_back</code> to add new data (<code>vector</code> will resize for you if required), and the indexing operator <code>[]</code> to retrieve data.</p>

<p>If at any point you can guess how much memory you'll need, I suggest calling <code>reserve</code> so that subsequent <code>push_back</code>'s won't have to reallocate as much.</p>

<p>If you want to read in a chunk of memory and append it to your buffer, easiest would probably be something like:</p>

<pre><code>typedef std::vector&lt;char&gt; buffer_type;
buffer_type myData;

do
{
    static const BufferSize = 1024;
    char rawBuffer[BufferSize];

    const unsigned bytesRead = get_network_data(rawBuffer, BufferSize); // pseudo

    myData.insert(myData.end(), rawBuffer, rawBuffer + bytesRead);
} while (bytesRead &gt; 0);
</code></pre>

<p><code>myData</code> now has all the read data.</p>

<p>If you need to treat your data as a raw-array, take the address of the first element:</p>

<pre><code>some_c_function(&amp;myData[0], myData.size());
</code></pre>

<p>For raw data (what you're using), try something like this:</p>

<pre><code>typedef std::vector&lt;char&gt; buffer_type;
buffer_type myData;

do
{
    static const BufferSize = 1024;

    const size_t oldSize = myData.size();
    myData.resize(myData.size() + BufferSize);        

    const unsigned bytesRead =
                       get_network_data(&amp;myData[oldSize], BufferSize); // pseudo

    myData.resize(oldSize + bytesRead);
} while (bytesRead &gt; 0);
</code></pre>

<p>Which reads directly into the buffer.</p>
"
"<p>So I have a function in an app that needs to let the user calculate a trig function (sin,cos,tan) using radians OR degrees, and also to expect a returned value from inverse trig functions (asin,acos,atan) as either radians or degrees.  is there any way to do this without building in a converter directly into the way they input something? what i am trying to avoid is having to convert: sin(45) to sin(dtor(45))
thanks!</p>
","87234","","<p>There isn't a way to change the way the functions operate.</p>

<p>A ""solution"" would be to re-make the interface, and do the conversions:</p>

<pre><code>// for example
float sin(float pX)
{
    return std::sinf(d2r(pX));
}
</code></pre>

<p>And use that interface instead. Put it in a <code>math::</code> namespace.</p>
"
"<p>Of course, I know the best answer is ""don't write your own cross-platform code, someone has already done what you need,"" but I'm doing this as a hobby/learning exercise and not in any paid capacity.  Basically, I'm writing a smallish console application in C++, and I'd like to make it cross platform, dealing with things like files, sockets, and threads.  OOP seems like a great way to handle this, but I haven't really found a good pattern for writing classes that share the same interface cross platform.</p>

<p>The easy approach is to just plan out some meta-interface, use that throughout the rest of the program, and just compile the same class with different files depending on the platform, but I feel like there's got to be a better way that's more elegant; at the very least, something that doesn't confuse IntelliSense and its ilk would be nice.</p>

<p>I've taken a look at some of the smaller classes in the wxWidgets source, and they use an approach that uses a private member holding data for the class, e.g</p>

<pre><code>class Foo
{
    public:
        Foo();

        void Bar();
    private:
        FooData data;
};
</code></pre>

<p>You can then compile this by simply choosing different implementation files depending on the platform.  This approach seems pretty clunky to me.</p>

<p>Another approach I've considered is writing an interface, and swapping out classes that inherit from that interface depending on the platform.  Something like this:</p>

<pre><code>class Foo
{
    public:
        virtual ~Foo() {};
        virtual void Bar() = 0;
};

class Win32Foo
{
    public:
        Win32Foo();
        ~Win32Foo();
        void Bar();
};
</code></pre>

<p>Of course this kind of screws up the actual instantiation since you don't know which implementation to create an object of, but that can be worked around by using a function</p>

<pre><code>Foo* CreateFoo();
</code></pre>

<p>and varying the implementation of the function based on which platform you're running on.  I'm not a huge fan of this either, because it still seems clunky littering the code with a bunch of instantiation method (and this would also be inconsistent with the method of creating non-cross-platform objects).</p>

<p>Which of these two approaches is better?  Is there a better way?</p>

<p><strong>Edit:</strong> To clarify, my question is not ""How do you write cross-platform C++?""  Rather, it's ""What is the best method to abstract away cross-platform code using classes in C++, while retaining as much benefit from the type system as possible?""</p>
","87234","","<p>Define your interface, which forwards to <code>detail</code> calls:</p>

<pre><code>#include ""detail/foo.hpp""

struct foo
{
    void some_thing(void)
    {
        detail::some_thing();
    }
}
</code></pre>

<p>Where ""detail/foo.hpp"" is something like:</p>

<pre><code>namespace detail
{
    void some_thing(void);
}
</code></pre>

<p>You'd then implement this in <code>detail/win32/foo.cpp</code> or <code>detail/posix/foo.cpp</code>, and depending on which platform your compiling for, compile one or the other.</p>

<p>Common interface just forwards calls to implementation-specific implementations. This is similar to how boost does it. You'll want to look at boost to get the full details.</p>
"
"<p>I'm wondering whether the C++ string is considered small enough to be more efficient when passed by value than by reference.</p>
","87234","","<p>No. Pass it by reference:</p>

<pre><code>void foo(const std::string&amp; pString);
</code></pre>

<p>In general, pass things by-reference if they have a non-trivial copy-constructor, otherwise by-value.</p>

<p>A string usually consists of a pointer to data, and a length counter. It may contain more or less, since it's implementation defined, but it's highly unlikely your implementation only uses one pointer.</p>

<p>In template code, you may as well use <code>const T&amp;</code>, since the definition of the function will be available to the compiler. This means it can decide if it should be a reference or not for you. (I think)</p>
"
"<p>I am using a doubly linked list in a C program. I am getting confused about freeing the memory.</p>

<ol>
<li>Should I free the list node by node?</li>
<li>Or, by assigning head and tail nodes to NULL?</li>
</ol>
","87234","","<p>If they were dynamically allocated, you need to free the nodes. Keep in mind that if your nodes hold pointers to some data, and that data was also dynamically allocated, you'll need to free that too.</p>

<p>Something like:</p>

<pre><code>list_node* node = head;
while (node)
{
    /* depends */
    /* free(node-&gt;data); */

    list_node* next = node-&gt;next;
    free(node);
    node = next;
}
</code></pre>
"
"<p>I am not getting why if there is an active exception then if an exception is raised again, it leads to termination of program. Could someone explain?</p>
","87234","","<p>What is it suppose to do? It can't ""double catch"" or anything, nor does it make sense to simply ignore one. The standard specifies that if, during stack unwinding, another exception escapes, then <code>terminate</code> shall be called.</p>

<p>There is more discussion in the <a href=""http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.3"" rel=""nofollow"">C++ FAQ</a>. One ""solution"" is to wrap your destructor code in a try/catch block, and simply don't let exceptions escape.</p>

<p>Another is to come up with some sort of custom exception chaining scheme. You'd do the above, but instead of ignoring an exception, you would append it to the currently thrown exception, and at the catch site handle both by hand.</p>

<p>The best solution, I think, it to try to remove the exceptional code from your destructor.</p>
"
"<p>If I've registered my very own vectored exception handler (VEH) and a StackOverflow exception had occurred in my process, when I'll reach to the VEH, will I'll be able to allocate more memory on the stack? will the allocation cause me to override some other memory? what will happen?<br>
I know that in .Net this is why the entire stack is committed during the thread's creation, but let's say i'm writing in native and such scenario occurs ... what will i able to do inside the VEH? what about memory allocation..?</p>
","87234","","<p>In the case of a stack overflow, you'll have a tiny bit of stack to work with. It's enough stack to start a new thread, which will have an entirely new stack. From there, you can do whatever you need to do before terminating.</p>

<p>You cannot recover from a stack overflow, it would involve unwinding the stack, but your entire program would be destroyed in the progress. Here's some code I wrote for a stack-dumping utility:</p>

<pre><code>// stack overflows cannot be handled, try to get output then quit   
set_current_thread(get_current_thread());
boost::thread t(stack_fail_thread);

t.join(); // will never exit
</code></pre>

<p>All this did was get the thread's handle so the stack dumping mechanism knew which thread to dump, start a new thread to do the dumping/logging, and wait for it to finish (which won't happen, the thread calls <code>exit()</code>).</p>

<p>For completeness, <code>get_current_thread()</code> looked like this:</p>

<pre><code>const HANDLE process = GetCurrentProcess();
HANDLE thisThread = 0;
DuplicateHandle(process, GetCurrentThread(), process,
        &amp;thisThread, 0, true, DUPLICATE_SAME_ACCESS);
</code></pre>

<p>All of these are ""simple"" functions that don't require a lot of room to work (and keep in mind, the compiler will inline these msot likely, removing a function call). You cannot, contrarily, throw an exception. Not only does that require much more work, but destructors can do quite a bit of work (like deallocating memory), which tend to be complex as well.</p>

<p>Your best bet is to start a new thread, save as much information about your application as you can or want, then terminate.</p>
"
"<p>Is there any sort of performance difference between the arithmetic operators in c++, or do they all run equally fast? E.g. is ""++"" faster than ""+=1""? What about ""+=10000""? Does it make a significant difference if the numbers are floats instead of integers? Does ""*"" take appreciably longer than ""+""?</p>

<p>I tried performing 1 billion each of ""++"", ""+=1"", and ""+=10000"". The strange thing is that the number of clock cycles (according to time.h) is actually counterintuitive. One might expect that if any of them are the fastest, it is ""++"", followed by ""+=1"", then ""+=10000"", but the data shows a slight trend in the opposite direction. The difference is more pronounced on 10 billion operations. This is all for integers.</p>

<p>I am dabbling in scientific computing, so I wanted to test the performance of operators. If any of the operators operated in time that was linear in terms of the inputs, for example.</p>
","87234","","<p>About your edit, the language says nothing about the architecture it's running on. Your question is platform dependent.</p>

<p>That said, typically all fundamental data-type operations have a one-to-one correspondence to assembly.</p>

<p>x86 for example has an instruction which increments a value by 1, which <code>i++</code> or <code>i += 1</code> would translate into. Addition and multiplication also have single instructions.</p>

<p>Hardware-wise, it's fairly obvious that adding or multiplying numbers is at least linear in the number of bits in the numbers. Because the hardware has a constant number of bits, it's O(1).</p>

<p>Floats have their own processing unit, usually, which also has single instructions for operations.</p>

<p><hr></p>

<p>Does it matter?</p>

<p>Why not write the code that does what you need it to do. If you want to add one, use ++. If you want to add a large number, add a large number. If you need floats, use floats. If you need to multiply two numbers, then multiply them.</p>

<p>The compiler will figure out the best way to do what you want, so instead of trying to be tricky, do what you need and let it do the hard work.</p>

<p>After you've written your working code, and you decide it's too slow, <strong>profile</strong> it and find out why. You'll find it's not silly things like multiplying versus adding, but rather going about the entire (sub-)problem in the wrong way.</p>

<p>Practically, all of the operators you listed will be done in a single CPU instruction anyway, on desktop platforms.</p>
"
"<p>Is there a safer way to typecast data from a generic pointer.?
More specifically , is there a way to check if the type casting is safe or not.</p>

<p>Suppose void*data we receive from the recv function in netwrking code.</p>

<p>Suppose there are two  structures:</p>

<pre><code>struct data1
{
int val;
double val1;
}

struct data2
{
char str[100];
long double val3;
}
</code></pre>

<p>Suppose we have the following receive call:</p>

<pre><code>recv(int s, void *buf, size_t len, int flags);
</code></pre>

<p>and buf can be of type struct data1 or struct data2. 
Here are my questions:</p>

<ol>
<li><p>Can we perform some sort of check of which type is stored in buf?</p></li>
<li><p>What happens if the following happens:</p>

<pre><code>// buf contains a message of type data1 


struct data2 *d2; // assume its malloced too


d2 = (struct data2)buf;


 d2-&gt;val3=3.145
</code></pre></li>
</ol>
","87234","","<p>If you've serialized your data and sent it, all you've got now is raw bytes. There's no way to determine what type raw data is.</p>

<p>The only way to try and alleviate the issue is to create a standard way of communicating the type as well. Simple method:</p>

<pre><code>enum possible_types
{
    t_data1 = 0,
    t_data2,
};
</code></pre>

<p>And send that first. The receiver can check what type it's suppose to be there.</p>
"
"<p>gcc 4.4.1</p>

<p>I am maintaining someone's code and I have come across something that I don't understand.</p>

<pre><code>#define RES_API(name, func) name##_##func
</code></pre>

<p>Can anyone explain?</p>

<p>Many thanks,</p>
","87234","","<p>The <code>##</code> operator concatenates two tokens. In your case, <code>name</code> is appended with an underscore, and that is appended with <code>func</code>.</p>

<p>So <code>RES_API(aName, aFunc)</code> results in <code>aName_aFunc</code>.</p>

<p>By itself, it seems rather annoying. I could see a use when mixing C and C++ code, as C libraries tend to prefix their functions, while C++ libraries would place them in a namespace.</p>

<p>Given an alternate definition, such as:</p>

<pre><code>#define RES_API(name, func) name##::##func
</code></pre>

<p>You suddenly have a generic way to switch between a C interface, or C++.</p>
"
"<p>We are working on a game engine written in C and currently we are using the following naming conventions.</p>

<pre><code>ABClass object;
ABClassMethod(object, args)
</code></pre>

<p><strong>AB</strong> Being our prefix.</p>

<p>Our API, even if working on objects, does not have inheritance, polymorphism or anything. All we have is data types and methods working on them.</p>

<p>Our Constants are named alike: <code>AB_ConstantName</code> and Preprocessor macros are named like <code>AB_API_BEGIN</code>. We don't use function like macros.</p>

<p>I was wondering how this was fitting as a C API. Also, you may note that the entire API is wrapper into <code>lua</code>, and you can either use the API from <code>C</code> or <code>lua</code>. Most of the time the engine will be used from lua.</p>
","87234","","<p>This seems standard enough. OpenGL did it with a <code>gl</code> prefix, so you can't be that far off. :)</p>
"
"<p>I tried to do something like this:</p>

<pre><code>int&amp; g(int&amp; number = 0)
{
//maybe do something with number
    return number;
}
</code></pre>

<p>but it doesn't work. It has to be passed by reference.
Thank you for any help.</p>

<p>P.S.
I think that ""Related Questions"" appearing once you type Title is a good idea, but I also think that they should be displayed only if they are related to specific language, i.e. it is less than useless for me to looking at topic with similar problem but in Ruby.</p>
","87234","","<p>You have a non-const reference, which means you can modify the referand. But your default is the <em>constant</em> 0.</p>

<p>Does it really make sense for this function to have a default?</p>
"
"<p>When invoking the method <code>push_back</code> from <code>std::vector</code>, its size is incremented by one, implying in the creation of a new instance, and then the parameter you pass will be copied into this recently created element, right? Example:</p>

<pre><code>myVector.push_back(MyVectorElement());
</code></pre>

<p>Well then, if I want to increase the size of the vector with an element simply using its default values, wouldn't it be better to use the <code>resize</code> method instead? I mean like this:</p>

<pre><code>myVector.resize(myVector.size() + 1);
</code></pre>

<p>As far as I can see, this would accomplish exactly the same thing but would avoid the totally unnecessary assignment copy of the attributes of the element. </p>

<p>Is this reasoning correct or am I missing something?</p>
","87234","","<p>I find <code>myVector.push_back(MyVectorElement());</code> much more direct and easier to read.</p>

<p>The thing is, <code>resize</code> doesn't just resize the array and default-construct elements on those places; that's just what it defaults to. It actually takes a second parameter which is what each new element will be made a copy of, and this defaults to <code>T()</code>. In essence, your two code samples are <strong>exactly</strong> the same.</p>
"
"<p>I am maintaining a fixed-length table of 10 entries. Each item is a structure of like 4 fields. There will be insert, update and delete operations, specified by numeric position. I am wondering which is the best data structure to use to maintain this table of information:</p>

<ol>
<li><p>array - insert/delete takes linear time due to shifting; update takes constant time; no space is used for pointers; accessing an item using [] is faster.</p></li>
<li><p>stl vector - insert/delete takes linear time due to shifting; update takes constant time; no space is used for pointers; accessing an item is slower than an array since it is a call to operator[] and a linked list .</p></li>
<li><p>stl list - insert and delete takes linear time since you need to iterate to a specific position before applying the insert/delete; additional space is needed for pointers; accessing an item is slower than an array since it is a linked list linear traversal.</p></li>
</ol>

<p>Right now, my choice is to use an array. Is it justifiable? Or did I miss something?</p>

<p>Which is faster: traversing a list, then inserting a node or shifting items in an array to produce an empty position then inserting the item in that position?</p>

<p>What is the best way to measure this performance? Can I just display the timestamp before and after the operations?</p>
","87234","","<p>You're making assumptions you shouldn't be making, such as ""accessing an item is slower than an array since it is a call to operator[]."" I can understand the logic behind it, but you nor I can know until we profile it.</p>

<p>If you do, you'll find there is no overhead at all, when optimizations are turned on. The compiler inlines the function calls. There <em>is</em> a difference in memory performance. An array is statically allocated, while a vector dynamically allocates. A list allocates per node, which can throttle cache if you're not careful.</p>

<p>Some solutions are to have the <code>vector</code> allocate from the stack, and have a pool allocator for a <code>list</code>, so that the nodes can fit into cache.</p>

<p>So rather than worry about unsupported claims, you should worry about making your design as clean as possible. So, which makes more sense? An array, vector, or list? I don't know what you're trying to do so I can't answer you.</p>

<p>The ""default"" container tends to be a <code>vector</code>. Sometimes an array is perfectly acceptable too.</p>
"
"<p>I'm trying to learn C++ by doing everything ""the C++ way"".  I'm writing a program where I have all of these known values (at compile time).  Here is my problem:</p>

<p>In my constructor I want to check to see if a passed value(an int) is one of 2,4,8,16 or 32 and throw an error elsewise.  I've though about:</p>

<ol>
<li>making a C style array or ints</li>
<li>creating a vector before by hand and interating through it to check</li>
<li>making a list?  I've never used lists before though.</li>
</ol>

<p>What I really want to do is make a const vector in a separate header file, this doesn't seem possible though.  </p>

<p>What is the most elegant way to do this check?</p>

<p>Also, similarly is there any way to make a vector with a set number of known values (at compile time) in a header?  If I can do <code>const std::string a_str(""a string"");</code> I don't see why I can't use a similar technique for vectors.</p>
","87234","","<p>What's wrong with:</p>

<pre><code>if (!(n == 2 || n == 4 || n == 8 || n == 16 || n == 32))
{
    // no!
}
</code></pre>

<p>If you want the ""C++ way"", a static array should do, with <code>find</code>:</p>

<pre><code>template &lt;typename T, size_t N&gt;
T* endof(T (&amp;pArray)[N])
{
    return &amp;pArray[0] + N;
}

static const int OkNumbers[] = {2, 4, 8, 16, 32};
static const int* OkNumbersEnd = endof(OkNumbers);
if (std::find(OkNumbers, OkNumbersEnd, n) == OkNumbersEnd)
{
    // no!
}
</code></pre>

<p>Modifying this list is simple, and I'm guessing the compiler <em>may</em> optimize this to my previous answer.</p>
"
"<p>I'm trying to use pass by reference in C so that the function can modify the values of the parameters passed to it.  This is the function signature:</p>

<pre><code>int locate(char *name, int &amp;s, int &amp;i)
</code></pre>

<p>However when I try to compile it I get this error that refers specifically to the above line:</p>

<blockquote>
  <p>error: expected ‘;’, ‘,’ or ‘)’ before
  '&amp;' token</p>
</blockquote>

<p>If I remove the '&amp;' the program will compile, but it will not function correctly, obviously.  What's wrong here?  How can I make call by reference work?</p>
","87234","","<p>C does not have references. You need to pass a pointer to the variable you wish to modify:</p>

<pre><code>int locate(char *name, int *s, int *i)
{
    /* ... */

    *s = 123;
    *i = 456;
}

int s = 0;
int i = 0;
locate(""GMan"", &amp;s, &amp;i);

/* s &amp; i have been modified */
</code></pre>
"
"<p>let's i have this loop :</p>

<pre><code>static a;
for (static int i=0; i&lt;10; i++)
{
   a++;
   ///// point A
}
</code></pre>

<p>to this loop 2 threads enters...</p>

<p>i'm not sure about something.... what will happen in case thread1 gets into POINT A , stay there, while THREAD2 gets into the loop 10 times, but after the 10'th loop after incrementing i's value to 10, before checking i's value if it's less then 10,
Thread1 is getting out of the loop and suppose to increment i and get into the loop again. 
what's the value that Thread1 will increment (which i will he see) ? will it be 10 or 0 ? </p>

<p>is it posibble that Thread1 will increment i to 1, and then thread 2 will get to the loop again for 9 times (and them maybe 8 ,7 , etc...)</p>

<p>thanks</p>
","87234","","<p>I'm just going to use <code>i++</code> in your loop:</p>

<pre><code>for (static int i=0; i&lt;10; i++)
{
}
</code></pre>

<p>Because it mimics <code>a</code>. (Note, <code>static</code> here is very strange)</p>

<p>Consider if Thread A is suspended just as it reaches <code>i++</code>. Thread B gets <code>i</code> all the way to 9, goes into <code>i++</code> and makes it 10. If it got to move on, the loop would exist. Ah, but now Thread A is resumed! So it continues where it left off: increment <code>i</code>! So <code>i</code> becomes 11, and your loop is borked.</p>

<p>Any time threads share data, it needs to be protected. You could also make <code>i++</code> and <code>i &lt; 10</code> happen atomically (never be interrupted), if your platform supports it.</p>
"
"<p>I'm investigating a memory leak and from what I see, the problem looks like this:</p>

<pre><code>int main(){
    char *cp = 0;
    func(cp);
    //code
    delete[] cp;
}

void func(char *cp){
    cp = new char[100];
}
</code></pre>

<p>At the //code comment, I expected cp to point to the allocated memory, but it still is a null pointer meaning I never delete the memory.  What am I doing wroing?</p>
","87234","","<p>You are assigning <code>cp</code> the value of the allocated memory. However, that's a variable on the stack: a copy of the <code>cp</code> in main! <code>cp</code> is local to the function you're in.</p>

<p>What you want is a reference:</p>

<pre><code>void func(char *&amp; cp)
</code></pre>

<p>This will alias <code>cp</code> to be the parameter passed in.</p>
"
"<p>I am learning about strings in C now.</p>

<p>How come to use scanf to get a string you can do </p>

<pre><code>scanf(""%s"",str1);
</code></pre>

<p>and for printf you can do</p>

<pre><code>printf(""The string is %s\n"", str1);
</code></pre>

<p>I understand that for scanf it is because the string is just a character array which is a pointer, but for printf, how is it that you can just put the variable name just like you would for an int or float?</p>
","87234","","<p><code>scanf</code> needs the address of the variable to read into, and string buffers are already represented as addresses (pointer to a location in memory, or an array that decomposes into a pointer).</p>

<p><code>printf</code> does the same, treating <code>%s</code> as a pointer-to-string.</p>
"
"<p>I'm currently working on adding exceptions and exception handling to my OSS application. Exceptions have been the general idea from the start, but I wanted to find a good exception framework and in all honesty, understand C++ exception handling conventions and idioms a bit better before starting to use them. I have a lot of experience with C#/.Net, Python and other languages that use exceptions. I'm no stranger to the idea (but far from a master). </p>

<p>In C# and Python, when an unhandled exception occurs, the user gets a nice stack trace and in general a lot of <strike>very useful</strike> priceless debugging information. If you're working on an OSS application, having users paste that info into issue reports is... well let's just say I'm finding it difficult to live without that. For this C++ project, I get ""The application crashed"", or from more informed users, ""I did X, Y and Z, and then it crashed"". But I want that debugging information too!</p>

<p>I've already (and with great difficulty) made my peace with the fact that I'll never see a cross-platform and cross-compiler way of getting a C++ exception stack trace, but I know I can get the function name and other relevant information.</p>

<p>And now I want that for my unhandled exceptions. I'm using <a href=""http://www.boost.org/doc/libs/1%5F41%5F0/libs/exception/doc/boost-exception.html"">boost::exception</a>, and they have this very nice <a href=""http://www.boost.org/doc/libs/1%5F41%5F0/libs/exception/doc/diagnostic%5Finformation.html"">diagnostic_information</a> thingamajig that can print out the (unmangled) function name, file, line and most importantly, other exception specific information the programmer added to that exception.</p>

<p>Naturally, I'll be handling exceptions inside the code whenever I can, but I'm not that naive to think I won't let a couple slip through (unintentionally, of course).</p>

<p>So what I want to do is wrap my main entry point inside a <code>try</code> block with a <code>catch</code> that creates a special dialog that informs the user that an error has occurred in the application, with more detailed information presented when the user clicks ""More"" or ""Debug info"" or whatever. This would contain the string from diagnostic_information. I could then instruct the users to paste this information into issue reports. </p>

<p>But a nagging gut feeling is telling me that wrapping everything in a try block is a really bad idea. Is what I'm about to do stupid? If it is (and even if it's not), what's a better way to achieve what I want?</p>
","87234","","<p>Wrapping all your code in one <code>try/catch</code> block is a-ok. It won't slow down the execution of anything inside it, for example. In fact, all my programs have (code similar to) this framework:</p>

<pre><code>int execute(int pArgc, char *pArgv[])
{
    // do stuff
}

int main(int pArgc, char *pArgv[])
{
    // maybe setup some debug stuff,
    // like splitting cerr to log.txt

    try
    {
        return execute(pArgc, pArgv);
    }
    catch (const std::exception&amp; e)
    {
        std::cerr &lt;&lt; ""Unhandled exception:\n"" &lt;&lt; e.what() &lt;&lt; std::endl;
        // or other methods of displaying an error

        return EXIT_FAILURE;
    }
    catch (...)
    {
        std::cerr &lt;&lt; ""Unknown exception!"" &lt;&lt; std::endl;

        return EXIT_FAILURE;
    }
}
</code></pre>
"
"<p>here is a quite simple question(I think), <strong>is there a STL library method that provides the limit of a variable type</strong> <em>(e.g integer)</em> <strong>?</strong> I know these limits differ on different computers but there must be a way to get them through a method, right?</p>

<p>Also, <strong>would it be really hard to write a method to calculate the limit of a variable type?</strong></p>

<p>I'm just curious! :) </p>

<p>Thanks ;).</p>
","87234","","<p>Use <a href=""http://en.cppreference.com/w/cpp/types/numeric_limits"" rel=""nofollow""><code>std::numeric_limits</code></a>:</p>

<pre><code>// numeric_limits example
// from the page I linked
#include &lt;iostream&gt;
#include &lt;limits&gt;
using namespace std;

int main () {
  cout &lt;&lt; boolalpha;
  cout &lt;&lt; ""Minimum value for int: "" &lt;&lt; numeric_limits&lt;int&gt;::min() &lt;&lt; endl;
  cout &lt;&lt; ""Maximum value for int: "" &lt;&lt; numeric_limits&lt;int&gt;::max() &lt;&lt; endl;
  cout &lt;&lt; ""int is signed: "" &lt;&lt; numeric_limits&lt;int&gt;::is_signed &lt;&lt; endl;
  cout &lt;&lt; ""Non-sign bits in int: "" &lt;&lt; numeric_limits&lt;int&gt;::digits &lt;&lt; endl;
  cout &lt;&lt; ""int has infinity: "" &lt;&lt; numeric_limits&lt;int&gt;::has_infinity &lt;&lt; endl;
  return 0;
}
</code></pre>
"
"<p>I am working on a 3rd party c++ app. It is crashing during the exit. If I look at the stack all I get is the __static_initialization_and_destruction_0 function and lots of questions marks. Project is huge and unfortunately it has many static objects. Is there any way to find out which one is crashing?</p>
","87234","","<p>If you can, run with a debugger attached and it'll let you break at the point of the crash.</p>

<p>Otherwise, you might try adding logging information in the destructors, such as:</p>

<pre><code>std::cout &lt;&lt; ""In ~SomeObject."" &lt;&lt; std::endl;
</code></pre>
"
"<p>For example:</p>

<pre><code>ifstream input;
input.open(""file.txt"");
translateStream(input, cout);
input.close();
</code></pre>

<p>How to write function translateStream?
<code>void translateStream(XXXX input, YYYY output)</code>?
What are the types for input and output?</p>

<p>Thanks</p>
","87234","","<p><a href=""http://www.cplusplus.com/reference/iostream/istream/"" rel=""nofollow""><code>std::istream</code></a> and <a href=""http://www.cplusplus.com/reference/iostream/ostream/"" rel=""nofollow""><code>std::ostream</code></a>, respectively:</p>

<pre><code>void translateStream(std::istream&amp; pIn, std::ostream&amp; pOut);
</code></pre>

<p>Example:</p>

<pre><code>void translateStream(std::istream&amp; pIn, std::ostream&amp; pOut)
{
    // line for line ""translation""
   std::string s;
   while (std::getline(pIn, s))
    {
        pOut &lt;&lt; s &lt;&lt; ""\n"";
    }
}
</code></pre>
"
"<p>Are there any guidelines available that can be followed before calling standard string operation related functions in C?</p>

<p>For example, how much optimization will comparing the first character of two strings (and checking if they are equal) before calling <code>strcmp</code> provide?</p>

<p>What types of overhead related to string related functions in C can be expected, and what mechanisms will help avoid them?</p>

<p>Thanks!</p>
","87234","","<p>The string functions are there for you to use them. If you need to compare two strings, call <code>strcmp</code>. Don't worry about tiny performance difference, which are mostly imagined anyway. Get your code working first. </p>

<p>First, to answer any question about performance, if you ask ""How much optimization will..."" the answer is ""Profile!"" Nobody can predict how fast something is going to run. The implementation of the C stdlib has been continuously improved for <em>years</em>, any optimization tricks you try to come up with might hurt it.</p>

<p>For example, I think GCC will use vectorization when comparing strings, so you're actually comparing some 4-8 elements at a time. Were you expecting that? Doing your single character compare might actually slow it down.</p>

<p>That said, a typical implementation just checks character for character, so you'd simply be moving one comparison out of the loop, for no net gain. (But as stated, maybe for a net loss!)</p>

<p>So the guideline is:</p>

<blockquote>
  <p>Program now, optimize later.</p>
</blockquote>

<p>And optimize the rational way: with evidence and testing, not with guessing.</p>
"
"<p>Is there C++ equivalent for python Xrange generator in either STL or boost?</p>

<p>xrange basically generates incremented number with each call to ++ operator.
the constructor is like this:</p>

<pre><code>xrange(first, last, increment)
</code></pre>

<p>was hoping to do something like this using boost for each:</p>

<pre><code>foreach(int i, xrange(N))
</code></pre>

<p>I. am aware of the for loop.  in my opinion they are too much boilerplate.</p>

<p>Thanks</p>

<h2>my reasons:</h2>

<p>my main reason for wanting to do so is because i use speech to text software, and programming loop usual way is difficult, even if using code completion. It is much more efficient to have pronounceable constructs.</p>

<p>many loops start with zero and increment by one, which is default for range. I find python construct more intuitive</p>

<pre><code> for(int i = 0; i &lt; N; ++i)
 foreach(int i, range(N))
</code></pre>

<p>functions which need to take range as argument:</p>

<pre><code> Function(int start, int and, int inc);
 function(xrange r);
</code></pre>

<p>I understand differences between languages, however if a particular construct in python is very useful for me and can be implemented efficiently in C++, I do not see a reason not to use it.  For each construct is foreign to C++ as well however people use it.</p>

<p>I put my implementation at the bottom of the page as well the example usage.</p>

<p>in my domain i work with multidimensional arrays, often rank 4 tensor.  so I would often end up with 4 nested loops with different ranges/increments to compute normalization, indexes, etc. those are not necessarily performance loops, and I am more concerned with correctness readability and ability to modify.</p>

<p>for example</p>

<pre><code>int function(int ifirst, int ilast, int jfirst, int jlast, ...);
versus
int function(range irange, range jrange, ...);
</code></pre>

<p>In the above, if different strids are needed, you have to pass more variables, modify loops, etc.  eventually you end up with a mass of integers/nearly identical loops.</p>

<p>foreach and range solve my problem exactly.  familiarity to average C++ programmer  is not high on my list of concerns - problem domain is a rather obscure, there is a lot of meta-programming, SSE intrinsic, generated code.</p>
","87234","","<p>What you're doing isn't go to work as efficiently as you intend. <code>BOOST_FOREACH</code> evaluates it's arguments only once. This means you need <code>xrange</code> to produce an iteratable container full of your values.</p>

<p>That is, it <em>could</em> look like this (note, could be more generic, like taking an advancement functor, etc.):</p>

<pre><code>template &lt;typename T&gt;
std::vector&lt;T&gt; xrange(const T&amp; pBegin, const T&amp; pEnd)
{
    std::vector&lt;T&gt; v;

    for (T i = pBegin, i &lt; pEnd; ++i)
    {
        v.push_back(i);
    }

    return v;
}
</code></pre>

<p>But all you've done is:</p>

<ol>
<li>Move the for-loop into a function,</li>
<li>Wasted time and resources allocating a vector that will die shortly after</li>
</ol>

<p>Rather, just use the for-loop directly, like I previously mentioned and other are mentioning.</p>

<p>If you're <em>really</em> against a loop (keep in mind you don't program to save keystrokes!), you could probably use a macro and some magic (untested):</p>

<pre><code>#define FOR_N(v, s, e)  for (BOOST_AUTO(v, s); v &lt; e; ++v)

#define for_n FOR_N // better looking

for_n(i, 0, N)
{
    // use i;
}
</code></pre>

<p>Of course now you have to include another file, and this code is :\</p>
"
"<p>I need to find a number of objects from a large container.</p>

<p>The only way I can think of to do that seems to be to just search the container for one item at a time in a loop, however, even which an efficient search with an average case of say ""log n"" (where n is the size of the container), this gives me ""m log n"" (where m is the number of items I'm looking for) for the entire operation.</p>

<p>That seems highly suboptimal to me, and as its something that I am likely to need to do on a frequent bases, something I'd definitely like to improve if possible.</p>

<p>Neither part has been implemented yet, so I'm open for suggestions on the format of the main container, the ""list"" of items I'm looking for, etc, as well as the actual search algorithm.</p>

<p>The items are complex objects, however the search key is just a simple integer.</p>
","87234","","<p>If you're purely doing look-up (you don't require ordered elements) and can give up some memory, try <a href=""http://en.wikipedia.org/wiki/Unordered%5Fmap%5F%28C%2B%2B%29"" rel=""nofollow"">unordered_map</a> (it's TR1, also implemented in Boost), which has constant-time amortized look-up.</p>

<p>In a game engine, we tested <code>std::map</code> and <code>unordered_map</code>, and while <code>map</code> was faster for insertions (if I recall), <code>unordered_map</code> blew it out of the water for retrieval. We had greater than 1000 elements in the map, for scale, which is fairly low compared to some other tasks you may be doing.</p>

<p>If you require elements to be ordered, your next bet is <code>std::map</code>, which has the look-up times you've posted, and keeps the elements ordered. In general, it also uses less memory than an <code>unordered_map</code>.</p>
"
"<p>Can I link a member function like this in some way?
redeclaring the method as a member and get it call the Mmsystem.h method to not have to wrap it?</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;Mmsystem.h&gt;

  namespace SoundLib {

 public class CWave
 {
 public:
  // WaveIn call
  external UINT waveOutGetNumDevs(VOID);
 };

}
</code></pre>
","87234","","<p>No, you have to wrap it. Additionally, your code has some errors, such as <code>external</code> versus <code>extern</code> (though that was theoretical anyway) and <code>public</code> before your class.</p>
"
"<p>I have a class which contains a few boost::numeric::ublas::matrix's within it.  I would like to overload the class's operators (+-*/=) so that I can act on the set of matrices with one statement.  </p>

<p>However this seems to require temporary instances of my class to carry values around without modifying the original class.  This makes sense to me, however, when I create a new instance within the function and return it I get:</p>

<p>warning: reference to local variable ‘temp’ returned</p>

<p>I'm pretty new to c++ and the examples of operator overloading seem to all return new temporary objects.  I would also like to avoid the overhead in instantiating new matrix's, which leads me towards looping over all elements.  How should I go about this?  Performance is a concern.</p>
","87234","","<p>The conventional way of operator overloading is as follows. (I think)</p>

<p>Your in-place operators are defined as members, such as:</p>

<pre><code>foo&amp; operator+=(const foo&amp; rhs);
foo&amp; operator*=(const foo&amp; rhs);
// etc.
</code></pre>

<p>Which simply do what they need on <code>*this</code>:</p>

<pre><code>foo&amp; operator+=(const foo&amp; rhs)
{
    // add elements together

    return *this;
}
</code></pre>

<p>Then make free functions, and let the copying be done in the arguments:</p>

<pre><code>const foo operator+(foo lhs, const foo&amp; rhs)
{
    return lhs += rhs;
}
</code></pre>

<p>The return value is <code>const</code> because it's strange to do:</p>

<pre><code>foo a, b, c;
(a + b) = c;
</code></pre>

<p>In the same way it's strange to do:</p>

<pre><code>int a, b, c;
(a + b) = c;
</code></pre>

<p>Though you'll get differing opinions on that. This is how you reuse your code, and have the copy done for you automatically. Very terse and readable.</p>

<p>Like Neil and I said above, though, if you're creating new data, at some point that data needs to have a new place to stay. Use mutating operators when you can to avoid this, but some things simply cannot be escaped.</p>

<p>It might not even be a problem. If it is, try to optimize the memory allocations you have; these are likely the slowest part. I'm not sure, but I think most boost classes let you specify an allocator. The boost memory pool library may be useful here.</p>
"
"<p>I tried to add objects to the ""content"" vector, and use show() on all of them. 
But the objects that are children (A, B) of ""Base"" behave like they were of ""Base"" type,
what is not my intention. As it seems, I tried to use virtual functions but it doesn't work. </p>

<p>I hope that the code will speak for itself. </p>

<pre><code>class Base {
    public:
        virtual void show() { cout &lt;&lt; ""Base ""; }
};

class A : public Base {
    public:
        virtual void show() { cout &lt;&lt; ""A ""; }
};

class B : public Base {
    public:
        virtual void show() { cout &lt;&lt; ""B""; }
};



vector&lt;Base&gt; content;

void add(Base &amp;o) {
    content.push_back(o);
}

A test1;
B test2;

add(test1);
add(test2);

for (size_t i = 0; i &lt; content.size(); i++) {
        collection[i].show(); // output is: Base Base instead of A B
}   
</code></pre>

<p>Thanks in advance.</p>
","87234","","<p>As others have said, you're experiencing slicing. The <code>vector</code> stores a <code>Base</code>, and any derived information gets sliced away.</p>

<p>Alleviate this with pointers:</p>

<pre><code>std::vector&lt;Base*&gt; v;
v.push_back(new A);
v.push_back(new B);
</code></pre>

<p>The problem now is with releasing your resources. Before the vector goes out of scope, you'll need to iterate through it and delete each element. An even worse problem is with exceptions.</p>

<p>If at any point during the life-time of the vector, if an exception is thrown, it will unwind the stack, at some point releasing all your pointers in the vector; one giant memory leak.</p>

<p>If you use a more dedicated container, you will avoid this problem. Either write one yourself (not recommended, of course), or use <a href=""http://www.boost.org/doc/libs/1_41_0/libs/ptr_container/doc/ptr_container.html"" rel=""nofollow"">boost pointer containers</a>.</p>
"
"<p>I have a VB6.0 application, created by someone in this company before me. Now I have to make some changes in it, is it possible to compile a VB6 project in VS2003 or VS2008?? If yes, then how? Do I need to do something special for that.</p>

<p>If no, Can I install VB6 as seperate app on my machine where I have both VS2003 and VS2008 installed? </p>

<p>Thanks for help.</p>
","87234","","<p>You can install VB6.0 on the same machine.</p>

<p>That said, if you open the project in a newer version it should try to convert it for you. There may be a few snags here or there, but it mostly does a good job.</p>
"
"<p>I have code that boils down to this:</p>

<pre><code>//Just a templated array class .. implementation doesn't matter
template&lt;int N&gt;
struct Array {};

//A simple Traits like class
template&lt;typename T&gt;
struct MyTraits {}

//Specialization of the traits class
template&lt;int N&gt;
struct Foo&lt; Array&lt;N&gt; &gt;
{
  static void monkey() {};
}

int main()
{
  Foo&lt; Array&lt;3&gt; &gt;::monkey();
}
</code></pre>

<p>Unfortunately the compiler doesn't like it...</p>

<pre><code>test.cpp: In function ‘int main()’:
test.cpp|17| error: ‘monkey’ is not a member of ‘Foo&lt;Array&lt;3&gt; &gt;’
</code></pre>

<p>What am I doing wrong, and how do I fix it?
Thanks</p>
","87234","","<p>The following works for me:</p>

<pre><code>//Just a templated array class .. implementation doesn't matter
template&lt;int N&gt;
struct Array {};

//A simple Traits like class
template&lt;typename T&gt;
struct MyTraits {};

//Specialization of the traits class
template&lt;int N&gt;
struct MyTraits&lt; Array&lt;N&gt; &gt;
{
    static void monkey() {};
};

int main()
{
    MyTraits&lt; Array&lt;3&gt; &gt;::monkey();
}
</code></pre>

<p>The way you have <code>Foo</code> is incorrect, as you can see I changed it to match the comment. Additionally, you had a missing semicolon after the declaration of <code>Foo</code>/<code>MyTraits</code>. Lastly, for an array class I would recommend you use <code>size_t</code> as the type of <code>N</code>.</p>
"
"<p>I have an <code>abstract</code> <code>Base</code> class and <code>Derived</code> class.</p>

<pre><code>int main ()
{
  Base *arrayPtr[3];

  for (int i = 0; i &lt; 3; i++)
  {
    arrayPtr[i] = new Derived();
  }

  //some functions here

  delete[] arrayPtr;

  return 0;
}
</code></pre>

<p>I'm not sure how to use the delete operator. If I delete array of base class pointers as shown above, will this call derived class objects destructors and clean the memory?</p>
","87234","","<p>Make sure <code>Base</code> has a virtual destructor. Then like <a href=""http://stackoverflow.com/questions/2012510/delete-operator-c/2012524#2012524"">fretje outlined</a>, delete each element in the array, then delete the array.</p>

<p>You should be using <code>std::vector</code> for the array. That said, you should <em>really</em> be using a container made for this sort of thing. (So you don't accidentally fail to delete all the elements, which will definitely be the case if an exception gets thrown!) Boost has <a href=""http://www.boost.org/doc/libs/1_41_0/libs/ptr_container/doc/ptr_container.html"" rel=""nofollow"">such a library</a>.</p>
"
"<p>So I generally use <code>cout</code> and <code>cerr</code> to write text to the console. However sometimes I find it easier to use the good old <code>printf</code> statement. I use it when I need to format the output. </p>

<p>So one example of where I would use this is:</p>

<pre><code>// Lets assume that I'm printing coordinates... 
printf(""(%d,%d)\n"", x, y);

// To do the same thing as above using cout....
cout &lt;&lt; ""("" &lt;&lt; x &lt;&lt; "","" &lt;&lt; y &lt;&lt; "")"" &lt;&lt; endl;
</code></pre>

<p>I know I can format output using <code>cout</code> but I already know how to use the <code>printf</code>. So is there any reason I shouldn't use the C <code>printf</code> statement?</p>
","87234","","<p>Streams are the canonical way. Try making this code work with <code>printf</code>:</p>

<pre><code>template &lt;typename T&gt;
void output(const T&amp; pX)
{
    std::cout &lt;&lt; pX &lt;&lt; std::endl;
}
</code></pre>

<p>Good luck.</p>

<p>What I mean is, you can make operators to allow your types to be outputted to <code>ostream</code>'s, and without hassle use it just like any other type. <code>printf</code> doesn't fit the the generality of C++, or more specifically templates.</p>

<p>There's more than usability. There's also consistency. In all my projects, I have cout (and <code>cerr</code> and <code>clog</code>) tee'd to also output to a file. If you use <code>printf</code>, you skip all of that. Additionally, consistency itself is a good thing; mixing <code>cout</code> and <code>printf</code>, while perfectly valid, is ugly.</p>

<p>If you have an object, and you want to make it output-able, the cleanest way to do this is overload <code>operator&lt;&lt;</code> for that class. How are you going to use <code>printf</code> then? You're going to end up with code jumbled with <code>cout</code>'s and <code>printf</code>'s.</p>

<p>If you really want formatting, use Boost.Format while maintaining the stream interface. Consistency <em>and</em> formatting.</p>
"
"<p>I'm trying to insert multiple times this same key into map but with different values. It doesn't work. I know that operator[] does this job, but my question is, if this behaviour of insert is correct? Shouldn't insert() inserts? I wonder what standard says. Unfortunately I don't have it(Standard for C++) so I can't check.<br>
Thank you for helpful ansers.</p>
","87234","","<p>I'm not sure I understand fully, but it sounds like you're overwriting your previous entries in the map; A <a href=""http://www.cplusplus.com/reference/stl/map/"" rel=""nofollow""><code>map</code></a> only stores <strong>one</strong> value per key.</p>

<p>Rather, you'd need to use <a href=""http://www.cplusplus.com/reference/stl/multimap/"" rel=""nofollow""><code>multi_map</code></a>. This will allow you to insert the same key with different values. You do lose <code>operator[]</code> this way, since it wouldn't really make sense. (When inserting, sure, but that operator also retrieves. Which value should it retrieve?)</p>

<p>Here's an example (modified from <a href=""http://www.sgi.com/tech/stl/Multimap.html"" rel=""nofollow"">here</a>):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;

int main(void)
{
    std::multimap&lt;std::string, int&gt; m;

    m.insert(std::make_pair(""a"", 1));
    m.insert(std::make_pair(""b"", 2));
    m.insert(std::make_pair(""c"", 3));
    m.insert(std::make_pair(""a"", 4));
    m.insert(std::make_pair(""b"", 5));
    m.insert(std::make_pair(""a"", 6));

    std::cout &lt;&lt; ""Number of elements with key a: "" &lt;&lt; m.count(""a"") &lt;&lt; endl;
    std::cout &lt;&lt; ""Number of elements with key b: "" &lt;&lt; m.count(""b"") &lt;&lt; endl;
    std::cout &lt;&lt; ""Number of elements with key c: "" &lt;&lt; m.count(""c"") &lt;&lt; endl;

    std::cout &lt;&lt; ""Elements in m: "" &lt;&lt; endl;
    for (m::iterator it = m.begin(); it != m.end(); ++it)
    {
        std::cout &lt;&lt; ""  ["" &lt;&lt; it-&gt;first &lt;&lt; "", "" &lt;&lt; it-&gt;second &lt;&lt; ""]"" &lt;&lt; endl;
    }
}
</code></pre>
"
"<p>I am using OpenCV library and I want to clone picture in separate function, but I cannot send address to the function</p>

<p><code>
IplImage* image = cvLoadImage( path, CV_LOAD_IMAGE_GRAYSCALE ); // loading is ok<br>
showFoundPoints(image); // -> here it shows errors<br>
...  </p>

<p>//my function<br>
int showFoundPoints(IplImage*image)<br>
{...}  </p>

<p></code></p>

<p>And I got this build error:<br>
error: conversion from <code>IplImage*' to non-scalar type</code>std::string' requested</p>

<p>I don't get why is there conversion. It looks very simple, but I really don't know what to do with this.<br>
Thanks for help.</p>
","87234","","<p>Is the definition of <code>showFoundPoints</code> consistent in the header and the source? It would seem you have it declared differently; one taking a <code>std::string</code> and the other not.</p>
"
"<p>how to answer this question?</p>
","87234","","<p>Andrei Alexandrescu talks about this briefly in <a href=""http://rads.stackoverflow.com/amzn/click/0201704315"" rel=""nofollow"">Modern C++ Design</a>.</p>

<p>He outlines two disadvantages to the monostate pattern:</p>

<ol>
<li>Static functions cannot be virtual.</li>
<li>Initialization and cleanup is not central. </li>
</ol>

<p>Number 1 means extending or changing the class might be made more difficult. Number 2 makes it difficult to track the life-time of data.</p>

<p>The monostate pattern and the singleton pattern solve two different but close problems. The monostate pattern makes sure all instances of the class operate on the same data, while a singleton makes sure here is only of instance of the class to operate with.</p>
"
"<p>I'm trying to collect user's input in a string variable that accepts whitespaces for a specified amount of time.</p>

<p>Since the usual <code>cin &gt;&gt; str</code> doesn't accept whitespaces, so I'd go with std::getline from &lt;string&gt;</p>

<p>Here is my code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;
int main()
{
    int n;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++)
    {
        string local;
        getline(cin, local); // This simply does not work. Just skipped without a reason.
        //............................
    }

    //............................
    return 0;
}
</code></pre>

<p>Any idea?</p>
","87234","","<p>You can see why this is failing if you output what you stored in <code>local</code> (which is a poor variable name, by the way :P):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;
int main()
{
    int n;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++)
    {
        string local;
        getline(cin, local);
        std::cout &lt;&lt; ""&gt; "" &lt;&lt; local &lt;&lt; std::endl;
    }

    //............................
    return 0;
}
</code></pre>

<p>You will see it prints a newline after <code>&gt;</code> immediately after inputting your number. It then moves on to inputting the rest.</p>

<p>This is because <code>getline</code> is giving you the empty line left over from inputting your number. (It reads the number, but apparently doesn't remove the <code>\n</code>, so you're left with a blank line.) You need to get rid of any remaining whitespace first:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;
int main()
{
    int n;
    cin &gt;&gt; n;
    cin &gt;&gt; ws; // stream out any whitespace
    for(int i = 0; i &lt; n; i++)
    {
        string local;
        getline(cin, local);
        std::cout &lt;&lt; ""&gt; "" &lt;&lt; local &lt;&lt; std::endl;
    }

    //............................
    return 0;
}
</code></pre>

<p>This the works as expected.</p>

<p>Off topic, perhaps it was only for the snippet at hand, but code tends to be <em>more</em> readable if you don't have <code>using namespace std;</code>. It defeats the purpose of namespaces. I suspect it was only for posting here, though.</p>
"
"<p><em><strong></em> Build of configuration Debug for project testcase **</strong></p>

<pre><code>make all 
Building target: testcase.exe
Invoking: MinGW C++ Linker
g++  -o""testcase.exe""  ./atest.o ./main.o  C:/cppunit/src/cppunit/.libs/libcppunit.a 
/mingw/lib/libmingw32.a(main.o):main.c:(.text+0xd2): undefined reference to `WinMain@16'
collect2: ld returned 1 exit status
make: *** [testcase.exe] Error 1

undefined reference to `WinMain@16' : mingw/lib/libmingw32.a(main.o):main.c:    
make: *** [testcase.exe] Error 1 
</code></pre>

<p>but am using an cpp program. in cpp program which has main.cpp, atestcase.cpp and a.hpp  but it showing main.c:(.text+0xd2): </p>

<p>Can any one solve this problem .please can any one help me 
                                                           yours faithfully,
                                                           r.kranthikumar</p>
","87234","","<p>You're building a <em>Windows Application</em>, but you don't have a <code>WinMain</code> that is required by Windows applications.</p>

<p>Likely, you have a <code>main</code> instead. You'll need to either change your project settings (to something along the lines of ""<em>Console Application</em>""), or use <code>WinMain</code> instead. You likely want the former.</p>

<p>Note, <code>WinMain</code> is not standard. This is just the Windows linkage requirement.</p>
"
"<p>is there a tool to generate a makefile out of a visual studio Solution?</p>
","87234","","<p>Code::Blocks has an option to import Visual Studio project files. It also uses a <code>make</code> system. So you could import your project into C::B, then steal the makefile. Not sure how well that would work for you.</p>
"
"<p>I have an enum StackIndex defined as follows:</p>

<pre><code>typedef enum 
{
    DECK,
    HAND,
    CASCADE1,
    ...
    NO_SUCH_STACK
} StackIndex;
</code></pre>

<p>I have created a class called <code>MoveSequence</code>, which is a wrapper for a <code>std::deque</code> of a bunch of tuples of the form <code>&lt;StackIndex, StackIndex&gt;</code>.</p>

<pre><code>class MoveSequence
{
    public:
        void AddMove( const tpl_move &amp; move ){ _m_deque.push_back( move ); }
        void Print();
    protected:
    deque&lt;tpl_move&gt; _m_deque;
};
</code></pre>

<p>I thought I could create a static <code>std::map</code> member of the <code>MoveSequence</code> class, which would translate a <code>StackIndex</code> to a <code>std::string</code>, for use by the <code>Print()</code> function. But when I tried, I got the error:</p>

<pre><code>""error C2864: 'MoveSequence::m' : only static const integral data members can be initialized within a class""
</code></pre>

<p>If its not possible to created a std::map as a static member, is there another way to create a std::map that translates a <code>StackIndex</code> to a <code>std::string</code> that can be used to print out <code>MoveSequence</code> objects?</p>

<p>thanks</p>

<p>Beeband.</p>
","87234","","<p>You need to move the initialization into a source file:</p>

<pre><code>// header
struct foo
{
    typedef std::map&lt;unsigned, std::string&gt; the_map;
    static const the_map m;
};

// source
const foo::the_map foo::m(...);
</code></pre>

<p>With however you want to initialize it. C++0x removes this restriction.</p>

<p>Keep in mind <a href=""http://www.boost.org/doc/libs/1_41_0/libs/assign/doc/index.html"" rel=""nofollow"">Boost.Assign</a> makes this quite easy:</p>

<pre><code>#include &lt;boost/assign.hpp&gt;
const foo::the_map foo::m = boost::assign::map_list_of(1, ""a"")(2, ""b"");
</code></pre>
"
"<p>I have an interesting question about C++ pointers.</p>

<p>You probably will think that I have to change my design, and avoid
doing what I am doing, and you are probably right.
But let's assume that I have a good reason to do it my way.</p>

<p>So this is the situation. I have a C++ class TestClass, and I have a pointer A of this type:</p>

<pre><code>TestClass* A = new TestClass();
</code></pre>

<p>Among other things TestClass has this function:</p>

<pre><code>void TestClass::Foo(){
    TestClass* B = new TestClass();
    ...
}
</code></pre>

<p>This function creates object B of the same type and populates it with some data.</p>

<p>At the end of this function, I want pointer A to point at object B.
Anywhere outside this function it would look like <strong><code>A=B</code></strong>; inside this function
it could look like <strong><code>this = B</code></strong><br>
But as you know you cannot reassign ""this"" pointer.</p>

<p>Possible solutions:</p>

<ol>
<li><p>Copy the memory:</p>

<pre><code>memcpy(this, B, sizeof(TestClass));
</code></pre>

<p>This method works correctly. The function copies each bit of object B into object A.<br>
Problem: if TestClass is a big object(and it is), it creates significant overhead in performance for multiple Foo calls.</p></li>
<li><p>Return a B pointer from the function and do something like this</p>

<pre><code>Temp = A;
A=A-&gt;Foo();
freeMemory(Temp);
</code></pre>

<p>But this code looks stupid, and it makes function Foo very hard to use.</p></li>
</ol>

<p>So the question is, how I can do <strong><code>this = B</code></strong> from inside a member function, without copying whole objects?</p>
","87234","","<p>What you are doing is not good.</p>

<p>First off, you have function <code>Foo</code> that will:</p>

<ul>
<li>Create and generate a new class</li>
<li>Reassign an existing class to the new class</li>
</ul>

<p>So, why not just change the existing class into the class you want?</p>

<p>That said, you could make <code>Foo</code> static and take ""take <code>this</code> manually"":</p>

<pre><code>void Foo(TestClass*&amp; this)
{
    delete this;
    this = // ...
}
</code></pre>

<p>But that's equally nasty as your other solutions. We probably need more context to give you the best solution.</p>
"
"<p>some one please tell me
how to change the default calling convention in c?</p>
","87234","","<p>Calling conventions are not specified by the language. They are extensions to your compiler.</p>

<p>That said, commonly you do something like:</p>

<pre><code>void __fastcall my_func(void);
</code></pre>

<p>But this is completely dependent on your compiler and platform.</p>
"
"<p>I am new to this website and I am trying a simple inheritance example in C++.
I checked my code lots of times and I really see nothing wrong with it, however the compilers gives me errors:</p>

<p>my code:</p>

<pre><code>#ifndef READWORDS_H
#define READWORDS_H
using namespace std;
#include ""ReadWords.h""

/**
 * ReadPunctWords inherits ReadWords, so MUST define the function filter.
 * It chooses to override the default constructor.
 */

class ReadPunctWords: public ReadWords {
    public:
    bool filter(string word);
};

#endif
</code></pre>

<p>And the messages I get from the compiler:</p>

<pre><code>ReadPunctWords.h:11: error: expected class-name before '{' token
ReadPunctWords.h:13: error: `string' has not been declared
ReadPunctWords.h:13: error: ISO C++ forbids declaration of `word' with no type

Tool completed with exit code 1
</code></pre>

<p>I am really not sure where I get it wrong as it looks just fine to me?
Thank you for any mistakes you might spot.</p>
","87234","","<p>You need to include string:</p>

<pre><code>#include &lt;string&gt;
</code></pre>

<p>That said, <em>don't use <code>using namespace</code></em>! Especially at file-scope, and <em>definitely</em> not in a header file. Now any unit that includes this file is forced to succumb to everything in the <code>std</code> namespace.</p>

<p>Take that out, and qualify your names:</p>

<pre><code>bool filter(std::string word);
</code></pre>

<p>It's arguable more readable, too. Additionally, you should take your string as a <code>const&amp;</code>:</p>

<pre><code>bool filter(const std::string&amp; word);
</code></pre>

<p>To avoid having to copy the string unnecessarily. Lastly, your header guards seem off. Should they be changed? As of now, they seem like the same ones that would be used in your other header, which might effectively stop it from being included.</p>

<p>If you define <code>READWORDS_H</code> and then include <code>ReadWords.h</code>, and if that also has:</p>

<pre><code>#ifndef READWORDS_H
#define READWORDS_H
</code></pre>

<p>Then nothing in that file will be processed. If that's the case, <code>ReadWords</code> as a class won't be defined, and you cannot inherit from it. Your guard should probably be:</p>

<pre><code>READPUNCTWORDS_H
</code></pre>
"
"<h3>Background</h3>

<p>This is for a memory manager in a game engine. I have a <code>freelist</code> implemented, and would like to have a compile-time list if these. (A MPL or Fusion vector, for example). The <code>freelist</code>'s correspond to allocation sizes, and when allocating/deallocating objects of size less than a constant, they will go to the corresponding <code>freelist</code>.</p>

<p>In the end, this means small objects globally have amortized constant time allocation and constant time deallocation. (Yay.)</p>

<h3>Problem</h3>

<p>The problem is generating the types I need, so I may eventually use Fusion to instantiate those types. The types in use are (shortened, etc.):</p>

<pre><code>template &lt;size_t N&gt;
struct data_block
{
    size_t mSize; // = N
    char mData[N];
};

template &lt;typename T, size_t ElementsPerPage,
    template &lt;typename&gt; class Allocator = std::allocator &gt;
class freelist { /* ... */ };

template &lt;typename T&gt;
class callocator; // allocator that uses malloc/free
</code></pre>

<p>The <code>freelist</code>'s will manage <code>data_block</code>'s of power-of-2 sizes, starting from a minimum going to a maximum. So what I want is:</p>

<pre><code>static const size_t MinimumSmallSize = 4; // anything smaller gets rounded up
static const size_t MaximumSmallSize = 512; // anything bigger goes to the large allocator
static const size_t ElementsPerPage = 4096;

// mpl magic
</code></pre>

<p>To generate this:</p>

<pre><code>typedef boost::mpl::vector&lt;
    freelist&lt;data_block&lt;4&gt;, ElementsPerPage, callocator&gt;,
    freelist&lt;data_block&lt;8&gt;, ElementsPerPage, callocator&gt;
    // ...
    freelist&lt;data_block&lt;256&gt;, ElementsPerPage, callocator&gt;
    freelist&lt;data_block&lt;512&gt;, ElementsPerPage, callocator&gt;
    &gt; free_list_collection;
</code></pre>

<p>Obviously, I could do this by hand but I'd rather avoid that for a more general and tweakable interface. Using the Fusion vector in code should be simpler than hard-coded members, too.</p>

<h3>Question</h3>

<p>I'm not sure the best way to go about this; I've never used MPL extensively before. Any ideas? I had a few poor ideas such as making a range, then <code>remove_if</code> it's not power of 2, etc., but surely that's not best. Maybe something recursive instead, that doubles each time, pushing into my result vector? I'm not sure how to go about that.</p>
","87234","","<p>This is the best solution I came up with, and it's fairly simple. It requires a <code>log</code> and <code>pow</code> meta-template, which I've included for those who want to play or try it:</p>

<pre><code>#include &lt;boost/mpl/for_each.hpp&gt;
#include &lt;boost/mpl/range_c.hpp&gt;
#include &lt;boost/mpl/transform.hpp&gt;
#include &lt;boost/mpl/vector.hpp&gt;
#include &lt;iostream&gt;

namespace bmpl = boost::mpl;

//// helpers
template &lt;size_t N, size_t Base&gt;
struct log
{
    static const size_t value = 1 + log&lt;N / Base, Base&gt;::value;
};

template &lt;size_t Base&gt;
struct log&lt;1, Base&gt;
{
    static const size_t value = 0;
};

template &lt;size_t Base&gt;
struct log&lt;0, Base&gt;
{
    static const size_t value = 0;
};

template &lt;size_t N, size_t Power&gt;
struct pow
{
    static const size_t value = N * pow&lt;N, Power - 1&gt;::value;
};

template &lt;size_t N&gt;
struct pow&lt;N, 0&gt;
{
    static const size_t value = 1;
};

//// types and constants
template &lt;size_t N&gt;
struct data_block
{
    size_t mSize; // = N
    char mData[N];
};

template &lt;typename T, size_t ElementsPerPage,
    template &lt;typename&gt; class Allocator = std::allocator &gt;
class freelist { /* ... */ };

template &lt;typename T&gt;
class callocator; // allocator that uses malloc/free

static const size_t MinimumSmallSize = 4;
static const size_t MaximumSmallSize = 512;
static const size_t ElementsPerPage = 4096;

//// type generation
// turn a power into a freelist
template &lt;typename T&gt;
struct make_freelist
{
    static const size_t DataSize = pow&lt;2, T::value&gt;::value;
    typedef data_block&lt;DataSize&gt; data_type;

    typedef freelist&lt;data_type, ElementsPerPage, callocator&gt; type;
};

// list of powers
typedef bmpl::range_c&lt;size_t, log&lt;MinimumSmallSize, 2&gt;::value,
                        log&lt;MaximumSmallSize, 2&gt;::value + 1&gt; size_range_powers;

// transform that list into freelists, into a vector
typedef bmpl::transform&lt;size_range_powers, make_freelist&lt;bmpl::_1&gt;,
                            bmpl::back_inserter&lt;bmpl::vector&lt;&gt; &gt; &gt;::type size_range;

//// testing
struct print_type
{
    template &lt;typename T&gt;
    void operator()(const T&amp;) const
    {
        std::cout &lt;&lt; typeid(T).name() &lt;&lt; ""\n"";
    }
};

int main(void)
{
    bmpl::for_each&lt;size_range&gt;(print_type());
    std::cout &lt;&lt; std::endl;
}
</code></pre>

<p>The core of it is just a <code>struct</code> and two <code>typedef</code>'s. The <code>log</code> trick reduced the size of the range greatly, and <code>pow</code> of course just undoes the <code>log</code>. Works exactly how I'd like, and I don't see any way to make it simpler.</p>

<p>That said, I've decided to go with Boost.Pool, so I won't be needing my solution (because their pool sizes are dynamic, not compile-time.) But this was good fun.</p>
"
"<p>I have a problem compiling the following code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;
int main () {
    printf(""short: [%d,%d]\n"",SHRT_MIN,SHRT_MAX);
    printf(""int: [%d, %d]\n"",INT_MIN, INT_MAX);
    printf(""long: [%d, %d]\n"",LONG_MIN,LONG_MAX);
    int aa=017;
    printf(""%d\n"",aa);
    return 0;
}
</code></pre>

<p>Error message is:</p>

<pre><code>1&gt;c:\tic\ex1\ex2\ex2.c(12) : error C2143: syntax error : missing ';' before 'type'
1&gt;c:\tic\ex1\ex2\ex2.c(13) : error C2065: 'aa' : undeclared identifier
</code></pre>

<p>However, compilation for this is fine:</p>

<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;limits.h&gt;
    int main () {
        int aa=017;
        printf(""short: [%d,%d]\n"",SHRT_MIN,SHRT_MAX);
        printf(""int: [%d, %d]\n"",INT_MIN, INT_MAX);
        printf(""long: [%d, %d]\n"",LONG_MIN,LONG_MAX);
        printf(""%d\n"",aa);
        return 0;
    }
</code></pre>

<p>Any idea what the issue is?</p>
","87234","","<p>In C, variables previously had to be declared at the top of the scope, before any code is executed. This isn't the case in C99 (which Visual Studio doesn't implement.)</p>
"
"<p>is there any reason why</p>

<p>foo = (bar->at(x))->at(y);</p>

<p>works but</p>

<p>foo = bar[x][y];</p>

<p>does not work, where bar is a vector of vectors (using the c++ stl)</p>

<p>the declaration is: </p>

<blockquote>
  <p>std::vector&lt; std::vector &lt; Object * > * ></p>
</blockquote>
","87234","","<p>Is it a vector of vectors or a vector of pointers to vectors? Your code should work <em>as advertised</em>:</p>

<pre><code>typedef std::vector&lt;int&gt; vec_int;
typedef std::vector&lt;vec_int&gt; multi_int;

multi_int m(10, vec_int(10));

m.at(2).at(2) = /* ... */;
m[2][1] = /* ... */;
</code></pre>

<p>But your code appears to have:</p>

<pre><code>typedef std::vector&lt;vec_int*&gt; multi_int; // pointer!
multi_int* m; // more pointer!
</code></pre>

<p>If you have pointers, you'll need to dereference them first to use <code>operator[]</code>:</p>

<pre><code>(*(*m)[2])[2] = /* ... */;
</code></pre>

<p>That that can be ugly. Maybe use references temporarily:</p>

<pre><code>multi_int&amp; mr = m;
(*mr[2])[2] = /* ... */;
</code></pre>

<p>Though that still has some ugly. Maybe free-functions are helpful:</p>

<pre><code>template &lt;typename T&gt;
typename T::value_type&amp; access_ptr(T* pContainer,
                                    unsigned pInner, unsigned pOuter)
{
    return (*(*pContainer)[pInner])[pOuter]);
}

access_ptr(m, 2, 2) = /* ... */
</code></pre>

<p><strong>Most preferable is to be rid of the pointers</strong>, though. Pointers can leak and have all sorts of problems, like leaking when exceptions are thrown. If you <em>must</em> use pointers, use a <a href=""http://www.boost.org/doc/libs/1_41_0/libs/ptr_container/doc/ptr_container.html"" rel=""nofollow"">pointer container</a> from boost for the inner vector, and store the actual object in a <a href=""http://www.boost.org/doc/libs/1_41_0/libs/smart_ptr/smart_ptr.htm"" rel=""nofollow"">smart pointer</a>.</p>

<p>Also, your title is a bit misleading. The difference between <code>at</code> and <code>operator[]</code> is that <code>at</code> does range checks. Otherwise, they are the same.</p>
"
"<p>There are two unsigned ints (x and y) that need to be subtracted. x is always larger than y.  However, both x and y can wrap around; for example, if they were both bytes, after 0xff comes 0x00.  The problem case is if x wraps around, while y does not. Now x appears to be smaller than y. Luckily, x will not wrap around twice (only once is guaranteed). Assuming bytes, x has wrapped and is now 0x2, whereas y has not and is 0xFE. The right answer of x - y is supposed to be 0x4. </p>

<p>Maybe, </p>

<pre><code>( x &gt; y) ? (x-y) : (x+0xff-y);
</code></pre>

<p>But I think there is another way, something involving 2s compliment?, and in this embedded system, x and y are the largest unsigned int types, so adding 0xff... is not possible</p>

<p>What is the best way to write the statement (target language is C)?</p>
","87234","","<p>Maybe I don't understand, but what's wrong with:</p>

<p><code>unsigned r = x - y;</code></p>
"
"<p>I would like to select the compiler optimizations to generate the fastest possible application.</p>

<p>Which of the following settings should I set to true?</p>

<ul>
<li>Dead store elimination</li>
<li>Eliminate duplicate expressions within basic blocks and functions</li>
<li>Enable loop induction variable and strength reduction</li>
<li>Enable Pentium instruction scheduling</li>
<li>Expand common intrinsic functions</li>
<li>Optimize jumps</li>
<li>Use register variables</li>
</ul>

<p>There is also the option 'Generate the fastest possible code.', which I have obviously set to true. However, when I set this to true, all the above options are still set at false. </p>

<p>So I would like to know if any of the above options will speed up the application if I set them to true?</p>
","87234","","<blockquote>
  <p>So I would like to know if any of the above options will speed up the application if I set them to true?</p>
</blockquote>

<p>I know some will hate me for this, but <em>nobody here can answer you truthfully</em>. You have to try your program with and without them, and <strong>profile</strong> each build and see what the results are. Guess-work won't get anybody anywhere.</p>

<p>Compilers already do tons(!) of great optimization, with or without your permission. Your best bet is to write your code in a clean and organized matter, and worry about maintainability and extensibility. As I like to say: Code now, optimize later.</p>
"
"<p>It must be something specific in my code, which I can't post. But maybe someone can suggest possible causes.</p>

<p>Basically I have:</p>

<pre><code>class CParent
{
 public:
  void doIt(int x);
};
class CChild : public CParent
{
 public:
  void doIt(int x,int y,int z);
};

CChild *pChild = ...
pChild-&gt;doIt(123); //FAILS compiler, no method found
CParent *pParent = pChild;
pParent-&gt;doIt(123); //works fine
</code></pre>

<p>How on earth?</p>

<p>EDIT: people are talking about shadowing/hiding. But the two versions of doIt have different numbers of parameters. Surely that can't confuse the compiler, overloads in child class which can't possibly be confused with the parent class version? Can it?</p>

<p>The compiler error I get is:
<strong>error C2660: 'CChild::doIt' : function does not take 1 argument</strong></p>
","87234","","<p>You have shadowed a method. For example:</p>

<pre><code>struct base
{
    void method(int);
    void method(float);
};

struct derived : base
{
    void method(int);
    // base::method(int) is not visible.
    // base::method(float) is not visible.
};
</code></pre>

<p>You can fix this with a <code>using</code> directive:</p>

<pre><code>class derived : public base
{
    using base::method; // bring all of them in.

    void method(int);
    // base::method(int) is not visible.
    // base::method(float) is visible.
};
</code></pre>

<hr>

<p><strong>Since you seem insistent about the number of parameters</strong>, I'll address that. <em>That doesn't change anything.</em> Observe:</p>

<pre><code>struct base
{
    void method(int){}
};

struct derived : base
{
    void method(int,int){}
    // method(int) is not visible.
};

struct derived_fixed : base
{
    using base::method;
    void method(int,int){}
};

int main(void)
{
    {
        derived d;

        d.method(1, 2); // will compile
        d.method(3); // will NOT compile
    }
    {
        derived_fixed d;

        d.method(1, 2); // will compile
        d.method(3); // will compile
    }
}
</code></pre>

<p>It will <em>still</em> be shadowed regardless of parameters or return types; it's simply the <em>name</em> that shadows. <code>using base::&lt;x&gt;;</code> will bring all of <code>base</code>'s ""<code>&lt;x&gt;</code>"" methods into visibility.</p>
"
"<p>First of all apologies if there is already a topic like this but I have not found... I need to know how to handle a really big number such as the result of 789^2346: </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
int main () {
    cout &lt;&lt; pow(789,2346) &lt;&lt; endl;
}
</code></pre>
","87234","","<p>You need a ""big number"" library. A popular choice is <a href=""http://gmplib.org/"" rel=""nofollow"">GNU's Multiple Precision Arithmetic Library</a>, which has a C interface. I's also been around for a while. Another one, for C++, is <a href=""http://mattmccutchen.net/bigint/"" rel=""nofollow"">Big Integer Library</a>.</p>

<p>I'm sure there is a list of bignum libraries on SO somewhere, but I cannot find it. There is <a href=""http://stackoverflow.com/questions/tagged/bignum"">a tag</a> you could stroll through.</p>
"
"<p>I need to read an image file in C/C++. It would be very great, if some one can post the code for me.</p>

<p>I work on gray scale images and the images are JPEG. I would like to read the images into a 2D array which will make my work easy. </p>

<p>Thanks in advance</p>
","87234","","<p>You could write your own by looking at the <a href=""http://en.wikipedia.org/wiki/JPEG"">JPEG format</a>.</p>

<p>That said, try a pre-existing library like <a href=""http://cimg.sourceforge.net/"">CImg</a>, or <a href=""http://www.boost.org/doc/libs/1_41_0/libs/gil/doc/index.html"">Boost's GIL</a>. Or for strictly JPEG's, <a href=""http://en.wikipedia.org/wiki/Libjpeg"">libjpeg</a>. There is also the <a href=""http://www.codeproject.com/KB/graphics/cximage.aspx"">CxImage</a> class on CodeProject.</p>

<p>Here's a <a href=""http://www.mathtools.net/C_C__/Image_Processing/"">big list</a>.</p>
"
"<p>In C, if I wanted to create a matrix struct, I would use:</p>

<pre><code>struct matrix {
  int col, row;
  double data[1]; // I want the matrix entries stored
                  // right after this struct
}
</code></pre>

<p>Then I can allocate it with</p>

<pre><code>matrix* allocate_matrix(int row, int col) {
  matrix* m = malloc(sizeof(matrix) + sizeof(double) * (row * col - 1));
  m-&gt;row = row; m-&gt;col = col;
  return m;
}
</code></pre>

<p>Now do I do the equiv in C++?</p>

<p>Thanks!</p>

<p>EDIT:</p>

<p>I want to know the cannonical way to implement a matrix class in C++.</p>
","87234","","<p>You <em>could</em> do it that way. The only difference is you'd need to cast the result from <code>malloc</code>.</p>

<p>Rather, you would use a <code>vector</code>, either as a 1D array with computed indexing or an embedded vector. (The former matches your code better.)</p>

<p>For example:</p>

<pre><code>template &lt;typename T&gt; // often, they are templates
struct matrix
{
    // should probably be hidden away, and the class would
    // provide `at` and `operator()` for access
    int col, row;
    std::vector&lt;T&gt; data;

    matrix(int columns, int rows) :
    col(columns), row(rows), 
    data(col * row)
    {}

}

matrix m(4, 4);
m.data[1 + 1 * 4] = /* ... */;
</code></pre>

<p>Or:</p>

<pre><code>template &lt;typename T&gt;
struct matrix
{
    int col, row;
    std::vector&lt;std::vector&lt;T&gt; &gt; data;

    matrix(int columns, int rows) :
    col(columns), row(rows), 
    data(col, std::vector(row))
    {}
}

matrix m(4, 4);
m.data[1][1] = /* ... */;
</code></pre>

<p>But these are only examples. You'd want to make a full-fledged class; if you want more advice on that, edit your question and clarify you'd like to know the canonical way of implementing matrix classes.</p>

<p>There are pre-existing matrix classes. My favorite is that from boost, <a href=""http://www.boost.org/doc/libs/1_41_0/libs/numeric/ublas/doc/index.htm"" rel=""nofollow"">UBLAS</a>.</p>
"
"<p>Is there anyways to have a define increment every time you use it?</p>

<p>For example</p>

<pre>int a = ADEFINE;
int b = ADEFINE;</pre>

<p>a is 1 and b is 2.</p>
","87234","","<p>You can use <code>__COUNTER__</code>, though it's not standard. Both MSVC++ and GCC support it.</p>

<hr>

<p>If you can use boost, the <a href=""http://www.boost.org/doc/libs/1_41_0/libs/preprocessor/doc/index.html"">pre-processor library</a> has an implementation of counter. Here's the example from the documentation:</p>

<pre><code>#include &lt;boost/preprocessor/slot/counter.hpp&gt;

BOOST_PP_COUNTER // 0

#include BOOST_PP_UPDATE_COUNTER()

BOOST_PP_COUNTER // 1

#include BOOST_PP_UPDATE_COUNTER()

BOOST_PP_COUNTER // 2

#include BOOST_PP_UPDATE_COUNTER()

BOOST_PP_COUNTER // 3
</code></pre>

<p>(Kudo's to gf)</p>
"
"<p>C++ compilers automatically generate copy constructors and copy-assignment operators. Why not <code>swap</code> too?</p>

<p>These days the preferred method for implementing the copy-assignment operator is the copy-and-swap idiom:</p>

<pre><code>T&amp; operator=(const T&amp; other)
{
    T copy(other);
    swap(copy);
    return *this;
}
</code></pre>

<p>(<a href=""http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/"">ignoring the copy-elision-friendly form that uses pass-by-value</a>).</p>

<p>This idiom has the advantage of being transactional in the face of exceptions (assuming that the <code>swap</code> implementation does not throw).  In contrast, the default compiler-generated copy-assignment operator recursively does copy-assignment on all base classes and data members, and that doesn't have the same exception-safety guarantees.</p>

<p>Meanwhile, implementing <code>swap</code> methods manually is tedious and error-prone:</p>

<ol>
<li>To ensure that <code>swap</code> does not throw, it must be implemented for all non-POD members in the class and in base classes, in their non-POD members, etc.</li>
<li>If a maintainer adds a new data member to a class, the maintainer must remember to modify that class's <code>swap</code> method.  Failing to do so can  introduce subtle bugs.  Also, since <code>swap</code> is an ordinary method, compilers (at least none I know of) don't emit warnings if the <code>swap</code> implementation is incomplete.</li>
</ol>

<p>Wouldn't it be better if the compiler generated <code>swap</code> methods automatically? Then the implicit copy-assignment implementation could leverage it.</p>

<p>The obvious answer probably is: the copy-and-swap idiom didn't exist when C++ was developed, and doing this now might break existing code.</p>

<p>Still, maybe people could opt-in to letting the compiler generate <code>swap</code> using the same syntax that C++0x uses for controlling other implicit functions:</p>

<pre><code>void swap() = default;
</code></pre>

<p>and then there could be rules:</p>

<ol>
<li>If there is a compiler-generated <code>swap</code> method, an implicit copy-assignment operator can be implemented using copy-and-swap.</li>
<li>If there is no compiler-generated <code>swap</code> method, an implicit copy-assignment operator would be implemented as before (invoking copy-assigment on all base classes and on all members).</li>
</ol>

<p>Does anyone know if such (crazy?) things have been suggested to the C++ standards committee, and if so, what opinions committee members had?</p>
","87234","","<p>This is in addition to Terry's answer.</p>

<p>The reason we had to make <code>swap</code> functions in C++ prior to 0x is because the general free-function <code>std::swap</code> was less efficient (and less versatile) than it could be. It made a copy of a parameter, then had two re-assignments, then released the essentially wasted copy. Making a copy of a heavy-weight class is a waste of time, when we as programmers know all we really need to do is swap the internal pointers and whatnot.</p>

<p>However, rvalue-references relieve this completely. In C++0x, <code>swap</code> is implemented as:</p>

<pre><code>template &lt;typename T&gt;
void swap(T&amp; x, T&amp; y)
{
    T temp(std::move(x));
    x = std::move(y);
    y = std::move(temp);
}
</code></pre>

<p>This makes much more sense. Instead of copying data around, we are merely moving data around. This even allows non-copyable types, like streams, to be swapped. The draft of the C++0x standard states that in order for types to be swapped with <code>std::swap</code>, they must be rvalue constructable, and rvalue assignable (obviously).</p>

<p>This version of <code>swap</code> will essentially do what any custom written swap function would do. Consider a class we'd normally write <code>swap</code> for (such as this ""dumb"" vector):</p>

<pre><code>struct dumb_vector
{
    int* pi; // lots of allocated ints

    // constructors, copy-constructors, move-constructors
    // copy-assignment, move-assignment
};
</code></pre>

<p>Previously, <code>swap</code> would make a redundant copy of all our data, before discarding it later. Our custom <code>swap</code> function would just swap the pointer, but can be clumsy to use in some cases. In C++0x, moving achieves the same end result. Calling <code>std::swap</code> would generate:</p>

<pre><code>dumb_vector temp(std::move(x));
x = std::move(y);
y = std::move(temp);
</code></pre>

<p>Which translates to:</p>

<pre><code>dumb_vector temp;
temp.pi = x.pi; x.pi = 0; // temp(std::move(x));
x.pi = y.pi; y.pi = 0; // x = std::move(y);
y.pi = temp.pi; temp.pi = 0; // y = std::move(temp);
</code></pre>

<p>The compiler will of course get rid of redundant assignment's, leaving:</p>

<pre><code>int* temp = x.pi;
x.pi = y.pi;
y.pi = temp;
</code></pre>

<p>Which is <em>exactly</em> what our custom <code>swap</code> would have made in the first place. So while prior to C++0x I would agree with your suggestion, custom <code>swap</code>'s aren't really necessary anymore, with the introduction of rvalue-references. <code>std::swap</code> will work perfectly in any class that implements move functions.</p>

<p>In fact, I'd argue implementing a <code>swap</code> function should become bad practice. Any class that would need a <code>swap</code> function would also need rvalue functions. But in that case, there is simply no need for the clutter of a custom <code>swap</code>. Code size does increase (two ravlue functions versus one <code>swap</code>), but rvalue-references don't just apply for swapping, leaving us with a positive trade off. (Overall faster code, cleaner interface, slightly more code, no more <code>swap</code> ADL hassle.)</p>

<p>As for whether or not we can <code>default</code> rvalue functions, I don't know. I'll look it up later or maybe someone else can chime in, but that would sure be helpful. :) </p>

<p>Even so, it makes sense to allow <code>default</code> rvalue functions instead of <code>swap</code>. So in essence, as long as they allow <code>= default</code> rvalue functions, your request has already been made. :)</p>

<p>EDIT: I did a bit of searching, and the proposal for <code>= default</code> move was proposal <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2583.html""><code>n2583</code></a>. According to <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2869.html"">this</a> (which I don't know how to read very well), it was ""moved back."" It is listed under the section titled ""Not ready for C++0x, but open to resubmit in future "". So looks like it won't be part of C++0x, but may be added later.</p>

<p>Somewhat disappointing. :(</p>

<p>EDIT 2: Looking around a bit more, I found this: <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2953.html"">Defining Move Special Member Functions</a> which is much more recent, and does look like we can default <code>move</code>. Yay!</p>
"
"<p>I have a few classes in a project that should be created only once.</p>

<p>What is the best way to do that?,</p>

<ol>
<li>They can be created as static object.</li>
<li>Can be created as singleton</li>
<li>Can be created as global.</li>
</ol>

<p>What is the best design pattern to implement this?</p>

<p>I am thinking of creating all classes as singleton, but that would create lot of singletons. Is it good programming practice to have lot of singletons?</p>

<p>What are the pros and cons for using singletons?</p>
","87234","","<p>If they only need to be created once, that doesn't mandate they should be singletons.</p>

<ul>
<li>If X is a singleton, it's implied there is one instance.</li>
<li>If X has one instance, that doesn't mean it should be a singleton.</li>
</ul>

<p>Use a singleton if you <em>require</em> there be only one instance of the class, and that it be globally accessible. In your case, simply only needing one isn't reason enough. Globals are bad, singletons are glorified globals.</p>

<p>Most often, you don't need them. You'll see it a lot in bad code because of the very mentality: I only need one, that must mean I should make it singleton! (<strong>Wrong</strong>) For example, I've finished the technical design of the most powerful game engine I've ever done to date. It has 2 singletons, for memory and threading. A very large project, and I only have two!</p>

<p>More context would help us give you better information.</p>
"
"<p>I am trying to learn C. Reading through some code I came across a line like this:</p>

<pre><code>__inline__ void () ...
</code></pre>

<p>What does the <code>__inline__</code> mean? And how does putting that word in front of a function make it different? </p>
","87234","","<p><code>__inline__</code> is a <em>non-standard</em> extension. Typically, it tells the compiler: ""inline this function"", but being a non-standard extension we can't say with certainty unless we know which compiler this is on.</p>

<p>To inline is to remove the function call and place it's contents directly where the call would be made. This often removes the overhead of calling a function. It is not always optimal, because of code bloat (code getting too big and not fitting into cache), so most compilers will ignore all inline directives and do what they feel is best. <em>This is a good thing.</em> We humans are very poor at that kind of stuff, and it's usually considered bad practice to tell the compiler how to do its job.</p>

<p>Inlining is an important optimization, especially with the presence of helper functions. Imagine a function that returned the smaller of two ints:</p>

<pre><code>int min(int x, int y)
{
    return (x &lt; y) ? x : y;
}
</code></pre>

<p>If I used this function in my code, it would be an enormous waste of time to actually make a function call, here. If I had:</p>

<pre><code>int a = /* some calculation */;
int b = /* some other calculation */;

int minCalc = min(a, b);
</code></pre>

<p>And the compiler inlined that function, the code would become:</p>

<pre><code>int a = /* some calculation */;
int b = /* some other calculation */;

int minCalc = (a &lt; b) ? a : b;
</code></pre>

<p>Which removes the overhead of calling a function. From here, even more optimizations can be made as the compiler gets to work directly with the code that would have normally been hidden behind a function call. As you can see, if I have a big function and I force the compiler to inline it everywhere, the code size could grow <em>very</em> large very fast, and would actually hinder execution speed.</p>

<p>There is a standard <code>inline</code> keyword which was used to indicate to the compiler a function should be inlined, but nowadays most compilers don't even acknowledge it as a hint to inline the function. </p>

<p>There is an important side-effect of <code>inline</code>, though, and this can be useful. If a function is marked as <code>inline</code>, multiple definitions of the same function across multiple translation units is not an error. Instead, a single function definition is selected and the others are thrown out, and assumed to be the same (it's up to you to make sure this is <em>actually</em> okay!). This allows you to define a function within a header file without risking ODR violation errors.</p>
"
"<p>I have recently been doing some work that has been quite in depth,
i was wondering what you think is better for logging.
Is it better to.</p>

<p>A. Every time i want to write to my log, open the file, write to it
   then close it straight away so it there is no real chance of losing
   information in the case of a critical failure or crash.</p>

<p>B. Save periodically, maybe after every major section has been finished
   meaning i can narrow downs where the errors are.</p>

<p>Any other suggestions??
I don't want to be opening and saving all day with the large volume of text
i need to record, but i don't want to lose my granularity of the information.
I am writing in C++, sorry for not mentioning it prior.</p>
","87234","","<p>To my knowledge, it's fairly common (mandated?) for a stream flush to be the equivalent to saving.</p>

<p>That is, when you say:</p>

<pre><code>file.flush();
</code></pre>

<p>Everything waiting to be written is written. Note that <code>std::endl;</code> also calls <code>flush</code>. So, leave it open and just flush after a dump of information.</p>
"
"<p>How would I go about taking a number like <code>123456</code> and having it print as <code>1 2 3 4 5 6</code>?</p>
","87234","","<p>A common method would be to extract each digit, and then print that digit. I won't give you the code, but it's the implemented version of:</p>

<pre><code>int d; // your number

/* While `d` is not zero */
/* Modulus `d` with 10 to extract the last digit */
/* Print it, with your space */
/* Divide by 10 to remove the last digit */
/* Repeat */
</code></pre>

<p>This will be backwards. I'll leave it as an exercise to you to fix that. (Hint: In the loop, put the result into an array of characters, and when you're finished start at the last index of the array and print backwards.)</p>
"
"<p>I know it is not allowed in C++, but why? What if it was allowed, what would the problems be?</p>
","87234","","<p>Judging by your <a href=""http://stackoverflow.com/questions/2091495/does-new-allocate-memory-for-the-functions-of-a-class-also"">other question</a>, it seems you don't understand how classes operate. Classes are a collection of functions which operate on data.</p>

<p>Functions themselves contain no memory in a class. The following class:</p>

<pre><code>struct dumb_class
{
    void foo(){}
    void bar(){}
    void baz(){}
    // .. for all eternity

    int i;
};
</code></pre>

<p>Has a size of <code>int</code>. No matter how many functions you have ever, this class will only take up the space it takes to operate on an <code>int</code>. When you call a function in this class, the compiler will pass you a pointer to the place where the data in the class is stored; this is the <code>this</code> pointer.</p>

<p>So, the function lie in memory somewhere, loaded once at the beginning of your program, and wait to be called with data to operate on. </p>

<p>Virtual functions are different. The C++ standard does <em>not</em> mandate how the behavior of the virtual functions should go about, only what that behavior should be. Typically, implementations use what's called a virtual table, or vtable for short. A vtable is a table of function pointers, which like normal functions, only get allocated once.</p>

<p>Take this class, and assume our implementor uses vtables:</p>

<pre><code>struct base { virtual void foo(void); };
struct derived { virtual void foo(void); };
</code></pre>

<p>The compiler will need to make two vtables, one for base and one for derived. They will look something like this:</p>

<pre><code>typedef /* some generic function pointer type */ func_ptr;

func_ptr __baseTable[] = {&amp;base::foo}; 
func_ptr __derivedTable[] = {&amp;derived::foo}; 
</code></pre>

<p>How does it use this table? When you create an instance of a class above, the compiler slips in a hidden pointer, which will point to the correct vtable. So when you say:</p>

<pre><code>derived d;
base* b = &amp;d;
b-&gt;foo();
</code></pre>

<p>Upon executing the last line, it goes to the correct table (<code>__derivedTable</code> in this case), goes to the correct index (0 in this case), and calls that function. As you can see, that will end up calling <code>derived::foo</code>, which is exactly what should happen.</p>

<p>Note, for later, this is the same as doing <code>derived::foo(b)</code>, passing <code>b</code> as the <code>this</code> pointer.</p>

<p>So, when virtual methods are present, the class of the size will increase by one pointer (the pointer to the vtable.) Multiple inheritance changes this a bit, but it's mostly the same. You can get more details at <a href=""http://www.parashift.com/c++-faq-lite/virtual-functions.html"">C++-FAQ</a>.</p>

<p>Now, to your question. I have:</p>

<pre><code>struct base { virtual void foo(void) = 0; }; // notice the = 0
struct derived { virtual void foo(void); };
</code></pre>

<p>and <code>base::foo</code> has no implementation. This makes <code>base::foo</code> a pure abstract function. So, if I were to call it, like above:</p>

<pre><code>derived d;
base* b = &amp;d;
base::foo(b);
</code></pre>

<p>What behavior should we expect? Being a pure virtual method, <code>base::foo</code> doesn't even exist. The above code is undefined behavior, and could do anything from nothing to crashing, with anything in between. (Or worse.)</p>

<p>Think about what a pure abstract function represents. Remember, functions take no data, they only describe how to manipulate data. A pure abstract function says: ""I want to call this method and have my data be manipulated. How you do this is up to you.""</p>

<p>So when you say, ""Well, let's call an abstract method"", you're replying to the above with: ""Up to me? No, you do it."" to which it will reply ""@#^@#^"". It simply doesn't make sense to tell someone who's saying ""do this"", ""no.""</p>

<p>To answer your question directly:</p>

<blockquote>
  <p>""why we cannot create an object for an abstract class?""</p>
</blockquote>

<p>Hopefully you see now, abstract classes only define the functionality the concrete class should be able to do. The abstract class itself is only a blue-print; you don't live in blue-prints, you live in houses that implement the blue-prints.</p>
"
"<pre><code>class Animal
{
public:
  int a;
  double d;
  int f(){ return 25;} 
};
</code></pre>

<p>Suppose for the code above, I try to initialize an object, by saying <code>new Animal()</code>, does this <code>new()</code> also allocate memory for the function <code>f()</code>?</p>

<p>In other words, <strong>what is the difference in memory allocation terms if I had this class instead and did a <code>new Animal()</code> ?</strong> :</p>

<pre><code>class Animal
{
public:
  int a;
  double d;
};
</code></pre>
","87234","","<p>For a class with no virtual functions, the function themselves take up no data space. Functions are sections of code that can be executed to manipulate data. It is the data members that must be allocated.</p>

<p>When you have a virtual class, often there is an extra pointer for virtual table. Note that a vtable is an implementation specific detail. Though most compilers use them, you can't count on it always being there.</p>

<p>I've <a href=""http://stackoverflow.com/questions/2091426/why-cant-we-create-objects-for-an-abstract-class-in-c/2091633#2091633"">expanded</a> on this answer on your other question.</p>
"
"<p>Do I need a mutex if I have only one reader and one writer? The reader takes the next command (<code>food.front()</code>) from the queue and executes a task based on the command. After the command is executed, it pops off the command. The writer to the queue pushes commands onto the queue (<code>food.push()</code>).</p>

<p>Do I need a mutex? My reader (consumer) only executes if <code>food.size() &gt; 0</code>. I am using a reader thread and send thread.</p>
","87234","","<p>A mutex is used in multi-threaded environments. I don't see mention of threads in your question, so I don't see a need for a mutex.</p>

<p>However, if we assume by reader and writer you mean you have two threads, you need to protect mutual data with a mutex (or other multi-threaded protection scheme.)</p>

<p>What happens when the queue has items, and the reader thread pops something off while the writer thread puts something on? Disaster! With a mutex, you'll be sure only one thread is operating on the queue at a time.</p>

<p>Another method is a lock-free thread-safe queue. It would use atomic operations to ensure the data isn't manipulated incorrectly.</p>
"
"<p>In various c++ code you often see different usage of strings: PWSTR, char*, std::string, CString, etc ...</p>

<p>When is the best time to use PWSTR as compared to any other string type?</p>
","87234","","<p>When whichever library you are working with wants a <code>PWSTR</code>. This is a, according to naming convention used in Windows, pointer to a string of wide-characters.</p>

<p>By default, you should use <code>std::string</code>/<code>std::wstring</code>. Only when you interface with someone expecting something else should you change that.</p>

<p>You can get a <code>PCWSTR</code> from a <code>std::wstring</code> with the <code>c_str()</code> method. <code>CString</code> is MFC, if I recall.</p>
"
"<p>I have code which works in VC9 (Microsoft Visual C++ 2008 SP1) but not in GCC 4.2 (on Mac):</p>

<pre><code>struct tag {};

template&lt; typename T &gt;
struct C
{   
    template&lt; typename Tag &gt;
    void f( T );                 // declaration only

    template&lt;&gt;
    inline void f&lt; tag &gt;( T ) {} // ERROR: explicit specialization in
};                               // non-namespace scope 'structC&lt;T&gt;'
</code></pre>

<p>I understand that GCC would like me to move my explicit specialization outside the class but I can't figure out the syntax.  Any ideas?</p>

<pre><code>// the following is not correct syntax, what is?
template&lt; typename T &gt;
template&lt;&gt;
inline void C&lt; T &gt;::f&lt; tag &gt;( T ) {}
</code></pre>
","87234","","<p>GCC is in the clear, here. MSVC has a non-standard extension that allows in-class specialization. The standard, however, says:</p>

<blockquote>
  <p>14.7.3.2:<br>
  2. An explicit specialization shall be declared in the namespace of
  which the template is a member, or, for member templates, in the
  namespace of which the enclosing class or enclosing class template is
  a member. An explicit specialization of a member function, member
  class or static data member of a class template shall be declared in
  the namespace of which the class template is a member. </p>
</blockquote>

<p>Additionally, you can't partially specialize a function. (Though I'm unsure about the details in your case, that would be the final blow.)</p>

<p>You <em>could</em> do this:</p>

<pre><code>#include &lt;iostream&gt;

struct true_type {};
struct false_type {};

template &lt;typename T, typename U&gt;
struct is_same : false_type
{
    static const bool value = false;
};

template &lt;typename T&gt;
struct is_same&lt;T, T&gt; : true_type
{
    static const bool value = true;
};

struct tag1 {};
struct tag2 {};

template&lt; typename T &gt;
struct C
{
    typedef T t_type;

    template&lt; typename Tag &gt;
    void foo( t_type pX)
    {
        foo_detail( pX, is_same&lt;Tag, tag1&gt;() );
    }

private:
    void foo_detail( t_type, const true_type&amp; )
    {
        std::cout &lt;&lt; ""In tag1 version."" &lt;&lt; std::endl;
    }
    void foo_detail( t_type, const false_type&amp; )
    {
        std::cout &lt;&lt; ""In not tag1 version."" &lt;&lt; std::endl;
    }
};

int main(void)
{
    C&lt;int&gt; c;
    c.foo&lt;tag1&gt;(int());
    c.foo&lt;tag2&gt;(int());
    c.foo&lt;double&gt;(int());
}
</code></pre>

<p>Though this is somewhat ugly.</p>
"
"<p>I'm wondering why C++ (and possibly other languages, I'm not sure) doesn't allow statements like this.</p>

<pre><code>MyObject foo.DoBar();
</code></pre>

<p>You would think that the language could understand to construct the object, then call the function. The only reason I can think of this not working is that if the construction of the object failed, the statement would still try to call the function.</p>

<p>What are the reasons why those who help develop and integrate new features into C++ (and possibly other languages) don't allow this?</p>
","87234","","<p>I think a better question is why should it? After all:</p>

<pre><code>MyObject foo;
foo.DoBar();
</code></pre>

<p>Is hardly any more difficult. It's more readable too (though obviously that may be biased.) Even if you could construct-call, it would likely be tagged as a ""bad thing"" to do. Sort of how like multiple declarations on the same line are allowed, but often decrease readability.</p>

<p>Such a construct adds rules and complexity to an already complex language, when an arguably preferable solution is already present. Do we really want to add costly sugar to a language just to save a few keystrokes?</p>

<p>In response to:</p>

<blockquote>
  <p>""I could see it being useful though when you want to construct an object and just call one function on it. ""</p>
</blockquote>

<p>If you want to construct an object just to call a function, would it be possible to just make that function a free-function? After all, it's operating either on default data or data that was passed to the constructor anyway. The only thing missing would be the destructor.</p>

<p>Not to mention the other option:</p>

<pre><code>struct MyObject
{
    MyObject(bool pCallDoBar = true)
    {
        if (pCallDoBar)
            DoBar();
    }

    void DoBar(void)
    {
    }
};

MyObject foo;
</code></pre>

<p>Or just:</p>

<pre><code>MyObject().DoBar(); // destructor called here, though
</code></pre>

<p>I think you'd need a concrete example to really make a case.</p>
"
"<blockquote>
  <p><a href=""http://www.cplusplus.com/reference/algorithm/for_each/"" rel=""nofollow"">http://www.cplusplus.com/reference/algorithm/for_each/</a> <br>
  Unary function taking an element in
  the range as argument. This can either
  be a pointer to a function or an
  object whose class overloads
  operator(). Its return value, if any,
  is ignored.</p>
</blockquote>

<p>According to this article, I expected that for_each actually modifies the object given as its third argument, but it seems like for_each operates on a temporary object, and doesn't even modify the object given to it.</p>

<p>So, why is it implemented in that way? It seems much less useful. Or did I misunderstand something and my code below contains errors?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

template &lt;class T&gt; struct Multiplicator{
    T mresult;
  public:
    const T&amp; result() const{return mresult;}
    Multiplicator(T init_result = 1){
      mresult = init_result;
    }
    void operator()(T element){
      mresult *= element;
      std::cout &lt;&lt; element &lt;&lt; "" ""; // debug print
    }
};

int main()
{
    std::vector&lt;double&gt; vec;
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);
    Multiplicator&lt;double&gt; multiply;
    std::for_each(vec.begin(),vec.end(),multiply);
    std::cout &lt;&lt; ""\nResult: "" &lt;&lt; multiply.result() &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>Expected output:</p>

<pre><code>1 2 3 Result: 6
</code></pre>

<p>But got following output:</p>

<pre><code>1 2 3 Result: 1
</code></pre>
","87234","","<p>While James is correct, using <a href=""http://www.cplusplus.com/reference/std/numeric/accumulate/""><code>std::accumulate</code></a> with <a href=""http://www.cplusplus.com/reference/std/functional/multiplies/""><code>std::multiplies</code></a> would be more correct, probably:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

int main(void)
{
    std::vector&lt;double&gt; vec;
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);

    double result = std::accumulate(vec.begin(), vec.end(),
                                    1.0, std::multiplies&lt;double&gt;());

    std::cout &lt;&lt; ""\nResult: "" &lt;&lt; result &lt;&lt; std::endl;

}
</code></pre>

<p>With your <code>for_each</code> version, you don't really need to copy the functor again, rather:</p>

<pre><code>double result = std::for_each(vec.begin(), vec.end(), multiply).result();
</code></pre>

<p>Or C++0x, for fun:</p>

<pre><code>double result = 1;
std::for_each(vec.begin(), vec.end(), [&amp;](double pX){ result *= pX; });
</code></pre>
"
"<p>According to the first answer to <a href=""http://stackoverflow.com/questions/317450/why-override-operator#317528"">this</a> question, the functor below should be able to retain a value after being passed to <code>foreach</code> ( I couldn't get the <code>struct Accumulator</code> in the example to compile, so built a class).</p>

<pre><code>class Accumulator
{
    public:
        Accumulator(): counter(0){}
        int counter;
        void operator()(const Card &amp; c) { counter += i; }
};
</code></pre>

<p>Example usage ( as per the example )</p>

<pre><code>// Using a functor
Accumulator acc;
std::for_each(_cards.begin(), _cards.end(), acc);
// according to the example - acc.counter contains the sum of all
// elements of the deque 

std::cout &lt;&lt; acc.counter &lt;&lt; std::endl;
</code></pre>

<p><code>_cards</code> is implemented as a <code>std::deque&lt;Card&gt;</code>. No matter how long <code>_cards</code> gets, <code>acc.counter</code> is zero after the <code>for_each</code> completes. As I step through in the debugger I can see counter incrementing, however, so is it something to do with <code>acc</code> being passed by value?</p>
","87234","","<p>This was just <a href=""http://stackoverflow.com/questions/2102056/foreach-doesnt-this-work-as-int"">asked here</a>.</p>

<p>The reason is that (as you guessed) <code>std::for_each</code> copies its functor, and calls on it. However, it also returns it, so as outlined in the answer linked to above, use the return value for <code>for_each</code>.</p>

<p><strong>That said</strong>, you just need to use <a href=""http://www.cplusplus.com/reference/std/numeric/accumulate/"" rel=""nofollow""><code>std::accumulate</code></a>:</p>

<pre><code>int counter = std::accumulate(_cards.begin(), _cards.end(), 0);
</code></pre>

<p>A functor and <code>for_each</code> isn't correct here.</p>

<hr>

<p>For your usage (counting some, ignoring others), you'll probably need to supply your own functor and use <a href=""http://www.cplusplus.com/reference/algorithm/count_if/"" rel=""nofollow""><code>count_if</code></a>:</p>

<pre><code>// unary_function lives in &lt;functional&gt;
struct is_face_up : std::unary_function&lt;const Card&amp;, const bool&gt;
{
    const bool operator()(const card&amp; pC) const
    {
        return pC.isFaceUp(); // obviously I'm guessing
    }
};

int faceUp = std::count_if(_cards.begin(), _cards.end(), is_face_up());
int faceDown = 52 - faceUp;
</code></pre>

<p>And with C++0x lambda's for fun (just because):</p>

<pre><code>int faceUp = std::count_if(_cards.begin(), _cards.end(),
                            [](const Card&amp; pC){ return pC.isFaceUp(); });
</code></pre>

<p>Much nicer.</p>
"
"<p>I find <a href=""http://www.boost.org/doc/libs/1_35_0/doc/html/foreach.html"">boost::foreach</a> very useful as it saves me a lot of writing. For example, let's say I want to print all the elements in a list:</p>

<pre><code>std::list&lt;int&gt; numbers = { 1, 2, 3, 4 };
for (std::list&lt;int&gt;::iterator i = numbers.begin(); i != numbers.end(); ++i)
   cout &lt;&lt; *i &lt;&lt; "" "";
</code></pre>

<p>boost::foreach makes the code above much simplier:</p>

<pre><code>std::list&lt;int&gt; numbers = { 1, 2, 3, 4 };
BOOST_FOREACH (int i, numbers)
   cout &lt;&lt; i &lt;&lt; "" "";
</code></pre>

<p>Much better! However I never figured out a way (if it's at all possible) to use it for <code>std::map</code>s. The documentation only has examples with types such as <code>vector</code> or <code>string</code>.</p>
","87234","","<p>You need to use:</p>

<pre><code>typedef std::map&lt;int, int&gt; map_type;
map_type map = /* ... */;

BOOST_FOREACH(const map_type::value_type&amp; myPair, map)
{
    // ...
}
</code></pre>

<p>The reason being that the macro expects two parameters. When you try to inline the pair definition, you introduce a second comma, making the macro three parameters instead. The preprocessor doesn't respect any C++ constructs, it only knows text.</p>

<p>So when you say <code>BOOST_FOREACH(pair&lt;int, int&gt;, map)</code>, the preprocessor sees these three arguments for the macro:</p>

<p>1.<code>pair&lt;int</code><br>
 2. <code>int&gt;</code><br>
 3. <code>map</code>   </p>

<p>Which is wrong. This is <a href=""http://www.boost.org/doc/libs/1_41_0/doc/html/foreach/pitfalls.html#"">mentioned</a> in the for-each documentation.</p>
"
"<p>What are the instances where you need to explicitly call a destructor?</p>
","87234","","<p>When you use placement-new is a common reason (the only reason?):</p>

<pre><code>struct foo {};

void* memoryLocation = ::operator new(sizeof(foo));
foo* f = new (memoryLocation) foo(); // note: not safe, doesn't handle exceptions

// ...

f-&gt;~foo();
::operator delete(memoryLocation);
</code></pre>

<p>This is mostly present in allocators (used by containers), in the <code>construct</code> and <code>destroy</code> functions, respectively.</p>

<p>Otherwise, don't. Stack-allocations will be done automatically, as it will when you <code>delete</code> pointers. (Use smart pointers!)</p>

<p>Well, I suppose that makes one more reason: When you want undefined behavior. Then feel free to call it as many times as you want... :)</p>
"
"<p>Code 1:</p>

<pre><code>template&lt;class T&gt;
const PtrInterface&lt;T&gt;*
PtrInterface&lt;T&gt;::newRef() const {
  PtrInterface&lt;T&gt;* me = (PtrInterface&lt;T&gt;*) this;
  ++me-&gt;references_;
  //++this-&gt;references_;
  return this;
} 
</code></pre>

<p>Code 2:</p>

<pre><code>template&lt;class T&gt;
const PtrInterface&lt;T&gt;*
PtrInterface&lt;T&gt;::newRef() const {
  //PtrInterface&lt;T&gt;* me = (PtrInterface&lt;T&gt;*) this;
  //++me-&gt;references_;
  ++this-&gt;references_;
  return this;
}
</code></pre>

<p>Is there ever <em>any</em> situation where these two blocks of code will do different things?
Thanks!</p>
","87234","","<blockquote>
  <p>Is there ever any situation where these two blocks of code will do different things?</p>
</blockquote>

<p>Yes, when you are in a <code>const</code> method. Currently, the one with <code>me</code> invokes undefined behavior. Here's why:</p>

<p>As you know, when you call a member function, there is an implicit <code>this</code> pointer. The <code>this</code> pointer is <code>const</code> when a function is marked <code>const</code>. Take this for example:</p>

<pre><code>struct foo
{
    void method1(void);
    void method2(void) const;

    int i;
};
</code></pre>

<p>Implicitly, the compiler generates (by the way, this is simplified):</p>

<pre><code>void foo::method1(foo* this); 
void foo::method2(const foo* this) const;
</code></pre>

<p>So, are these two bodies the same?</p>

<pre><code>foo* me = (foo*)this;
me-&gt;i = 1;

// and

this-&gt;i = 1;
</code></pre>

<p>The answer is <em>it depends</em>, and as stated earlier, it's dependent on the <code>const</code>-ness of the function. In a non-<code>const</code> function, they are the same:</p>

<pre><code>void foo::method1(foo* this)
{
    foo* me = (foo*)this; // this cast is redundant
    me-&gt;i = 1;

    // ...

    this-&gt;i = 1;
}
</code></pre>

<p>But in a <code>const</code> function:</p>

<pre><code>void foo::method2(const foo* this) const
{
    foo* me = (foo*)this; // uh-oh! acts like const_cast
    me-&gt;i = 1; // modifying a const_cast'd variable is undefined behavior

    // ...

    this-&gt;i = 1; // wouldn't compile
}
</code></pre>

<p>We end up stripping the <code>const</code> away. So, no, they aren't always the same. This is the peril of the C-style cast: it will find a way. By the way, casting <code>const</code> away in itself isn't undefined behavior; it's the modification of said variable that does it.</p>

<p>There is a sticky problem in your question though: your code shouldn't compile. Like in the commented code above, in your <code>const</code> method you shouldn't be able to modify <code>reference_</code>.</p>

<p>This is different if <code>reference_</code> is <code>mutable</code>, which I'm guessing it might be (assuming you gave us compilable code.) In this case, I'm not certain if the first sample leads to undefined behavior, since it was <code>mutable</code> in the first place. I wouldn't take the chance though.</p>
"
"<p>I have a template struct tree_parse_info declared as follows:</p>

<pre><code>template &lt;
    typename IteratorT,
    typename NodeFactoryT,
    typename T
&gt;
struct tree_parse_info 
{
  // ...
};
</code></pre>

<p>The compiler allows the follows code:</p>

<pre><code>tree_parse_info&lt;&gt; m_info;
</code></pre>

<p>Why does this code compile even though we do not have default template parameters for the template struct tree_parse_info ?</p>
","87234","","<p>If the class has been forward declared previously, you won't need to restate the default parameters. For example:</p>

<pre><code>// forward declare only
template &lt;typename T = int, size_t N = 10&gt;
struct array;

// actual definition
template &lt;typename T , size_t N&gt;
struct array
{};

int main(void)
{
    array&lt;&gt; a; // uses the defaults it saw in the forward-declaration
}
</code></pre>

<p>Look above your actual definition to see if you forward declared it.</p>

<p>By the way, if you give defaults at one place, and differing defaults at another, you'll get a compile error:</p>

<pre><code>template &lt;typename T = int, size_t N = 10&gt;
struct array;

// error: redefinition of default parameter
template &lt;typename T = double , size_t N = 2&gt;
struct array
{};
</code></pre>

<p>Try giving the code you showed us defaults that can't possibly accidentally match, like:</p>

<pre><code>struct stupid_special_tag_type_lolroflwat {};

template &lt;
    typename IteratorT = stupid_special_tag_type_lolroflwat,
    typename NodeFactoryT = stupid_special_tag_type_lolroflwat,
    typename T = stupid_special_tag_type_lolroflwat
&gt;
struct tree_parse_info 
{
  // ...
};
</code></pre>

<p>If you get redefinition errors, you know you've given it defaults in some other location.</p>
"
"<p>Here's the basic problem.  There's an API which I depend on, with a method using the following syntax:</p>

<pre><code>void foo_api (std::vector&lt;type&gt;&amp; ref_to_my_populated_vector);
</code></pre>

<p>The area of code in question is rather performance intensive, and I want to avoid using the heap to allocate memory.  As a result, I created a custom allocator which allocates the memory required for the vector on the stack.  So, I can now define a vector as:</p>

<pre><code>// Create the stack allocator, with room for 100 elements
my_stack_allocator&lt;type, 100&gt; my_allocator;

// Create the vector, specifying our stack allocator to use
std::vector&lt;type, my_stack_allocator&gt; my_vec(my_allocator);
</code></pre>

<p>This is all fine.  Performance tests using the stack allocated vector compared to the standard vector show performance is roughly 4x faster.  The problem is, I can't call foo_api!  So...</p>

<pre><code>foo_api(my_vec); // Results in an error due to incompatible types.
// Can't convert std::vector&lt;type&gt; to std::vector&lt;type, allocator&gt;
</code></pre>

<p>Is there a solution to this? </p>
","87234","","<p>You have to use the default allocator just as the function expects. You have two different types, and there's no way around that.</p>

<p>Just call <code>reserve</code> prior to operating on the vector to get the memory allocations out of the way.</p>

<p>Think about the bad things that could happen. That function may take your vector and start adding more elements. Soon, you could over-flow the stack space you've allocated; oops!</p>

<p>If you're <em>really</em> concerned about performance, a much better route is to replace <code>operator new</code> and kin with a custom memory manager. I have done so and allocations can be hugely improved. For me, allocating sizes of size 512 or less is about 4 operations (move a couple pointers around); I used a pool allocator)</p>
"
"<p>I'm making a simple crime sim game.</p>

<p>Throughout it I keep doing the same thing over and over:</p>

<pre><code>// vector&lt;Drug*&gt; drugSack;
for (unsigned int i = 0; i &lt; this-&gt;drugSack.size(); i++)
            this-&gt;sell(drugSack[i]);
</code></pre>

<p>Just one example.  I hate having all these for loops all over the place omg QQ, anyway to do something like:</p>

<pre><code>drugSack-&gt;DoForAll((void*)myCallBack);
</code></pre>

<p>I'm not well versed in the STL.</p>
","87234","","<p>Honestly, C++ is currently pretty bad at this kind of stuff. It can definitely do it, as outlined in xtofl's answer, but it's often very clumsy.</p>

<p>Boost has a <a href=""http://www.boost.org/doc/libs/1_41_0/doc/html/foreach.html"" rel=""nofollow"">for-each macro</a> that is quite convenient:</p>

<pre><code>#include &lt;boost/foreach.hpp&gt;
#define foreach BOOST_FOREACH

// ...

foreach(Drug* d, drugSack)
{
    sell(d);
}
</code></pre>

<p>Or perhaps <a href=""http://www.boost.org/doc/libs/1_41_0/libs/bind/bind.html"" rel=""nofollow"">Boost.Bind</a>, though this is slightly more complex, it reads very nice for your case:</p>

<pre><code>#include &lt;boost/bind.hpp&gt;

// ...

// ThisClass refers to whatever class this method is in
std::for_each(drugSack.begin(), drugSack.end(),
                boost::bind(&amp;ThisClass::sell, this, _1));
</code></pre>

<p>Bind will make a functor that calls the member function of <code>ThisClass</code>, <code>sell</code>, on the instance of the class pointed to by <code>this</code>, and will replace <code>_1</code> with the argument it gets from <code>for_each</code>.</p>

<p>The most general method is with lambda's. Boost has a <a href=""http://www.boost.org/doc/libs/1_41_0/doc/html/lambda.html"" rel=""nofollow"">lambda library</a>. I won't include
samples here because for your specific case boost bind works, and the lambda's would be the same code. That said, lamba's can do much more! They basically create in-place functions (implemented as functors), but are much more complex to learn.</p>

<p>Both for-each and bind are far cleaner than the ""standard"" C++ methods, in my opinion. For now, I'd recommend, in order: for-each, bind, standard C++, lambda's.</p>

<p>In C++0x, the next C++ standard, all this will be nice again with built-in lambda support:</p>

<pre><code>std::for_each(drugSack.begin(), drugSack.end(),
                [this](DrugSack* d){ sell(d); });
</code></pre>

<p>Or the new range-based for loops:</p>

<pre><code>for(DrugSack* d : drugSack)
{
    sell(d);
}
</code></pre>

<p>But we must wait a couple years before this is an option. :( Also, I think the range-based for-loop is the easiest thing to read. This is why I recommend boost for-each, because it mimics this behavior and syntax (mostly).</p>

<p>Also, totally unrelated: the style where you include <code>this-&gt;</code> before everything is, in my experience, generally considered bad practice. The compiler will do it for you, all you're doing is cluttering up your code and introducing the chance of mistakes. Things read much better without it.</p>
"
"<p>Basically, I am looking for a library solution that does this:</p>

<pre><code>#include &lt;boost/type_traits.hpp&gt;

template&lt;bool&gt;
struct bool_to_bool_type;

template&lt;&gt;
struct bool_to_bool_type&lt;false&gt;
{
    typedef boost::false_type type;
};

template&lt;&gt;
struct bool_to_bool_type&lt;true&gt;
{
    typedef boost::true_type type;
};
</code></pre>

<p>Is there such a metafunction?</p>
","87234","","<p>While <code>integral_constant</code> is the answer, you may make a type or two just to make things a bit clearer. I use this in my library:</p>

<pre><code>// utility/bool_type.hpp
#include &lt;boost/type_traits/integral_constant.hpp&gt;

namespace utility
{
    template &lt;bool B&gt;
    struct bool_type : boost::integral_constant&lt;bool, B&gt;
    {
        static const bool value = B;
    };

    typedef const boost::true_type&amp; true_tag;
    typedef const boost::false_type&amp; false_tag;
}

// main.cpp
// just some predicate for example
template &lt;typename T&gt;
struct is_pointer
{
    static const bool value = false;
};

template &lt;typename T&gt;
struct is_pointer&lt;T*&gt;
{
    static const bool value = true;
};

// some specialized function.
// the true/false tag parameter is a
// little easier to read, i think
template &lt;typename T&gt;
void foo(T, utility::true_tag)
{
}

/* versus:
template &lt;typename T&gt;
void foo(T, const boost::true_type&amp;)
*/

template &lt;typename T&gt;
void foo(T, utility::false_tag)
{
}

// the actual function
template &lt;typename T&gt;
void foo(T pX)
{
    // a bit shorter
    foo(pX, utility::bool_type&lt;is_pointer&lt;T&gt;::value&gt;());

    /* versus:
    foo(pX, boost::integral_type&lt;bool, is_pointer&lt;T&gt;::value&gt;());
    */
}

int main(void)
{
    int i = 0;
    foo(i);
    foo(&amp;i);
}
</code></pre>

<p>But that's just my opinion. :]</p>
"
"<p>GCC treats these two function declarations as equivalent:</p>

<pre><code>void F(int* a) { }
void F(int* const a) { }
</code></pre>

<blockquote>
  <p>test.cpp: In function 'void F(int*)':</p>
  
  <p>test.cpp:235: error: redefinition of 'void F(int*)'</p>
  
  <p>test.cpp:234: error: 'void F(int*)' previously defined here</p>
</blockquote>

<p>This makes some sense because a caller will always ignore the const in this case... it only affects the usage of the parameter 'a' inside of the function.</p>

<p>What I'm wondering is where (if anywhere) the standard says that it's specifically OK to discard qualifiers on pointers used as function arguments for the purpose of overload resolution.</p>

<p>(My real issue is that I'd like to figure out where GCC strips these pointless qualifiers internally, and since the C++ frontend of GCC is littered with comments referencing the standard, the relevant section of the standard might help me find the correct spot.)</p>
","87234","","<p>It's the same as:</p>

<pre><code>void foo(int);
void foo(const int);
</code></pre>

<p>Being the same to the caller. This is because the function is getting a copy by-value no matter what, so the caller doesn't care if it's thought of as <code>const</code> or not; it makes no difference to it.</p>

<p>It's <em>not</em> legal for the compiler to ignore such things, but there is no difference in overload resolution. The <code>const</code> applies to the implementation of the function.</p>

<p>Illegal would be if the compiler treated:</p>

<pre><code>void foo(int i)
{
    i = 5; // good
}

void foo(const int)
{
    i = 5; // lolwut?
}
</code></pre>

<p>The same, by ignoring the <code>const</code>.</p>
"
"<p>I was going through the auto_ptr documentation on this link <a href=""http://www2.roguewave.com/support/docs/sourcepro/edition9/html/stdlibref/auto-ptr.html"" rel=""nofollow"">auto_ptr</a>
There is something which i could not fully understand why is it done. In the interface section there are two declarations for its copy constructor</p>

<p>1)</p>

<pre><code>auto_ptr(auto_ptr&lt;X&gt;&amp;) throw (); 
</code></pre>

<p>2)    </p>

<pre><code>template &lt;class Y&gt; 
     auto_ptr(auto_ptr&lt;Y&gt;&amp;) throw(); 
</code></pre>

<p>What purpose is this for.</p>
","87234","","<p>It's there in case you can implicitly convert the pointers:</p>

<pre><code>struct base {};
struct derived : base {};

std::auto_ptr&lt;derived&gt; d(new derived);
std::auto_ptr&lt;base&gt; b(d); // converts 
</code></pre>

<p>Also, you didn't ask but you'll notice the copy-constructor is non-const. This is because the <code>auto_ptr</code> will take ownership of the pointer. In the sample above, after <code>b</code> is constructed, <code>d</code> holds on to nothing. This makes <code>auto_ptr</code> unsuitable for use in containers, because it can't be copied around.</p>

<p>C++0x ditches <code>auto_ptr</code> and makes one called <code>unique_ptr</code>. This pointer has the same goals, but accomplishes them correctly because of move-semantics. That is, while it cannot be copied, it can ""move"" ownership:</p>

<pre><code>std::unique_ptr&lt;derived&gt; d(new derived);

std::unique_ptr&lt;base&gt; b(d); // nope, cannot be copied
std::unique_ptr&lt;base&gt; b(std::move(d)); // but can be moved
</code></pre>

<p>This makes <code>unique_ptr</code> suitable for use in containers, because they no longer copy their values, they move them.</p>
"
"<p>I've noticed that when I use a boost feature the app size tends to increase by about .1 - .3 MB. This may not seem like much, but compared to using other external libraries it is (for me at least). Why is this?</p>
","87234","","<p>""so much"" is a comparative term, and I'm afraid you're comparing apples to oranges. Just because other libraries are smaller doesn't imply you should assume Boost is as small. 
Look at the sheer amount of work Boost does for you!</p>

<p>I doubt making a custom library with the same functionality would be of any considerable lesser size. The only valid comparison to make is ""Boost's library that does X"" versus ""Another library that does X"". Not ""Boost's library that does X"" and ""Another library that does Y.""</p>

<p>The file system library is very powerful, and this means lots of functions, and lot's of back-bone code to provide you and I with a simple interface. Also, like others mentioned templates in general can increase code size, but it's not like that's an avoidable thing. Templates or hand-coded, either one will results in the same size code. The only difference is templates are much easier.</p>
"
"<p>The following shows ♠♣♥♦ on windows xp, will it for all systems??</p>

<pre><code>#include &lt;stdio.h&gt;
int main(int argc, char *argv[])
{
    for (int i = 3; i &lt;= 6; ++i)
        printf(""%c"", (char)i);

    getchar();
    return 0;
}
</code></pre>
","87234","","<p>Nope. Character encoding is a very platform dependent, in my experience.</p>

<p>Consider, in ASCII those characters <a href=""http://www.asciitable.com/"" rel=""nofollow"">don't even exist</a>. And I have no clue where they are in Unicode. And where ever they are, you would then be depending on how your platform outputs Unicode.</p>
"
"<p>How do .lib and .obj files relate to each other?  What is their purpose?  Is a .lib just a collection of .obj files?  If so are the .obj's then stored inside the .lib making the .obj's unnecessary? </p>
","87234","","<p>Typically, the <code>.obj</code> files refer to <em>object files</em>. This is a source file in its compiled form. For example, a <code>main.cpp</code> and <code>foo.cpp</code> would produce <code>main.obj</code> and <code>foo.obj</code>.</p>

<p>It is then the linkers job to link them together, so that <code>main.obj</code> can reach functions defined in <code>foo.obj</code> and vice-versa. The linker will output your binary file, which is the <code>.lib</code> (or <code>.a</code>, or <code>.exe</code>, or .dll``, etc).</p>

<p>So in a loose sense, yes, the binary output (<code>.lib</code> in your case) is the collection of linked <code>.obj</code> files. Once you are finished compiling, and want to use the library, you only need other programs to link with the <code>.lib</code>. The <code>.obj</code> are what's considered intermediate files, and are not needed after linking is completed.</p>
"
"<p>First night at taking a look at different ways to create Terrain.</p>

<p>I'm wanting to work on a racing project and was wondering if there was a way to create a 3D race track some how.</p>

<p>We plan on using C++, and are also using PhysX and openGL. Where should I be looking for creating Terrain? Also, does anyone know of some good Tutorials/Tips that can help me :)</p>

<p>Thanks</p>
","87234","","<p>The most basic way to make terrain is by using a height-map, and generating a mesh out of it. Google will have <a href=""http://www.google.com/search?q=opengl+terrain&amp;ie=utf-8&amp;oe=utf-8&amp;aq=t&amp;rls=org.mozilla%3aen-US%3aofficial&amp;client=firefox-a"" rel=""nofollow"">more information</a> than I can <a href=""http://www.gamedev.net/reference/list.asp?categoryid=188"" rel=""nofollow"">give you</a>.</p>

<p>By the way, <strong>avoid going to Lighthouse3D right now</strong>; it's been hacked and crashes your browser. Here's a <a href=""http://74.125.95.132/search?q=cache%3aWM-3iPEPhaIJ%3awww.lighthouse3d.com/opengl/terrain/index.php3%3Fheightmap+opengl+terrain&amp;cd=2&amp;hl=en&amp;ct=clnk&amp;gl=us&amp;client=firefox-a"" rel=""nofollow"">cached version</a> that may be helpful.</p>
"
"<p>I've run into a strange problem. The following simplified code reproduces the problem in MSVC 2010:</p>

<pre><code>template &lt;typename T&gt;
struct dummy
{
    static T foo(void) { return T(); }
};

int main(void)
{
    typedef dummy&lt;bool&gt; dummy_type;
    auto x = []{ bool b = dummy_type::foo(); };
    // auto x = []{ bool b = dummy&lt;bool&gt;::foo(); }; // works
}
</code></pre>

<p>The <code>typedef</code> I created locally in the function doesn't seem to be visible in the lambda. If I replace the <code>typedef</code> with the actual type, it works as expected.</p>

<p>Here are some other test cases:</p>

<pre><code>// crashes the compiler, credit to Tarydon
int main(void)
{
    struct dummy {};

    auto x = []{ dummy d; };
}

// works as expected
int main(void)
{
    typedef int integer;

    auto x = []{ integer i = 0; };
}
</code></pre>

<p>I don't have g++ available to test it, right now. Is this some strange rule in C++0x, or just a bug in the compiler?</p>

<p>From the results above, I'm leaning towards bug. Though the crash is definitely a bug.</p>

<hr>

<p>For now, I have filed two <a href=""http://stackoverflow.com/questions/2122282/are-function-local-typedefs-visible-inside-c0x-lambdas/2122432#2122432"">bug reports</a>.</p>

<p>All code snippets above should compile. The error has to do with using the scope resolution on locally defined scopes. (Spotted by <a href=""http://stackoverflow.com/users/149467/dvide"">dvide</a>.)</p>

<p>And the crash bug has to do with... who knows. :)</p>

<hr>

<h3>Update</h3>

<p>According to the <a href=""http://stackoverflow.com/questions/2122282/are-function-local-typedefs-visible-inside-c0x-lambdas/2122432#2122432"">bug reports</a>, they have both been fixed for the next release of Visual Studio 2010. (Though this doesn't seem to be the case; VS11 perhaps.)</p>
","87234","","<p>I have filed two bug reports.</p>

<ul>
<li>The crash bug by <a href=""http://stackoverflow.com/questions/2122282/are-function-local-typedefs-visible-inside-c0x-lambdas/2122324#2122324"">Tarydon</a>. (<a href=""https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=526671"" rel=""nofollow"">Report</a>)</li>
<li>The lambda scope resolution bug. (<a href=""https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=526672"" rel=""nofollow"">Report</a>)</li>
</ul>

<p>We'll see how it goes. :)</p>

<hr>

<h3>Update</h3>

<p>Both bugs have been marked as fixed:</p>

<blockquote>
  <p>We appreciate your feedback. This bug has been seen by us before and we have fixed it in next release. Thank you for using the product.</p>
  
  <p>Thanks,<br>
  Ulzii Luvsanbat<br>
  Windows C++ Team </p>
</blockquote>

<p>So there we go.</p>
"
"<p>I am working on a opengl project in C++. I need to write a loader to input features from a .model file. It seems fstream can not handle that. Any comment or advice? Thanks.</p>
","87234","","<p>You're probably using <code>fstream</code> wrong. If you open it in text mode, you'll get conversions that mess up your loading process. You need to open the file as binary.</p>

<pre><code>std::ifstream file(""something.model"", std::ios::binary);
</code></pre>

<p>You can then read in raw data:</p>

<pre><code>// read in float
float f;
file.read(&amp;f, sizeof(f));
</code></pre>

<p>However you need. Be aware that types like <code>int</code> or <code>char</code> aren't necessarily the correct bit-width. If you want to be sure, you need fixed-width integers. Boost provides <a href=""http://www.boost.org/doc/libs/1_41_0/libs/integer/index.html"" rel=""nofollow"">such a library</a>.</p>

<pre><code>#include &lt;boost/cstdint.hpp&gt;

// ...
// read a 32-bit int
boost::uint32_t i;
file.read(&amp;i, sizeof(i));
</code></pre>
"
"<pre><code>#include &lt;stdio.h&gt;

int main(void){
  unsigned a[3][4] = {
    {2,23,6,7},
    {8,5,1,4},
    {12,15,3,9}
 };
 printf(""%u"",*((int*)(((char*)a)+4)));
 return 0;
}
</code></pre>

<p>The output in my machine is the value at <code>a[0][1]</code> i.e <strong>23</strong>.Could somebody explain how is this working ?</p>

<p>Edit: Rolling Back to old <code>yucky</code> code,exactly what was presented to me :P</p>
","87234","","<p>So you have your array in memory as so:</p>

<pre><code>2, 23, 6, 7, 8...
</code></pre>

<p>What this does is cast the array to a <code>char*</code>, which lets you access individual bytes, and it points here:</p>

<pre><code>2, 23, 6, 7, 8...
^
</code></pre>

<p>It then adds four bytes, moving it over to the next value (more on this later).</p>

<pre><code>2, 23, 6, 7, 8...
   ^
</code></pre>

<p>Then it turns it into an <code>int*</code> and dereferences it, getting the value 23.</p>

<hr>

<p>There are technically three things wrong with this code.</p>

<p>The first is that it assumes that an <code>unsigned</code> is 4 bytes in size. (Hence the <code>+ 4</code>). But this isn't necessarily true! Better would have been <code>+ sizeof(unsigned)</code>, ensuring correctness no matter what size <code>unsigned</code> happens to be.</p>

<p>The second problem is the cast to <code>int</code>: the original array was <code>unsigned</code>, but the value is being cast to an <code>int</code>. There exists values in the <code>unsigned</code> range that <code>int</code> cannot represent (because in an <code>int</code> half of the range is in the negatives.) So if one of the values in the array was not representable as an <code>int</code> (meaning the value was greater than <code>INT_MAX</code>), you'd get the wrong value. Better would be to convert to <code>unsigned*</code>, to maintain the correct type. </p>

<p>The last thing is the format specifier. The specifier for integers is <code>%d</code>, but the code uses <code>%u</code>, which is for unsigned integers. In effect, even though casting back to <code>int*</code> was wrong, <code>printf</code> is going to cast <em>that</em> value back into an <code>unsigned*</code>, restoring it's integrity. By fixing problem two, problem three fixes itself.</p>

<p>There is a <em>hidden</em> fourth problem: The code sucks. This may be for learning purposes, but <strong>yuck</strong>.</p>
"
"<p>Stuck on a little fiddly problem. I'm creating a GUI in C++ using XP and VS C++ using the command CreateWindow().</p>

<p>My question is, how do I make the inside paintable region a perfect square. When passing in the size of the window to create, some of this is deducted for the menu bar at the top, border all around etc. Are there any real time variables I can pass in, e.g. to create a 500x500 window would be:</p>

<pre><code>...500+BORDER,500+MENU_TOP+BORDER...
</code></pre>

<p>Thanks everyone</p>
","87234","","<p>The way I usually do it is with <a href=""http://msdn.microsoft.com/en-us/library/ms632665%28VS.85%29.aspx?ppud=4"" rel=""nofollow""><code>AdjustWindowRect</code></a>. I find it simpler than the other suggested methods (which should work just as well, it's your choice). Use it as such:</p>

<pre><code>RECT rect = {0, 0, desiredWidth, desiredHeight};

AdjustWindowRect(&amp;rect, windowStyle, hasMenu);

const int realWidth = rect.right - rect.left;
const int realHeight = rect.bottom - rect.top;
</code></pre>

<p>And pass <code>realWidth</code> &amp; <code>realHeight</code> to <code>CreateWindow</code>.</p>

<p>The function will, as its name suggests, adjust the window according to your window style and menu use, so that the client region matches your desired size.</p>
"
"<p>Can anybody tell what's the problem of the code below? </p>

<pre><code>int main () { 
return main() ; 
}
</code></pre>

<p>I tested, it compiles correctly. It's running forever. Anymore trick behind the scene?</p>
","87234","","<p>Calling <code>main</code> in C++ is illegal (§3.6.1.3):</p>

<blockquote>
  <p>The function main shall not be used within a program.</p>
</blockquote>

<p>Your compiler is allowing illegal behavior.</p>

<p>It loops forever because, well, <code>main</code> calls <code>main</code>, who calls <code>main</code>, who calls <code>main</code>, and so on.</p>
"
"<p>I'm trying to understand how variants are implemented, and reading:</p>

<p><a href=""http://www.codeproject.com/KB/cpp/TTLTyplist.aspx"" rel=""nofollow"">http://www.codeproject.com/KB/cpp/TTLTyplist.aspx</a></p>

<p>And I'm getting the impression that I can't write a variant that takes X types; but that the template writer picks some N, and I can only have less than-N types in a variant.</p>

<p>Is this correct?</p>

<p>Thanks!</p>
","87234","","<p>In C++03, there are no variadic templates. This means yes; you simply have to pick some N to go up to, and live with that.</p>

<p>In C++0x, there will be variadic templates, so you could use one definition for all X.</p>

<p>If you're looking to make changing the number easy, you can use <a href=""http://www.boost.org/doc/libs/1_41_0/libs/preprocessor/doc/index.html"" rel=""nofollow"">Boost.Preprocessor</a> and have it do the work for you:</p>

<pre><code>#define MAXIMUM_TYPELIST_SIZE 20 // or something

struct empty{};

template &lt;BOOST_PP_ENUM_BINARY_PARAMS(MAXIMUM_TYPELIST_SIZE, typename T, =empty)&gt;
struct typelist;

template &lt;BOOST_PP_ENUM_PARAMS(MAXIMUM_TYPELIST_SIZE, typename T)&gt;
struct typelist
{
    typedef T1 head;
    typedef typelist&lt;
            BOOST_PP_ENUM_PARAMS(BOOST_PP_DEC(MAXIMUM_TYPELIST_SIZE), T)&gt; tail;
  enum
  {
    length = tail::length+1
  };
};
</code></pre>

<p>If <code>MAXIMUM_TYPELIST_SIZE</code> were 5, those macro's would expand to what the article has.</p>

<p>(Of course, if you're using Boost just use their <a href=""http://www.boost.org/doc/libs/1_41_0/libs/mpl/doc/index.html"" rel=""nofollow"">meta-programming library</a>.)</p>
"
"<p>I've just completed writing a program for a programming class, and I want to avoid use of magic numbers, so here's my question:</p>

<p>In the function below, would my array indexers be considered magic numbers?</p>

<p>Code:</p>

<pre><code>string CalcGrade(int s1, int s2, int s3, double median)
{
const int SIZE = 23;
const int LETTER_GRADE_BARRIERS[SIZE] = { 400, 381, 380, 361, 360, 341, 340, 321, 320, 301, 300, 281, 280, 261, 260, 241, 240, 221, 220, 201, 200, 181, 180 }; 
double finalGrade;
string letterGrade;

finalGrade = s1 + s2 + s3 + median;

if (finalGrade &gt;= LETTER_GRADE_BARRIERS[1] &amp;&amp; finalGrade &lt;= LETTER_GRADE_BARRIERS[0])
{
    letterGrade = ""A"";
}
else if (finalGrade &gt;= LETTER_GRADE_BARRIERS[3] &amp;&amp; finalGrade &lt;= LETTER_GRADE_BARRIERS[2])
{
    letterGrade = ""A-"";
}
else if (finalGrade &gt;= LETTER_GRADE_BARRIERS[5] &amp;&amp; finalGrade &lt;= LETTER_GRADE_BARRIERS[4])
{
    letterGrade = ""B+"";
}
else if (finalGrade &gt;= LETTER_GRADE_BARRIERS[7] &amp;&amp; finalGrade &lt;= LETTER_GRADE_BARRIERS[6])
{
    letterGrade = ""B"";
}
else if (finalGrade &gt;= LETTER_GRADE_BARRIERS[9] &amp;&amp; finalGrade &lt;= LETTER_GRADE_BARRIERS[8])
{
    letterGrade = ""B-"";
}
else if (finalGrade &gt;= LETTER_GRADE_BARRIERS[11] &amp;&amp; finalGrade &lt;= LETTER_GRADE_BARRIERS[10])
{
    letterGrade = ""C+"";
}
else if (finalGrade &gt;= LETTER_GRADE_BARRIERS[13] &amp;&amp; finalGrade &lt;= LETTER_GRADE_BARRIERS[12])
{
    letterGrade = ""C"";
}
else if (finalGrade &gt;= LETTER_GRADE_BARRIERS[15] &amp;&amp; finalGrade &lt;= LETTER_GRADE_BARRIERS[14])
{
    letterGrade = ""C-"";
}
else if (finalGrade &gt;= LETTER_GRADE_BARRIERS[17] &amp;&amp; finalGrade &lt;= LETTER_GRADE_BARRIERS[16])
{
    letterGrade = ""D+"";
}
else if (finalGrade &gt;= LETTER_GRADE_BARRIERS[19] &amp;&amp; finalGrade &lt;= LETTER_GRADE_BARRIERS[18])
{
    letterGrade = ""D"";
}
else if (finalGrade &gt;= LETTER_GRADE_BARRIERS[21] &amp;&amp; finalGrade &lt;= LETTER_GRADE_BARRIERS[20])
{
    letterGrade = ""D-"";
}
else if (finalGrade &lt;= LETTER_GRADE_BARRIERS[22])
{
    letterGrade = ""Fail"";
}

return letterGrade;
}
</code></pre>

<p>Thanks!</p>
","87234","","<p><em>In the fashion you are doing things</em>, I would say they are not magic numbers. What would you rename them? I can't think of any useful answer (<code>static const int One = 1;</code> is useless.)</p>

<p>The <code>400, 381,</code> etc. line is more confusing to me at first. I would put something like <code>// GPA times 100</code> above it to clarify.</p>

<p>In fact, while your question (array indexes) isn't too magical, the <code>400...</code> line should probably be replaced with <code>static const int A = 400; static const int AMinus = 381;</code> then <code>...BARRIERS[] = {A, AMinus,}</code> and so on. Those are definitely meaningful constants</p>

<p>There are alternate (cleaner) methods that would need numbers that should definitely be turned into named constants. (The same ones suggested above)</p>
"
"<p>May I know how I can convert std::string, to MSVC specific __int64?</p>
","87234","","<p><code>__int64</code>, while an extension, is still just a numeric type. Use whichever method you would typically use.</p>

<p>Boost <a href=""http://www.boost.org/doc/libs/1_40_0/libs/conversion/lexical_cast.htm"" rel=""nofollow"">lexical cast</a> is my favorite. It pretty much wraps up Michaels answer in an easy to use form:</p>

<pre><code>__int64 x = boost::lexical_cast&lt;__int64&gt;(""3473472936"");
</code></pre>

<p>If you can't use boost, you can still do a pretty good job of making a simple version. Here's an implementation I wrote for another answer:</p>

<pre><code>template &lt;typename R&gt;
const R lexical_cast(const std::string&amp; s)
{
    std::stringstream ss(s);

    R result;
    if ((ss &gt;&gt; result).fail() || !(ss &gt;&gt; std::ws).eof())
    {
        throw std::bad_cast();
    }

    return result;
}
</code></pre>

<p>It does some extras, like checking for trailing characters. (<code>""123125asd""</code> would fail). If the cast cannot be made, <code>bad_cast</code> is thrown. (Similar to boost.)</p>

<p>Also, if you have access to boost, you can avoid the need to use the MSVC-specific <code>__int64</code> extension with:</p>

<pre><code>#include &lt;boost/cstdint.hpp&gt;
typedef boost::int64_t int64;
</code></pre>

<p>To get <code>int64</code> on any platform that provides it, without changing your code.</p>
"
"<p>I have two classes declared as below:</p>

<pre><code>class User
{
public:
 MyMessageBox dataMsgBox;
};

class MyMessageBox
{
public:
 void sendMessage(Message *msg, User *recvr);
 Message receiveMessage();
 vector&lt;Message&gt; *dataMessageList;
};
</code></pre>

<p>When I try to compile it using gcc, it gives the following error:
'MyMessageBox does not name a type'. Please help me in this regard.</p>
","87234","","<p>When the compiler compiles the class <code>User</code> and gets to the <code>MyMessageBox</code> line, <code>MyMessageBox</code> has not yet been defined. It has no idea it exists, so cannot understand the meaning of your class member.</p>

<p>You need to make sure <code>MyMessageBox</code> is defined <em>before</em> you use it as a member. This is solved by reversing the definition order. However, you have a cyclic dependency: if you move <code>MyMessageBox</code> above <code>User</code>, then in the definition of <code>MyMessageBox</code> the name <code>User</code> won't be defined!</p>

<p>What you can do is <em>forward declare</em> <code>User</code>; that is, declare it but don't define it. During compilation, a type that is declared but not defined is called an <em>incomplete type</em>.
Consider the simpler example:</p>

<pre><code>struct foo; // foo is *declared* to be a struct, but that struct is not yet defined

struct bar
{
    // this is okay, it's just a pointer;
    // we can point to something without knowing how that something is defined
    foo* fp; 

    // likewise, we can form a reference to it
    void some_func(foo&amp; fr);

    // but this would be an error, as before, because it requires a definition
    /* foo fooMember; */
};

struct foo // okay, now define foo!
{
    int fooInt;
    double fooDouble;
};

void bar::some_func(foo&amp; fr)
{
    // now that foo is defined, we can read that reference:
    fr.fooInt = 111605;
    fr.foDouble = 123.456;
}
</code></pre>

<p>By forward declaring <code>User</code>, <code>MyMessageBox</code> can still form a pointer or reference to it:</p>

<pre><code>class User; // let the compiler know such a class will be defined

class MyMessageBox
{
public:
    // this is ok, no definitions needed yet for User (or Message)
    void sendMessage(Message *msg, User *recvr); 

    Message receiveMessage();
    vector&lt;Message&gt;* dataMessageList;
};

class User
{
public:
    // also ok, since it's now defined
    MyMessageBox dataMsgBox;
};
</code></pre>

<p>You <em>cannot</em> do this the other way around: as mentioned, a class member needs to have a definition. (The reason is that the compiler needs to know how much memory <code>User</code> takes up, and to know that it needs to know the size of its members.) If you were to say:</p>

<pre><code>class MyMessageBox;

class User
{
public:
    // size not available! it's an incomplete type
    MyMessageBox dataMsgBox;
};
</code></pre>

<p>It wouldn't work, since it doesn't know the size yet.</p>

<hr>

<p>On a side note, this function:</p>

<pre><code> void sendMessage(Message *msg, User *recvr);
</code></pre>

<p>Probably shouldn't take either of those by pointer. You can't send a message without a message, nor can you send a message without a user to send it to. And both of those situations are expressible by passing null as an argument to either parameter (null is a perfectly valid pointer value!)</p>

<p>Rather, use a reference (possibly const):</p>

<pre><code> void sendMessage(const Message&amp; msg, User&amp; recvr);
</code></pre>
"
"<p>Yes this is not very portable, I wonder why one would want to do something like this:`</p>

<pre><code>char *cp ;
reinterpret_cast&lt;char *&amp;&gt;(a) = cp;
</code></pre>

<p>` and what it means?</p>

<p>Thx</p>
","87234","","<p>Some people are confused about the reference in the cast. Without the reference, we would have something like this:</p>

<pre><code>T a; // whatever a is, we don't know
char* cp; // or something convertible to char*

// remember, this is not what actually gets generated
char* some_temporary_rvalue = reinterpret_cast&lt;char*&gt;(a);
some_temporary_rvalue = cp; // illegal, and senseless
</code></pre>

<p>With the reference, it becomes:</p>

<pre><code>T a; // whatever a is, we don't know
char* cp; // or something convertible to char*

char*&amp; a_treated_as_charptr = reinterpret_cast&lt;char*&amp;&gt;(a);
a_treated_as_charptr = cp; // assigns a char* that is at &amp;a
</code></pre>
"
"<p>One of the cool new C++ features in Visual Studio 2010 are lambda expressions. However, I can't get them to work within a managed class.</p>

<pre><code>class UnmanagedClass {
    void Foo() {
        // Creating empty lambda within unmanaged class.
        // This compiles fine.
        auto lambda = [](){ ; };
    }
};

ref class ManagedClass {
    void Foo() {
        // Creating empty lambda within managed class.
        // This creates error C3809:
        // A managed type cannot have any friend functions/classes/interfaces.
        auto lambda = [](){ ; };
    }
};
</code></pre>

<p>My best guess is that the compiler creates the anonymous function class as a friend class, even though I never use class members. This seems to mean that lambdas cannot be used at all within ref classes.</p>

<p>I was so happy when I read that VS2010 adds lambda expressions to C++. Does anybody know how to get them to work within ref classes?</p>
","87234","","<p><a href=""http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=524356"" rel=""nofollow"">Looks like</a> it is being considered for future versions. Otherwise known as: ""We'll get to it.""</p>
"
"<p>I was trying to make a Intel 8080 CPU emulator (then I'd like to emulate Space Invaders, which use it).</p>

<p>I coded nearly complete implementation of this CPU (thanks to MAME and Tickle project (mostly) ;) ) except undocument instructions (0x08, 0x10, 0x18, 0x20, 0x28, 0x30, 0x38, 0x0CB, 0x0D9, 0x0DD, 0x0ED, 0x0FD).</p>

<p>I've have only problems when I compile it, I don't know why.</p>

<p>This is the code:</p>

<pre><code>static const unsigned char cycles_table[256] =
{
    /*                       8080's Cycles Table                         */
    /*     0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F */
    /*0*/  4, 10,  7,  5,  5,  5,  7,  4,  0, 10,  7,  5,  5,  5,  7,  4,
    /*1*/  0, 10,  7,  5,  5,  5,  7,  4,  0, 10,  7,  5,  5,  5,  7,  4,
    /*2*/  0, 10, 16,  5,  5,  5,  7,  4,  0, 10, 16,  5,  5,  5,  7,  4,
    /*3*/  0, 10, 13,  5, 10, 10, 10,  4,  0, 10, 13,  5,  5,  5,  7,  4,
    /*4*/  5,  5,  5,  5,  5,  5,  7,  5,  5,  5,  5,  5,  5,  5,  7,  5,
    /*5*/  5,  5,  5,  5,  5,  5,  7,  5,  5,  5,  5,  5,  5,  5,  7,  5,
    /*6*/  5,  5,  5,  5,  5,  5,  7,  5,  5,  5,  5,  5,  5,  5,  7,  5,
    /*7*/  7,  7,  7,  7,  7,  7,  7,  7,  5,  5,  5,  5,  5,  5,  7,  5,
    /*8*/  4,  4,  4,  4,  4,  4,  7,  4,  4,  4,  4,  4,  4,  4,  7,  4,
    /*9*/  4,  4,  4,  4,  4,  4,  7,  4,  4,  4,  4,  4,  4,  4,  7,  4,
    /*A*/  4,  4,  4,  4,  4,  4,  7,  4,  4,  4,  4,  4,  4,  4,  7,  4,
    /*B*/  4,  4,  4,  4,  4,  4,  7,  4,  4,  4,  4,  4,  4,  4,  7,  4,
    /*C*/  5, 10, 10, 10, 11, 11,  7, 11,  5, 10, 10,  0, 11, 17,  7, 11,
    /*D*/  5, 10, 10, 10, 11, 11,  7, 11,  5,  0, 10, 10, 11,  0,  7, 11,
    /*E*/  5, 10, 10, 18, 11, 11,  7, 11,  5,  5, 10,  4, 11,  0,  7, 11,
    /*F*/  5, 10, 10,  4, 11, 11,  7, 11,  5,  5, 10,  4, 11,  0,  7, 11
};
</code></pre>

<p>g++ takes me this error:</p>

<blockquote>
  <p>8080.h:521: error: invalid in-class initialization of static data member of non- integral type `const unsigned char[256]'</p>
</blockquote>

<p>This array is in a class called i8080.</p>
","87234","","<p>Like it says, you cannot initialize static non-integral types in a class definition. That is, you could do this:</p>

<pre><code>static const unsigned value = 123;
static const bool value_again = true;
</code></pre>

<p>But not anything else.</p>

<p>What you should do is place this in your class definition:</p>

<pre><code>static const unsigned char cycles_table[256];
</code></pre>

<p>And in the corresponding source file, place what you have:</p>

<pre><code>const unsigned char i8080::cycles_table[256] = // ...
</code></pre>

<p>What this does is say (in the definition), ""Hey, there's gonna be this array."" and in the source file, ""Hey, here's that array.""</p>
"
"<p>I developed a scripting engine that has many built-in functions, so to call any function, my code just went into an <code>if .. else if .. else if</code> wall checking the name but I would like to develop a more efficient solution.</p>

<p>Should I use a <em>hashmap</em> with strings as keys and pointers as values? How could I do it by using an STL map? </p>

<p><strong>EDIT</strong>:
Another point that came into my mind: of course using a map will force the compiler not to inline functions, but my inefficient approach didn't have any overhead generated by the necessity of function calls, it just executes code.</p>

<p>So I wonder if the overhead generated by the function call will be any better than having an <code>if..else</code> chain.. otherwise I could minimize the number of comparisons by checking a character at runtime (will be longer but faster).</p>
","87234","","<p>Whatever your function signatures are:</p>

<pre><code>typedef void (*ScriptFunction)(void); // function pointer type
typedef std::map&lt;std::string, ScriptFunction&gt; script_map;

// ...

void some_function(void)
{
}

// ...

script_map m;
m.insert(std::make_pair(""blah"", &amp;some_function));

// ...

void call_script(const std::string&amp; pFunction)
{
    script_map::const_iterator iter = m.find(pFuntion);
    if (iter == m.end())
    {
        // not found
    }

    (*iter-&gt;second)();
}
</code></pre>

<p>STL doesn't have a hash-map implementation. But you can use either TR1 or Boost to get <code>unordered_map</code>, which is your hash map.</p>
"
"<p>suggest i have a template function like following:</p>

<pre><code>template&lt;class T&gt;
void doSomething()
{
    T a; // a is correctly initialized if T is a class with a default constructor
    ...
};
</code></pre>

<p>But variable a leaves uninitialized, if T is a primitive type. I can write T a(0), but this doesn't work if T is a class. Is there a way to initialize the variable in both cases (T == class, T == int, char, bool, ...)?</p>
","87234","","<p>Like so:</p>

<pre><code>T a{};
</code></pre>

<hr>

<p>Pre-C++11, this was the simplest approximation:</p>

<pre><code>T a = T();
</code></pre>

<p>But it requires <code>T</code> be copyable (though the copy is certainly going to be elided).</p>
"
"<p>I'm having trouble distinguishing the practical difference between calling glFlush() and glFinish().</p>

<p>The docs say that glFlush() and glFinish() will push all buffered operations to opengl so that one can be assured they will all be executed, the difference being that glFlush() returns immediately where as glFinish() blocks until all the operations are complete.</p>

<p>Having read the definitions, I figured that if I were to use glFlush() that I would probably run into the problem of submitting more operations to openGL than it could execute. So, just to try, I swapped out my glFinish() for a glFlush() and lo and behold, my program ran (as far as I could tell), the exact same; frame rates, resource usage, everything was the same.</p>

<p>So I'm wondering if there's much difference between the two calls, or if my code makes them run no different. Or where one should be used vs. the other.
I also figured that openGL would have some call like glIsDone() to check whether or not all the buffered commands for a glFlush() are complete or not (so one doesn't send operations to openGL faster than they can be executed), but I could find no such function.</p>

<p>My code is the typical game loop:</p>

<pre><code>while (running) {
    process_stuff();
    render_stuff();
}
</code></pre>
","87234","","<p>There doesn't seem to be a way of querying the status of the buffer. There is this <a href=""http://www.opengl.org/registry/specs/APPLE/fence.txt"" rel=""nofollow"">Apple extension</a> which could serve the same purpose, but it doesn't seem cross-platform (haven't tried it.) At it quick glance, it seems prior to <code>flush</code> you'd push the fence command in; you can then query the status of that fence as it moves through the buffer.</p>

<p>I wonder if you could use <code>flush</code> prior to buffering up commands, but prior to beginning to render the next frame you call <code>finish</code>. This would allow you to begin processing the next frame as the GPU works, but if it's not done by the time you get back, <code>finish</code> will block to make sure everything's in a fresh state.</p>

<p><strike>I haven't tried this, but I will shortly.</strike></p>

<p>I have tried it on an old application that has pretty even CPU &amp; GPU use. (It originally used <code>finish</code>.)</p>

<p>When I changed it to <code>flush</code> at end and <code>finish</code> at begin, there were no immediate problems. (Everything looked fine!) The responsiveness of the program increased, probably because the CPU wasn't stalled waiting on the GPU. Definitely a better method.</p>

<p>For comparison, I removed <code>finished</code> from the start of the frame, leaving <code>flush</code>, and it performed the same.</p>

<p>So I would say use <code>flush</code> and <code>finish</code>, because when the buffer is empty at the call to <code>finish</code>, there is no performance hit. And I'm guessing if the buffer were full you should want to <code>finish</code> anyway.</p>
"
"<p>(from reading chapter 3 of modern c++ design)</p>

<p>typelist.hpp:</p>

<pre><code>class NullType {};

struct EmptyType {};


template &lt;class T, class U&gt;
struct Typelist
{
  typedef T Head;
  typedef U Tail;
};

#define TYPELIST_1(T1) Typelist&lt;T1, NullType&gt;
#define TYPELIST_2(T1, T2) Typelist&lt;T1, TYPELIST_1(T2) &gt;
#define TYPELIST_3(T1, T2, T3) Typelist&lt;T1, TYPELIST_2(T2, T3) &gt;
#define TYPELIST_4(T1, T2, T3, T4) Typelist&lt;T1, TYPELIST_3(T2, T3, T4) &gt;
#define TYPELIST_5(T1, T2, T3, T4, T5) Typelist&lt;T1, TYPELIST_4(T2, T3, T4, T5) &gt;
#define TYPELIST_6(T1, T2, T3, T4, T5, T6) Typelist&lt;T1, TYPELIST_5(T2, T3, T4, T5, T6) &gt;


namespace TL
{
  template &lt;class TList&gt; struct Length;
  template &lt;&gt; struct Length&lt;NullType&gt;
  {
    enum { value = 0 };
  };

  template &lt;class T, class U&gt;
    struct Length&lt; Typelist&lt;T, U&gt; &gt;
    {
      enum { value = 1 + Length&lt;U&gt;::value };
    };


  template &lt;class Head, class Tail&gt;
    struct TypeAt&lt;Typelist&lt;Head, Tail&gt;, 0&gt;
    {
      typedef Head Result;
    };

  template &lt;class Head, class Tail, unsigned int i&gt;
    struct TypeAt&lt;Typelist&lt;Head, Tail&gt;, i&gt;
    {
      typedef typename TypeAt&lt;Tail, i-1&gt;::Result Result;
    };

}
</code></pre>

<p>main.cpp</p>

<pre><code>#include ""typelist.hpp""

Typelist&lt;int, double&gt; foo;

int main() {
}
</code></pre>

<p>g++ main.cpp</p>

<pre><code>typelist.hpp:37: error: ‘TypeAt’ is not a template
typelist.hpp:43: error: type/value mismatch at argument 2 in template parameter list for ‘template&lt;class Head, class Tail&gt; struct TL::TypeAt’
typelist.hpp:43: error:   expected a type, got ‘i’
</code></pre>

<p>Why do I get this error? How do I fix this?</p>
","87234","","<p>Looks like you're missing a forward declaration.</p>

<p>This is a partial specialization:</p>

<pre><code>template &lt;class Head, class Tail&gt;
struct TypeAt&lt;Typelist&lt;Head, Tail&gt;, 0&gt;
</code></pre>

<p>But the compiler has no idea what it's a specialization of. Add this before it:</p>

<pre><code>template &lt;class List, unsigned Index&gt;
struct TypeAt;
</code></pre>

<p>This let's the compiler know: ""There is a class <code>TypeAt</code> which has two template parameters."" So now when you specialize it, the compiler knows what class you're talking about.</p>

<hr>

<p>Note, your usage of <code>Typelist</code> is incorrect. These algorithm's are <em>sentinel-terminated</em>. This means, like C-strings, they expect the data to be concluded with a special value. In our case, this is <code>NullType</code>.</p>

<p>So, take <a href=""http://stackoverflow.com/questions/2150618/how-do-i-fix-this-c-typelist-template-compile-error/2150669#2150669"">Éric</a>'s advice. (i.e. hint: if you found his answer helpful, up-vote it.)</p>
"
"<p>How efficient is dispatching on a boost::variant ?</p>

<p>If it's a switch statement, it should only take O(1) time, but as far as I know, template metaprogrammign can only generate if's, which would put boost::variant dispatchs at a runtime overhead of O(n), where n = number of types in the variant.</p>

<p>Can anyone confirm/deny/enlighten me on this?</p>

<p>Thanks!</p>
","87234","","<p>Looking at the source, it should be constant time. Boost uses Boost.PreProcessor to generate a switch-table, and keeps track of which index it should jump to (via the type being stored).</p>
"
"<p>In C/C++ I can allocate memory in one thread and delete it in another thread. Yet whenever one requests memory from the heap, the heap allocator needs to walk the heap to find a suitably sized free area. How can two threads access the same heap efficiently without corrupting the heap? (Is this done by locking the heap?)</p>
","87234","","<p>Yes, normally access to the heap has to be locked. Any time you have a shared resource, that resource needs to be protected; memory is a resource.</p>
"
"<p>I've this program</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std ;

#if 0
namespace skg 
{
 template &lt;class T&gt;
  struct Triplet ;
}

template &lt;class T&gt;
ostream&amp; operator&lt;&lt; (ostream&amp; os, const skg::Triplet&lt;T&gt;&amp; p_t) ;
#endif

namespace skg
{
 template &lt;class T&gt;
  struct Triplet
  {
 //  friend ostream&amp; ::operator&lt;&lt; &lt;&gt; (ostream&amp; os, const Triplet&lt;T&gt;&amp; p_t) ;

   private:
   T x, y, z ;

   public:
   Triplet (const T&amp; p_x, const T&amp; p_y, const T&amp; p_z)
    : x(p_x), y(p_y), z(p_z) { }
  } ;
}

template &lt;class T&gt;
ostream&amp; operator&lt;&lt; (ostream&amp; os, const skg::Triplet&lt;T&gt;&amp; p_t)
{
 os &lt;&lt; '(' &lt;&lt; p_t.x &lt;&lt; ',' &lt;&lt; p_t.y &lt;&lt; ',' &lt;&lt; p_t.z &lt;&lt; ')' ;
 return os ;
}

namespace {
 void printVector()
 {
  typedef skg::Triplet&lt;int&gt; IntTriplet ;

  vector&lt; IntTriplet &gt; vti ;
  vti.push_back (IntTriplet (1, 2, 3)) ;
  vti.push_back (IntTriplet (5, 5, 66)) ;

  copy (vti.begin(), vti.end(), ostream_iterator&lt;IntTriplet&gt; (cout, ""\n"")) ;
 }
}
int main (void)
{
 printVector() ;
}
</code></pre>

<p>Compilation fails because compiler could not find any output operator for skg::Triplet. But output operator does exist. </p>

<p>If I move Triplet from skg namespace to global namespace everything works fine. what is wrong here ?</p>
","87234","","<p>You need to move your implementation of <code>operator&lt;&lt;</code> into the same namespace as your class. It's looking for:</p>

<pre><code>ostream&amp; operator&lt;&lt; (ostream&amp; os, const skg::Triplet&lt;T&gt;&amp; p_t)
</code></pre>

<p>But won't find it because of a short-coming in argument-dependent look-up (ADL). ADL means that when you call a free function, it'll look for that function in the namespaces of it's arguments. This is the same reason we can do:</p>

<pre><code>std::cout &lt;&lt; ""Hello"" &lt;&lt; std::endl;
</code></pre>

<p>Even though <code>operator&lt;&lt;(std::ostream&amp;, const char*)</code> is in the <code>std</code> namespace. For your call, those namespaces are <code>std</code> and <code>skg</code>.</p>

<p>It's going to look in both, not find one in <code>skg</code> (since yours is in the global scope), then look in <code>std</code>. It will see possibilities (all the normal <code>operator&lt;&lt;</code>'s), but none of those match. <em>Because the code running (the code in <code>ostream_iterator</code>) is in the namespace <code>std</code>, access to the global namespace is completely gone.</em></p>

<p>By placing your operator in the same namespace, ADL works. This is discussed in an article by Herb Sutter: <em><a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1792.pdf"">""A Modest Proposal: Fixing ADL.""</a></em>. (PDF). In fact, here's a snippet from the article (demonstrating a shortcoming):</p>

<pre><code>// Example 2.4
//
// In some library header:
//
namespace N { class C {}; }
int operator+( int i, N::C ) { return i+1; }

// A mainline to exercise it:
//
#include &lt;numeric&gt;
int main() {
    N::C a[10];
    std::accumulate( a, a+10, 0 ); // legal? not specified by the standard
}
</code></pre>

<p>Same situation you have.</p>

<p>The book <em>""C++ Coding Standards""</em> by Sutter and &amp; Alexandrescu has a useful guideline:</p>

<blockquote>
  <ol>
  <li>Keep a type and its nonmember function interface in the same namespace.</li>
  </ol>
</blockquote>

<p>Follow it and you and ADL will be happy. I recommend this book, and even if you can't get one at least read the PDF I linked above; it contains the relevant information you should need.</p>

<hr>

<p>Note that after you move the operator, you'll need your friend directive (so you can access private variables):</p>

<pre><code>template &lt;typename U&gt;
friend ostream&amp; operator&lt;&lt; (ostream&amp; os, const Triplet&lt;U&gt;&amp; p_t);
</code></pre>

<p>And ta-da! Fixed.</p>
"
"<p>I am writing my own string copy function. The following works:</p>

<pre><code>char *src, *dest;
src = (char *) malloc(BUFFSIZE);
//Do something to fill the src
dest = (char *) malloc(strlen(src) + 1);
mystringcpy(src, dest);

void mystringcopy(char *src, char *dest) {
   for(; (*dest = *src) != '\0'; ++src, +dest);
}
</code></pre>

<p>But this doesn't work:</p>

<pre><code>char *src, *dest;
src = (char *) malloc(BUFFSIZE);
//Do something to fill the src
mystringcpy(src, strlen(src), dest);

void mystringcopy(char *src, size_t length, char *dest) {
   dest = (char *)malloc(length + 1);
   for(; (*dest = *src) != '\0'; ++src, +dest);
}
</code></pre>

<p>and I can't understand why... Is allocating memory inside a called function a mistake?</p>
","87234","","<p>You haven't really said what ""works"" means, but I'm assuming you're confused why <code>dest</code> isn't being changed to the new memory back in the calling function.</p>

<p>The reason is that in your <code>mystringcopy</code> function, the parameter <code>dest</code> is a <em>copy</em> of the pointer <code>dest</code> in the calling function.</p>

<p>You then assign that copy to a new buffer, do the copy, and then the copy goes away. The original is unchanged. You need to pass <code>dest</code> as a pointer (to a pointer).</p>

<p>Also, I assume you wrote what you did from memory since it shouldn't compile as is (bad dereference in the calling function). Here's the fixed code:</p>

<pre><code>char *src, *dest;
src = (char *)malloc(BUFFSIZE); // no dereference on src, it's a pointer

//Do something to fill the src
mystringcpy(src, strlen(src), &amp;dest); // pass the address of dest

// take a pointer to a char*
void mystringcopy(char *src, size_t length, char **dest) {
    // now you should dereference dest, to assign to
    // the char* that was passed in
    *dest = (char *)malloc(length + 1);

    // for simplicity, make an auxiliary dest
    char* destAux = *dest;

    // and now the code is the same
    for(; (*destAux = *src) != '\0'; ++src, ++destAux);
}
</code></pre>

<p>Another method is to return the <code>dest</code> pointer:</p>

<pre><code>char *src, *dest;
src = (char *)malloc(BUFFSIZE);

//Do something to fill the src
dest = mystringcpy(src, strlen(src)); // assign dest

char* mystringcopy(char *src, size_t length) {
    char* dest = (char *)malloc(length + 1);

    // for simplicity, make an auxiliary dest
    char* destAux = dest;

    for(; (*destAux = *src) != '\0'; ++src, ++destAux);

    return dest; // give it back
}
</code></pre>

<p>Keep in mind if length is smaller than the source buffer's real length that you'll overrun your destination buffer. See the comments for a solution, though this is left up to you.</p>
"
"<p>I've got a class (A) that accesses (indirectly via a static method) a static variable (an STL container) in another class (B) in its constructor and destructor.</p>

<p>A objects may be global, global constants, static members of another class, stored in other classes (which may themselves have global or static instances) or basically anywhere else a c++ object can be.</p>

<p>If an A object is constructed before the static members in B or destructed after the static members in B, it will cause a crash at some point (usually an access violation).</p>

<p>Is there some way to guarantee that all instances of class A (except those that have leaked, since by definition there ""lost"" and so wont be destructed any way) are constructed after and destructed before B's static variable?</p>

<p>I've seen some solutions for making a specific variable be constructed/destructed before/after another, however not a general case of all instances of a given type so am not sure how to approach this.</p>
","87234","","<p>No. This is known as the <a href=""http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.15"">static-initialization fiasco</a>. The order that objects get constructed prior to entering main is unspecified. The only guarantee is that it happens.</p>

<p>What you can do is lazy-initialize. This means your objects won't be initialized until you use them. Such as:</p>

<pre><code>struct A { /* some data */ };
struct B { B(void){ /* get A's data */ } };

A&amp; get_A(void)
{
    static A instance;
    return instance;
}

B&amp; get_B(void)
{
    static B instance;
    return instance;
}
</code></pre>

<p>You use <code>get_A</code> and <code>get_B</code> to get the global instances. The part where <code>B</code> uses <code>A</code> should use <code>get_A</code>, and your use of <code>B</code> should be with <code>get_B</code>. Note the <code>get_B</code> is optional in your case.</p>

<p>What happens when B is first created? (Either globally or in the function) The constructor will call <code>get_A</code> and <em>that's</em> where <code>A</code> will be created. This let's you control the order things get constructed.</p>

<p>Note I think I reversed your A and B.</p>
"
"<p>Why isn't openGL object-orientied? Everybody teaches Object Orientated Programming + Design Patterns, but OpenGL has many global functions. <strong>Isn't this bad style?</strong></p>
","87234","","<p>OpenGL was created for and in C, and none of that stuff existed then. Even now, they still want to keep a C interface, because C is still a widely used language.</p>

<p>Should they maintain both C interfaces and C++ wrappers, ditch C and just use C++, or keep a C interface? I'd argue the latter is the best solution: easy on them, not too hard for us.</p>

<p>That said, the OpenGL interface is admittedly gross. Lot's of stuff was ""suppose"" to be deprecated, but alas that got moved to a later date.</p>
"
"<p>I have following code:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

class Base
{
private:
    int i;
    char ch;
public:
    void showdata()
    {
        cout&lt;&lt;""Int:""&lt;&lt;i&lt;&lt;endl;
        cout&lt;&lt;""Char:""&lt;&lt;ch&lt;&lt;endl;
    }
    //int pub_data ;
} ;

int main()
{
    Base ob;
    ob.showdata() ;
    //cout&lt;&lt;""Public Data:""&lt;&lt;ob.pub_data&lt;&lt;endl;
    return 0;
}
</code></pre>

<p>This program compiles and runs fine. The output shows that i is initialized with 0 and ch is initialized with '\0'.<br>
If you notice i have commented out 2 statements in this program. First the declaration of public data pub_data and second the line inside main printing this public data.<br>
Now here the problem is, if i uncomment these two lines, the data members of class i.e. i, ch, pub_data do not seem to be initialized and when printed, they display junk values.<br>
So my question is what difference public data makes here?<br>
I'm using g++ 3.4.6</p>
","87234","","<p>None. You're just getting ""lucky"". Fundamental types remain uninitialized, so your <code>i</code> and <code>ch</code>, as the program stands, could very well not always be 0.</p>

<p>It just so happens adding that public member ""messes it up"". To correct your class, initialize the members in the initialization list of the constructor:</p>

<pre><code>class Base
{
private:
    int i;
    char ch;
public:
    Base(void) :
    i(0), ch(0) //, pub_data(0)
    {}

    void showdata()
    {
        cout&lt;&lt;""Int:""&lt;&lt;i&lt;&lt;endl;
        cout&lt;&lt;""Char:""&lt;&lt;ch&lt;&lt;endl;
    }
    //int pub_data ;
} ;
</code></pre>

<p>Now when a <code>Base</code> gets constructed <code>i</code>, <code>ch</code>, and (when uncommented) <code>pub_data</code> will be properly initialized to meaningful values.</p>
"
"<p>similar to iostream.h ,conio.h , ...</p>
","87234","","<p>The standard library is generally all templates. You can just open up the desired header and see how it's implemented<sup>†</sup>. Note it's not <code>&lt;iostream.h&gt;</code>, it's <code>&lt;iostream&gt;</code>; the C++ standard library does not have <code>.h</code> extensions. C libraries like <code>&lt;string.h&gt;</code> can be included as <code>&lt;cstring&gt;</code> (though that generally just includes <code>string.h</code>)</p>

<p>That said, the run-time library (stuff like the C library, not-template-stuff) is compiled. You can search around your compiler install directory to find the source-code to the run-time library.</p>

<p>Why? If just to look, there you go. But it's a terrible way to try to learn, as the code may have non-standard extensions specific to the compiler, and most implementations are just generally ugly to read.</p>

<p>If you have a specific question about the inner-workings of a function, feel free to start a new question and ask how it works.</p>

<p><sub>
† I should mention that you may, on the off chance, have a compiler that supports <code>export</code>. This would mean it's entirely possible they have templated code also compiled; this is highly unlikely though. Just should be mentioned for completeness.
</sub></p>
"
"<p>I have a struct of type Duplicate
I have a variable of type int called stringSize, it has a value of 5
I am creating a dynamic array:</p>

<pre><code>Duplicate *duplicates;
duplicates = new Duplicate[stringSize - 1];
</code></pre>

<p>Later I delete[] duplicates;</p>

<p>I'm getting one member in that array only? I've verified that stringSize - 1 = 4 with a debug walk through. What can I do to get the 4 members I need?</p>

<p>Any help appreciated,
Thanks // :)</p>
","87234","","<pre><code>Duplicate *duplicates;
duplicates = new Duplicate[stringSize - 1];
</code></pre>

<p>Indeed gives you <code>duplicates[0-3]</code> (Assuming <code>stringSize - 1</code> is 4, like you say). How are you determining you're getting less?</p>

<p>I suspect you may be doing something like: <code>sizeof(duplicates) / sizeof(duplicates[0])</code>, and on an off-change getting one. The above code only works for statically allocated arrays, where <code>sizeof(duplicates)</code> would match the size of the array, in bytes. In your case, it'll simply return the size of a pointer on your system. (<code>duplicates</code> is a <code>Duplicate*</code>)</p>

<p>And mandatory: Use <code>std::vector</code> if this is ""real"" code.</p>

<hr>

<p>Your debugger is doing the best it can. As far is it's concerned, you've merely got a pointer to some data. Consider:</p>

<pre><code>Duplicate foo;
Duplicate *duplicates_A;
duplicates_A = &amp;foo; // points to one Duplicate

Duplicate *duplicates_B;
duplicates_B = new Duplicate[4]; // points to memory containing 4 Duplicate's

bar(duplicates_A);
bar(duplicates_B);

void bar(Duplicate* p)
{
    // is p a pointer to one value, or is it an array?
    // we can't tell, and this is the same boat your debugger is in
}
</code></pre>

<p>How should the debugger, just given a pointer, know if it's pointing to an array or just one value? It cannot, safely. (It would have to determine, somehow, if the pointer was to an array, and the size of that array.)</p>
"
"<p>I work on a game project. Recently, we run into a problem which we catch a ""bad_alloc"" exception when we load/unload different scenes for about three times. </p>

<p>Eachtime we load a scene, we first load the compressed .zip folder into the memory and then extract game objects from it. Since we don't have any memory profiler tool, I simply use the performance graph of Process Explorer to see what is going on:</p>

<ol>
<li>Run the game  ==> ~620 MB</li>
<li>Load the 1st scene ==> ~1.1 GB</li>
<li>Unload it ==> ~620 MB</li>
<li>Load the 2nd scene ==> ~1.1 GB</li>
<li>Unload it ==> ~620 MB</li>
<li>Load the 3rd scene ==> bad_alloc</li>
</ol>

<p>I trace down to the new operator of each load. The loading of the compressed folder costs 100~120 MB memory itself, and the bad_alloc is throw from it at the 3rd load.</p>

<p>Our platform is installed with 2GB physics memory. It seems that we do not left anything behind after unloading the scene. Each compressed folder is about the same size. However, the new operator of the 3rd load just doesn't work.</p>

<p>I'm wondering, what's the possible meaning of this bad_alloc? Out of memory? or simply can't allocate a contiguous block of the required size? If it does have several possibility, how can I determine it?</p>

<p>Any help is apppreciated, thanks!</p>
","87234","","<p><code>bad_alloc</code> is thrown by <code>new</code> when the allocation could not be fulfilled. Likely, you've simply run out of memory. Typically, custom memory managers will also throw <code>bad_alloc</code> when they request cannot be fulfilled, but you said you aren't using any. Run your code in a debugger to see where the exception originates from.</p>

<p>By the way, that's <em>a lot</em> of memory. Most professional games require half to a quarter of what you're doing; look into ways of reducing memory usage. Another thing to watch out for is memory leaks; if you never free memory, you'll eventually run out.</p>
"
"<p>I want to call member function by passing it as template parameter, without using boost is possible. Here is an example off what I tried to do,</p>

<pre><code>class object { void method(); }

{
object object_instance;
...
apply&lt;object:: method&gt;();
...

template&lt;class F&gt;
void apply() { F(object_instance); } // want to call object_instance.F()
}
</code></pre>

<p>that does not work, so question is how do I go about binding object method to an object.
Thanks</p>

<p>above is an example, not the real code. I have a bunch of functions differing only in name, but with many parameters, that I want to wrap around in operators.</p>
","87234","","<p>Something like:</p>

<pre><code>struct foo
{
    void bar(void) {}
};

template &lt;typename R, typename C&gt;
R apply(C&amp; pObject, R (C::*pFunc)())
{
    return (pObject.*pFunc)();
}

int main(void)
{
    foo f;
    apply(f, &amp;foo::bar);
}
</code></pre>

<p>this. </p>
"
"<p>i use devcpp and borland c compiler....</p>

<pre><code>asm {
    mov ax,4       // (I/O Func.)
    mov bx,1       // (Output func)  
    mov cx,&amp;name   // (address of the string)
    mov dx,6       // (length of the string)
    int 0x21       // system call
}
</code></pre>

<p>in the above code snippets i want to print a string with the help of assembly language...
but how can i put the address of the string in register cx....</p>

<p>is there something wrong in code???</p>
","87234","","<p>Just put the variable name in there:</p>

<pre><code>mov ax,4       // (I/O Func.)
mov bx,1       // (Output func)  
mov cx,name   // (address of the string)
mov dx,6       //  (lenght of the string)
int 0x21       // system call
</code></pre>

<p><sub>Disclaimer: I'm not too good at assembly.</sub></p>
"
"<p>I'm a programming student in my first C++ class, and for a recent project I did, I was unable to create an array of strings like I could do in C#:</p>

<pre><code>string MONTHS[ARRAY_CAPACITY] = { ""Jan"", ""Feb"", ""Mar"", ""April"", ""May"", ""June"", ""July"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec"" };
// this yields many compiler errors in C++
</code></pre>

<p>Is it possible to do something similar in C++?</p>

<p>Thanks!</p>
","87234","","<p>Yes, it does:</p>

<pre><code>#include &lt;string&gt;

int main(void)
{
    static const size_t Capacity = 12;
    std::string Months[Capacity] = { ""Jan"", ""Feb"", ""Mar"", ""April"", ""May"",
                                        ""June"", ""July"", ""Aug"", ""Sep"", ""Oct"",
                                        ""Nov"", ""Dec"" };
}
</code></pre>

<p>Your errors were probably related to something else. Did you remember to use <code>std::</code>? Without knowing, it could be anything. Was <code>Capacity</code> the wrong size? Etc.</p>

<p>Note your code wasn't actually a constant array. This is:</p>

<pre><code>#include &lt;string&gt;

int main(void)
{
    static const size_t Capacity = 12;
    static const std::string Months[Capacity] = { ""Jan"", ""Feb"", ""Mar"", ""April"",
 /* ^^^^^^^^^^^^ */                                 ""May"", ""June"", ""July"", ""Aug"",
                                                    ""Sep"", ""Oct"", ""Nov"", ""Dec"" };
}
</code></pre>

<p>Also, you don't actually need <code>Capacity</code>, as others will show, and you <em>could</em> use <code>const char*</code> if you'd like, though you lose the <code>std::string</code> interface.</p>
"
"<p>Consider the following code:</p>

<pre><code>class A
{
    B* b; // an A object owns a B object

    A() : b(NULL) { } // we don't know what b will be when constructing A

    void calledVeryOften(…)
    {
        if (b)
            delete b;

        b = new B(param1, param2, param3, param4);
    }
};
</code></pre>

<p>My goal: I need to maximize performance, which, in this case, means minimizing the amount of memory allocations.</p>

<p>The obvious thing to do here is to change <code>B* b;</code> to <code>B b;</code>. I see two problems with this approach:</p>

<ul>
<li>I need to initialize <code>b</code> in the constructor. Since I don't know what <code>b</code> will be, this means I need to pass dummy values to B's constructor. Which, IMO, is ugly.</li>
<li>In <code>calledVeryOften()</code>, I'll have to do something like this: <code>b = B(…)</code>, which is wrong for two reasons:
<ul>
<li>The destructor of <code>b</code> won't be called.</li>
<li>A temporary instance of B will be constructed, then copied into <code>b</code>, then the destructor of the temporary instance will be called. The copy and the destructor call could be avoided. Worse, calling the destructor could very well result in undesired behavior.</li>
</ul></li>
</ul>

<p>So what solutions do I have to avoid using <code>new</code>? Please keep in mind that:</p>

<ul>
<li>I only have control over A. I don't have control over B, and I don't have control over the users of A.</li>
<li>I want to keep the code as clean and readable as possible.</li>
</ul>
","87234","","<p>I liked Klaim's answer, so I wrote this up real fast. I don't claim perfect correctness but it looks pretty good to me. (i.e., the only testing it has is the sample <code>main</code> below)</p>

<p>It's a generic lazy-initializer. The space for the object is allocated once, and the object starts at null. You can then <code>create</code>, over-writing previous objects, with no new memory allocations.</p>

<p>It implements all the necessary constructors, destructor, copy/assignment, swap, yadda-yadda. Here you go:</p>

<pre><code>#include &lt;cassert&gt;
#include &lt;new&gt;

template &lt;typename T&gt;
class lazy_object
{
public:
    // types
    typedef T value_type;
    typedef const T const_value_type;
    typedef value_type&amp; reference;
    typedef const_value_type&amp; const_reference;
    typedef value_type* pointer;
    typedef const_value_type* const_pointer;

    // creation
    lazy_object(void) :
    mObject(0),
    mBuffer(::operator new(sizeof(T)))
    {
    }

    lazy_object(const lazy_object&amp; pRhs) :
    mObject(0),
    mBuffer(::operator new(sizeof(T)))
    {
        if (pRhs.exists())
        {
            mObject = new (buffer()) T(pRhs.get());
        }
    }

    lazy_object&amp; operator=(lazy_object pRhs)
    {
        pRhs.swap(*this);

        return *this;
    }

    ~lazy_object(void)
    {
        destroy();
        ::operator delete(mBuffer);
    }

    // need to make multiple versions of this.
    // variadic templates/Boost.PreProccesor
    // would help immensely. For now, I give
    // two, but it's easy to make more.
    void create(void)
    {
        destroy();
        mObject = new (buffer()) T();
    }

    template &lt;typename A1&gt;
    void create(const A1 pA1)
    {
        destroy();
        mObject = new (buffer()) T(pA1);
    }

    void destroy(void)
    {
        if (exists())
        {
            mObject-&gt;~T();
            mObject = 0;
        }
    }

    void swap(lazy_object&amp; pRhs)
    {
        std::swap(mObject, pRhs.mObject);
        std::swap(mBuffer, pRhs.mBuffer);
    }

    // access
    reference get(void)
    {
        return *get_ptr();
    }

    const_reference get(void) const
    {
        return *get_ptr();
    }

    pointer get_ptr(void)
    {
        assert(exists());
        return mObject;
    }

    const_pointer get_ptr(void) const
    {
        assert(exists());
        return mObject;
    }

    void* buffer(void)
    {
        return mBuffer;
    }

    // query
    const bool exists(void) const
    {
        return mObject != 0;
    }

private:
    // members
    pointer mObject;
    void* mBuffer;
};

// explicit swaps for generality
template &lt;typename T&gt;
void swap(lazy_object&lt;T&gt;&amp; pLhs, lazy_object&lt;T&gt;&amp; pRhs)
{
    pLhs.swap(pRhs);
}

// if the above code is in a namespace, don't put this in it!
// specializations in global namespace std are allowed.
namespace std
{
    template &lt;typename T&gt;
    void swap(lazy_object&lt;T&gt;&amp; pLhs, lazy_object&lt;T&gt;&amp; pRhs)
    {
        pLhs.swap(pRhs);
    }
}

// test use
#include &lt;iostream&gt;

int main(void)
{
    // basic usage
    lazy_object&lt;int&gt; i;
    i.create();
    i.get() = 5;

    std::cout &lt;&lt; i.get() &lt;&lt; std::endl;

    // asserts (not created yet)
    lazy_object&lt;double&gt; d;
    std::cout &lt;&lt; d.get() &lt;&lt; std::endl;
}
</code></pre>

<p>In your case, just create a member in your class: <code>lazy_object&lt;B&gt;</code> and you're done. No manual releases or making copy-constructors, destructors, etc. Everything is taken care of in your nice, small re-usable class. :)</p>

<h3>EDIT</h3>

<p>Removed the need for vector, should save a bit of space and what-not.</p>

<h3>EDIT<sup>2</sup></h3>

<p>This uses <code>aligned_storage</code> and <code>alignment_of</code> to use the stack instead of heap. I used <a href=""http://www.boost.org/doc/libs/1_40_0/libs/type_traits/doc/html/boost_typetraits/reference/aligned_storage.html"" rel=""nofollow"">boost</a>, but this functionality exists in both TR1 and C++0x. We lose the ability to copy, and therefore swap.</p>

<pre><code>#include &lt;boost/type_traits/aligned_storage.hpp&gt;
#include &lt;cassert&gt;
#include &lt;new&gt;

template &lt;typename T&gt;
class lazy_object_stack
{
public:
    // types
    typedef T value_type;
    typedef const T const_value_type;
    typedef value_type&amp; reference;
    typedef const_value_type&amp; const_reference;
    typedef value_type* pointer;
    typedef const_value_type* const_pointer;

    // creation
    lazy_object_stack(void) :
    mObject(0)
    {
    }

    ~lazy_object_stack(void)
    {
        destroy();
    }

    // need to make multiple versions of this.
    // variadic templates/Boost.PreProccesor
    // would help immensely. For now, I give
    // two, but it's easy to make more.
    void create(void)
    {
        destroy();
        mObject = new (buffer()) T();
    }

    template &lt;typename A1&gt;
    void create(const A1 pA1)
    {
        destroy();
        mObject = new (buffer()) T(pA1);
    }

    void destroy(void)
    {
        if (exists())
        {
            mObject-&gt;~T();
            mObject = 0;
        }
    }

    // access
    reference get(void)
    {
        return *get_ptr();
    }

    const_reference get(void) const
    {
        return *get_ptr();
    }

    pointer get_ptr(void)
    {
        assert(exists());
        return mObject;
    }

    const_pointer get_ptr(void) const
    {
        assert(exists());
        return mObject;
    }

    void* buffer(void)
    {
        return mBuffer.address();
    }

    // query
    const bool exists(void) const
    {
        return mObject != 0;
    }

private:
    // types
    typedef boost::aligned_storage&lt;sizeof(T),
                boost::alignment_of&lt;T&gt;::value&gt; storage_type;

    // members
    pointer mObject;
    storage_type mBuffer;

    // non-copyable
    lazy_object_stack(const lazy_object_stack&amp; pRhs);
    lazy_object_stack&amp; operator=(lazy_object_stack pRhs);
};

// test use
#include &lt;iostream&gt;

int main(void)
{
    // basic usage
    lazy_object_stack&lt;int&gt; i;
    i.create();
    i.get() = 5;

    std::cout &lt;&lt; i.get() &lt;&lt; std::endl;

    // asserts (not created yet)
    lazy_object_stack&lt;double&gt; d;
    std::cout &lt;&lt; d.get() &lt;&lt; std::endl;
}
</code></pre>

<p>And there we go.</p>
"
"<p>I've doing some performance analysis on the software I develop, and I've found that lookups on a global dictionary of URL's takes about 10% of the application's ""load"" phase time.  The dictionary is implemented as a C++ STL std::map, which has O(lg n) lookups.  I'm going to move it to a hash_map, which has roughly fixed time lookups.  The stl string class doesn't have a hash code property, and it certainly doesn't cache a hash code.  That means that each lookup requires re-generating the hash code.</p>

<p>I'm skeptical that caching the hash code is worth the effort.  It would mean changing many lines of code to use a new string class with a cached hash code property.  Given that the current implementation does log(n) full string comparisons on every lookup, I think reducing it to basically one string traversal (by the hash function) per lookup is a big win.</p>

<p>Does anyone have experience with caching string hash codes?  Has it ever proven worth the effort?</p>
","87234","","<p>You'll of course need to profile to check your results. Change to a hash map, and then see where most of your time is spent. Unless you're hashing keys left and right, I doubt most of your time will be spent there. Hashing is intended to be a fast operation, otherwise a hash map would have no advantages over an ordered container.</p>

<p>The compiler itself will know if a string hasn't been changed, and can probably cache the result for you (within the same scope). That said, you <em>don't</em> want to inherit from <code>std::string</code>; STL classes weren't made for that.</p>

<p>Rather, make a <code>std::pair</code> and pass that around:</p>

<p><code>std::pair&lt;const std::string, const size_t&gt; string_hash_pair;</code></p>

<p>You'd then need to overload the (going by Boost here, not TR1; I don't know how similar they are) <code>hash_value</code> function for your type, in the same namespace as the pair is defined:</p>

<pre><code>size_t hash_value(const string_hash_pair&amp; pPair)
{
    return pPair.second; // don't actually hash
}
</code></pre>

<p>And that's it. Note that in the pair, both <code>string</code> and <code>size_t</code> are immutable. This is because if the <code>string</code> changes, your hash is wrong. So we make it <code>const</code>, and we may as well make the hash <code>const</code> too.</p>

<p>You'll want a helper function:</p>

<pre><code>string_hash_pair make_string_hash(const std::string&amp; pStr)
{
    return std::make_pair(pStr, boost::hash_value(pStr));
}
</code></pre>

<p>Now if you're going to be using a string for look-ups, just make a pair out of it and you get constant-time hashing.</p>

<p>That said, I really doubt this much work is necessary. Hashing functions really are trivial, usually. Also, <em>don't make your own</em>. Use a pre-existing tried-and-tested hash; it's quite easy to make a crappy hash.</p>
"
"<p>Suppose I have the following snipplet:</p>

<pre><code>Foo foo;
....
return bar();
</code></pre>

<p>Now, does the C++ standard guarantees me that bar() will be called before foo::~Foo() ? Or is this the compiler/implementation's choice?</p>

<p>Thanks!</p>
","87234","","<p><em>Objects destruct when leaving the scope.</em></p>

<p><code>return</code> leaves the scope, but it can't return until it has executed <code>bar()</code>. Ergo, <code>bar()</code> is called.</p>
"
"<p>A recent talk about <code>unordered_map</code> in C++ made me realize, that I should use <code>unordered_map</code> for most cases where I used <code>map</code> before, because of the efficiency of lookup ( <em>amortized O(1)</em> vs. <em>O(log n)</em> ). Most times I use a map I use either <code>int</code>'s or <code>std::strings</code> as keys, hence I've got no problems with the definition of the hash function. The more I thought about it, the more I came to realize that I can't find any reason of using a <code>std::map</code> in case of simple types over a <code>unordered_map</code> -- I took a look at the interfaces, and didn't find any significant differences that would impact my code. </p>

<p>Hence the question - is there any real reason to use <code>std::map</code> over <code>unordered map</code> in case of simple types like <code>int</code> and <code>std::string</code>?</p>

<p>I'm asking from a strictly programming point of view -- I know that it's not fully considered standard, and that it may pose problems with porting. </p>

<p>Also I expect that one of the correct answers might be <em>""it's more efficient for smaller sets of data""</em> because of a smaller overhead (is that true?) -- hence I'd like to restrict the question to cases where the amount of keys is non-trivial (>1 024).</p>

<p><strong>Edit:</strong> <em>duh, I forgot the obvious (thanks GMan!) -- yes, map's are ordered of course -- I know that, and am looking for other reasons.</em></p>
","87234","","<p>Don't forget the <code>map</code>'s keep their elements ordered. If you can't give up that, obviously you can't use an <code>unordered_map</code>.</p>

<p>Something else to keep in mind is that <code>unordered_map</code>'s generally use more memory. A <code>map</code> just has a few house-keeping pointers then memory for each object. Contrarily, <code>unordered_map</code>'s have a big array (these can get quite big in some implementations) and then additional memory for each object. If you need to be memory-aware, a <code>map</code> should prove better, because it lacks the large array.</p>

<p>So, if you need pure lookup-retrieval, I'd say an <code>unordered_map</code> is the way to go. But there are always trade-offs, and if you can't afford them, then you can't use it.</p>

<p>Just from personal experience, I found an enormous improvement in performance (measured, of course) when using an <code>unordered_map</code> isntead of a <code>map</code> in a main entity look-up table.</p>

<p>On the other hand, I found it was much slower at repeatedly inserting and removing elements. It's great for a relatively static collection of elements, but if you're doing tons of insertions and deletions the hashing + bucketing seems to add up. (Note, this was over many iterations.)</p>
"
"<p>Is there an accepted best practice for commenting functions? I only know of the doxygen style but it is not officially supported by C++ like Javadocs is for Java so just wondering what is best.</p>
","87234","","<p>There only general thing most people will agree with is that comments should say ""why"", not ""what"". Other than that, guidelines depend on the coding standards at your place of work.</p>

<p>Personally, I hate doxygen and the like, because it contradicts the first thing I said. The ""documentation"", if it can be called that, is just a prettified header file. And the cost? Nearly duplicated code, obtrusive comments (seriously, it doubles the height of everything), and just a pain.</p>

<p>Your code should be self-documenting: use descriptive names, factor everything into well-defined tasks, etc. The only comments should be things that may need clarification.</p>

<p>For example, an excerpt from a network socket class I wrote:</p>

<pre><code>const bool socket_connected(void) const;
</code></pre>

<p>You already know what this function does; I don't need to explain it. Do I really need to add a big chunk of comment explaining that it returns a boolean (duh) that will indicate of the socket is connected (duh)? No. doxygen is just going to take my header and add some fancy style-sheet to it.</p>

<p>Here's an example where a quick note may be useful (making this class up):</p>

<pre><code>struct fancy_pants
{
    // doesn't transfer ownship, ensure foo stays alive
    fancy_pants(foo&amp;);
};
</code></pre>

<p>Now it's clear I need to make sure the <code>foo</code> I pass it doesn't go out of scope. This didn't require the uglification of my code. If I'm going to write documentation, it should be written by me, describing rationale, intended usage, ""gotcha""'s , examples, etc. Like Boost.</p>

<p>That said, all my headers have a copyright block on the top. I find this is a fantastic place to write a tiny bit of info about the class. For example, <code>is_same.hpp</code>:</p>

<pre><code>/*-------------------------------------------------------
                    &lt;copyright notice&gt;

Determine if two types are the same. Example:

template &lt;typename T, typename U&gt;
void do_something(const T&amp;, const U&amp;, bool flag);

template &lt;typename T, typename U&gt;
void do_something(const T&amp; t, const U&amp; u)
{
    do_something(t, u, is_same&lt;T,U&gt;::value);
}

---------------------------------------------------------*/
</code></pre>

<p>It gives a quick demo at a glance. Anything more, like what I said above, is in a written documentation file.</p>

<p>But you see, I get to make up my code standards for the most part. At companies, you usually have to follow their standard anyway.</p>
"
"<p>I have a function which makes use of memory on the heap and it will go badly wrong if it is called before another instance of the same function has completed.
How can I prevent this from happening at compile time?</p>
","87234","","<p>You cannot do it at compile-time without static analysis. Here is an exception-safe recursive assertion:</p>

<pre><code>#include &lt;cassert&gt;

class simple_lock
{
public:
    simple_lock(bool&amp; pLock):
    mLock(pLock)
    {
        assert(!mLock &amp;&amp; ""recursive call"");
        mLock = true;
    }

    ~simple_lock(void)
    {
        mLock = false;
    }

private:
    simple_lock(const simple_lock&amp;);
    simple_lock&amp; operator=(const simple_lock&amp;);

    bool&amp; mLock;
};

#define ASSERT_RECURSION static bool _lockFlag = false; \
                            simple_lock _lock(_lockFlag)

void foo(void)
{
    ASSERT_RECURSION;

    foo();
}

int main(void)
{
    foo();
    //foo();
}
</code></pre>
"
"<p>I am trying to call a C++ class and its method from a c file.</p>

<p>I google this topic and find this <a href=""http://developers.sun.com/solaris/articles/mixing.html"" rel=""nofollow"">http://developers.sun.com/solaris/articles/mixing.html</a></p>

<p>It says ""</p>

<pre><code>You can write extern ""C"" functions in C++ that access class M objects and call them from C code. Here is a C++ function designed to call the member function foo: 
extern ""C"" int call_M_foo(M* m, int i) { return m-&gt;foo(i); }""
</code></pre>

<p>My question is where do I put the about line? In my c++ .h file? or c .h file?</p>

<p>And it goes on and says ""</p>

<pre><code>Here is an example of C code that uses class M:

struct M; /* you can supply only an incomplete declaration */
int call_M_foo(struct M*, int); /* declare the wrapper function */
int f(struct M* p, int j) /* now you can call M::foo */
    { return call_M_foo(p, j); } ""
</code></pre>

<p>But how/where do I create the class M in my c file? 
And where do I put the above code? c .h file? c++ .h file? or c .c file?</p>

<p>Thank you.</p>

<p>Thank you for GMan's detailed answer.
 I did follow your suggestion. But I get compile error in my .c file.
main.c:33:
./some_class.h:24: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘<strong>attribute</strong>’ before ‘*’ token
./some_class.h:25: error: expected ‘)’ before ‘*’ token
./some_class.h:26: error: expected ‘)’ before ‘*’ token</p>

<p>And here are my some_class.h line 24-26:</p>

<pre><code>#ifdef __cplusplus 
class M {

public:
  M();
  virtual ~M(); 

  void method1(char* name, char* msg);
};
extern ""C"" {
#else
struct M;


#endif

/* access functions line 24-26 are here*/ 
 M* M_new(void);
 void M_delete(M*);
 void M_method1(M*, char*, char*);
#ifdef __cplusplus 
}
#endif
</code></pre>

<p>For some reason, my C compile does not like 'extern ""c"" in GMan's original some_test.h. So I have to modify to above.  It seems like the c compiler does not like/understand the struct M; line</p>

<p>Any idea will be much appreciate.</p>
","87234","","<p>Your header file, which is shared between your C and C++ code:</p>

<pre><code>#ifdef __cplusplus // only actually define the class if this is C++

class some_class
{
    public:
        int some_method(float);
};

#else

// C doesn't know about classes, just say it's a struct
typedef struct some_class some_class; 

#endif

// access functions
#ifdef __cplusplus
    #define EXPORT_C extern ""C""
#else
    #define EXPORT_C
#endif

EXPORT_C some_class* some_class_new(void);
EXPORT_C void some_class_delete(some_class*);
EXPORT_C int some_class_some_method(some_class*, float);
</code></pre>

<p>Then your source file:</p>

<pre><code>#include ""some_foo.h""

int some_class::some_method(float f)
{
    return static_cast&lt;int&gt;(f);
}

// access functions
EXPORT_C some_class* some_class_new(void)
{
    return new some_class();
}

EXPORT_C void some_class_delete(some_class* this)
{
    delete this;
}

EXPORT_C int some_class_some_method(some_class* this, float f)
{
    return this-&gt;some_method(f);
}
</code></pre>

<p>Now compile that source, and link to it. Your C source would be something like:</p>

<pre><code>#include ""some_class.h""

some_class* myInstance = some_class_new();

int i = some_class_some_method(myInstance, 10.0f);

some_class_delete(myInstance);
</code></pre>

<p>If you're serious about mixing C and C++, you'll want macro's.</p>

<hr>

<p>Here are some sample macro's that would make this much easier:</p>

<pre><code>// in something like c_export.h
// extern ""C"" macro
#ifdef __cplusplus
    #define EXPORT_C extern ""C""
#else
    #define EXPORT_C
#endif

// new
#define EXPORT_C_CLASS_NEW(classname) EXPORT_C \
            classname * classname##_new(void)

#define EXPORT_C_CLASS_NEW_DEFINE(classname) \
            EXPORT_C_CLASS_NEW(classname) \
            { return new classname (); }

// repeat as much as you want. allows passing parameters to the constructor
#define EXPORT_C_CLASS_NEW_1(classname, param1) EXPORT_C \
            classname * classname##_new( param1 p1)

#define EXPORT_C_CLASS_NEW_1_DEFINE(classname, param1) \
            EXPORT_C_CLASS_NEW_1(classname, param1) \
            { return new classname (p1); }

// delete
#define EXPORT_C_CLASS_DELETE(classname) EXPORT_C \
            void classname##_delete( classname * this)

#define EXPORT_C_CLASS_DELETE_DEFINE(classname) \
            EXPORT_C_CLASS_DELETE(classname) \
            { delete this; }

// functions
#define EXPORT_C_CLASS_METHOD(classname, methodname, ret) EXPORT_C \
            ret classname##_##methodname##( classname * this)

#define EXPORT_C_CLASS_METHOD_DEFINE(classname, methodname, ret) \
            EXPORT_C_CLASS_METHOD(classname, methodname, ret) \
            { return this-&gt;##methodname##(); }

// and repeat as necessary.
#define EXPORT_C_CLASS_METHOD_1(classname, methodname, ret, param1) EXPORT_C \
            ret classname##_##methodname( classname * this, param1 p1)

#define EXPORT_C_CLASS_METHOD_1_DEFINE(classname, methodname, ret, param1) \
            EXPORT_C_CLASS_METHOD_1(classname, methodname, ret, param1) \
            { return this-&gt;##methodname##(p1); }
</code></pre>

<p>And so on. Our header/source becomes:</p>

<pre><code>// header
#include ""c_export.h"" // utility macros

#ifdef __cplusplus // only actually define the class if this is C++

class some_class
{
    public:
        int some_method(float);
};

#else

// C doesn't know about classes, just say it's a struct
typedef struct some_class some_class; 

#endif

// access functions
EXPORT_C_CLASS_NEW(some_class);
EXPORT_C_CLASS_DELETE(some_class);
EXPORT_C_CLASS_METHOD_1(some_class, some_method, int, float);

// source
#include ""some_foo.h""

int some_class::some_method(float f)
{
    return static_cast&lt;int&gt;(f);
}

// access functions
EXPORT_C_CLASS_NEW_DEFINE(some_class);
EXPORT_C_CLASS_DELETE_DEFINE(some_class);
EXPORT_C_CLASS_METHOD_1_DEFINE(some_class, some_method, int, float);
</code></pre>

<p>And that's much more concise. It could be made simpler (possibly) with variadic macro's, but that's non-standard and I leave that to you. :] Also, you can make macro's for normal non-member functions.</p>

<hr>

<p>Note that C does <em>not</em> know what references are. If you want to bind to a reference, your best bet is probably just to write the export definition manually. (But I'll think about it, maybe we can get it automatically).</p>

<p>Imagine our <code>some_class</code> took the <code>float</code> by (non-const)reference (for whatever reason). We'd define the function like so:</p>

<pre><code>// header
// pass by pointer!                                     v
EXPORT_C_CLASS_METHOD_1(some_class, some_method, int, float*) ;

// source
EXPORT_C_CLASS_METHOD_1(some_class, some_method, int, float*) 
{
    // dereference pointer; now can be used as reference
    return this-&gt;some_method(*p1);
}
</code></pre>

<p>And there we go. C would interface with references with pointers instead:</p>

<pre><code>// c source, if some_method took a reference:
float f = 10.0f;
int i = some_class_some_method(myInstance, &amp;f);
</code></pre>

<p>And we pass <code>f</code> ""by reference"".</p>
"
"<p>I am updating a code base that is 10 years old and used Metrowerks Code Warrior on Mac and Windows.</p>

<p>I am updating to OS X, XCode 3.2, Universal Binary. </p>

<p>I seem to be getting a lot of template related errors and not being a genius on templates (and forgetting to eat a healthy dose of frosted templates for breakfast), I find myself wondering about template portability issues.</p>

<p>IIRC, templates are/or can be compiler specific?</p>

<p>Does anyone have advice or a tutorial on templates that they recommend?</p>
","87234","","<p>Templates themselves have well-defined behavior, as defined in §14 in the standard.</p>

<p>What <em>is</em> implementation-dependent is the limits of template use.  For example, from Annex B (which lists recommended limit minimums):</p>

<ul>
<li>Template arguments in a template declaration [1024].</li>
<li>Recursively nested template instantiations [17].</li>
</ul>

<p>If you're depending on behavior more than these, it may be implementation dependent. It should be noted a compiler does <em>not</em> have to provide these minimal limits to remain standards compliant.</p>

<p>If you post some actual code/errors, we can tell you why you're getting an error. Likely, you're old code used some compiler-specific extensions or otherwise was allowed to use explicitly forbidden behavior.</p>
"
"<pre><code>#include &lt;iostream&gt;
using namespace std;
void main()
{
  int i = 0;
  while (i &lt; 1000)
  {
      int TEMP = i * 2;
      cout &lt;&lt; i &lt;&lt; endl;
      TEMP = i;
      i = i +1;
      // ???
  }

  return;
}
</code></pre>

<p>I'm so confused?? :(</p>
","87234","","<p>The Fibonacci sequence F is <code>F(n) = F(n - 1) + F(n - 2), F(0) = 0, F(1) = 1</code>.</p>

<p>Here's some psuedo-code:</p>

<pre><code>Start Counter1 at 0
Start Counter2 at 1.

For i = 0 to 1000
    New value = Counter1 + Counter2
    Print new value

    Counter2 = Counter1
    Counter1 = New Value
End For
</code></pre>

<p>This doesn't print out 0 or 1; it starts at F(2). You can easily fix this by just printing out 0 and 1 first. Also, this code prints the first 1000 numbers. If you change this to: <code>While Counter1 &lt; 1000</code>, you'll stop when you reach or pass 1000.</p>

<p>It's up to you to implement it, and make sure you understand how it works.</p>
"
"<p>I am creating a simple CLI calculator tool as an exercise. I need to make sure n1 and n2 are numeric in order for the functions to work; consequently, I would like to make the program quit upon coming across a predetermined non-numeric value. </p>

<p>Can anyone give me some direction?</p>

<p>Additionally, if anyone can offer any general tips as to how I could have done this better, I would appreciate it. I'm just learning c++.</p>

<p>Thank you!</p>

<p>The complete code is included below.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;new&gt;

using namespace std;

double factorial(double n) { return(n &lt;= 1) ? 1 : n * factorial(n - 1); }

double add(double n1, double n2) { return(n1 + n2); }

double subtract(double n1, double n2) { return(n1 - n2); }

double multiply(double n1, double n2) { return(n1 * n2); }

double divide(double n1, double n2) { return(n1 / n2); }

int modulo(int n1, int n2) { return(n1 % n2); }

double power(double n1, double n2) {
    double n = n1;
    for(int i = 1 ; i &lt; n2 ; i++) {
        n *= n1;
    }
    return(n);
}

void print_problem(double n1, double n2, char operatr) {
    cout&lt;&lt;n1&lt;&lt;flush;
    if(operatr != '!') {
        cout&lt;&lt;"" ""&lt;&lt;operatr&lt;&lt;"" ""&lt;&lt;n2&lt;&lt;flush;
    } else {
        cout&lt;&lt;operatr&lt;&lt;flush;
    }
    cout&lt;&lt;"" = ""&lt;&lt;flush;
}

int main(void) {

double* n1, * n2, * result = NULL;
char* operatr = NULL;

n1 = new (nothrow) double;
n2 = new (nothrow) double;
result = new (nothrow) double;
operatr = new (nothrow) char;

if(n1 == NULL || n2 == NULL || operatr == NULL || result == NULL) {
    cerr&lt;&lt;""\nMemory allocation failure.\n""&lt;&lt;endl;
} else {

    cout&lt;&lt;""\nTo use this calculator, type an expression\n\tex: 3*7 or 7! or \nThen press the return key.\nAvailable operations: (+, -, *, /, %, ^, !)\n""&lt;&lt;endl;

    do {    
        cout&lt;&lt;""calculator&gt;&gt; ""&lt;&lt;flush;       
        cin&gt;&gt;*n1;

        cin&gt;&gt;*operatr;

        if(*operatr == '!') {
            print_problem(*n1, *n2, *operatr);
            cout&lt;&lt;factorial(*n1)&lt;&lt;endl;
        } else {

            cin&gt;&gt;*n2;

            switch(*operatr) {
                case '+':
                    print_problem(*n1, *n2, *operatr);
                    cout&lt;&lt;add(*n1, *n2)&lt;&lt;endl;
                    break;
                case '-':
                    print_problem(*n1, *n2, *operatr);
                    cout&lt;&lt;subtract(*n1, *n2)&lt;&lt;endl;
                    break;
                case '*':
                    print_problem(*n1, *n2, *operatr);
                    cout&lt;&lt;multiply(*n1, *n2)&lt;&lt;endl;
                    break;
                case '/':
                    if(*n2 &gt; 0) {
                        print_problem(*n1, *n2, *operatr);
                        cout&lt;&lt;divide(*n1, *n2)&lt;&lt;endl;
                    } else {
                        print_problem(*n1, *n2, *operatr);
                        cout&lt;&lt;"" cannot be computed.""&lt;&lt;endl;
                    }
                    break;
                case '%':
                    if(*n1 &gt;= 0 &amp;&amp; *n2 &gt;= 1) {
                        print_problem(*n1, *n2, *operatr);
                        cout&lt;&lt;modulo(*n1, *n2)&lt;&lt;endl;
                    } else {
                        print_problem(*n1, *n2, *operatr);
                        cout&lt;&lt;"" cannot be computed.""&lt;&lt;endl;
                    }
                    break;
                case '^':
                    print_problem(*n1, *n2, *operatr);
                    cout&lt;&lt;power(*n1, *n2)&lt;&lt;endl;
                    break;
                default:
                    cout&lt;&lt;""Invalid Operator""&lt;&lt;endl;
            }
        }
    } while(true);
    delete n1, n2, operatr, result;
}
return(0);
}
</code></pre>
","87234","","<p>What you want to do is read a line of input, or a string, then attempt to convert that line to your numeric form. Boost wraps this in <code>lexical_cast</code>, but you don't need that at all. I've answered a question similar to yours twice, <a href=""http://stackoverflow.com/questions/1243428/convert-string-to-int-with-bool-fail-in-c/1243435#1243435"">here</a> and <a href=""http://stackoverflow.com/questions/1435253/c-syntax-question-if-var-type-int/1435268#1435268"">here</a>. Read those posts to understand what's going on.</p>

<p>Here's the final result:</p>

<pre><code>template &lt;typename T&gt;
T lexical_cast(const std::string&amp; s)
{
    std::stringstream ss(s);

    T result;
    if ((ss &gt;&gt; result).fail() || !(ss &gt;&gt; std::ws).eof())
    {
        throw std::bad_cast();
    }

    return result;
}
</code></pre>

<p>Use it how I outlined in those posts:</p>

<pre><code>int main(void)
{
    std::string s;
    std::cin &gt;&gt; s;

    try
    {
        int i = lexical_cast&lt;int&gt;(s);

        /* ... */
    }
    catch(...)
    {
        /* ... */
        // conversion failed
    }
}
</code></pre>

<p>This uses exceptions. You can make this no-throw like outlined in the links above, by catching the <code>bad_cast</code> exception:</p>

<pre><code>template &lt;typename T&gt;
bool lexical_cast(const std::string&amp; s, T&amp; t)
{
    try
    {
        t = lexical_cast&lt;T&gt;(s);

        return true;
    }
    catch (const std::bad_cast&amp; e)
    {
        return false;
    }
}

int main(void)
{
    std::string s;
    std::cin &gt;&gt; s;

    int i;
    if (!lexical_cast(s, i))
    {
        std::cout &lt;&lt; ""Bad cast."" &lt;&lt; std::endl;
    }   
}
</code></pre>

<p>This is good for making Boost's <code>lexical_cast</code> no-throw, but if you're implementing it yourself, there's no reason to waste time throwing and catching an exception. Implement them in terms of each other, where the throwing version uses the no-throw version:</p>

<pre><code>// doesn't throw, only returns true or false indicating success
template &lt;typename T&gt;
const bool lexical_cast(const std::string&amp; s, T&amp; result)
{
    std::stringstream ss(s);

    return (ss &gt;&gt; result).fail() || !(ss &gt;&gt; std::ws).eof();
}

// throws 
template &lt;typename T&gt;
T lexical_cast(const std::string&amp; s)
{
    T result;
    if (!lexical_cast(s, result))
    {
        throw std::bad_cast(""bad lexical cast"");
    }

    return result;
}
</code></pre>

<hr>

<p>There is more trouble in your code: you're <code>new</code>ing everything! Is there a reason for that? Consider if any part of your code throws an exception: now you jump out of main and leak everything. If you stack allocate your variables, they will be guaranteed to destruct.</p>
"
"<p>For two unrelated classes ""class A"" and ""class B""
and a function </p>

<pre><code>B convert(const A&amp;);
</code></pre>

<p>Is there a way to tell C++ to automatically, for any function that takes ""class B"" as argument, to auto convert a ""class A"".</p>

<p>Thanks!</p>
","87234","","<p>What you would normally do in this case is give <code>B</code> a constructor that takes an <code>A</code>:</p>

<pre><code>class B
{
public:
    B(const A&amp;);
};
</code></pre>

<p>And do the conversion there. The compiler will say ""How can I make <code>A</code> a <code>B</code>? Oh, I see <code>B</code> can be constructed from an <code>A</code>"".</p>

<p>Another method is to use a conversion operator:</p>

<pre><code>class A
{
public:
    operator B(void) const; 
}
</code></pre>

<p>And the compiler will say ""How can I make <code>A</code> a <code>B</code>? Oh, I see <code>A</code> can be converted to <code>B</code>"".</p>

<p>Keep in mind these are very easy to abuse. Make sure it really makes sense for these two types to implicitly convert to each other.</p>
"
"<p>I am fooling around with C++ and const references and am confused why this code works:</p>

<pre><code>#include &lt;iostream&gt;

class A {
public:
    A() : a_(50) {}
    const int&amp; getA() const { return a_; }
private:
    const int a_;
};

int main(int argc, char* argv[])
{
    A* a = new A();
    const int&amp; var = a-&gt;getA();
    std::cout &lt;&lt; var &lt;&lt; std::endl;
    delete a;
    std::cout &lt;&lt; var &lt;&lt; std::endl;
}
</code></pre>

<p>Result:</p>

<pre><code>50
50
</code></pre>

<p>Here are my thoughts:</p>

<p>var stores a reference to a_.<br>
when a is deleted, a_ should also be deleted.<br>
when var is accessed again, it no longer contains a valid reference and a segmentation fault should occur.</p>

<p>Why does this work?  I do not believe I make a temporary copy. </p>
","87234","","<p>The moment you deleted <code>a</code>, accessing <code>var</code> became your door into undefined behavior land.</p>

<p>It's ""working"" by chance. The space where <code>var</code> was one referring to is no longer yours, but you got away with accessing it, this time. It could have resulted in a segmentation fault, returned a number other than 50, or reformatted your hard drive.</p>

<p>Remember, seeming to work is one possible way undefined behavior can manifest itself.</p>
"
"<p>I'm trying to create a named constructor for my class Matrix, with an input as a stream from which I can read the values for the initialization.</p>

<pre><code>#include &lt;istream&gt;
// ...

class Matrix
{
public:
    Matrix(int);
    // some methods
    static Matrix *newFromStream(istream&amp;);

private:
    int n;
    std::valarray&lt; Cell &gt; data;
};
</code></pre>

<p>The method should be implemented more or less like this</p>

<pre><code>Matrix *Matrix::newFromStream(istream &amp;ist) {

    // read first line and determine how many numbers there are
    string s;
    getline( ist, s );
    ...
    istringstream iss( s, istringstream::in);

    int n = 0, k = 0;
    while ( iss &gt;&gt; k)
        n++;
    Matrix *m = new Matrix( n );    

    // read some more values from ist and initialize        

    return m;
}
</code></pre>

<p>However, while compiling, I get an error in the declaration of the method (line 74 is where the prototype is defined, and 107 where the implementation starts)</p>

<pre><code>hitori.h:74: error: expected ‘;’ before ‘(’ token
hitori.cpp:107: error: no ‘Matrix* Matrix::newFromStream(std::istream&amp;)’ member function declared in class ‘Matrix’
</code></pre>

<p>These errors, however, I do not get when defining and implementing a named constructor with a simple parameter, like an int.</p>

<p>What am I missing? Any help would be greatly appreciated.</p>
","87234","","<p><code>istream</code> is in the namespace <code>std</code>:</p>

<pre><code>static Matrix *newFromStream(std::istream&amp;);
</code></pre>

<p>The error indicates it's lost once it gets to <code>istream</code>. Change it in both header and source, of course. A couple notes:</p>

<p>In your header, use <code>&lt;iosfwd&gt;</code> instead of <code>&lt;istream&gt;</code>, and in your source file use <code>&lt;istream&gt;</code>. This is more ""correct"" and may speed up compilation.</p>

<p>Also, do you really want to return newly allocated memory? This is risky and isn't terribly safe. Stack-allocation would be much easier, and maybe even faster.</p>

<p>Lastly, just something to keep in mind: You're very close to having a good <code>operator&lt;&lt;</code>. You can implement it in terms of your current function:</p>

<pre><code>std::istream&amp; operator&lt;&lt;(std::istream&amp; pStream, Matrix&amp; pResult)
{
    // ... book keeping for istream

    pResult = Matrix::from_stream(pStream);

    // ... more book keeping
}
</code></pre>
"
"<p>Is there any way I can access Private member variable of a class?</p>

<p>Editing:
Not from a member function or friend function but through an instance.</p>
","87234","","<p>You could:</p>

<ol>
<li>Place the private members in the public section</li>
<li>Make your class or function a friend of the class.</li>
<li>Provide an accessor to the data.</li>
<li>Take the address of the class, add the offset to that variable, cast, and dereference. (Yuck)</li>
</ol>

<p>What are you trying to do? If something is private, don't mess with it. It's private for a reason.</p>
"
"<p>This is more of a theory question, then any actual code.
I understand that if you declare a variable
int i; then it sets aside 4 bytes in memory for the integer i.
I understand if you use malloc to create your memory as well.</p>

<p>I am curious how memory is handled when you do something like</p>

<pre><code>int x;
int y;
double z;

z = (float)x/(float)y;
</code></pre>

<p>When you cast like this, how is the memory handled. Does the program create  floats and store x and y and then do the division? Or is it something outside of memory?</p>

<p>Thanks for any explanation!</p>
","87234","","<p>It's of course completely implementation dependent, and platform-specific. By the way, <code>sizeof(int)</code> isn't necessarily 4 like you say.</p>

<p>For your code, one possible output might be (off the top of my head):</p>

<pre><code>fild [x] // load x from the stack into a register
fidiv [y] // divide by y loaded from the stack
fstp [z] // store the result in z
</code></pre>

<p>This would be on a processor with an FPU.</p>
"
"<p>I'd like to package a library I'm working on as a header-only library to make it easier for clients to use. (It's small and there's really no reason to put it into a separate translation unit) However, I cannot simply put my code in headers because this violates C++'s one definition rule. (Assuming that the library header is included in multiple translation units of a client project)</p>

<p>How does one modify a library to make it header-only?</p>
","87234","","<p>You can use the <code>inline</code> keyword:</p>

<pre><code>// header.hpp (included into multiple translation units)

void foo_bad() {} // multiple definitions, one in every translation unit :(

inline void foo_good() {} // ok :)
</code></pre>

<p><code>inline</code> allows the linker to simply pick one definition and discard the rest.</p>

<p>(As such, if those definitions don't actually match, you get a good dose of undefined behavior...!)</p>

<hr>

<p>As an aside, member functions defined within a class-type, are implicitly marked <code>inline</code>:</p>

<pre><code>struct myclass
{
    void i_am_inline_implicitly()
    {
        // because my definition is here
    }

    void but_i_am_not();
    void neither_am_i();
};

inline void myclass::but_i_am_not()
{
    // but that doesn't mean my definition cannot be explicitly inline
}

void myclass::neither_am_i()
{
    // but in this case, no inline for me :(
}
</code></pre>
"
"<p>I love declaring variables on the stack, especially when using the standard container. Each time you avoid a <code>new</code>, you avoid a potential memory leak.</p>

<p>I also like using polymorphism, ie class hierarchies with virtual functions. However, it seems these features are a bit incompatible: you can't do:</p>

<pre><code>std::vector&lt;BaseType&gt; vec;
vec.push_back(DerivedType())
</code></pre>

<p>or at least it seems you would lose the polymorphic nature of the object you push in.</p>

<p>So, is there any way to reconcile stack-based memory management and the use of virtual functions?</p>
","87234","","<p>Well the obvious answer:</p>

<pre><code>std::vector&lt;BaseType*&gt; vec;
DerivedType d;
vec.push_back(&amp;d);
</code></pre>

<p>But probably not what you intended. <code>d</code> and <code>vec</code> better die at the same time; if <code>vec</code> outlives <code>d</code> you've got a bad pointer.</p>

<p>I think what you really want is something like Boost <a href=""http://www.boost.org/doc/libs/1_42_0/libs/ptr_container/doc/ptr_container.html"" rel=""nofollow"">pointer containers</a>:</p>

<pre><code>boost::ptr_vector&lt;BaseType&gt; vec;
vec.push_back(new DerivedType());
</code></pre>

<p>So you don't have to worry about leaks. The pointer containers were made specifically for the task of easing use and storage of polymorphic objects.</p>
"
"<p>I was told the reference variable must be initialized in the initialization list, but why this is wrong?</p>

<pre><code>   class Foo
    {
    public: 
        Foo():x(0) {      
         y = 1;
        }
    private:
        int&amp; x;
        int y;
    };
</code></pre>

<p>Because 0 is a temporary object? If so, what kind of object can reference be bound? The object which can take an address?</p>

<p>Thanks!</p>
","87234","","<p>0 is not an lvalue, it's an rvalue. You cannot modify it, but you're trying to bind to a reference where it could be modified.</p>

<p>If you make your reference <code>const</code>, it will work as expected. Consider this:</p>

<pre><code>int&amp; x = 0;
x = 1; // wtf :(
</code></pre>

<p>This obviously is a no-go. But <code>const&amp;</code>'s can be bound to temporaries (rvalues):</p>

<pre><code>const int&amp; x = 0;
x = 1; // protected :) [won't compile]
</code></pre>

<p>Note that the life-time of the temporary is ended at the completion of the constructor. If you make static-storage for your constant, you'll be safe:</p>

<pre><code>class Foo
{
public:
    static const int Zero = 0;

    Foo() : x(Zero) // Zero has storage
    {
        y = 1;
    }
private:
    const int&amp; x;
    int y;
};
</code></pre>
"
"<p>I have two classes and both of them uses some of the other class, on example:</p>

<pre><code>// class1.h
class Class1;
#include ""class2.h""

class Class1 {
  public:
  static Class2 *C2;
  ...
};

// class2.h
class Class2;
#include ""class1.h""

class Class2 {
  public:
  static Class1 *C1;
  ...
};
</code></pre>

<p>And when I define it like in example above, it works (I also have some <code>#ifndef</code> to avoid infinite header recurency). But I also want to add some inline functions to my classes. And I read <a href=""http://www.parashift.com/c++-faq-lite/inline-functions.html"" rel=""nofollow"">here</a> that I should put definition of inline function in header file, because it won't work if I'll put them in cpp file and want to call them from other cpp file (when I do it I get undefined reference during linking). But the problem here is with something like this:</p>

<pre><code>// class1.h
...
inline void Class1::Foo() {
  C2-&gt;Bar();
}
</code></pre>

<p>I get error: invalid use of incomplete type ‘struct Class2’.</p>

<p>So how can I do it?</p>
","87234","","<p>You have it mix'd up. What you want is:</p>

<pre><code>// class1.h
class Class2;

class Class1 {
  public:
  static Class2 *C2;
  ...
};

// class2.h
class Class1;

class Class2 {
  public:
  static Class1 *C1;
  ...
};
</code></pre>

<p>And include the respective headers in the source. The line:</p>

<pre><code>class Class1; // or Class2
</code></pre>

<p>Declares an <em>incomplete type</em>, and you can have pointers and references to incomplete types. Upon usage, though, it needs to be complete. So just say ""hey it'll exist!"" in the header, and in the source tell it what it is.</p>
"
"<p>I'm trying to initialize a list to random integers using a for_each and a lambda function. I'm new to boost.lambda functions so I may be using this incorrectly but the following code is producing a list of the same numbers. Every time I run it the number is different but everything in the list is the same:</p>

<pre><code>srand(time(0));

theList.resize(MaxListSize);

for_each(theList.begin(), theList.end(), _1 = (rand() % MaxSize));
</code></pre>
","87234","","<p>Boost lambda will evaluate <code>rand</code> before the functor is made. You need to <code>bind</code> it, so it's evaluated at lambda evaluation time:</p>

<pre><code>#include &lt;boost/lambda/lambda.hpp&gt;
#include &lt;boost/lambda/bind.hpp&gt; // for bind
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    namespace bl = boost::lambda;
    typedef std::vector&lt;int&gt; int_vec;

    static const size_t MaxListSize = 10;
    static const int MaxSize = 20;

    int_vec theList;
    theList.resize(MaxListSize);

    std::srand(static_cast&lt;unsigned&gt;(std::time(0)));
    std::for_each(theList.begin(), theList.end(),
                    bl::_1 = bl::bind(std::rand) % MaxSize);

    std::for_each(theList.begin(), theList.end(), std::cout &lt;&lt; bl::_1 &lt;&lt; ' ' );
}
</code></pre>

<p>This works as expected.</p>

<p>However, the <em>correct</em> solution is to use <code>generate_n</code>. Why make a bunch of 0's just to overwrite them?</p>

<pre><code>#include &lt;boost/lambda/lambda.hpp&gt;
#include &lt;boost/lambda/bind.hpp&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    namespace bl = boost::lambda;
    typedef std::vector&lt;int&gt; int_vec;

    static const size_t MaxListSize = 10;
    static const int MaxSize = 20;

    int_vec theList;
    theList.reserve(MaxListSize); // note, reserve

    std::srand(static_cast&lt;unsigned&gt;(std::time(0)));
    std::generate_n(std::back_inserter(theList), MaxListSize,
                        bl::bind(std::rand) % MaxSize);

    std::for_each(theList.begin(), theList.end(), std::cout &lt;&lt; bl::_1 &lt;&lt; ' ' );
}
</code></pre>
"
"<p>In the unit test of a class, I try to declare a class variable by calling explicitly the empty constructor and pass it to a function that excepts a reference to the interface of the type I'm declaring, but the compiler produces error.  When I just declare it without any explicit constructor call the function accepts it.</p>

<p>See the code below:</p>

<pre><code>//classundertest.h
class IController;

class CClassUnderTest
{
public:
    CClassUnderTest() {}
    virtual ~CClassUnderTest() {}

    unsigned int Run(IController &amp; controller);
};

//testclassundertest.h
#include ""UnitTest++.h""

#include ""classundertest.h""
#include ""icontroller.h""

class CTestController : public IController
{
public:
    CTestController() : IController() {}
    virtual ~CTestController() {}

    virtual void Play(unsigned int i) {}
};

struct CClassUnderTestFixture
{
    CClassUnderTest classUnderTest;
};

TEST_FIXTURE(CClassUnderTestFixture, RunTest)
{
    CTestController controllerA;   

    CHECK_EQUAL(classUnderTest.Run(controllerA), 105U);

    CTestController controllerB();   

    CHECK_EQUAL(classUnderTest.Run(controllerB), 105U);
}
</code></pre>

<p>The compiler believes controllerB is the reference of the constructor:</p>

<blockquote>
  <p>error: no matching function for call to `CClassUnderTest::Run(CTestController (&amp;)())'
  error: candidates are: unsigned int CClassUnderTest::Run(IController&amp;)</p>
</blockquote>

<p>I'm confused by why the compiler won't allow me to call the constructor when instantiating controllerB, especially when the production code seems okay with this?</p>
","87234","","<p>This line:</p>

<pre><code>CTestController controllerB();
</code></pre>

<p>is the declaration of a function that takes nothing and returns a <code>CTestController</code>. For default construction, you must simply leave off the parenthesis.</p>

<p>This is related to something called the ""most vexing parse"". Consider:</p>

<pre><code>struct S {};

int main()
{
    S s(S()); // copy construct a default-constructed S ...?
}
</code></pre>

<p>This doesn't work. This declares <code>s</code> as a function that takes a pointer to a function that takes nothing and returns an S, that returns an S. To fix this, you can use an extra set of parenthesis:</p>

<pre><code>struct S {};

int main()
{
    S s((S())); // copy construct a default-constructed S :)
}
</code></pre>
"
"<p>I'm trying to change the integer values in a vector using transform and an if_then_else control structure from Boost Lambda. However my compiler is not appreciating my efforts. The code I am attempting is:</p>

<pre><code>transform(theVec.begin(), theVec.end(), theVec.begin(), 
          if_then_else(bind(rand) % ratio == 0, _1 = bind(rand) % maxSize, _1));
</code></pre>

<p>I tried simplifying it to the following:</p>

<pre><code>transform(theVec.begin(), theVec.end(), theVec.begin(),
          if_then_else(0 == 0, _1 = MaxIntSizeCFG, _1));
</code></pre>

<p>but the compiler tells me: no matching function for call to 'if_then_else(..........'
I read that the return values from control structures is void, so is my attempted usage in this case entirely wrong?</p>

<p>Thanks in advance for your time!</p>
","87234","","<p><code>if_then_else</code> in your usage is incorrect, in the same way this is:</p>

<pre><code>int i = if (some_condition){ 0; } else { 1; };
</code></pre>

<p>What you want is merely the ternary operator; however, this won't work in a lambda. You can simulate this with the the <code>if_then_else_return</code> structure instead. (i.e., you were close!) </p>

<p>The <code>if_then_else</code> is for something like a <code>for_each</code> loop, where you'd take one action or the other depending on a condition. The <code>if_then_else_return</code> is for a ternary conditional.</p>
"
"<p>I have 3 classes. In it's simplest form, it looks like,</p>

<pre><code>class tree
{
public:
    tree_node* find_node(const std::string&amp; text) {
       return factory.find(text);
    }
private:
    tree_node_factory factory;
}

class tree_node
{
public:
    tree_node(const std::string&amp; text) : text_(text) {}

    const std::string&amp; text() const {
       return text_;
    }

    void set_parent(const tree_node* new_parent);

private:
    std::string text_;
}

class tree_node_factory
{
public:
    tree_node* find(const std::string&amp; text);
private:
    std::vector&lt;tree_node*&gt; allocated_nodes;
}
</code></pre>

<p>I don't want to allow users of <code>tree</code> to modify the <code>tree_node</code> returned by methods like <code>find_node</code>. So I changed, <code>find_node</code> and <code>tree_node_factory::find</code> to,</p>

<pre><code>const tree_node* find_node(const std::string&amp; text) const {
    return factory.find(text);
}

const tree_node* find(const std::string&amp; text) const;
</code></pre>

<p>Problem is <code>tree</code> internally should be able to modify the nodes and work on methods like <code>set_parent</code>. But since factory returns only <code>const</code> nodes, I ended up with adding another overload (non const version) of <code>find</code> into the factory.</p>

<pre><code>tree_node* find(const std::string&amp; text);
</code></pre>

<p>I am wondering is this the correct way to handle these kind of problems? I see the code is getting duplicated in the const and non-const versions.</p>

<p>Any thoughts..?</p>
","87234","","<p>Item 3 in Scott Meyers' book <em>Effective C++</em> demonstrates a method to remove this code duplication. Basically, in your non-const function you will add const to <code>this</code>, call the const version, then cast the const away. This is safe; though writing to a const-variable leads to undefined behavior, because <code>this</code> was originally non-const it's okay.</p>

<p>Example:</p>

<pre><code>const std::string&amp; operator[](size_t index) const
{
    // some other code

    // since `this` isn't really const, this is modifiable 
    return mData[index]; 
}

std::string&amp; operator[](size_t index)
{
    return const_cast&lt;std::string&amp;&gt; // (3) take const off result
            (static_cast&lt;const my_type&amp;&gt; // (1) add const
            (*this)[index]); // (2) use const version

}
</code></pre>

<p>Normally it would all be on one line. You can also make a utility for it.</p>

<p>Note a caveat: if the const version returns a ""real"" const object, this method clearly results in undefined behavior. The constness of the return value must be reflected by the constness of the object referred to by <code>this</code>. This is broken code:</p>

<pre><code>const std::string&amp; operator[](size_t index) const
{
    static const std::string constString = ""Don't modify me."";

    if (index == 0)
    {
        // even though `this` isn't really const, this is NOT modifiable
        return constString; 
    }

    return mData[index - 1];
}

std::string&amp; operator[](size_t index)
{
    return const_cast&lt;std::string&amp;&gt; // (3) !!! take const off result !!!
            (static_cast&lt;const my_type&amp;&gt; // (1)
            (*this)[index]); // (2)

}
</code></pre>

<p>In practice, we avoid global state so this is rarely an issue. It's trivial to check, anyway.</p>
"
"<p>I'm writing a math library as a practical exercise. I've run into some problems when overloading the = operator. When I debuged it, I noticed that the call to vertex1 = vertex2 calls the copy constructor instead. </p>

<p>In the header file I have:</p>

<pre><code>//constructors
vector3();
vector3( vector3 &amp;v );
vector3(float ix, float iy, float iz);

//operator overloading
vector3 operator =(vector3 p);
....
</code></pre>

<p>In the source file I implemented:</p>

<pre><code>vector3 vector3::operator =(vector3 p)
{
    vector3 v3;
    v3.x = p.x;
    v3.y = p.y;
    v3.z = p.z;
    return v3;
}
</code></pre>

<p>Later on I have a crossproduct method, and I want to use it like so:</p>

<pre><code>vector3 v3;
v3 = v1.crossProduct(v2);
</code></pre>

<p>The error message is:
    error: no matching function for call to `vector3::vector3(vector3)'
but I do not want to call the copy constructor.</p>
","87234","","<p>There are mistakes in your code. Your copy-constructor must take a <code>const&amp;</code>. The reference will avoid making a copy (which you wouldn't be able to do, being the copy-constructor), and it should be <code>const</code> since you're not modifying it:</p>

<pre><code>vector3(const vector3&amp;);
</code></pre>

<p>Temporary variables can be bound to <code>const&amp;</code>, but <em>cannot</em> be bound to a mutable reference. That is, with your code you could do:</p>

<pre><code>vector3 a;
vector3 b(a);
</code></pre>

<p>but not:</p>

<pre><code>vector3 a(some_calculation()); // some_calculation returns a vector3
</code></pre>

<p>Additionally, your <code>operator=</code> is incorrect. Like the copy-constructor, it should generally take a <code>const&amp;</code>, <em>but it should return a reference to <code>this</code></em>. That's how chaining works:</p>

<pre><code>int a, b, c;
a = b = c = 0;
// a.operator=(b.operator=(c.operator=(0)));
</code></pre>

<p>Returning a temporary is unorthodox, and doesn't accomplish anything. In your case, you could assign over and over and never change the value. <strong>Weird</strong>:</p>

<pre><code>vector 3 a, b;
a = b; // doesn't change a...?!
</code></pre>

<p><code>operator=</code> needs to change <code>this</code>.</p>
"
"<p>Well, I'm trying to avoid using the deprecated DirectInput.</p>

<p>But I need, at each ""frame"" or ""iteration"" of the game to <b>snatch ALL KEY STATES so that I can act accordingly</b>.  For example, if the player is down on the VK_RIGHT key then he will move just a smidgen right on that frame.</p>

<p>The problem with WM_INPUT messages is they can appear an unpredictable number of times per frame, because of the way the game loop is written:</p>

<pre>
    MSG message ;
    while( 1 )
    {
        if( PeekMessage( &message, NULL, 0, 0, PM_REMOVE ) )
        {
            if( message.message == WM_QUIT )
            {
                break ;  // bail when WM_QUIT
            }

            TranslateMessage( &message ) ;
            DispatchMessage( &message ) ;
        }
        else
        {
            // No messages, so run the game.
            Update() ;
            Draw() ;
        }
    }

</pre>

<p>So if <em>more than one</em> WM_INPUT message is stacked there then they will all get processed before Update()/Draw().</p>

<p>I resolved this issue by using an array of BOOL to remember what keys were down:</p>

<pre>

    bool array_of_keys_that_are_down[ 256 ] ;

    case WM_INPUT :
        if( its keyboard input )
        {
            array_of_keys_that_are_down[ VK_CODE ] = TRUE ;
        }

</pre>

<p>That works fine because the Update() function checks</p>

<pre>

    void Update()
    {
        if( array_of_keys_that_are_down[ VK_RIGHT ] )
        {
            // Move the player right a bit
        }
    }
</pre>

<p>BUT the problem is now that WM_INPUT messages <em>don't get generated <b>often</b> enough</em>.  There's a delay of about 1 second between the first press of VK_RIGHT and subsequent VK_RIGHT messages, even if the player had his finger down on it the whole time.  Its not like DirectInput where you can <code>keyboard-&gt;GetDeviceState( 256, (void*)array_of_keys_that_are_down );</code> (snatch out all key states each frame with a single call)</p>

<p>So I'm lost.  Other than resorting to GetAsyncKeystate() function calls for each key I need to monitor, I see no way to avoid using DirectInput if you can't snatch out all key states each frame reliably.</p>

<p>It seems to me that DirectInput was a <em>very good solution</em> to this problem, but if it was deprecated, then there really must be some way to do this conveniently using Win32 api only.</p>

<p>Currently <code>array_of_keys_that_are_down</code> gets reset back to all FALSE's every frame.</p>

<pre>
    memset( array_of_keys_that_are_down, 0, sizeof( array_of_keys_that_are_down ) ) ;
</pre>

<h2>*EDIT</h2>

<p>I've been working on this problem and <em>one solution</em> is to only reset a key state, once its been released</p>

<pre>
    case WM_INPUT :
        if( its keyboard input )
        {
            if( its a down press )
                array_of_keys_that_are_down[ VK_CODE ] = TRUE ;
            else
                array_of_keys_that_are_down[ VK_CODE ] = FALSE ;
        }
</pre>

<p>I don't like this solution though because it seems <em>flimsy</em>.  If the user switches away from the application while down on a key, then that key will be ""stuck"" until he switches back and presses that same key again because we'll never get the upstroke <b>WM_INPUT</b> message.  It makes for weird ""sticky key"" bugs.</p>
","87234","","<p>You can use <a href=""http://msdn.microsoft.com/en-us/library/ms646299%28VS.85%29.aspx"" rel=""nofollow""><code>GetKeyboardState</code></a> instead. What you generally want is two arrays; one stores the previous frames' input state, and one stores the current. This allows things like differentiating between being held and being triggered.</p>

<pre><code>// note, cannot use bool because of specialization
std::vector&lt;unsigned char&gt; previous(256);
std::vector&lt;unsigned char&gt; current(256);

// in update_keys or similar:
current.swap(previous); // constant time, yay
GetKeyboardState(&amp;current[0]); // normally do error checking
</code></pre>

<p>And you're done.</p>
"
"<p>I'm trying to do a double-loop over a std::list to operate on each pair of elements. However, I'm having some trouble initialising the second iterator. The code I'd like to write is:</p>

<pre><code>for(std::list&lt;int&gt;::iterator i = l.begin(); i != l.end(); ++i) {
    for(std::list&lt;int&gt;::iterator j = i+1; j != l.end(); ++j) {
        ...
    }
}
</code></pre>

<p>That doesn't work because list iterators aren't random-access, so you can't do +1. But I'm having some trouble finding a neat alternative; the compiler doesn't seem to be very happy with <code>std::list&lt;int&gt;::iterator j(i)++;</code> which I had some hope for. Achieving what I want seems like I'm going to have to have some awkward extra increment which won't fit the structure of the for loop nicely.</p>

<p>There are obvious alternatives (using a vector, for example!) but it seems to me that there should be some reasonably neat way of doing this which I'm just not seeing at the moment.</p>

<p>Thanks in advance for any help :)</p>
","87234","","<p>I'm just going off the idea I had in dirkgently's answer:</p>

<pre><code>template &lt;typename Iter, typename Dist&gt;
Iter advance_copy(Iter pIter, const Dist&amp; pOffset)
{
    std::advance(pIter, pOffset);

    return pIter;
}

// ...

typedef std::list&lt;int&gt; int_list;

for(int_list::iterator i = l.begin(); i != l.end(); ++i)
{
    for(int_list::iterator j = advance_copy(i, 1); j != l.end(); ++j)
    {
    }
}
</code></pre>

<p>You can make another class of utility functions too, to help make it concise:</p>

<pre><code>// for consistency,
template &lt;typename Iter&gt;
void increment(Iter&amp; pIter)
{
    ++pIter;
}

template &lt;typename Iter&gt;
Iter increment_copy(Iter pIter)
{
    return ++pIter;
}

// ...

typedef std::list&lt;int&gt; int_list;

for(int_list::iterator i = l.begin(); i != l.end(); ++i)
{
    for(int_list::iterator j = increment_copy(i); j != l.end(); ++j)
    {
    }
}
</code></pre>
"
"<p>i'm trying to use boost regex within my program
the problem is i get this error...
the only installation step i did was to add: ""C:\Program Files\boost\boost_1_42""
into the Additional Include Directories...</p>

<p>i'm using VS2008...</p>

<p>trying to implement this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;boost/regex.hpp&gt;

using namespace std;

int main( ) {

   std::string s, sre;
   boost::regex re;
   boost::cmatch matches;

   while(true)
   {
      cout &lt;&lt; ""Expression: "";
      cin &gt;&gt; sre;
      if (sre == ""quit"")
      {
         break;
      }

      cout &lt;&lt; ""String:     "";
      cin &gt;&gt; s;

      try
      {
         // Assignment and construction initialize the FSM used
         // for regexp parsing
         re = sre;
      }
      catch (boost::regex_error&amp; e)
      {
         cout &lt;&lt; sre &lt;&lt; "" is not a valid regular expression: \""""
              &lt;&lt; e.what() &lt;&lt; ""\"""" &lt;&lt; endl;
         continue;
      }
      // if (boost::regex_match(s.begin(), s.end(), re))
      if (boost::regex_match(s.c_str(), matches, re))
      {
         // matches[0] contains the original string.  matches[n]
         // contains a sub_match object for each matching
         // subexpression
         for (int i = 1; i &lt; matches.size(); i++)
         {
            // sub_match::first and sub_match::second are iterators that
            // refer to the first and one past the last chars of the
            // matching subexpression
            string match(matches[i].first, matches[i].second);
            cout &lt;&lt; ""\tmatches["" &lt;&lt; i &lt;&lt; ""] = "" &lt;&lt; match &lt;&lt; endl;
         }
      }
      else
      {
         cout &lt;&lt; ""The regexp \"""" &lt;&lt; re &lt;&lt; ""\"" does not match \"""" &lt;&lt; s &lt;&lt; ""\"""" &lt;&lt; endl;
      }
   }
}
</code></pre>

<p>what seems to be the problem ? any additional settings should be made ?</p>
","87234","","<p>Some Boost libraries have to be built; this is one of them. Here's how you can build them:</p>

<p>Make a new file called <code>boost_build.bat</code>, and inside put:</p>

<pre><code>bjam toolset=msvc-9.0 variant=release threading=multi link=static define=_SECURE_SCL=0 define=_HAS_ITERATOR_DEBUGGING=0
bjam toolset=msvc-9.0 variant=debug threading=multi link=static
</code></pre>

<p>Note 9.0 refers to VS 2008. (10.0 for 2010, 8.0 for 2005, 7.1 for 2003, 6.0 for, well, 6.0). Once you've done this:</p>

<ol>
<li><p>Extract <code>build_boost.bat</code> to <code>&lt;boost_root&gt;</code></p></li>
<li><p>Go to:
<code>&lt;boost_root&gt;\tools\jam</code>
And run <code>build_dist.bat</code></p></li>
<li><p>Copy <code>&lt;boost_root&gt;\tools\jam\stage\bin.ntx86\bjam.exe</code> to <code>&lt;boost_root&gt;</code></p></li>
<li><p>Run <code>boost_build.bat</code></p></li>
<li><p>Libraries are located in <code>&lt;boost_root&gt;\stage\lib</code></p></li>
</ol>

<p>Note, this is my own method. I would <em>love</em> if someone chimed in an easier way, or some link from Boost; it seems it's difficult to find proper build instructions from Boost.</p>

<p>Once it's built, make sure you let the compiler know where the libraries are in your VC Directories (the Library Paths); add ""<code>&lt;boost_root&gt;\stage\lib</code>"".</p>

<hr>

<p>In the <code>bjam</code> defines, I have <code>_SECURE_SCL=0</code> <code>_HAS_ITERATOR_DEBUGGING=0</code> for Release. This disables all iterator checking in Release builds, for a speed improvement.</p>
"
"<p>I made a small program with Boost in Linux 2 yrs ago. Now I want to make it work in Windows. I found there are few .a files in my libs folder. I am wondering how to make it works in Windows? do I need to build Boost in Windows to get library or I can download somewhere? I am using Visual Studio 6. </p>
","87234","","<p>Yes, you'll need to recompile for different platforms. Coincidentally, I posted instructions on this <a href=""http://stackoverflow.com/questions/2274188/fatal-error-lnk1104-cannot-open-file-libboost-regex-vc90-mt-gd-1-42-lib/2274252#2274252"">not long ago</a>.</p>

<p>I <em>hugely</em> recommend you <em>do not</em> use Visual Studio 6. It's very dated, and terribly non-conforming. You can get the newer versions for free, as Express. You won't be missing anything.</p>
"
"<p>Suppose I have:</p>

<pre><code>void foo() {
  static Bar bar;
}
</code></pre>

<p>Does c++ guarantee me that Bar::Bar() is called on bar, and Bar::~Bar() is never called on bar? (Until after main exits).</p>

<p>Thanks!</p>
","87234","","<p>Yes. The first time <code>foo()</code> is called, <code>Bar bar</code> will be constructed. It will then be available until <code>main()</code> finishes, after which point it will be destructed.</p>

<p>It's essentially:</p>

<pre><code>static Bar *bar = 0;
if (!bar)
{
    bar = new Bar;

    // not ""real"", of course
    void delete_bar(void) { delete bar; }
    atexit(delete_bar);
}
</code></pre>

<p>Note I said ""essentially""; this probably isn't what actually happens (though I don't think it's too far off).</p>

<hr>

<blockquote>
  <p>3.7.1 Static storage duration<br>
  1 All objects which neither have dynamic storage duration nor are local have static storage duration. The storage for these objects shall last for the duration of the program (3.6.2, 3.6.3).</p>
</blockquote>
"
"<p>I have the following constructor:</p>

<pre><code> TCPConnector(int32_t fd, string ip, uint16_t port,
            vector&lt;uint32_t&gt;&amp; protocolChain, const Variant&amp; customParameters)
    : IOHandler(fd, IOHT_TCP_CONNECTOR) {
        _ip = ip;
        _port = port;
        _protocolChain = protocolChain;
        _closeSocket = true;
        _customParameters = customParameters;
    }
</code></pre>

<p>And I wanted to know whether or not a string (i.e. _ip) can be assigned safely within the constructor without explicitly initializing it?</p>
","87234","","<p><code>std::string</code> has <a href=""http://www.cplusplus.com/reference/string/string/string/"" rel=""nofollow"">several constructors</a>. In your case, it's default constructed (to """"), then is assigned a new value.</p>

<p>Consider placing it (and your other variables) into the initialization list:</p>

<pre><code>: _ip(ip) ...
</code></pre>
"
"<p>I am porting a project to the iPhone and it uses realloc and memcpy which are not found. What is the header to include?
it's a projet mixing objc and c++ and I am starting to be lost.</p>

<p>Thanks in advance for your help!</p>
","87234","","<p>In C:</p>

<pre><code>#include &lt;string.h&gt; // memcpy
#include &lt;stdlib.h&gt; //realloc
</code></pre>

<p>In C++, remove the <code>.h</code> and prefix with a <code>c</code>. In C++, they will be placed in the <code>std</code> namespace, but are also global.</p>
"
"<p>I have 10 files need to be open for write in sequence. Can I have one fstream to do this? Do I need to do anything special (except flush()) in between each file or just call <code>open(file1, fstream::out | std::ofstream::app)</code> for a each file and close the stream at the end of all 10 files are written. </p>
","87234","","<p>You will need to close it first, because calling <code>open</code> on an already open stream fails. (Which means the <code>failbit</code> flag is set to true). Note <code>close()</code> flushes, so you don't need to worry about that:</p>

<pre><code>std::ofstream file(""1"");
// ...
file.close();
file.clear(); // clear flags
file.open(""2"");
// ...

// and so on
</code></pre>

<p>Also note, you don't need to <code>close()</code> it the last time; the destructor does that for you (and therefore also <code>flush()</code>'s). This may make a nice utility function:</p>

<pre><code>template &lt;typename Stream&gt;
void reopen(Stream&amp; pStream, const char * pFile,
            std::ios_base::openmode pMode = ios_base::out)
{
    pStream.close();
    pStream.clear();
    pStream.open(pFile, pMode);
}
</code></pre>

<p>And you get:</p>

<pre><code>std::ofstream file(""1"");
// ...
reopen(file, ""2"")
// ...

// and so on
</code></pre>
"
"<p>I have the following C formula</p>

<pre><code>bucket = (hash - _min) * ((_capacity-1) / range());
</code></pre>

<p>What I need to to rearrange the equation to return the _capacity instead of bucket (I have all other variables apart from _capacity). e.g.</p>

<pre><code>96 = (926234929-805306368) * (( x -1) /1249540730)
836 = (1852139639-805306368) * ((x -1) /1249540730)
</code></pre>

<p>As you can see it's a fairly simple equation, all I need is x on the left. But my algebra is very rusty, so any help appreciated.</p>
","87234","","<pre><code>capacity = (range() * bucket) / (hash - _min) + 1;
</code></pre>

<hr>

<pre><code>bucket = (hash - _min) * ((_capacity - 1) / range()); // start
bucket = ((hash - _min) * (_capacity - 1)) / range(); // rearrange
range() * bucket = (hash - _min) * (_capacity - 1); // multiply by range
(range() * bucket) / (hash - _min) = _capacity - 1; // divide by (hash - _min)
(range() * bucket) / (hash - _min) + 1 = _capacity; // add 1
capacity = (range() * bucket) / (hash - _min) + 1; // rearrange
</code></pre>
"
"<p>I have a strange problem with my code when porting from a computer with glibc-2.5-25 (suse 10.2) to a computer with glibc-2.3.2-6 (suse 8.2). I use several method calls on temporary objects and they are not working on the older machine.</p>

<pre><code>class A
{
public:
    A(int n) {}
    void method() {}
};

int main()
{
    A(10).method(); //here the compiler gives parse error before . 

    A a(10);
    a.method(); //this works fine 
}
</code></pre>

<p>Could this really happen because of the older libc version or it might be a setting in my IDE (compiler setting)?</p>
","87234","","<p>This seems to be a compiler bug: <a href=""http://gcc.gnu.org/ml/gcc-bugs/1998-10/msg00178.html"" rel=""nofollow"">http://gcc.gnu.org/ml/gcc-bugs/1998-10/msg00178.html</a> (older version, same bug). A workaround with identical semantics would be something like:</p>

<pre><code>#define TEMP(T, x, y) { T _temporary(x); _temporary.y; }

A(10).method(); // is:
TEMP(A, 10, method())
</code></pre>

<p>Yuck.</p>
"
"<p>The program is supposed to receive an input through cin, tokenize it, and then output each one to show me that it worked properly. It did not.</p>

<p>The program compiles with no errors, and takes an input, but fails to output anything.</p>

<p>What am I doing wrong?</p>

<pre><code>int main(int argc, char* argv[])
{
  string input_line;

  while(std::cin &gt;&gt; input_line){
    char* pch = (char*)malloc( sizeof( char ) *(input_line.length() +1) );

    char *p = strtok(pch, "" "");
    while (p != NULL) {
      printf (""Token: %s\n"", p);
      p = strtok(NULL, "" "");
    }
  }
  return 0;
}
</code></pre>

<p>I followed the code example here: <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strtok/"" rel=""nofollow"">http://www.cplusplus.com/reference/clibrary/cstring/strtok/</a></p>

<p>Thanks.</p>
","87234","","<p>This is more of a correctness post, Hans has your problem.</p>

<p>The correct way to get a line of input is with <code>getline</code>:</p>

<pre><code>std::string s;
std::getline(std::cin, s);
</code></pre>

<p><code>std::cin</code> breaks at whitespace anyway, so if you typed <code>asd 123</code> and ran your code, <code>input_line</code> would first be ""asd"", then the second time in the loop ""123"" (without waiting for enter).</p>

<p>That said, an easy way to get your result is with a <code>stringstream</code>. Any time you explicitly allocate memory, especially with <code>malloc</code>, you're probably doing something the hard way. Here's one possible solution to tokenizing a string:</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main(void)
{
    std::string input;
    std::getline(std::cin, input);

    std::stringstream ss(input);
    std::string token;
    while(std::getline(ss, token, ' '))
    {
        std::cout &lt;&lt; token &lt;&lt; ""..."";
    }

    std::cout &lt;&lt; std::endl;
}
</code></pre>

<p>If you really want to use <code>strtok</code>, you might do something like this:</p>

<pre><code>#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main(void)
{
    std::string input;
    std::getline(std::cin, input);

    std::vector&lt;char&gt; buffer(input.begin(), input.end());
    buffer.push_back('\0');

    char* token = strtok(&amp;buffer[0], "" "");
    for (; token; token = strtok(0, "" ""))
    {
        std::cout &lt;&lt; token &lt;&lt; ""..."";
    }

    std::cout &lt;&lt; std::endl;
}
</code></pre>

<p>Remember, manually memory management is bad. Use a <code>vector</code> for arrays, and you avoid leaks. (Which your code has!)</p>
"
"<p>Online references have rather brief and vague descriptions on the purpose of <code>std::iostream::sentry</code>. When should I concern myself with this little critter? If it's only intended to be used internally, why make it public?</p>
","87234","","<p>It's used whenever you need to extract or output data with a stream. That is, whenever you make an <code>operator&gt;&gt;</code>, the extraction operator, or <code>operator&lt;&lt;</code>, the insertion operator.</p>

<p>It's purpose is to simplify the logic: ""Are any fail bits set? Synchronize the buffers. For input streams, optionally get any whitespace out of the way. Okay, ready?""</p>

<p>All extraction stream operators should begin with:</p>

<pre><code>// second parameter to true to not skip whitespace, for input that uses it
const std::istream::sentry ok(stream, icareaboutwhitespace);

if (ok)
{
    // ...
}
</code></pre>

<p>And all insertion stream operators should begin with:</p>

<pre><code>const std::ostream::sentry ok(stream); 

if (ok)
{
    // ...
}
</code></pre>

<p>It's just a cleaner way of doing (something similar to):</p>

<pre><code>if (stream.good())
{
    if (stream.tie())
        stream.tie()-&gt;sync();

    // the second parameter
    if (!noskipwhitespace &amp;&amp; stream.flags() &amp; ios_base::skipws)
    {
        stream &gt;&gt; std::ws;            
    }
}

if (stream.good())
{
    // ...
}
</code></pre>

<p><code>ostream</code> just skips the whitespace part.</p>
"
"<p>The following code prints one,two,three.  Is that desired and true for all C++ compilers?</p>

<pre><code>
class Foo
{
      const char* m_name;
public:
      Foo(const char* name) : m_name(name) {}
      ~Foo() { printf(""%s\n"", m_name); }
};

void main()
{
      Foo foo(""three"");
      Foo(""one"");   // un-named object
      printf(""two\n"");
}
</code></pre>
","87234","","<p>A temporary variable lives until the end of the full expression it was created in. Yours ends at the semicolon.</p>

<p>This is in 12.2/3:</p>

<blockquote>
  <p>Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created.</p>
</blockquote>

<p>Your behavior is guaranteed.</p>

<p>There are two conditions that, if met, will extend the lifetime of a temporary. The first is when it's an initializer for an object. The second is when a reference binds to a temporary.</p>
"
"<p>I am running the same exact code that I ran in plain C:</p>

<pre><code>pthread_create(&amp;threads[i], &amp;attr, SomeMethod, ptrChar);
</code></pre>

<p>And I get the errors:</p>

<blockquote>
  <p>error: invalid conversion from
  'void*(<code>*)(char'*)' to 'void*(*)(void*)</code>'</p>
  
  <p>error: initializing argument 3 of 'int
  <code>pthread_create(__pthread_t**,
  __pthread_attr_t* conts*, void*(*)(void*), void*)'</code></p>
</blockquote>

<p>SomeMethod is:</p>

<pre><code>void *SomeMethod(char *direction)
</code></pre>

<p>Do I need to do something different in C++?  I thought you could just run any C code in C++ and it would work fine?</p>

<p>I am using Cygwin at the moment.</p>
","87234","","<p>Like it says, they are two different function signatures. You should do:</p>

<pre><code>void *SomeMethod(void* direction) // note, void
{
    char* dir = static_cast&lt;char*&gt;(direction); // and get the value
}
</code></pre>

<p>C was casting from one function pointer to the other, apparently. Casting one function pointer to another is undefined behavior in C++.</p>

<p>That said, I'm pretty sure POSIX requires that casts between function pointers be well-defined, so you may be able to do this instead:</p>

<pre><code>pthread_create(&amp;threads[i], &amp;attr, // cast the function pointer
                reinterpret_cast&lt;void* (*)(void*)&gt;(SomeMethod), ptrChar);
</code></pre>
"
"<p>Consider the following example:</p>

<pre><code>template &lt;typename T&gt;
class A {
    public:
        void f() {
            cout &lt;&lt; ""A::f()\n"";
        }
};

template&lt;&gt;
class A&lt;int&gt; {
};

template&lt;typename T&gt;
class B: public A&lt;T&gt; {
    public:
        void g() {
            cout &lt;&lt; ""B::g()\n"";
            A&lt;T&gt;::f();
        }
};

int main() {
    B&lt;int&gt; b;     // (1)
    b.g();        // (2)

    return 0;
}
</code></pre>

<p>Obviously the call to A::f() inside B::g() will fail for int template type. My question is at what point does the call fail? At (1) or (2)? I thought it should be (1) because at that point the compiler creates a new class with the template type int and compiles it. That compilation should fail in f() correct?</p>
","87234","","<p>It will fail at (2), and this is guaranteed by the standard. In section 14.7.1/1, it says instantiating a template class does <em>not</em> instantiate it's members definitions. That will only happen once the member is used.</p>

<p>If you remove (2) from the code, it will compile.</p>

<blockquote>
  <p>14.7.1/1 excerpt:<br>
  The implicit instantiation of a class template specialization causes the implicit
  instantiation of the declarations, <strong>but not of the definitions or default arguments, of the class member functions, member classes, static data members and member templates</strong>; and it causes the implicit instantiation of the definitions of member anonymous unions.</p>
</blockquote>

<p>Emphasis mine.</p>

<hr>

<p>Visual Studio's diagnosis is misleading. It will say <code>see reference to class template instantiation 'B&lt;T&gt;' being compiled</code>. What it means is not ""I'm failing at the instantiation of <code>B&lt;T&gt;</code>"", but ""I'm failing at instantiating a member of the class <code>B&lt;T&gt;</code>""</p>
"
"<p>I was reading the STL source code (which turned out to be both fun and very useful), and I came across this kind of thing</p>

<pre><code>//file backwards/auto_ptr.h, but also found on many others.

template&lt;typename _Tp&gt;                                                                                                 
      class auto_ptr

//Question is about this:
template&lt;&gt;
    class auto_ptr&lt;void&gt;
</code></pre>

<p>Is the <code>template&lt;&gt;</code> part added to avoid class duplication?</p>

<p>Thanks in advance.</p>
","87234","","<p>That's specialization. For example:</p>

<pre><code>template &lt;typename T&gt;
struct is_void
{
    static const bool value = false;
};
</code></pre>

<p>This template would have <code>is_void&lt;T&gt;::value</code> as <code>false</code> for <em>any</em> type, which is obviously incorrect. What you can do is use this syntax to say ""I'm filling in T myself, and specializing"":</p>

<pre><code>template &lt;&gt; // I'm gonna make a type specifically
struct is_void&lt;void&gt; // and that type is void
{
    static const bool value = true; // and now I can change it however I want
};
</code></pre>

<p>Now <code>is_void&lt;T&gt;::value</code> is <code>false</code> except when <code>T</code> is <code>void</code>. Then the compiler chooses the more specialized version, and we get <code>true</code>.</p>

<p>So, in your case, it has a generic implementation of <code>auto_ptr</code>. But that implementation has a problem with <code>void</code>. Specifically, it cannot be dereferenced, since it has no type associated with it.</p>

<p>So what we can do is specialize the <code>void</code> variant of <code>auto_ptr</code> to remove those functions.</p>
"
"<p>Can't a compiler warn (even better if it throws errors) when it notices a statement with undefined/unspecified/implementation-defined behaviour?</p>

<p>Probably to flag a statement as error, the standard should say so, but it can warn the coder at least. Is there any technical difficulties in implementing such an option? Or is it merely impossible?</p>

<p>Reason I got this question is, in statements like <code>a[i] = ++i;</code> won't it be knowing that the code is trying to reference a variable and modifying it in the same statement, before a sequence point is reached.</p>
","87234","","<p>Contrarily, compilers are <strong>not</strong> required to make any sort of diagnosis for undefined behavior:</p>

<blockquote>
  <p>§1.4.1:<br>
  The set of diagnosable rules consists of all syntactic and semantic rules in this International Standard except for those rules containing an explicit notation that “no diagnostic is required” <strong>or which are described as resulting in “undefined behavior.”</strong></p>
</blockquote>

<p>Emphasis mine. While I agree it may be nice, the compiler's have enough problem trying to be standards compliant, let alone teach the programmer how to program.</p>
"
"<p>I'm using Visual Studio C++ 2008 Express Edition.</p>

<p>Is it possible to modify the text in the Output pane for compilation (or other) errors?</p>

<p>For example, I might receive an error that reads: error C2556: int Class::getResult(void) + a lot more relative garbage.</p>

<p>I can parse the output text and find and fix my mistakes easily.  It would still be nice/useful if I could modify the errors to make them cleaner, shorter, and more friendly.  An example would be receiving an error that read:  ""Source.cc (Line 10): Missing a closing;""</p>
","87234","","<p>There are a few things you have to understand. The compiler is really doing the best it can; it tells you exactly where it failed, and the entire compilation up until that point. It doesn't know what you intended to write, it knows what you wrote, so how can it possibly assume an error was caused by something else more remote? I think if you were writing it and got to the point of making errors ""cleaner, shorter, and more friendly"", you'd realize this is much more difficult that it might seem.</p>

<p>There are situations when it can do that, and compilers are getting better at suggesting them it seems. For example this:</p>

<pre><code>if (x);
{
    x = 5;
}
</code></pre>

<p>Produces a warning:</p>

<blockquote>
  <p>warning C4390: ';' : empty controlled statement found; is this the intent?</p>
</blockquote>

<p>But they can't always do that.</p>

<p>That all said, the error messages are really all you need to solve the problem, once you learn the language a bit and understand what it all means. I think it's an enormous myth and exaggeration that template errors are ""evil and cryptic"". While they can be verbose, they're really not that hard to understand at all. I don't think it's template errors being cryptic, I think it's the reader not knowing how to read it well, which makes it seem cryptic. But if you take your time, you see exactly what it was trying to do and where it failed.</p>

<p>There were a thing called ""concepts"" that would appear in the next standard, C++0x, that would fix this up immensely. They were sort of like tags that classes could fit into if they supported everything that tag said they had to. So in <code>std::copy</code>, instead of errors about being unable to call <code>operator=</code> on something, along with the errors that propagates, you would simply get something like ""Error: Type is not CopyAssignable"" and that would be it. Same error, different presentation. And that's also the reason they got cut out, for now. they were proving to be trouble, and since it was syntactic sugar anyway, it's more important to work on other things. Hopefully we'll see them someday.</p>

<p>Now, there is a tool called <a href=""http://www.bdsoft.com/tools/stlfilt.html"" rel=""nofollow"">STLFilt</a>, which will filter template errors concerning things in the STL. I have never used it, but I've heard it recommended more than once. Here's one of their <a href=""http://www.bdsoft.com/dist//msvc7-demo.txt"" rel=""nofollow"">sample filters</a>. You might give it a try.</p>

<hr>

<p>Since you seem to think this is something possible to do in the language itself: nope. The language has no concepts of what errors messages should look like or what should warn or what shouldn't.</p>

<p>You'll find what I mean in the standard in section 1.4/2. Summarized, it basically says ""If there's an error, output something about it"". That's it.</p>
"
"<p>Is there a one-liner that will free the memory that is being taken by all pointers you created using <code>malloc</code>s? Or can this only be done manually by <code>free</code>ing every pointer separately?</p>
","87234","","<p><code>malloc</code> on it's own has implementation-defined behavior. So there isn't a necessity for it to keep track of all the pointers it has, which obviously puts a damper on the idea.</p>

<p>You'd need to make your own memory manager that tracks the pointers, and then provides a function called <code>free_all</code> or something that goes through the list of pointers it has and calls <code>free</code> on them.</p>

<p>Note, this sounds like a somewhat bad idea. It's better to be a bit more strict/responsible about your memory usage, and <code>free</code> things when you're done; not leave them hanging about.</p>

<p>Perhaps with a bit more background on where you want to apply your idea, we might find easier solutions.</p>
"
"<p>I was programming normally when I realized that its probably not perfectly safe to assume an int is going to be a pointer to something 4 bytes in length.</p>

<p>Because <a href=""http://stackoverflow.com/questions/625333/how-to-limit-the-impact-of-implementation-dependent-language-features-in-c/625440"">Some of the aspects of C++’s fundamental types, such as the size of an int, are implementation- defined</a>..</p>

<p>What if you're dealing with something (like a waveform, for example) that has 32-bit signed integer samples.  You cast the byte pointer to (int*) and deal with it one sample at a time.</p>

<p>I'm just curious what's the ""safe way"" to acquire a 4-byte pointer, that ISN'T going to stop working if sometime in the future MSVC committee decides <code>int</code> is now 8 bytes.</p>

<p><a href=""http://stackoverflow.com/questions/269614/gcc-fixed-size-integers"">Related</a></p>
","87234","","<p>There is a C99 header called <a href=""http://en.wikipedia.org/wiki/Stdint.h"" rel=""nofollow""><code>stdint.h</code></a> your compiler might have. It defines types like <code>uint32_t</code>, an unsigned 32-bit integer.</p>

<p>If not, check out <a href=""http://www.boost.org/doc/libs/1_42_0/libs/integer/doc/html/index.html"" rel=""nofollow"">Boost Integer</a>, which mimics this header as <code>&lt;boost/cstdint.hpp&gt;</code>.</p>

<hr>

<p>For storing pointers as integers, use <code>intptr_t</code>, defined in the same header.</p>
"
"<p>Given the following piece of code:</p>

<pre><code>template&lt;typename T&gt;
class MyContainer
{
    typedef T value_type;
    typedef unsigned int size_type;

    ...
};
</code></pre>

<p>How one should initialize variables using size_type (like loop indexes)?<br />
Should it be:<br/></p>

<pre><code>for(size_type currentIndex = size_type(0);currentIndex &lt; bound;++currentIndex)
</code></pre>

<p>or</p>

<pre><code>for(size_type currentIndex = static_cast&lt;size_type&gt;(0);currentIndex &lt; bound;++currentIndex)
</code></pre>

<p>The rationale for the question is to produce code that will still work when type underlying size_type is changed or added to template parameters.</p>

<p>Thanks...</p>
","87234","","<p>There are four possibilities I see:</p>

<pre><code>size_type();
size_type(0);
static_cast&lt;size_type&gt;(0);
0;
</code></pre>

<p>I would prefer the last one. It's concise, and has the same effect as the rest.</p>

<p>You're probably worried that if the type change this won't work, or something. The thing is, <code>size_type</code>'s are, by convention, unsigned integers. 0 is always going to be a valid value as long as <code>size_type</code> is a sensible &amp; correct size-measuring type.</p>
"
"<p>Is <code>using namespace std;</code> a standard C++ function?</p>
","87234","","<p>No. It's what's called a <code>using directive</code>. I's outlined in §7.3.4 in the standard:</p>

<blockquote>
  <p>A using-directive specifies that the names in the nominated namespace can be used in the scope in which the using-directive appears after the using-directive. During unqualified name lookup (3.4.1), the names appear as if they were declared in the nearest enclosing namespace which contains both the using-directive and the nominated namespace.</p>
</blockquote>

<p>Essentially, it takes everything in the namespace you specify and moves in into the namespace the directive was used.</p>
"
"<p>I'm trying to print the list of a singly linked list that I referred to in <a href=""http://stackoverflow.com/questions/2309359/creating-a-singly-linked-list-in-c"">link text</a></p>

<p>It works, but I do get the compiler warnings</p>

<p>""Initialization discards qualifiers from pointer target type""(on declaration of start = head) and return discards qualifiers from pointer target type""(on return statement) in this code (I am using XCode):</p>

<pre><code>/* Prints sinly linked list and returns head pointer */
LIST *PrintList(const LIST *head) 
{
    LIST *start = head;

    for (; start != NULL; start = start-&gt;next)
        printf(""%15s %d ea\n"", head-&gt;str, head-&gt;count);

    return head;
}
</code></pre>

<p>Any thoughts?  Thanks!</p>
","87234","","<p>It's this part:</p>

<pre><code>LIST *start = head;
</code></pre>

<p>The parameter for the function is a constant pointer, <code>const LIST *head</code>; this means you cannot change what it is pointing to. However, the pointer above is non-const; you could dereference it and change it.</p>

<p>It needs to be <code>const</code> as well:</p>

<pre><code>const LIST *start = head;
</code></pre>

<p>The same applies to your return type.</p>

<hr>

<p>All the compiler is saying is: ""Hey, you said to the caller 'I won't change anything', but you're opening up opportunities for that.""</p>
"
"<p>I'm trying to print the second member variable of all items in an stl map using a lambda expression</p>

<pre><code>map&lt;int, int&gt; theMap;
for_each(theMap.begin(), theMap.end(), 
         cout &lt;&lt; bind(&amp;pair&lt;int, int&gt;::second, _1) &lt;&lt; constant("" ""));
</code></pre>

<p>but this is not compiling. I essentially want to de-reference the placeholder. Any idea what I'm missing here?</p>

<p>Thanks in advance!</p>
","87234","","<p><code>std::map</code> will add <code>const</code> to its key; this is to prevent messing up the ordering. Your pair should be:</p>

<pre><code>std::pair&lt;const int, int&gt;
</code></pre>

<p>Like dirkgently suggests, use the <code>value_type</code> to always get the correct type. The verbosity is alleviated with a typedef:</p>

<pre><code>typedef std::map&lt;int, int&gt; int_map;

int_map::value_type::second
</code></pre>
"
"<p>Given the following:</p>

<pre><code>StreamLogger&amp; operator&lt;&lt;(const char* s) {
  elements.push_back(String(s));
  return *this;
}

StreamLogger&amp; operator&lt;&lt;(int val) {
  elements.push_back(String(asString&lt;int&gt;(val)));
  return *this;
}

StreamLogger&amp; operator&lt;&lt;(unsigned val) {
  elements.push_back(String(asString&lt;unsigned&gt;(val)));
  return *this;
}

StreamLogger&amp; operator&lt;&lt;(size_t val) {
  elements.push_back(String(asString&lt;size_t&gt;(val)));
  return *this;
}
</code></pre>

<p>is there a way to eliminate repetition? I want to use templates, but I only want it for the following types: const char* int, unsigned, and size_t</p>
","87234","","<p>Really, in ""vanilla"" C++ you either write the by hand, for specific types, or you use a template like dirkgently suggested.</p>

<p>That said, if you can use Boost this does what you want:</p>

<pre><code>template &lt;class T&gt;
StreamLogger&amp; operator&lt;&lt;(T val)
{
    typedef boost::mpl::vector&lt;const char*, int,
                                unsigned, size_t&gt; allowed_types;

    BOOST_MPL_ASSERT_MSG(boost::mpl::contains&lt;allowed_types, T&gt;::value,
                            TYPE_NOT_ALLOWED, allowed_types);

    // generic implementation follows
    elements.push_back(boost::lexical_cast&lt;std::string&gt;(val));

    return *this;
}
</code></pre>

<p>This will generate a compile-time error with the message <code>TYPE_NOT_ALLOWED</code> embedded in it if the type being compiled is not contained in the typelist.</p>

<p>Also, since this answer requires Boost I just used <code>lexical_cast</code>. You'll note you're repeating that code, and that's bad. Consider <a href=""http://stackoverflow.com/questions/1243428/convert-string-to-int-with-bool-fail-in-c/1243435#1243435"">wrapping</a> that functionality into a function.</p>

<hr>

<p>If you <em>aren't</em> able to use Boost, you can simulate this pretty easily with some type traits:</p>

<pre><code>template &lt;typename T, typename U&gt;
struct is_same
{
    static const bool value = false;
};

template &lt;typename T&gt;
struct is_same&lt;T, T&gt;
{
    static const bool value = true;
};

template &lt;bool&gt;
struct static_assert;

template &lt;&gt;
struct static_assert&lt;true&gt; {}; // only true is defined

// not the best, but it works
#define STATIC_ASSERT(x) static_assert&lt; (x) &gt; _static_assert_

template &lt;class T&gt;
StreamLogger&amp; operator&lt;&lt;(T val)
{
    STATIC_ASSERT(is_same&lt;const char*, T&gt;::value ||
                    is_same&lt;int, T&gt;::value ||
                    is_same&lt;unsigned, T&gt;::value ||
                    is_same&lt;size_t, T&gt;::value);

    // generic implementation follows
    elements.push_back(boost::lexical_cast&lt;std::string&gt;(val));

    return *this;
}
</code></pre>

<p>This will also generate a compile-time error if the assert fails, though the code isn't as sexy. :( &lt;- Not sexy</p>
"
"<p>I have:</p>

<pre><code>class Foo;

class Bar {
  Foo foo;
  Bar(): foo(foo) {};
}

Bar bar;
</code></pre>

<p>At this point, is</p>

<pre><code>bar.foo // &lt;--- how is this initialized?
</code></pre>

<p>[This question arose from a buggy ref-counted pointer implemntation; I could have sworn that I ensured each pointer was pointing at something non-null; but I ended up with a pointer that pointed at something NULL.]</p>
","87234","","<p><code>foo</code> is fully initialized once you've entered the body of the constructor (that's the guaranteed general case; specifically once it has finished initializing in the initialize list.)</p>

<p>In your case, you are copy-constructing from a non-constructed object. This results in undefined behavior, per §12.7/1 (thank you, gf):</p>

<blockquote>
  <p>For an object of non-POD class type (clause 9), before the constructor begins execution and after the destructor finishes execution, referring to any nonstatic member or base class of the object results in undefined behavior.</p>
</blockquote>

<p>In fact, it gives this example:</p>

<pre><code>struct W { int j; };
struct X : public virtual W { };
struct Y {
    int *p;
    X x;
    Y() : p(&amp;x.j) // undefined, x is not yet constructed
    { }
};
</code></pre>

<p>Note, the compiler is <em>not</em> required to give a diagnosis of undefined behavior, per §1.4/1. While I think we all agree it would be nice, it simply isn't something the compiler implementers need to worry about.</p>

<hr>

<p>Charles points out a loophole of sorts. If <code>Bar</code> has static storage and if <code>Foo</code> is a POD type, then it <em>will</em> be initialized when this code runs. Static-stored variables are zero-initialized before an other initialization runs.</p>

<p>This means whatever <code>Foo</code> is, as long as it doesn't need a constructor to be run to be initialized (i.e., be POD) it's members will be zero-initialized. Essentially, you'll be copying a zero-initialized object.</p>

<p>In general though, such code is to be avoided. :)</p>
"
"<p>If you use std::logic_error exception in your code, in what case do you use it for?</p>
","87234","","<p><code>logic_error</code> is the base for these exceptions:
<code>domain_error</code>, <code>invalid_argument</code>, <code>length_error</code>, <code>out_of_range</code>.</p>

<p>Those are all logical errors: Somethings wrong with the input such that the output would be illogical. So I'd say you usually don't need to use it directly, since those four cover any logic errors I can think of. But those give you an idea of what the category is.</p>
"
"<p>I wish to insert into a c++ vector at a known position. I know the c++ library has an insert() function that takes a position and the object to insert but the position type is an iterator. I wish to insert into the vector like I would insert into an array, using a specific index.</p>
","87234","","<p>It's always nice to wrap these things up:</p>

<pre><code>template &lt;typename T&gt;
T&amp; insert_at(T&amp; pContainer, size_t pIndex, const T::value_type&amp; pValue)
{
    pContainer.insert(pContainer.begin() + pIndex, pValue);

    return pContainer;
}
</code></pre>

<p>That should do it. There is a now deleted answer that you can construct an iterator from an index, but I've never see that before. If that's true, that's definitely the way to go; I'm looking for it now.</p>
"
"<p>I wrote this really simple game in SDL using C++ and now i want to show some of my friends who are on windows. I wrote my program in ubuntu 9.10 using code blocks. I want to take my source code and make a windows installer so they can install it and play. How can i go about doing this?</p>
","87234","","<p>Congrats on completing a project. :)</p>

<p>That said, now you need to find a Windows compiler like MinGW (the port of gcc) or Microsoft Visual Studio (2008 Express is free, and 2010 Release Candidate is free) so you can compile your game for the Windows platform.</p>

<p>As long as your code is portable and sticks to the standard (and I know SDL works cross-platform), you should have minimal snags. If you have any problems of course feel free to ask for help. You can even just get CodeBlocks bundled with MinGW (though it may not be the latest version) and use the same project structure.</p>

<p>Once you've got that working, you need a install system to package all your stuff together. I'm no expert in this area, but I love the <a href=""http://www.clickteam.com/website/usa/installcreator.html"" rel=""nofollow"">ClickTeam Install Creator</a>; it's very easy yet very flexible. It costs money but there is a freeware version with a ""made with Install Creator"" at the end of your installer.</p>

<p>There may be other install creators, but I have little experience with them. You just need to make sure your end-users have the required binaries: package an SDL dll's you use with your game, all data, etc.</p>
"
"<p>In standard library, I found that namespace <code>std</code> is declared as a macro.</p>

<pre><code>#define _STD_BEGIN  namespace std {
#define _STD_END        }
</code></pre>

<ol>
<li>Is this a best practice when using namespaces?</li>
<li>The macro is declared in <code>Microsoft Visual Studio 9.0\VC\include\yvals.h</code>. But I couldn't find the STL files including this. If it is not included, how it can be used?</li>
</ol>

<p>Any thoughts..?</p>
","87234","","<p>Probably not a best practice as it can be difficult to read compared to a vanilla <code>namespace</code> declaration. That said, remember rules don't always apply universally, and I'm sure there is some scenario where a macro might clean things up considerably.</p>

<p>""But I couldn't find the STL files including this. If it is not included, how it can be used?"".</p>

<p>All files that use this macro include <code>yvals.h</code> somehow. For example <code>&lt;vector&gt;</code> includes, <code>&lt;memory&gt;</code>, which includes <code>&lt;iterator&gt;</code>, which includes <code>&lt;xutility&gt;</code>, which includes <code>&lt;climits&gt;</code>, which includes <code>&lt;yvals.h&gt;</code>. The chain may be deep, but it <em>does</em> include it it some point.</p>

<p>And I want to clarify, this only applies to this particular implementation of the standard library; this is in no way standardized.</p>
"
"<p>I have a problem with with my output when I write to I file I get squares when I put endl to change lines.</p>

<pre><code>std::ofstream outfile   (a_szFilename, std::ofstream::binary);
outfile&lt;&lt;""[""&lt;&lt;TEST&lt;&lt;""]""&lt;&lt;std::endl;
</code></pre>

<p>I get something like this in my file plus the other outputs don't write on the next line but on the same one.</p>

<pre><code>[TEST]square
</code></pre>

<p>apparently I can't write the square here, but is it something about the ofstream being binary or something?</p>
","87234","","<p>It's probably because you're in binary mode and the line endings are wrong. <code>std::endl</code> will place <code>'\n'</code> on the stream before flushing. In text mode, this will be converted to the correct line ending for your platform. In binary mode, no such conversions take place.</p>

<p>If you're on Windows, your code will have a line feed (LF), but Windows also requires a carriage return (CF) first, which is <code>'\r'</code>. That is, it wants ""\r\n"", not just a newline.</p>

<p>Your fix is to open the file in text mode. Binary files are not suppose to be outputting newlines or formatted output, which is why you don't want to use the extraction and insertion operators.</p>

<p>If you really want to use binary, then treat your file like a binary file and don't expect it to display properly. Binary and formatted output do not go hand in hand. From your usage, it seems you should be opening in text mode.</p>
"
"<blockquote>
  <p><strong>Possible Duplicates:</strong><br>
  <a href=""http://stackoverflow.com/questions/1128837/using-this-in-front-of-member-variables-in-c"">Using &ldquo;this&rdquo; in front of member variables in C++</a><br>
  <a href=""http://stackoverflow.com/questions/1057425/is-excessive-use-of-this-in-c-a-code-smell"">Is excessive use of this in C++ a code smell</a>  </p>
</blockquote>



<p>Years ago, I got in the habit of using this-> when accessing member variables. I knew it wasn't strictly necessary, but I thought it was more clear.</p>

<p>Then, at some point, I started to prefer a more minimalistic style and stopped this practice... </p>

<p>Recently I was asked by one of my more junior peers whether I thought it was a good idea and I found that I didn't really have a good answer for my preference... Is this really a wholly stylistic choice or are there real reasons why not prefixing this-> on member variable accesses is better?</p>
","87234","","<p>While this is a totally subjective question, I think the general C++ community prefers <em>not</em> to have <code>this-&gt;</code>. Its cluttering, and entirely not needed.</p>

<p>Some people use it to differentiate between member variables and parameters. A much more common practice is to just prefix your member variables with something, like a single underscore or an <code>m</code>, or <code>m_</code>, etc.</p>

<p>That is much easier to read, in my opinion. If you need <code>this-&gt;</code> to differentiate between variables, you're doing it wrong. Either change the parameter name (from <code>x</code> to <code>newX</code>) or have a member variable naming convention.</p>

<p>Consistency is preferred, so instead of forcing <code>this-&gt;</code> on yourself for the <em>few</em> cases you need to differentiate (note in initializer lists this is completely well-defined: <code>x(x)</code>, where the member <code>x</code> is initialized by the parameter <code>x</code>), just get better variable names.</p>

<p>This leaves the only time I use <code>this</code>: when I actually need the address of the instance, for whatever reason.</p>
"
"<p>Is there a way to posix_memalign a std::vector without creating a local instance of the vector first? 
The problem I'm encountering is that I need to tell posix_memalign how much space to allocate and I don't know how to say </p>

<pre><code>sizeof(std::vector&lt;type&gt;(n)) 
</code></pre>

<p>without actually creating a new vector.</p>

<p>Thanks</p>
","87234","","<p>Well, there are two sizes here. The <code>vector</code> itself is typically no more than a pointer or two to some allocated memory, and unsigned integers keeping track of size and capacity. There is also the allocated memory itself, which is what I think you want.</p>

<p>What you want to do is make a custom allocator that the <code>vector</code> will use. When it comes time, it will use your allocator and you can have your own special functionality. I won't go over the <a href=""http://www.codeproject.com/KB/cpp/allocator.aspx"" rel=""nofollow"">full details</a> of an allocator, but the specifics:</p>

<pre><code>template &lt;typename T&gt;
struct aligned_allocator
{
    // ...

    pointer allocate(size_type pCount, const_pointer = 0)
    { 
        pointer mem = 0;
        if (posix_memalign(&amp;mem, YourAlignment, sizeof(T) * pCount) != 0)
        {
            throw std::bad_alloc(); // or something
        }

        return mem;
    }

    void deallocate(pointer pPtr, size_type)
    { 
        free(pPtr);
    }

    // ...
};
</code></pre>

<p>And then you'd use it like:</p>

<pre><code>typedef std::vector&lt;T, aligned_allocator&lt;T&gt; &gt; aligned_T_vector;

aligned_T_vector vec;
vec.push_back( /* ... */ ); // array is aligned
</code></pre>

<p>But to reiterate the first point, the size of a <code>vector</code> is the same regardless of how many elements it's holding, as it only points to a buffer. Only the size of that buffer changes.</p>
"
"<p>I am initializing a map <code>map&lt;string,int&gt; ex;</code>
in C++. I could not find contains_key or similar function in stl,
hence I am just using <code>ex[inputString]++;</code></p>

<p>The debugger shows the int to be initialized to zero correctly, is it a good assumption?</p>
","87234","","<p>Yes, values that do not exist when accessed with <code>operator[]</code> are default-constructed. For numeric values, this is 0.</p>

<p>That said, you're looking for the <code>count</code> method:</p>

<pre><code>bool hasElement = ex.count(""element"");
</code></pre>
"
"<p>I'm new in c++, how to made code below work (compile without a syntax error)? </p>

<pre><code>typedef struct _PersonA{
    char name[128];
    LPPersonB rel;
}PersonA, *LPPersonA;

typedef struct _PersonB{
    char name[128];
    LPPersonA rel;
}PersonB, *LPPersonB;
</code></pre>

<p>Please, don't ask me why I need to do it like this, because it is just an example to explain my question.</p>
","87234","","<p>You have to forward declare:</p>

<pre><code>struct _PersonB;

typedef struct _PersonA{
char name[128];
_PersonB* rel; // no typedef
}PersonA, *LPPersonA;

typedef struct _PersonB{
char name[128];
LPPersonA rel;
}PersonB, *LPPersonB;
</code></pre>

<p>That said, this is very...ugly. Firstly, there is no need for the typedef in C++:</p>

<pre><code>struct PersonB;

struct PersonA
{
    char name[128];
    PersonB* rel;
};

struct PersonB
{
    char name[128];
    PersonA* rel;
};
</code></pre>

<p>Which also has the side-effect of getting rid of your bad name: <code>_PersonA</code>. This name is reserved for the compiler because it begins with an underscore followed by a capital letter.</p>

<p>And that's it. Hiding pointers behind typedef's is generally considered bad, by the way.</p>
"
"<p>Having problems iterating.  Problem has to do with const correctness, I think.  I assume B::getGenerate() should be const for this code to work, but I don't have control over B::getGenerate().</p>

<p>Any help is greatly appreciated.</p>

<p>Thanks in advance,
jbu</p>

<p>Code follows:</p>

<pre><code>int
A::getNumOptions() const
{
   int running_total = 0;

   BList::const_iterator iter = m_options.begin();

   while(iter != m_options.end())
   {
      if(iter-&gt;getGenerate()) //this is the line of the error; getGenerate() returns bool; no const in signature
      {
         running_total++;
      }
   }

   return running_total;
}
</code></pre>

<p>1>.\A.cpp(118) : error C2662: 'B::getGenerate()' : cannot convert 'this' pointer from 'const B' to 'B &amp;'</p>
","87234","","<p>Well, if <code>getGenerate</code> is non-const, your iterator must be non-const. And if that's the case, your <code>getNumOptions</code> will also have to be non-const.</p>

<p>If <code>getGenerate</code> isn't under you control, there isn't anything else you can do. But if that method <em>could be</em> <code>const</code>, bring it up with whoever implemented that method; tell them it should be <code>const</code>.</p>
"
"<p>I'm writing a multi-threaded demo program using pthreads, where one thread loads data into an STL queue, and another thread reads from it.  Sounds trivial, right?  Unfortunately, data pushed into the queue is vanishing.  I'm not new to multithreading, nor am I unfamiliar with memory structures - however, this has me stumped.</p>

<p>These are my declarations for the queue itself and the mutex that protects it, which are located in a header included by the client code:</p>

<pre><code>static std::queue&lt;int32_t&gt; messageQueue;
static pthread_mutex_t messageQueueLock; 
</code></pre>

<p>When the program starts up, it initializes the mutex with the process shared attribute:</p>

<pre><code>pthread_mutexattr_t sharedAttr;
pthread_mutexattr_init(&amp;sharedAttr);
pthread_mutexattr_setpshared(&amp;sharedAttr, PTHREAD_PROCESS_SHARED);
pthread_mutex_init(&amp;messageQueueLock, &amp;sharedAttr);
</code></pre>

<p>It then launches the 'producer' thread and 'consumer' threads, and lets them do their thing.  The producer thread pushes a new item onto the queue and then goes to sleep.  Here are the lines where it adds something to the queue:</p>

<pre><code>pthread_mutex_lock(&amp;messageQueueLock);
messageQueue.push(message);
pthread_mutex_unlock(&amp;messageQueueLock);
</code></pre>

<p>It then sleeps and lets the consumer thread take over.  However, when the consumer thread checks for items in the queue, the queue is magically empty.</p>

<p>I have stepped through the program using gdb.  Below is the output of my run. You can see where the producer adds something to the queue, I print the queue's size to make sure it's there, there is a context switch to the consumer thread, I print the queue's size again, and it's empty.  Check it out:</p>

<pre><code>(gdb) b main_ex.cpp:70
Breakpoint 1 at 0x100006a24: file main_ex.cpp, line 70.
(gdb) run
Starting program: a.out 
Reading symbols for shared libraries ++. done
Creating the mutex.
Producer thread starting up. 
PRODUCER: Creating a message to send.
PRODUCER: Adding the message to the queue.
[Switching to process 7432]

Breakpoint 1, yourProcess () at main_ex.cpp:70
70      pthread_mutex_lock(&amp;messageQueueLock);
(gdb) n
71      messageQueue.push(message);
(gdb) p messageQueue.size()
$1 = 0
(gdb) n
72      pthread_mutex_unlock(&amp;messageQueueLock);
(gdb) p messageQueue.size()
$2 = 1
(gdb) b consumer.cpp:81
Breakpoint 2 at 0x1000043f7: file consumer.cpp, line 81.
(gdb) c
Continuing.
PRODUCER: Sleep time!
[Switching to process 7432]

Breakpoint 2, Producer::processMessageQueue (this=0x1001000c0) at producer.cpp:81
81      pthread_mutex_lock(&amp;messageQueueLock);
(gdb) n
83      if(messageQueue.empty()) {
(gdb) p messageQueue.size()
$3 = 0
(gdb) quit
</code></pre>

<p>So, I'm really not sure what is going on.  The queue is only ever accessed in a critical section (both read/write), the queue is static, and the header is if-def'd to not be multi-included.</p>

<p>I'm grateful for any help anyone can offer!</p>
","87234","","<p>Header guards protect from multiple inclusion <em>per translation unit</em>. However, different translation units will re-include them.</p>

<p>In your case, it seems they are each getting their very own static queue and mutex. Also, consider even if you were correct: Without re-including the header, the translation unit would have no idea what queue and mutex are! You'd be trying to use some undeclared identifier.</p>

<p>You need extern, which is actually the opposite of static:</p>

<pre><code>extern std::queue&lt;int32_t&gt; messageQueue;
extern pthread_mutex_t messageQueueLock;
</code></pre>

<p>Then in one unit, actually define them:</p>

<pre><code>std::queue&lt;int32_t&gt; messageQueue;
pthread_mutex_t messageQueueLock;
</code></pre>
"
"<p>in C++, I can easily create a function pointer by taking the address of a member function. However, is it possible to change the address of that local function? </p>

<p>I.e. say I have funcA() and funcB() in the same class, defined differently. I'm looking to change the address of funcA() to that of funcB(), such that at run time calling funcA() actually results in a call to funcB(). I know this is ugly, but I need to do this, thanks!</p>

<p><strong>EDIT----------</strong></p>

<p>Background on what I'm trying to do:</p>

<p>I'm hoping to implement unit tests for an existing code base, some of the methods in the base class which all of my modules are inheriting from are non-virtual. I'm not allowed to edit any production code. I can fiddle with the build process and substitute in a base class with the relevant methods set to virtual but I thought I'd rather use a hack like this (which I thought was possible).</p>

<p>Also, I'm interested in the topic out of technical curiosity, as through the process of trying to hack around this problem I'm learning quite a bit about how things such as code generation &amp; function look-up work under the hood, which I haven't had a chance to learn in school having just finished 2nd year of university. I'm not sure as to I'll ever be taught such things in school as I'm in a computer engineering program rather than CS.</p>

<p><strong>Back on topic</strong>
The the method funcA() and funcB() do indeed have the same signature, so the problem is that I can only get the address of a function using the &amp; operator? Would I be correct in saying that I can't change the address of the function, or swap out the contents at that address without corrupting portions of memory? Would DLL injection be a good approach for a situation like this if the functions are exported to a dll?</p>
","87234","","<p>No. Functions are compiled into the executable, and their address is fixed throughout the life-time of the program.</p>

<p>The closest thing is virtual functions. Give us an example of what you're trying to accomplish, I promise there's a better way.</p>
"
"<p>If I have a texture, is it then possible to generate a normal-map for this texture, so it can be used for bump-mapping?</p>

<p>Or how is normal maps usually made?</p>

<p>Sandra</p>
","87234","","<p>Yes. Well, sort of. Normal maps can be accurately made from height-maps. Generally, you can also put a regular texture through and get decent results as well. Keep in mind there are other methods of making a normal map, such as taking a high-resolution model, making it low resolution, then doing ray casting to see what the normal should be for the low-resolution model to simulate the higher one.</p>

<p>For height-map to normal-map, you can use the <a href=""http://en.wikipedia.org/wiki/Sobel_operator"">Sobel Operator</a>. This operator can be run in the x-direction, telling you the x-component of the normal, and then the y-direction, telling you the y-component. You can calculate z with <code>1.0 / strength</code> where strength is the emphasis or ""deepness"" of the normal map. Then, take that x, y, and z, throw them into a vector, normalize it, and you have your normal at that point. Encode it into the pixel and you're done.</p>

<p>Here's some older incomplete-code that demonstrates this:</p>

<pre><code>// pretend types, something like this
struct pixel
{
    uint8_t red;
    uint8_t green;
    uint8_t blue;
};

struct vector3d; // a 3-vector with doubles
struct texture; // a 2d array of pixels

// determine intensity of pixel, from 0 - 1
const double intensity(const pixel&amp; pPixel)
{
    const double r = static_cast&lt;double&gt;(pPixel.red);
    const double g = static_cast&lt;double&gt;(pPixel.green);
    const double b = static_cast&lt;double&gt;(pPixel.blue);

    const double average = (r + g + b) / 3.0;

    return average / 255.0;
}

const int clamp(int pX, int pMax)
{
    if (pX &gt; pMax)
    {
        return pMax;
    }
    else if (pX &lt; 0)
    {
        return 0;
    }
    else
    {
        return pX;
    }
}

// transform -1 - 1 to 0 - 255
const uint8_t map_component(double pX)
{
    return (pX + 1.0) * (255.0 / 2.0);
}

texture normal_from_height(const texture&amp; pTexture, double pStrength = 2.0)
{
    // assume square texture, not necessarily true in real code
    texture result(pTexture.size(), pTexture.size());

    const int textureSize = static_cast&lt;int&gt;(pTexture.size());
    for (size_t row = 0; row &lt; textureSize; ++row)
    {
        for (size_t column = 0; column &lt; textureSize; ++column)
        {
            // surrounding pixels
            const pixel topLeft = pTexture(clamp(row - 1, textureSize), clamp(column - 1, textureSize));
            const pixel top = pTexture(clamp(row - 1, textureSize), clamp(column, textureSize));
            const pixel topRight = pTexture(clamp(row - 1, textureSize), clamp(column + 1, textureSize));
            const pixel right = pTexture(clamp(row, textureSize), clamp(column + 1, textureSize));
            const pixel bottomRight = pTexture(clamp(row + 1, textureSize), clamp(column + 1, textureSize));
            const pixel bottom = pTexture(clamp(row + 1, textureSize), clamp(column, textureSize));
            const pixel bottomLeft = pTexture(clamp(row + 1, textureSize), clamp(column - 1, textureSize));
            const pixel left = pTexture(clamp(row, textureSize), clamp(column - 1, textureSize));

            // their intensities
            const double tl = intensity(topLeft);
            const double t = intensity(top);
            const double tr = intensity(topRight);
            const double r = intensity(right);
            const double br = intensity(bottomRight);
            const double b = intensity(bottom);
            const double bl = intensity(bottomLeft);
            const double l = intensity(left);

            // sobel filter
            const double dX = (tr + 2.0 * r + br) - (tl + 2.0 * l + bl);
            const double dY = (bl + 2.0 * b + br) - (tl + 2.0 * t + tr);
            const double dZ = 1.0 / pStrength;

            math::vector3d v(dX, dY, dZ);
            v.normalize();

            // convert to rgb
            result(row, column) = pixel(map_component(v.x), map_component(v.y), map_component(v.z));
        }
    }

    return result;
}
</code></pre>
"
"<p>I know that when a constructor fails, the completed member objects will be destroyed. There is no memory leak.</p>

<p>My question is that how does compiler do that? How can compiler know what member is constructed? Does it make any record of it? Does the compiler really destroy everything in this case? How does it guarantee this?</p>
","87234","","<p>How the compiler does that is up to the compiler.</p>

<p>But yes, you are guaranteed that any constructed objects will be destructed (in the reverse order they were constructed). §15.2/2:</p>

<blockquote>
  <p>An object that is partially constructed or partially destroyed will have destructors executed for all of its fully constructed subobjects, that is, for subobjects for which the constructor has completed execution and the destructor has not yet begun execution. Should a constructor for an element of an automatic array throw an exception, only the constructed elements of that array will be destroyed. If the object or array was allocated in a new-expression, the matching deallocation function (3.7.3.2, 5.3.4, 12.5), if any, is called to free the storage occupied by the object.</p>
</blockquote>
"
"<p>Suppose I have a class <code>Foo</code>, with a private variable <code>bar_</code> containing some state for <code>Foo</code>. If necessary, I may write public get/set methods for <code>bar_</code>. Naturally, I avoid this as much as possible to maintain encapsulation.</p>

<p>Assuming I have these get/set methods, whenever I have to access or modify <code>bar_</code> within a method belonging to <code>Foo</code>, I usually do it directly to <code>bar_</code>, instead of using the get/set methods, which I use for accessing <code>bar_</code> from outside the class. I have no justification other than concerns regarding the speed of directly accessing the variable versus calling the methods, but I suspect that if the get/set methods are defined inline (which they are) it shouldn't make a difference. Does it make a difference? Does <code>const</code>ness play a role in this?</p>

<p>So far I haven't had any problems with this, but I have a lingering feeling I am Doing It Wrong. Are there any compelling arguments for not doing it? Any guidelines regarding this?</p>
","87234","","<blockquote>
  <p>I have no justification other than concerns regarding the speed of directly accessing the variable versus calling the methods, but I suspect that if the get/set methods are defined inline (which they are) it shouldn't make a difference. Does it make a difference? Does constness play a role in this?</p>
</blockquote>

<p>The inline keyword hardly plays a role in whether or not the compiler does any inlining. The use for the keyword in that regard is essentially deprecated. Modern compilers inline like crazy, and they know when to do it better tan any programmer does.</p>

<p>Any compiler worth dirt will say ""Hm, call this function to get this member variable; hey I can just get the member variable!"" You're worrying about nothing. This happens regardless of any inline keywords.</p>

<p>That said, I almost always use the member functions. If I change how a variable behaves when it's accessed, I now ""automatically"" apply that everywhere it's used. Clean code should be your goal, though, not a dogmatic ""always skip functions"" or not.</p>

<p>Anytime I just want a variable value, I use the corresponding member variable. (i.e, if I were writing <code>std::vector</code>, if I needed to check if the size was less than something, I'd say <code>size() &lt; x</code>). But if it's cleaner to use the variable directly, do that instead, such as <code>mSize++</code>.</p>

<p><code>const</code>-ness is irrelevant. If you're in a non-const function, you'll use the non-const version of your getter, same with const. Obviously, using the members directly maintains const-ness. There is no difference.</p>
"
"<p>I'm starting to learn C++ and as an exercise decide to implement a simple <code>LinkedList</code> class (Below there is part of the code). I have a question regarding the way the copy constructor should be implemented and the best way the data on the original <code>LinkedList</code> should be accessed.</p>

<pre><code>    template &lt;typename T&gt;
    class LinkedList {

        struct Node {
            T data;
            Node *next;

            Node(T t, Node *n) : data(t), next(n) {};
        };

    public:
        LinkedList();
        LinkedList(const LinkedList&amp;);
        ~LinkedList();

        //member functions
        int size() const;              //done
        bool empty() const;            //done
        void append(const T&amp;);         //done
        void prepend(const T&amp;);        //done
        void insert(const T&amp;, int i); 
        bool contains(const T&amp;) const; //done
        bool removeOne(const T&amp;);      //done
        int  removeAll(const T&amp;);      //done
        void clear();                  //done
        T&amp; last();                     //done
        const T&amp; last() const;         //done
        T&amp; first();                    //done
        const T&amp; first() const;        //done
        void removeFirst();            //done
        T takeFirst();                 //done
        void removeLast();
        T takeLast();


        //delete when finished
        void print();                  
        //end delete

        //operators
        bool operator ==(const LinkedList&lt;T&gt; &amp;other) const;    //done
        bool operator !=(const LinkedList&lt;T&gt; &amp;other) const;    //done
        LinkedList&lt;T&gt;&amp; operator =(const LinkedList&lt;T&gt; &amp;other); //done


    private:
        Node* m_head;
        Node* m_tail;
        int   m_size;

    };

    template&lt;typename T&gt;
    LinkedList&lt;T&gt;::LinkedList() : m_head(0), m_tail(0), m_size(0) {

    }
...
</code></pre>

<p>Should my copy constructor access the data on each node of the original <code>LinkedList</code> directly?</p>

<pre><code>template&lt;typename T&gt;
LinkedList&lt;T&gt;::LinkedList(const LinkedList&amp; l) {

    m_head = 0;
    m_tail = 0;
    m_size = 0;

    Node *n = l.m_head;

    // construct list from given list
    while(n) {
        append(n-&gt;data);
        n = n-&gt;next;
    }
}
</code></pre>

<p>Or should I access the data through the corresponding accessor? (I know that I don't have the accessor(s) defined).</p>

<p>Also, I intend to create a custom iterator so that it can be possible to iterate over the <code>LinkedList</code>. Should I use in the copy constructor to access the data on each node? </p>

<p>Another question (completely off-topic, I know), when and/or why should we declare a pointer to a <code>LinkedList</code></p>

<pre><code>LinkedList&lt;int&gt; *l = new LinkedList&lt;int&gt;(); 
</code></pre>

<p>instead of</p>

<pre><code>LinkedList&lt;int&gt; l;
</code></pre>
","87234","","<p>I assume append will properly handle the initial head/tail details, yes? If so, what you have now is great and simple: Go through the other list, and take its item and add a copy to my list. Perfect.</p>

<p>Well, almost. Use an initializer list to initialize member variables:</p>

<pre><code>template&lt;typename T&gt;
LinkedList&lt;T&gt;::LinkedList(const LinkedList&amp; l) :
m_head(0), m_tail(0), m_size(0)
{
 // ...
}
</code></pre>

<p>Also, maybe a matter of style, this woks instead of a while loop:</p>

<pre><code>// construct list from given list
for (Node *n = l.m_head; n != 0; n = n-&gt;next)
    append(m-&gt;data);
</code></pre>

<p>In fact, I'd recommend this instead. When you have iterators, you'd do something like:</p>

<pre><code>for (const_iterator iter = l.begin(); iter != l.end(); ++iter)
    append(*iter);
</code></pre>

<p>It just follows the style of a for-loop better. (Initialize something, check something, do something). Though for iterators, it'll probably be different. (More later)</p>

<hr>

<blockquote>
  <p>Or should I access the data through the corresponding accessor? (I know that I don't have the accessor(s) defined).</p>
  
  <p>Also, I intend to create a custom iterator so that it can be possible to iterate over the LinkedList. Should I use in the copy constructor to access the data on each node?</p>
</blockquote>

<p>Those iterators are your accessors. You <em>don't</em> want to expose your internal head-tail pointers, that a recipe for disaster. The purpose of the class is to <em>not</em> expose the details. That said, iterators are the abstract wrapper around those details.</p>

<p>Once you have your iterators, then you could use them to iterate through the list instead of pointer arithmetic. This ties in to this recently <a href=""http://stackoverflow.com/questions/2374009/calling-this-get-this-set-methods-versus-directly-accesing-member-variables-in/2374051"">asked question</a>. In general, you should use your abstractions to deal with your data. So yes once you have your iterators 
in place, you should use those to iterate across the data.</p>

<p>Most classes that provide iterators also provide a way to insert data given a beginning and ending iterator. This is usually called <code>insert</code>, like this: <code>insert(iterBegin, iterEnd)</code>. This loops through the iterators, appending it's data to the list.</p>

<p>If you had such functionality, your copy-constructor would simply be:</p>

<pre><code>insert(l.begin(), l.end()); // insert the other list's entire range
</code></pre>

<p>Where <code>insert</code> is implemented like the for-loop we had above.</p>

<hr>

<blockquote>
  <p>Another question (completely off-topic, I know), when and/or why should we declare a pointer to a LinkedList</p>
  
  <p>LinkedList *l = new LinkedList(); instead of LinkedList l;</p>
</blockquote>

<p>The first is dynamic allocation, the second is automatic (stack) allocation. You should prefer stack allocation. It's almost always faster, and safer too (since you don't need to delete anything). In fact, a concept called RAII relies on automatic storage, so destructors are guaranteed to run.</p>

<p>Only use dynamic allocation when you have to.</p>
"
"<p><a href=""http://www.cppreference.com/wiki/operator_precedence"">This</a> is the only place I've ever seen <code>and</code>, <code>or</code> and <code>not</code> listed as actual operators in C++. When I wrote up a test program in NetBeans, I got the red underlining as if there was a syntax error and figured the website was wrong, but it is NetBeans which is wrong because it compiled and ran as expected.</p>

<p>I can see <code>!</code> being favored over <code>not</code> but the readability of <code>and</code> &amp;&amp; <code>or</code> seems greater than their grammatical brothers. Why do these versions of the logical operators exist and why does seemingly no one use it? Is this truly valid C++ or some sort of compatibility with C that was included with the language?</p>
","87234","","<p>They originated in C in the header <a href=""http://en.wikipedia.org/wiki/Iso646.h""><strong><code>&lt;iso646.h&gt;</code></strong></a>. At the time there were keyboards that couldn't type the required symbols for <code>&amp;&amp;</code> (for example), so the header contained <code>#define</code>'s that would assist them in doing so, by (in our example) defining <code>and</code> to be <code>&amp;&amp;</code>. Of course, as time went by this became less used.</p>

<p>In C++, they became what are known as <em>alternate tokens</em>. You do <strong>not</strong> need to include anything to use these tokens in a compliant compiler (as such, the C++-ified version of the C header, <code>&lt;ciso646&gt;</code>, is blank). Alternate tokens are just like regular tokens, except for spelling. So during parsing <code>and</code> is <em>exactly</em> the same as <code>&amp;&amp;</code>, it's just a different way of spelling the same thing.</p>

<p>As for their use: because they are rarely used, using them is often more surprising and confusing than it is helpful. I'm sure if it were normal, they would be much easier to read, but people are so used to <code>&amp;&amp;</code> and <code>||</code> anything else just gets distracting.</p>

<p>EDIT: I have seen a very slight increase in their usage since I posted this, however. I still avoid them.</p>
"
"<pre><code>std::map&lt;std::string, int&gt; m;
// Can I make assumption that m[""NoSuchKey""] will return 0?
std::cout &lt;&lt; m[""NoSuchKey""] &lt;&lt; std::endl;
</code></pre>
","87234","","<p>Yes. When an item is accessed through <code>operator[]</code> that does not exist, it is created with a default-constructed value, and returned.</p>

<p>For numeric types, default-constructed means 0.</p>
"
"<p>This is just a quick question to understand correctly what happens when you create a class with a constructor like this:</p>

<pre><code>class A
{
  public:
    A() {}
};
</code></pre>

<p>I know that no default constructor is generated since it is already defined but are copy and assignment constructors generated by the compiler or in other words do i need to 
declare a private copy constructor and a private assignment operator in order to prevent this from happening?</p>

<pre><code>class A
{
  private:
    // needed to prevent automatic generation?
    A( const A&amp; );
    A&amp; operator=( const A&amp; );
  public:
    A() {}
};
</code></pre>
","87234","","<p>Yes. The copy constructor, assignment operator, and destructor are always created regardless of other constructors and operators.</p>

<p>If you want to disable one, what you've got there is perfect. It's quite common too.</p>
"
"<p>Please consider the following code,</p>

<pre><code>struct foo
{
    foo()
    {
        std::cout &lt;&lt; ""Constructing!"" &lt;&lt; std::endl;
    }

    foo(const foo&amp; f)
    {
        std::cout &lt;&lt; ""Copy constructing!"" &lt;&lt; std::endl;
    }

    ~foo()
    {
        std::cout &lt;&lt; ""Destructing.."" &lt;&lt; std::endl;
    }
};

foo get()
{
    foo f;
    return f;
}

int main()
{
    const foo&amp; f = get();
    std::cout &lt;&lt; ""before return"" &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p><strong>Output on MSVC</strong></p>

<pre><code>Constructing!
Copy constructing!
Destructing..
before return
Destructing..
</code></pre>

<p><strong>Output of GCC</strong></p>

<pre><code>Constructing!
before return
Destructing..
</code></pre>

<p>The result which comes on MSVC looks incorrect. </p>

<p><strong>Questions</strong></p>

<ol>
<li>AFAIK, GCC produces the correct result here. Why MSVC is giving different results and why it is doing copy construction?</li>
<li><code>const foo&amp; f = get()</code> and <code>const foo f = get()</code> produces same output because of return value optimization. In this case, which way of writing should be preferred?</li>
</ol>

<p>Any thoughts..</p>
","87234","","<p>Your MSVC build has no optimizations on. Turn them on, you'll get identical output for both.</p>

<p>GCC is merely performing, by default, RVO on your temporary. It's basically doing:</p>

<pre><code>const foo&amp; f = foo();
</code></pre>

<p>MSVC is not. It's making the <code>foo</code> in the function, copying it to the outside the function (ergo the copy-constructor call), destructing the inner <code>foo</code>, then binds the reference.</p>

<p>Both outputs are correct. RVO is one instance where the standard explicitly allows the observable behavior of the program to change.</p>
"
"<p>Is there an easy way to check if a file is empty.  Like if you are passing a file to a function and you realize it's empty, then you close it right away?  Thanks.</p>

<p>Edit, I tried using the fseek method, but I get an error saying 'cannot convert ifstream to FILE *'.  </p>

<p>My function's parameter is </p>

<pre><code>myFunction(ifstream &amp;inFile)
</code></pre>
","87234","","<p>Perhaps something akin to:</p>

<pre><code>bool is_empty(std::ifstream&amp; pFile)
{
    return pFile.peek() == std::ifstream::traits_type::eof();
}
</code></pre>

<p>Short and sweet.</p>

<hr>

<p>With concerns to your error, the other answers use C-style file access, where you get a <code>FILE*</code> with specific functions.</p>

<p>Contrarily, you and I are working with C++ streams, and as such cannot use those functions. The above code works in a simple manner: <code>peek()</code> will peek at the stream and return, without removing, the next character. If it reaches the end of file, it returns <code>eof()</code>. Ergo, we just <code>peek()</code> at the stream and see if it's <code>eof()</code>, since an empty file has nothing to peek at.</p>

<p>Note, this also returns true if the file never opened in the first place, which should work in your case. If you don't want that:</p>

<pre><code>std::ifstream file(""filename"");

if (!file)
{
    // file is not open
}

if (is_empty(file))
{
    // file is empty
}

// file is open and not empty
</code></pre>
"
"<p>If I define a non-member function in a header, will it always be inlined by the compiler, or does the compiler choose based on its heuristics? I know that __inline is just a hint, is it the same with functions in headers?</p>
","87234","","<p>Remember that including something from a header is no different than just typing it directly in the source file. So being in a header makes no difference as far as the compiler is concerned; it never knew it was there.</p>

<p>So when you define a function in a header file, and you include that header file in a file, it's like you just typed the function straight into the file. So now the question is, ""does the compiler choose to inline things based on heuristics?""</p>

<p>The answer is ""it depends on the compiler"". The standard makes no guarantees about what gets inlined or not. That said, any modern compiler will be extremely intelligent about what it inlines, likely with heuristics.</p>

<p>However, we come to an interesting point. Imagine you have a function in a header and you include that header in multiple source files. You will then have multiple definitions of the function, across translation units, and this violates the one-definition rule. Ergo, you will get compile errors. (The linker error is usually something along the lines of: ""Error, function x already defined in y"") What you can do is use the <code>inline</code> keyword and you no longer violate the ODR.</p>

<p>By the way <code>__inline</code> is non-standard. Contrary to your post, it's usually a compiler extension which <em>forces</em> inlining, not hints it. <code>inline</code> is the standard keyword, which was originally intended to hint at inlining. Like you say, most modern compilers completely ignore it in that regard and it's only purpose nowadays is to give things internal linkage.</p>
"
"<p>I've started to learn c++ using ""C++ Primer by Stephen Prate"" and I'm currently trying to complete one of the exercises. I am wondering if I should declare arc_to_minute &amp; arc_to_degree as float or cast them as float as I've done already. Any tips welcome!</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    using namespace std;
    cout.setf(ios_base::fixed, ios_base::floatfield);

    const int arc_to_minute = 60;
    const int arc_to_degree = 60;

    float degrees;
    float minutes;
    int seconds;

    cout &lt;&lt; ""Degrees: "";
    cin &gt;&gt; degrees;
    cout &lt;&lt; ""Minutes: "";
    cin &gt;&gt; minutes;
    cout &lt;&lt; ""Seconds: "";
    cin &gt;&gt; seconds;

    //convert seconds to minutes and add
    minutes = minutes + seconds / float (arc_to_minute);

    //covert minutes to degrees and add
    degrees = degrees + minutes / float (arc_to_degree);

    cout &lt;&lt; degrees;
}
</code></pre>
","87234","","<p>Make them floats, there's no reason for them to be integers when all your calculations are done in floating point:</p>

<pre><code>const float arc_to_minute = 60.0f;
const float arc_to_degree = 60.0f;
</code></pre>

<p>Keep in mind in a constant-value case the cast will be done at compile-time anyway, so this is purely a design choice, with no performance changes. But in general, if you find yourself casting, you probably chose the incorrect data type to begin with.</p>

<p>For what it's worth, you should prefer C++ style casts when you do need to cast. For example:</p>

<pre><code>static_cast&lt;float&gt;(arc_to_minute);
</code></pre>
"
"<p>I am working on a school project with OpenCV.  A major part of the program will be a comparison of histograms.  There will be a database of histograms and new histograms will be created from a live video feed then compared to the histograms in the database.  Right now I am just trying to get the histograms created correctly from the video feed.  <strong>My problem is that the program crashes or slows down dramatically at random intervals. So my question is how do I prevent the program from crashing or slowing down?</strong>  OpenCV has always been kind of flaky for me, so I'm not sure if it is an issue with my code or if it is just the nature of OpenCV.  If it is to do with my code I think the issue might have something to do with the frame rates (a guess/gut feeling).  I am useing ""cvWaitKey"" to ""pace"" the loading of frames, but the ""Learning OpenCV"" book has this to say about ""cvWaitKey""</p>

<p><em>c = cvWaitKey(33);
if( c == 27 ) break;
Once we have displayed the frame, we then wait for 33 ms. If the user hits a key, then c
will be set to the ASCII value of that key; if not, then it will be set to –1. If the user hits
the Esc key (ASCII 27), then we will exit the read loop. Otherwise, 33 ms will pass and
we will just execute the loop again.
It is worth noting that, in this simple example, we are not explicitly controlling
the speed of the video in any intelligent way. We are relying solely on the timer in
cvWaitKey() to pace the loading of frames. In a more sophisticated application it would
be wise to read the actual frame rate from the CvCapture structure (from the AVI) and
behave accordingly!</em></p>

<p>You will see in my code below (modified from <a href=""http://blog.isaias.com.mx/2005/12/1d-histogram-with-opencv-c.html"" rel=""nofollow"">here</a>) that I my loop waits 10ms before starting the next execution.  Often times the program will run with no issues at all, but sometimes it will crash less than a minute in, or five minutes in, there really is not pattern that I can detect.  <strong>Any suggestions on how this crash( or slow down) can be prevented would be welcomed.</strong>  Also I should add that I am using OpenCV 1.1 (can't ever get OpenCV 2.0 to work right), I am using Visual Studio 2008, and I create an .MSI installer package everytime I modify my code, that is, I do not debug in Visual Studio.  Dependencies are cv110.dll, cxcore110.dll, and highgui110.dll.  My code is below:</p>

<pre><code>// SLC (Histogram).cpp : Defines the entry point for the console application.

#include ""stdafx.h""
#include &lt;cxcore.h&gt;
#include &lt;cv.h&gt;
#include &lt;cvaux.h&gt;
#include &lt;highgui.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;

using namespace std;

int main(){

    CvCapture* capture = cvCaptureFromCAM(0);

    if(!cvQueryFrame(capture)){
        cout&lt;&lt;""Video capture failed, please check the camera.""&lt;&lt;endl;
    }

    else{
        cout&lt;&lt;""Video camera capture successful!""&lt;&lt;endl;
    };

    CvSize sz = cvGetSize(cvQueryFrame(capture));

    IplImage* image = cvCreateImage(sz, 8, 3);
    IplImage* imgHistogram = 0;
    IplImage* gray = 0;
    CvHistogram* hist;

    cvNamedWindow(""Image Source"",1);
    cvNamedWindow(""Histogram"",1);

    for(;;){

        image = cvQueryFrame(capture);

        //Size of the histogram -1D histogram
        int bins = 256;
        int hsize[] = {bins};

        //Max and min value of the histogram
        float max_value = 0, min_value = 0;

        //Value and normalized value
        float value;
        int normalized;

        //Ranges - grayscale 0 to 256
        float xranges[] = {0, 256};
        float* ranges[] = {xranges};

        //Create an 8 bit single channel image to hold a grayscale version of the original picture
        gray = cvCreateImage(cvGetSize(image), 8, 1);
        cvCvtColor(image, gray, CV_BGR2GRAY);

        //Planes to obtain the histogram, in this case just one
        IplImage* planes[] = {gray};

        //Get the histogram and some info about it
        hist = cvCreateHist(1, hsize, CV_HIST_ARRAY, ranges,1);
        cvCalcHist(planes, hist, 0, NULL);
        cvGetMinMaxHistValue(hist, &amp;min_value, &amp;max_value);
        printf(""Minimum Histogram Value: %f, Maximum Histogram Value: %f\n"", min_value, max_value);

        //Create an 8 bits single channel image to hold the histogram and paint it white
        imgHistogram = cvCreateImage(cvSize(bins, 50),8,3);
        cvRectangle(imgHistogram, cvPoint(0,0), cvPoint(256,50), CV_RGB(255,255,255),-1);

        //Draw the histogram
        for(int i=0; i &lt; bins; i++){
            value = cvQueryHistValue_1D(hist, i);
            normalized = cvRound(value*50/max_value);
            cvLine(imgHistogram,cvPoint(i,50), cvPoint(i,50-normalized), CV_RGB(0,0,0));
        }

        cvFlip(image, NULL, 1);
        cvShowImage(""Image Source"", image);
        cvShowImage(""Histogram"", imgHistogram);

        //Page 19 paragraph 3 of ""Learning OpenCV"" tells us why we DO NOT use ""cvReleaseImage(&amp;image)"" in this section
        cvReleaseImage(&amp;imgHistogram);
        cvReleaseImage(&amp;gray);
        cvReleaseHist(&amp;hist);

        char c = cvWaitKey(10);

        //if ASCII key 27 (esc) is pressed then loop breaks
        if(c==27) break;

    }

    cvReleaseImage(&amp;image);
    cvReleaseCapture(&amp;capture);
    cvDestroyAllWindows();

}
</code></pre>
","87234","","<p>Only a few things I can see or recommend:</p>

<p>Considering the build, make sure you're building in Release. Also, make sure the build of OpenCV you're using was built with OpenMP enabled, it makes an enormous difference.</p>

<p>Try moving your allocations outside the loop. Every loop you're re-creating <code>gray</code> and other images, when they should be re-used.</p>

<p>The other thing is your style, which makes it difficult to give good recommendations easily. It's poor style to pre-declare a bunch of variables, this is C-style. Declare your variables just prior to their use, and the code will be easier to read.</p>
"
"<p>Macros are fine.
Templates are fine.
Pretty much whatever it works is fine.</p>

<p>The example is OpenGL; but the technique is C++ specific and relies on no knowledge of OpenGL.</p>

<p>Precise problem:</p>

<p>I want an expression E; where I do not have to specify a unique name; such that a constructor is called where E is defined, and a destructor is called where the block E is in ends.</p>

<p>For example, consider:</p>

<pre><code>class GlTranslate {
  GLTranslate(float x, float y, float z); {
    glPushMatrix();
    glTranslatef(x, y, z);
  }
  ~GlTranslate() { glPopMatrix(); }
</code></pre>

<p>};</p>

<p>Manual solution:</p>

<pre><code>{
  GlTranslate foo(1.0, 0.0, 0.0); // I had to give it a name
  .....
} // auto popmatrix
</code></pre>

<p>Now, I have this not only for glTranslate, but lots of other PushAttrib/PopAttrib calls too. I would prefer not to have to come up with a unique name for each var. Is there some trick involving macros templates ... or something else that will automatically create a variable who's constructor is called at point of definition; and destructor called at end of block?</p>

<p>Thanks!</p>
","87234","","<p>If your compiler supports <code>__COUNTER__</code> (it probably does), you could try:</p>

<pre><code>// boiler-plate
#define CONCATENATE_DETAIL(x, y) x##y
#define CONCATENATE(x, y) CONCATENATE_DETAIL(x, y)
#define MAKE_UNIQUE(x) CONCATENATE(x, __COUNTER__)

// per-transform type
#define GL_TRANSLATE_DETAIL(n, x, y, z) GlTranslate n(x, y, z)
#define GL_TRANSLATE(x, y, z) GL_TRANSLATE_DETAIL(MAKE_UNIQUE(_trans_), x, y, z)
</code></pre>

<p>For</p>

<pre><code>{
    GL_TRANSLATE(1.0, 0.0, 0.0);

    // becomes something like:
    GlTranslate _trans_1(1.0, 0.0, 0.0);

} // auto popmatrix
</code></pre>
"
"<p>This simple example fails to compile in VS2K8:</p>

<pre><code>    io_service io2;
    shared_ptr&lt;asio::deadline_timer&gt; dt(make_shared&lt;asio::deadline_timer&gt;(io2, posix_time::seconds(20)));
</code></pre>

<p>As does this one:</p>

<pre><code>shared_ptr&lt;asio::deadline_timer&gt; dt = make_shared&lt;asio::deadline_timer&gt;(io2);
</code></pre>

<p>The error is:</p>

<blockquote>
  <p>error C2664: 'boost::asio::basic_deadline_timer::basic_deadline_timer(boost::asio::io_service &amp;,const boost::posix_time::ptime &amp;)' : cannot convert parameter 1 from 'const boost::asio::io_service' to 'boost::asio::io_service &amp;'</p>
</blockquote>
","87234","","<p>The problem is that <code>asio::deadline_timer</code> has a constructor that requires a non-const reference to a service. However, when you use <code>make_shared</code> its parameter is <code>const</code>. That is, this part of <code>make_shared</code> is the problem:</p>

<pre><code>template&lt; class T, class A1 &gt; // service is passed by const-reference
boost::shared_ptr&lt; T &gt; make_shared( A1 const &amp; a1 )
{
    // ...

    ::new( pv ) T( a1 ); // but the constructor requires a non-const reference

    // ...
}
</code></pre>

<p>What you can do is wrap the service up into a <code>reference_wrapper</code>, using <code>ref</code>:</p>

<pre><code>#include &lt;boost/ref.hpp&gt;

asio::io_service io1;
shared_ptr&lt;asio::deadline_timer&gt; dt = // pass a ""reference""
    make_shared&lt;asio::deadline_timer&gt;(boost::ref(io1));
</code></pre>

<p>This takes your instance, and puts it into an object that can be converted implicitly to a reference to your isntance. You've then essentially passed an object <em>representing</em> a non-const reference to your instance.</p>

<p>This works because the <code>reference_wrapper</code> really stores a pointer to your instance. It can therefore return that pointer dereferenced while still being <code>const</code>.</p>
"
"<p>I would like my class to have a static pointer to a dynamically allocated region of memory.  I understand how to initialize it - in my case I will initialize it when the first object needs it.  However, I don't know when/where in the code to free it.  I'd like to free it when the program terminates.</p>

<p>I might be able to free the pointer in my objects' destructor, but then I'd have to maintain an object count to see if it's safe to free when the object is the last object in use.  </p>

<p>Is there a more elegant way to do this? </p>

<p>Please let me know.</p>

<p>Thanks,
jbu</p>
","87234","","<p>Throw it in a smart pointer. It will have static lifetime and be destroyed after <code>main</code> returns:</p>

<pre><code>static std::auto_ptr&lt;T&gt; thePointer;
</code></pre>

<p>Another option is to register your own <code>atexit</code> function:</p>

<pre><code>// static
void YourClass::freePointer(void)
{
    delete getPointer();
}

// static
T* YourClass::getPointer(void)
{
    if (!thePointer)
    {
        thePointer = new T;
        atexit(freePointer);
    }

    return thePointer;
}
</code></pre>

<p>Which will have the same effect. Another option you already mention is to keep a static counter. Note you can actually wrap that up pretty effectively.</p>
"
"<p>Let's assume we have a template function ""foo"":</p>

<pre><code>template&lt;class T&gt;
void foo(T arg)
{ ... }
</code></pre>

<p>I can make specialization for some particular type, e.g.</p>

<pre><code>template&lt;&gt;
void foo(int arg)
{ ... }
</code></pre>

<p>If I wanted to use the same specialization for all builtin numeric types (int, float, double etc.) I would write those lines many times. I know that body can be thrown out to another function and just call of this is to be made in every specialization's body, however it would be nicer if i could avoid writting this ""void foo(..."" for every type. Is there any possibility to tell the compiler that I want to use this specialization for all this types?</p>
","87234","","<p>With boost:</p>

<pre><code>#include &lt;boost/type_traits/is_scalar.hpp&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

namespace detail
{
    typedef const boost::true_type&amp; true_tag;
    typedef const boost::false_type&amp; false_tag;

    template &lt;typename T&gt;
    void foo(const T&amp; pX, true_tag)
    {
        std::cout &lt;&lt; ""special: "" &lt;&lt; pX &lt;&lt; std::endl;
    }

    template &lt;typename T&gt;
    void foo(const T&amp; pX, false_tag)
    {
        std::cout &lt;&lt; ""generic: "" &lt;&lt; pX &lt;&lt; std::endl;
    }
}

template &lt;typename T&gt;
void foo(const T&amp; pX)
{
    detail::foo(pX, boost::is_scalar&lt;T&gt;());
}

int main()
{
    std::string s = "":D"";
    foo(s);
    foo(5);
}
</code></pre>

<p>You can mostly easily do it without boost:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

// boolean stuff
template &lt;bool B&gt;
struct bool_type {};

typedef bool_type&lt;true&gt; true_type;
typedef bool_type&lt;false&gt; false_type;

// trait stuff
template &lt;typename T&gt;
struct is_scalar : false_type
{
    static const bool value = false;
};

#define IS_SCALAR(x) template &lt;&gt; \
            struct is_scalar&lt;x&gt; : true_type \
            { \
                static const bool value = true; \
            };

IS_SCALAR(int)
IS_SCALAR(unsigned)
IS_SCALAR(float)
IS_SCALAR(double)
// and so on

namespace detail
{
    typedef const true_type&amp; true_tag;
    typedef const false_type&amp; false_tag;

    template &lt;typename T&gt;
    void foo(const T&amp; pX, true_tag)
    {
        std::cout &lt;&lt; ""special: "" &lt;&lt; pX &lt;&lt; std::endl;
    }

    template &lt;typename T&gt;
    void foo(const T&amp; pX, false_tag)
    {
        std::cout &lt;&lt; ""generic: "" &lt;&lt; pX &lt;&lt; std::endl;
    }
}

template &lt;typename T&gt;
void foo(const T&amp; pX)
{
    detail::foo(pX, is_scalar&lt;T&gt;());
}

int main()
{
    std::string s = "":D"";
    foo(s);
    foo(5);
}
</code></pre>
"
"<p>I am tired of writing shared_ptr&lt;>, it's lengthening the code lines tremendously. Any reason not to do this?</p>
","87234","","<p>Why use macro's? Such a mechanism already exists:</p>

<pre><code>typedef boost::shared_ptr&lt;some_longer_name_omg_help&gt; pointer_type;

pointer_type p; // phew
</code></pre>

<hr>

<p>If you're asking about what Steve is suggesting in the comments, you could try:</p>

<pre><code>template &lt;typename T&gt;
struct sp
{
    typedef boost::shared_ptr&lt;T&gt; type;
};

typedef sp&lt;some_longer_name_omg_help&gt;::type pointer_type;
</code></pre>

<p>But I don't know if it's that much shorter.</p>

<p>I think your macro use is a sign of laziness, honestly. <code>boost::shared_ptr</code> is, in almost any reasonable measure of ""lengthy"", not lengthy at all. All you're doing is destroying readability.</p>
"
"<p>I am calculating intersection, union and differences of sets.
I have a typedef of my set type:</p>

<pre><code>typedef set&lt;node_type&gt; node_set;
</code></pre>

<p>When it is replaced with </p>

<pre><code>typedef hash_set&lt;node_type&gt; node_set;
</code></pre>

<p>The results are different. It's a complicated program, and before I start debugging - am I doing it right? When I use functions like this:</p>

<pre><code>set_intersection(v_higher.begin(), v_higher.end(), neighbors[w].begin(), neighbors[w].end(), 
            insert_iterator&lt;node_set&gt;(tmp1, tmp1.begin()));
</code></pre>

<ul>
<li>should they work seamlessly with both set and hash_set?</li>
</ul>
","87234","","<p>I'm going to go with no. Keep in mind <code>hash_set</code> isn't standard C++ and never will be, it's an older extension that's no longer supported. The newer ""hash maps"" are called <code>unordered_set</code> and <code>unordered_map</code>, available in TR1, Boost, and C++0x.</p>

<p>The reason it's a no is that <code>set_intersection</code> requires the input data to be sorted. Contrarily, the reason a hash map is so quick is it gives up ordering. This is obviously more pronounced under the name <code>unordered_set</code>. So the precondition cannot be reliably met.</p>
"
"<p>Why cant we initialize Const and reference varibales inside the constructor braces({ }) and is always done via initialization list</p>

<p>Thanks,
Sandeep</p>
","87234","","<p>The lifetime for a reference begins after it's initialized (like all variables), and once it's initialized it represents an alias to another variable. Consider:</p>

<pre><code>int&amp; x;

/// ...

SomeClassConstructor(void)
{ // initialization list is done, reference lifetime has begun, and
  // therefore is an alias. It already must alias a variable, then.

    x = 5; // setting whatever x is an alias for to 5
}
</code></pre>

<p>You see, once we enter the constructor, all member variables are initialized. For a reference, this means it must be referring to a variable. Ergo, we must initialize it to refer to something in the initialization list.</p>

<p>Likewise, assigning to a <code>const</code> variable is illegal: <code>const int x = 5; x = 2; // doesn't compile</code>. It must be initialized to a value, and it will remain the value for its lifetime. Therefore, it too must be initialized in the initialization list.</p>
"
"<p>assume this following function:</p>

<pre><code>int binaryTree::findHeight(node *n) {
    if (n == NULL) {
        return 0;
    } else {
        return 1 + max(findHeight(n-&gt;left), findHeight(n-&gt;right));
    }
}
</code></pre>

<p>Pretty standard recursive <code>treeHeight</code> function for a given binary search tree <code>binaryTree</code>. Now, I was helping a friend (he's taking an algorithms course), and I ran into some weird issue with this function that I couldn't 100% explain to him.</p>

<p>With max being defined as <code>max(a,b) ((a)&gt;(b)?(a):(b))</code> (which happens to be the max definition in <code>windef.h</code>), the recursive function freaks out (it runs something like <code>n^n</code> times where <code>n</code> is the tree height). This obviously makes checking the height of a tree with 3000 elements take very, very long.</p>

<p>However, if max is defined via templating, like <code>std</code> does it, everything is okay. So using <code>std::max</code> fixed his problem. I just want to know why.</p>

<p>Also, why does the <code>countLeaves</code> function work fine, using the same programmatic recursion?</p>

<pre><code>int binaryTree::countLeaves(node *n) {
    if (n == NULL) {
        return 0;
    } else if (n-&gt;left == NULL &amp;&amp; n-&gt;right == NULL) {
        return 1;
    } else {
        return countLeaves(n-&gt;left) + countLeaves(n-&gt;right);
    }
}
</code></pre>

<p>Is it because in returning the ternary function, the values <code>a =&gt; countLeaves(n-&gt;left)</code> and <code>b =&gt; countLeaves(n-&gt;right)</code> were recursively double called simply because they were the resultants?</p>

<p>Thank you!</p>

<h2>The question was answered below</h2>

<p>I just wanted to link some literature on the subject for future reference:<br>
<a href=""http://www.boostpro.com/tmpbook/preprocessor.html"" rel=""nofollow"">http://www.boostpro.com/tmpbook/preprocessor.html</a><br>
<a href=""http://msdn.microsoft.com/en-us/library/z3f89ch8.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/z3f89ch8.aspx</a></p>

<p>The main difference between the two implementations being:</p>

<pre><code>#define max(i, j) (((i) &gt; (j)) ? (i) : (j))
</code></pre>

<p>vs</p>

<pre><code>template&lt;class T&gt; T max (T i, T j) { return ((i &gt; j) ? i : j) }
</code></pre>

<p><strong>Thank you all!</strong></p>
","87234","","<p>Macros are expanded by the preprocessor, before the compiler gets to see the code. This means that, for example, macro parameters might be evaluated more than once.</p>

<p>With your macro, you're going to end up with something akin to:</p>

<pre><code>int binaryTree::findHeight(node *n) {
    if (n == NULL) {
        return 0;
    } else {
        return 1 + (findHeight(n-&gt;left) &gt; findHeight(n-&gt;right)) ? // call once...
                    findHeight(n-&gt;left) : findHeight(n-&gt;right); // and ouch
    }
}
</code></pre>

<p>As you can see, it's going to evaluate both functions, then one more an additional time. This is why macros can be evil.</p>

<p>You can disable the macro by defining <code>NOMINMAX</code> prior to including the Windows headers. Then use the function in <code>&lt;algorithm&gt;</code> instead.</p>

<p>If he must use the macro, he'll have to store the calculations in a variable:</p>

<pre><code>int binaryTree::findHeight(node *n) {
    if (n == NULL) {
        return 0;
    } else {
        const int leftHeight = findHeight(n-&gt;left);
        const int rightHeight = findHeight(n-&gt;right);
        return 1 + max(leftHeight, rightHeight);
    }
}
</code></pre>

<hr>

<p>With a function, each call will be evaluated <em>prior</em> to calling the function. That is, it's somewhat like the previous code block. It evaluates the function's arguments, gets the results, then passes those into the <code>std::max</code> function. There are no repeated evaluations.</p>
"
"<p>These are my errors:</p>

<blockquote>
  <p>error: static declaration of <code>doct</code> follows non-static declaration<br>
  error: previous declaration of <code>doct</code> was here.</p>
</blockquote>

<p>And my code is:</p>

<pre><code>int doct(int*); /* &lt;- Second error points here */

private int doct(int *a)
  {
    static int a=0; /* First error points here */
    a++;
    *a=a;
    return 0;
  }
</code></pre>

<p>Any suggestions?</p>
","87234","","<p>This error happens when a function was declared as non-static, then defined static, such as:</p>

<pre><code>void foo(void);

static void foo(void) {}
</code></pre>

<p>Make <code>static</code> match on both, either by removing it from both or adding it to both. Make sure you understand what <code>static</code> does.</p>

<p>If your function is marked <code>static</code>, it is only visible in that translation unit. In your case, your declaration has no static meaning ""this function will be available, non-statically."", but then you define it statically.</p>

<hr>

<p>There are other errors. The <code>a</code> in your function will hide the <code>a</code> in the parameter list. You need to give them different names. <code>*a = a</code> won't work because, in that scope, <code>a</code> is an integer, not a pointer. Use a descriptive name like <code>counter</code> for the integer.</p>
"
"<p>Respected sirs,</p>

<p>My name is @nimit. I want to create a batch file and run it in a DOS prompt.  The batch file will execute a C++ program I've written. The output should be stored in a single text-file.  How can I do this?</p>

<p>The C++ program output should be stored in a particular text file.</p>

<p>Thanks in advance, 
@nimit</p>
","87234","","<p>You can do this:</p>

<pre><code>programname &gt; outputgoeshere.txt
</code></pre>

<hr>

<p>To collect outputs:</p>

<pre><code>programname1 &gt;&gt; outputgoeshere.txt
programname2 &gt;&gt; outputgoeshere.txt
programname3 &gt;&gt; outputgoeshere.txt
</code></pre>
"
"<p>I have the code below in my test code in many places:</p>

<pre><code>  //
  // Make a function call while expecting an exception should be thrown
  //
  bool exceptionThrown = false;
  try
  {
    expectNotEqual(someData, anotherData, methodName);
  }
  catch(std::logic_error&amp;)
  {
    exceptionThrown = true;
  }
  if(!exceptionThrown)
    throw std::logic_error(methodName+""exception not thrown"");
</code></pre>

<p>It would be nice (more readable, concise) if I could encapsulate all that, and do something like:</p>

<pre><code>  exceptionShouldBeThrown(expectNotEqual(someData, anotherData, methodName));
</code></pre>

<p>I dont want to use macro ...does anyone know how I could achieve the one-liner above with C++? </p>
","87234","","<p>I know you say no macro's, but why? They exist for generating code:</p>

<pre><code>#define SHOULD_THROW(x, name) \
    { \
        bool didThrow = false; \
        try \
        { \
            x; \
        } \
        catch(...) { didThrow = true; } \
        \
        if (!didThrow) \
            throw std::logic_error(name "" did not throw.""); \
    }

SHOULD_THROW(expectNotEqual(someData, anotherData), ""expectNotEqual"")
</code></pre>

<p>If you really don't want to use macros, you need to make a functor to call:</p>

<pre><code>template &lt;typename Func&gt;
void should_throw(Func pFunc, const std::string&amp; pName)
{
    bool didThrow = false;
    try
    {
        pFunc();
    }
    catch (...)
    {
        didThrow = true;
    }

    if (!didThrow)
        throw std::logic_error(pName + "" did not throw."");
}
</code></pre>

<p><a href=""http://www.boost.org/doc/libs/1_42_0/libs/bind/bind.html"" rel=""nofollow"">Boost Bind</a> helps here:</p>

<pre><code>should_throw(boost::bind(expectNotEqual, someData, anotherData),
                ""expectNotEqual"");
</code></pre>

<p>Of course anything that makes a functor works, like lambda's, etc. But if Boost is available, just use their <a href=""http://www.boost.org/doc/libs/1_42_0/libs/test/doc/html/index.html"" rel=""nofollow"">testing library</a>:</p>

<pre><code>#define BOOST_TEST_MAIN
#include &lt;boost/test/unit_test.hpp&gt;

BOOST_AUTO_TEST_CASE(test)
{
    BOOST_CHECK_THROW(expectNotEqual(someData, anotherData) , std::logic_error);
}
</code></pre>
"
"<p>I got the answer NO! Because passing by value and passing by reference looks identical to the caller.</p>

<p>However, the code below compiles right</p>

<pre><code>class A {

public:
void f(int i) {}    

void f(int&amp; i) {}
};
</code></pre>

<p>But when I try to use it, there is compile error.</p>

<pre><code>int main () {

   A a;
   int i = 9;
   int&amp; j = i;
   a.f(1);
   a.f(i);
   a.f(j);
  return 0;
}
</code></pre>

<p>Why does not the compiler disable it even without knowing it is going to be used?</p>
","87234","","<p>Yes, they can be overloaded based on reference or not. That is why it's perfectly fine to have them coexist like that; they are different.</p>

<p>The problem has to do with ambiguity. While <code>f(1)</code> can only be called on one variation, <code>f(i)</code> can be called on both. Neither is preferable, therefore you get an error for ambiguity. If you added a third function, <code>foo (const int&amp;)</code>, <strong>all</strong> calls would be ambiguous. But all are still overloads of each other, and non-conflicting.</p>

<p>I agree it's strange to be able to have three overloads of a function, and be able to directly call none. Perhaps someone else has more to add.</p>
"
"<p>Why won't the following C code compile? It seems like it should just change the pointers' address but it throws an error. </p>

<pre><code>int x[10];
int y[10];
y=x;
</code></pre>
","87234","","<p>What pointers? You have two arrays. Arrays are not pointers. Pointers hold the address of a single variable in memory, while arrays are a contiguous collection of elements up to a specified size.</p>

<p>That said, arrays cannot be assigned. Conceivably, saying <code>y = x</code> could copy every element from <code>x</code> into <code>y</code>, but such a thing is dangerous (accidentally do an expensive operation with something as simple looking as an assignment). You can do it manually, though:</p>

<pre><code>for (unsigned i = 0; i &lt; 10; ++i)
    y[i] = x[i];
</code></pre>
"
"<p>I want to make a simple macro with #define for returning the smaller of two numbers.</p>

<p>How can i do this in C ? Suggest some ideas, and see if you can make it more obfuscated too. </p>
","87234","","<p>Typically:</p>

<pre><code>#define min(a, b) (((a) &lt; (b)) ? (a) : (b))
</code></pre>

<p>Be warned this evaluates the minimum twice, which was the reason for disaster in a <a href=""http://stackoverflow.com/questions/2445514/returning-recursive-ternary-freaks-out/2445552#2445552"">recent question</a>.</p>

<p>But why would you want to obfuscate it?</p>

<hr>

<p>This one stores the result in a variable, and only evaluates each argument once. It's basically a poor-mans inline function + declaration:</p>

<pre><code>#define min(t, x, a, b) \
            t x; \
            { \
                t _this_is_a_unique_name_dont_use_it_plz_0_ = a; \
                t _this_is_a_unique_name_dont_use_it_plz_1_ = b; \
                x = _this_is_a_unique_name_dont_use_it_plz_0_ &lt; \  
                    _this_is_a_unique_name_dont_use_it_plz_1_ ? \
                    _this_is_a_unique_name_dont_use_it_plz_0_ : \  
                    _this_is_a_unique_name_dont_use_it_plz_1_ ; \
            }
</code></pre>

<p>Use it like:</p>

<pre><code>min(int, x, 3, 4)
/* x is an int, equal to 3
  Just like doing:

  int x = min(3, 4);

  Without double evaluation.
*/
</code></pre>
"
"<p>I am using a template function and I am passing and I may be sending instances of a variety of classes to a string stream. What can I do to make sure this continues to work?</p>

<p>Let me be more specific where do I define the behavior for this? Is there some member that should be on each class being sent to the string stream, should I in some enhance or extend the existing String stream (I was thinking building a class that inherits from sstream and overloads the &lt;&lt; operator to handle all the possible classes)? </p>

<p>I had trouble even finding documentation on this, so even links to more resources would be helpful.</p>
","87234","","<p>It sounds to me like you want to make stream insertion operators. for a class you want to be able to output to a stream, define the free function:</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const SomeClassType&amp; x)
{
    stream &lt;&lt; x.someData();

    return stream;
}
</code></pre>

<p>So if we have <code>SomeClassType z;</code>, and we do <code>std::cout &lt;&lt; z</code> (or any other output stream, like an <code>fstream</code> or <code>stringstream</code>), the compiler will look for and find our function, and call it. That is, <code>std::cout &lt;&lt; z</code> becomes <code>operator&lt;&lt;(std::cout, z)</code> and inside there you output what you need.</p>
"
"<p>Here is an exception defined in <code>&lt;stdexcept&gt;</code>:</p>

<pre><code>class length_error : public logic_error 
{
public:
    explicit length_error(const string&amp;  __arg);
};
</code></pre>

<p>Here is my exception:</p>

<pre><code>#include &lt;string&gt;
#include &lt;stdexcept&gt;
using namespace std;

class rpn_expression_error : public logic_error
{
public:
    explicit rpn_expression_error(const string&amp; __arg);
};
</code></pre>

<p>Why do I get this error when <code>&lt;stdexcept&gt;</code> does not?</p>

<pre><code>Undefined symbols:
  rpn_expression_error::rpn_expression_error(/*string*/ const&amp;), referenced from:
        ...
ld: symbol(s) not found
</code></pre>

<p>At @<em>sbi</em>'s request, here is a minimal example of my code at the moment:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std;

class RPN_Calculator {
public:
    class rpn_expression_error : public logic_error {
    public:
        explicit rpn_expression_error(const string&amp; arg) : logic_error(arg) {}
    };

    void Execute() {
        throw rpn_expression_error(""Hello"");
    }
};

int main() {
    RPN_Calculator calc;

    try {
        calc.Execute();
    } catch (exception e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }
}
</code></pre>

<p>I saved this as <code>rpn.cpp</code> and ran <code>make rpn</code><strike>to produce the error</strike>. </p>

<p><strong>The code now builds completely,</strong> however, the real program still gives me the original error.</p>

<p><strong>Note/Solution:</strong> Although the code above runs just fine, the same exception class in the real code <em>still</em> produces the linker error. To simplify, I just promoted <code>rpn_expression_error</code> to its own global-scope class, and that seems to have fixed the problem.</p>
","87234","","<p>There is a problem with the way you are catching your exceptions. Specifically, consider this code:</p>

<pre><code>struct Base
{
    virtual void do() { std::cout &lt;&lt; ""Base!"" &lt;&lt; std::endl; }
};

struct Derived : Base
{
    virtual void do() { std::cout &lt;&lt; ""Derived!"" &lt;&lt; std::endl; }
};

void foo(Base x)
{
    x.do();
}

int main()
{
    Derived d;
    foo(d); // &lt;--
}
</code></pre>

<p>On that marked line, <code>d</code> gets what is called ""sliced"". That is, in order to satisfy being a <code>Base</code>, everything that isn't part of <code>Base</code> gets sliced off! So the above code will output ""Base!"".</p>

<p>If we want the intended output, we need to make the parameter not a value:</p>

<pre><code>void foo(Base&amp; x) // polymorphic
{
    x.do();
}
</code></pre>

<p>Our above code would then display ""Derived!"", because it's no longer being sliced. (One could also use a pointer.)</p>

<p>So, take a look at your catch clause:</p>

<pre><code>catch (exception e)
</code></pre>

<p>Here, any exceptions you've thrown will be <em>sliced</em> into the base <code>std::exception</code> class, losing any derived information! This is why it's much more common (and possibly ""correct"") to catch-by-reference:</p>

<pre><code>catch (const exception&amp; e)
</code></pre>

<p>You'll now find <code>e.what()</code> returns the non-sliced error message, as intended.</p>

<h3>Old</h3>

<p>Here's how the entire thing should look (don't use <code>using namespace</code> in a header!):</p>

<pre><code>// rpn_expression_error.h
#include &lt;stdexcept&gt; // for logic_error
#include &lt;string&gt; // for string

class rpn_expression_error : public std::logic_error
{
public:
    explicit rpn_expression_error(const std::string&amp; pMsg);
};

// rpn_expression_error.cpp
#include ""rpn_expression_error.h""

rpn_expression_error::rpn_expression_error(const std::string&amp; pMsg) :
std::logic_error(pMsg)
{}
</code></pre>

<hr>

<h3>Older</h3>

<p>Because those exception classes are declared inside the standard namespace, but yours is not. <code>string</code> is inside the namespace <code>std</code> so they don't need to qualify it, but you do:</p>

<pre><code>#include &lt;string&gt;

// ...
                                    vvv 
explicit rpn_expression_error(const std::string&amp; arg);
</code></pre>

<p>Keep in mind I've changed your parameter name. Names that contain a double-underscore are reserved, and you shouldn't use them.</p>
"
"<p>How in C++ get array length with pointers only ? I know that tab name is pointer to first element, but what next ?</p>
","87234","","<p>You cannot. A pointer is just a memory location, and contains nothing special that could determine the size.</p>

<p>Since this is C++, what you can do is pass the array by reference like so:</p>

<pre><code>template &lt;typename T, size_t N&gt;
void handle_array(T (&amp;pX)[N])
{
    // the size is N

    pX[0] = /* blah */;
    // ...
    pX[N - 1] = /* blah */;
}

// for a specific type:
template &lt;size_t N&gt;
void handle_array(int (const &amp;pX)[N]) // const this time, for fun
{
    // the size is N

    int i = pX[0]; // etc
}
</code></pre>

<p>But otherwise you need to pass start &amp; end and do a subtraction, like Alok suggests, a start &amp; size, like you suggest, or ditch a static array and use a vector, like Tyler suggests.</p>

<p>If you know the size of the array you'll be working with, you can make a <code>typedef</code>:</p>

<pre><code>typedef int int_array[10];

void handle_ten_ints(int_array&amp; pX)
{
    // size must be 10
}
</code></pre>

<hr>

<p>And just for the size:</p>

<pre><code>template &lt;typename T, size_t N&gt;
size_t countof(T (&amp;pX)[N])
{
    return N;
}

template &lt;typename T, size_t N&gt;
T* endof(T (&amp;pX)[N])
{
    return &amp;pX[0] + N;
}

// use
int someArray[] = {1, 2, 6, 2, 8, 1, 3, 3, 7};

size_t count = countof(someArray); // 9
std::for_each(someArray, endof(someArray), /* ... */);
</code></pre>

<p>I use these utility functions from time to time.</p>
"
"<p>This is an interview question I faced recently.</p>

<hr>

<p>Given an array of 1 and 0, find a way to partition the bits <code>in place</code> so that 0's are grouped together, and 1's are grouped together. It does not matter whether 1's are ahead of 0's or 0's are ahead of 1's.</p>

<p>An example input is <code>101010101</code>, and output is either <code>111110000</code> or <code>000011111</code>.</p>

<p>Solve the problem in less than linear time.</p>

<p>Make the problem simpler. The input is an integer array, with each element either 1 or 0. Output is the same integer array with integers partitioned well.</p>

<hr>

<p>To me, this is an easy question if it can be solved in <strong>O</strong>(N). My approach is to use two pointers, starting from both ends of the array. Increases and decreases each pointer; if it does not point to the correct integer, swap the two.</p>

<pre>
    int * start = array;
    int * end = array + length - 1;

    while (start &lt end) {
        // Assume 0 always at the end
        if (*end == 0) {
            --end; 
            continue;
        }

        // Assume 1 always at the beginning
        if (*start == 1) {
            ++start; 
            continue;
        }

        swap(*start, *end);
    }
</pre>

<p>However, the interview insists there is a sub-linear solution. This makes me thinking hard but still not get an answer.</p>

<p>Can anyone help on this interview question?</p>

<p><strong>UPDATE</strong>: Seeing replies in SO stating that the problem cannot be solved in sub-linear time, I can confirm my original idea that there cannot be a solution of sub-linear. </p>

<p>Is it possible the interviewer plays a trick?</p>
","87234","","<p>Perhaps the confusion comes from ""less than linear time"". For example, this solution counts the number of bits, that makes a masks containing that many bits. It only counts bits while there are uncounted on-bits:</p>

<pre><code>// from http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan
unsigned count_bits(unsigned pX)
{
    unsigned result;
    for (result = 0; v; ++result)
    {
        pX &amp;= pX - 1;
    }

    return result;
}

unsigned n = /* the number */;

// r contains 000...111, with number of 1's equal to number of 1's in v
unsigned r = 1 &lt;&lt; count_bits(n); 
</code></pre>

<p>Even though this minimizes the number of bits to count, it's still linear. So if this is what is meant by ""sub-linear"", there you go.</p>

<p>But if they really meant sub-linear as in logarithmic or constant, I don't see a way. You could conceivably make a look-up table for every value, but :/</p>
"
"<p>I want to derive a stringstream so that I can use the operator&lt;&lt; to construct a message which will then be thrown. The API would look like:</p>

<pre><code>error(""some text"") &lt;&lt; "" more text "" &lt;&lt; 42 &lt;&lt; std::endl;
</code></pre>

<p>This should do a</p>

<pre><code>throw ""some text more text 42""
</code></pre>

<p>So what I did is make an errorbuf (inheriting from streambuf) which overloads the 'overflow' method and then create an ostream(&amp;errorbuf). I wonder if I shouldn't instead inherit from basic_ostringstream or something...</p>
","87234","","<p>You could probably make it easier by doing something like:</p>

<pre><code>class error_builder
{
public:
    error_builder(const std::string&amp; pMsg = """")
    {
        mMsg &lt;&lt; pMsg;
    }

    ~error_builder(void)
    {
        throw std::runtime_error(mMsg.str());
    }

    template &lt;typename T&gt;
    error_builder&amp; operator&lt;&lt;(const T&amp; pX)
    {
        mMsg &lt;&lt; pX;

        return *this;
    }

private:
    std::stringstream mMsg;    
};


error_builder(""some text"") &lt;&lt; "" more text "" &lt;&lt; 42 &lt;&lt; std::endl;
</code></pre>

<p>Note that you shouldn't throw strings like you are, hence I used <code>std::runtime_error</code>. All exceptions should derive from <code>std::exception</code>, which <code>runtime_error</code> does, that way all meaningful exceptions can be caught with const <code>std::exception&amp;</code>.</p>

<p>This works because the temporary lives until the end of the full expression.</p>
"
"<p>Suppose I have a STL map where the values are pointers, and I want to delete them all. How would I represent the following code, but making use of std::for_each? I'm happy for solutions to use Boost.</p>

<pre><code>for( stdext::hash_map&lt;int, Foo *&gt;::iterator ir = myMap.begin();
     ir != myMap.end();
     ++ir )
{
  delete ir-&gt;second; // delete all the (Foo *) values.
}
</code></pre>

<p>(I've found Boost's <code>checked_delete</code>, but I'm not sure how to apply that to the <code>pair&lt;int, Foo *&gt;</code> that the iterator represents).</p>

<p>(Also, for the purposes of this question, ignore the fact that storing raw pointers that need deleting in an STL container isn't very sensible).</p>

<p><strong>Note: I have subsequently found and listed a one-line answer below... but the code is pretty awful so I've accepted GMan's saner answer.</strong></p>
","87234","","<p>You have to make a function object:</p>

<pre><code>struct second_deleter
{
    template &lt;typename T&gt;
    void operator()(const T&amp; pX) const
    {
        delete pX.second;
    }
};

std::for_each(myMap.begin(), myMap.end(), second_deleter());
</code></pre>

<p>If you're using boost, you could also use the lambda library:</p>

<pre><code>namespace bl = boost::lambda;
std::for_each(myMap.begin(), myMap.end(), second_deleter(),
                bl::bind(bl::delete_ptr(), 
                bl::bind(std::select2nd&lt;myMap::value_type&gt;(), _1));
</code></pre>

<p>But you might try the <a href=""http://www.boost.org/doc/libs/1_42_0/libs/ptr_container/doc/ptr_map.html"">pointer containers</a> library which does this automatically.</p>

<p>Note you are not using a map, but a <code>hash_map</code>. I recommend you switch to boost's <code>unordered_map</code>, which is more current. However, there doesn't seem to be a <code>ptr_unordered_map</code>.</p>

<p>For safety, you should wrap this thing up. For example:</p>

<pre><code>template &lt;typename T, typename Deleter&gt;
struct wrapped_container
{
    typedef T container_type;
    typedef Deleter deleter_type;

    wrapped_container(const T&amp; pContainer) :
    container(pContainer)
    {}

    ~wrapped_container(void)
    {
        std::for_each(container.begin(), container.end(), deleter_type());
    }

    T container;
};
</code></pre>

<p>And use it like:</p>

<pre><code>typedef wrapped_container&lt;
            boost::unordered_map&lt;int, Foo*&gt;, second_deleter&gt; my_container;

my_container.container./* ... */
</code></pre>

<p>This ensures no matter what, your container will be iterated through with a deleter. (For exceptions, for example.)</p>

<p>Compare:</p>

<pre><code>std::vector&lt;int*&gt; v;
v.push_back(new int);

throw ""leaks!""; // nothing in vector is deleted

wrapped_container&lt;std::vector&lt;int*&gt; &gt; v;
v.container.push_back(new int);

throw ""no leaks!""; // wrapped_container destructs, deletes elements
</code></pre>
"
"<p>I have a class which has a private attribute vector rectVec;</p>

<pre><code>class A {
private:
   vector&lt;Rect&gt; rectVec;
};
</code></pre>

<p>My question is how can I return a 'read-only' copy of my Vector?
I am thinking of doing this:</p>

<pre><code>class A {
public:
  const vect&lt;Rect&gt;&amp; getRectVec() { return rectVect; }
}
</code></pre>

<p>Is that the right way? 
I am thinking this can guard against the callee modify the vector(add/delete Rect in vector), what about the Rect inside the vector?</p>
","87234","","<p>That's the normal way. <code>const</code> means ""you cannot modify this"". It also applies to the elements within the container.</p>

<p>A simple test:</p>

<pre><code>#include &lt;vector&gt;

typedef std::vector&lt;int&gt; int_vec;

struct foo
{
    const int_vec&amp; get(void)
    {
        return v;
    }

    int_vec v;
};

int main(void)
{
    foo f;
    f.v.push_back(1);
    f.v.push_back(2);
    f.v.push_back(3);

    f.get()[0] = 2; // nope
}
</code></pre>

<hr>

<p><code>const_cast</code> could be used to strip the <code>const</code> away, but you'd then end up with undefined behavior if you modified a variable through it:</p>

<pre><code>int_vec&amp; v = const_cast&lt;int_vec&amp;&gt;(f.get()); // this is okay
v[0] = 0; // but now we've entered undefined behavior
</code></pre>
"
"<p>Is the following well-defined in C++, or not? I am forced to 'convert' exceptions to return codes (the API in question is used by many C users, so I need to make sure all C++ exceptions are caught &amp; handled before control is returned to the caller).</p>

<pre><code>enum ErrorCode {…};
ErrorCode dispatcher() {
   try {
      throw;
   }
   catch (std::bad_alloc&amp;) {
      return ErrorCode_OutOfMemory;
   }
   catch (std::logic_error&amp;) {
      return ErrorCode_LogicError;
   }
   catch (myownstdexcderivedclass&amp;) {
      return ErrorCode_42;
   }
   catch(...) {
      return ErrorCode_UnknownWeWillAllDie;
   }
}

ErrorCode apifunc() {
   try {
      // foo() might throw anything
      foo();
   }
   catch(...) {
      // dispatcher rethrows the exception and does fine-grained handling
      return dispatcher();
   }
   return ErrorCode_Fine;
}

ErrorCode apifunc2() {
   try {
      // bar() might throw anything
      bar();
   }
   catch(...) {
      return dispatcher();
   }
   return ErrorCode_Fine;
}
</code></pre>

<p>I hope the sample shows my intention. My guess is that this is undefined behaviour, but I'm not sure. Please provide quotes from the standard, if applicable. Alternative approaches are appreciated as well.</p>

<p>Thanks!</p>
","87234","","<p>That's fine. The exception is active until it's caught, where it becomes inactive. But <em>it lives until the scope of the handler ends.</em> From the standard, emphasis mine:</p>

<blockquote>
  <p>§15.1/4:
  The memory for the temporary copy of the exception being thrown is allocated in an unspecified way, except as noted in 3.7.4.1. <em>The temporary persists as long as there is a handler being executed for that exception.</em></p>
</blockquote>

<p>That is:</p>

<pre><code>catch(...)
{ // &lt;--

    /* ... */

} // &lt;--
</code></pre>

<p>Between those arrows, you can re-throw the exception. Only when the handlers scope ends does the exception cease to exist.</p>

<p>Keep in mind if you call <code>dispatch</code> without an active exception, <code>terminate</code> will be called. If <code>dispatch</code> throws an exception in one if it's handlers, <em>that</em> exception will begin to propagate. More information in <a href=""http://stackoverflow.com/questions/2474429/does-throw-inside-a-catch-ellipsis-rethrow-the-original-error"">a related question</a>.</p>
"
"<p>I need an array to hold member-function-pointers of different classes. How can I define the array?</p>

<p>The code should look like this :</p>

<pre><code>arr[0] = &amp;CMyClass::FuncX;
arr[1] = &amp;CYourClass::FuncY;
arr[2] = &amp;CHerClass::FuncZ;
</code></pre>

<p>I tried void*, but it doesn't work.</p>

<p>Thanks.</p>

<p>Best regards,
Zach@Shine</p>
","87234","","<p>You can't; they are all different types and arrays are homogeneous.</p>

<p>Regardless what the arguments are or what the return value is, there is an implicit <code>this</code> which is unique to the class type. The type of a class member pointer is:</p>

<pre><code>return_value (class_type::*)(parameters);
</code></pre>

<p>As you can see, because they belong to different classes they will always be a different type. Even if it were the same class, the <code>return_value</code> and <code>parameters</code> would have to be consistent to create an array, otherwise you'd still have different types.</p>

<p>What's the bigger picture? <a href=""http://www.boost.org/doc/libs/1_42_0/libs/bind/bind.html"" rel=""nofollow"">Boost.Bind</a> with <a href=""http://www.boost.org/doc/libs/1_42_0/doc/html/function.html"" rel=""nofollow"">Boost.Function</a> comes to mind. Also, virtual functions may solve your problem.</p>
"
"<p>Consider the following code:</p>

<pre><code>#include &lt;iostream&gt;

struct foo
{
    void bar() { std::cout &lt;&lt; ""gman was here"" &lt;&lt; std::endl; }
    void baz() { x = 5; }

    int x;
};

int main()
{
    foo* f = 0;

    f-&gt;bar(); // (a)
    f-&gt;baz(); // (b)
}
</code></pre>

<p>We expect <code>(b)</code> to crash, because there is no corresponding member <code>x</code> for the null pointer. In practice, <code>(a)</code> doesn't crash because the <code>this</code> pointer is never used.</p>

<p>Because <code>(b)</code> dereferences the <code>this</code> pointer (<code>(*this).x = 5;</code>), and <code>this</code> is null, the program enters undefined behavior, as dereferencing null is always said to be undefined behavior.</p>

<p>Does <code>(a)</code> result in undefined behavior? What about if both functions (and <code>x</code>) are static?</p>
","87234","","<p>Both <code>(a)</code> and <code>(b)</code> result in undefined behavior. It's always undefined behavior to call a member function through a null pointer. If the function is static, it's technically undefined as well, but there's some dispute.</p>

<hr>

<p>The first thing to understand is why it's undefined behavior to dereference a null pointer. In C++03, there's actually a bit of ambiguity here.</p>

<p>Although <em>""dereferencing a null pointer results in undefined behavior""</em> is mentioned in notes in both §1.9/4 and §8.3.2/4, it's never explicitly stated. (Notes are non-normative.)</p>

<p>However, one can try to deduced it from §3.10/2: </p>

<blockquote>
  <p>An lvalue refers to an object or function.</p>
</blockquote>

<p>When dereferencing, the result is an lvalue. A null pointer <em>does not</em> refer to an object, therefore when we use the lvalue we have undefined behavior. The problem is that the previous sentence is never stated, so what does it mean to ""use"" the lvalue? Just even generate it at all, or to use it in the more formal sense of perform lvalue-to-rvalue conversion?</p>

<p>Regardless, it definitely cannot be converted to an rvalue (§4.1/1):</p>

<blockquote>
  <p>If the object to which the lvalue refers is not an object of type T and is not an object of a type derived from T, or if the object is uninitialized, a program that necessitates this conversion has undefined behavior.</p>
</blockquote>

<p>Here it's definitely undefined behavior.</p>

<p>The ambiguity comes from whether or not it's undefined behavior to deference <em>but not use</em> the value from an invalid pointer (that is, get an lvalue but not convert it to an rvalue). If not, then <code>int *i = 0; *i; &amp;(*i);</code> is well-defined. This is an <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232"">active issue</a>.</p>

<p>So we have a strict ""dereference a null pointer, get undefined behavior"" view and a weak ""use a dereferenced null pointer, get undefined behavior"" view. </p>

<p>Now we consider the question.</p>

<hr>

<p>Yes, <code>(a)</code> results in undefined behavior. In fact, if <code>this</code> is null then <em>regardless of the contents of the function</em> the result is undefined.</p>

<p>This follows from §5.2.5/3:</p>

<blockquote>
  <p>If <code>E1</code> has the type “pointer to class X,” then the expression <code>E1-&gt;E2</code> is converted to the equivalent form <code>(*(E1)).E2;</code></p>
</blockquote>

<p><code>*(E1)</code> will result in undefined behavior with a strict interpretation, and <code>.E2</code> converts it to an rvalue, making it undefined behavior for the weak interpretation.</p>

<p>It also follows that it's undefined behavior directly from (§9.3.1/1):</p>

<blockquote>
  <p>If a nonstatic member function of a class X is called for an object that is not of type X, or of a type derived from X, the behavior is undefined.</p>
</blockquote>

<hr>

<p>With static functions, the strict versus weak interpretation makes the difference. Strictly speaking, it is undefined:</p>

<blockquote>
  <p>A static member may be referred to using the class member access syntax, in which case the object-expression is evaluated.</p>
</blockquote>

<p>That is, it's evaluated just as if it were non-static and we once again dereference a null pointer with <code>(*(E1)).E2</code>.</p>

<p>However, because <code>E1</code> is not used in a static member-function call, if we use the weak interpretation the call is well-defined. <code>*(E1)</code> results in an lvalue, the static function is resolved, <code>*(E1)</code> is discarded, and the function is called. There is no lvalue-to-rvalue conversion, so there's no undefined behavior.</p>

<p>In C++0x, as of n3126, the ambiguity remains. For now, be safe: use the strict interpretation.</p>
"
"<p>Is it possible to get typename of a member variable? For example:</p>

<pre><code>struct C { int value ; };

typedef typeof(C::value) type; // something like that?
</code></pre>

<p>Thanks</p>
","87234","","<p>Not in C++03. C++0x introduces <code>decltype</code>:</p>

<pre><code>typedef decltype(C::value) type;
</code></pre>

<p>Some compilers have a <code>typeof</code> extension, though:</p>

<pre><code>typedef typeof(C::value) type; // gcc
</code></pre>

<p>If you're okay with Boost, they have a <a href=""http://www.boost.org/doc/libs/1_42_0/doc/html/typeof/refe.html#typeof.typo"" rel=""nofollow"">library</a> for it:</p>

<pre><code>typedef BOOST_TYPEOF(C::value) type;
</code></pre>
"
"<p>If in my code I do the following snippet:</p>

<pre><code>try {
  doSomething();
} catch (...) {
  doSomethingElse();
  throw;
}
</code></pre>

<p>Will the throw rethrow the specific exception caught by the default ellipsis handler?</p>
","87234","","<p>Yes. The exception is active until it's caught, where it becomes inactive. But <em>it lives until the scope of the handler ends</em>. From the standard, emphasis mine:</p>

<blockquote>
  <p>§15.1/4: The memory for the temporary copy of the exception being thrown is allocated in an unspecified way, except as noted in 3.7.4.1. <em>The temporary persists as long as there is a handler being executed for that exception.</em></p>
</blockquote>

<p>That is:</p>

<pre><code>catch(...)
{ // &lt;--

    /* ... */

} // &lt;--
</code></pre>

<p>Between those arrows, you can re-throw the exception. Only when the handlers scope ends does the exception cease to exist.</p>

<p>In fact, in §15.1/6 the example given is nearly the same as your code:</p>

<pre><code>try {
    // ...
}
catch (...) { // catch all exceptions
    // respond (partially) to exception &lt;-- ! :D
    throw; //pass the exception to some
           // other handler
}
</code></pre>

<p>Keep in mind if you <code>throw</code> without an active exception, <code>terminate</code> will be called. This cannot be the case for you, being in a handler.</p>

<hr>

<p>If <code>doSomethingElse()</code> throws and the exception has no corresponding handler, because the original exception is considered handled the new exception will replace it. (As if it had just thrown, begins stack unwinding, etc.)</p>

<p>That is:</p>

<pre><code>void doSomethingElse(void)
{
    try
    {
        throw ""this is fine"";
    }
    catch(...)
    {
        // the previous exception dies, back to
        // using the original exception
    }

    try
    {
        // rethrow the exception that was
        // active when doSomethingElse was called
        throw; 
    }
    catch (...)
    {
        throw; // and let it go again
    }

    throw ""this replaces the old exception"";
    // this new one takes over, begins stack unwinding
    // leaves the catch's scope, old exception is done living,
    // and now back to normal exception stuff
}

try
{
    throw ""original exception"";
}
catch (...)
{
  doSomethingElse();
  throw; // this won't actually be reached,
         // the new exception has begun propagating
}
</code></pre>

<p>Of course if nothing throws, <code>throw;</code> will be reached and you'll throw your caught exception as expected.</p>
"
"<p>I've recently started teaching myself the standard template library. I was curious as to why the GetTotal() method in this class is returning 0?</p>

<pre><code>...

class Count
{
public:
    Count() : total(0){}
    void operator() (int val){ total += val;}
    int GetTotal() { return total;}
private:
    int total;
};

void main()
{
    set&lt;int&gt; s;
    Count c;
    for(int i = 0; i &lt; 10; i++) s.insert(i);
    for_each(s.begin(), s.end(), c);
    cout &lt;&lt; c.GetTotal() &lt;&lt; endl;
}
</code></pre>
","87234","","<p><code>for_each</code> takes the function by-value. That is, it uses a copy of the functor and not the functor itself. Your local <code>c</code> is left unchanged.</p>

<p><code>for_each</code> returns the functor it used, though, so you could do:</p>

<pre><code>Count c;
c = for_each(s.begin(), s.end(), c);
</code></pre>

<p>Or more idiomatically:</p>

<pre><code>Count c = for_each(s.begin(), s.end(), Count());
</code></pre>

<p>However, there exists such functionality already (no need for your functor):</p>

<pre><code>int total = std::accumulate(s.begin(), s.end(), 0);
</code></pre>
"
"<p>hi can anybody tell me the error in this?</p>

<pre><code>#include&lt;stdio.h&gt;

int main()
{
    char a[]=""abcdefgh"";
    int i=0;
    int n=strlen(a);
    char *first;
    char *second;
    char *c;
    *first=a[0];
    *second=a[7];
    for(i=0;i&lt;=n/2;i++)
    {
            *c=*first;
            *first=*second;
            *second=*c;
            first++;
            second--;
    }

    for(i=0;i&lt;=7;i++)
    {
            printf(""%c"",a[i]);
    }
}
</code></pre>
","87234","","<p>The problem is these lines:</p>

<pre><code>*first=a[0];
*second=a[7];
</code></pre>

<p>I think what you want is to get <code>first</code> and <code>second</code> to point to the correct elements, which is:</p>

<pre><code>first = &amp;a[0]; // address of the first element
second = &amp;a[7]; // address of the eighth element
</code></pre>

<p>What you have is assigning the value of <code>a[0]</code> to the address pointed to by <code>first</code>, which is not initialized. Also, you might as well use <code>n - 1</code> instead of 7 here, so you don't hardcode the size. Also these lines:</p>

<pre><code>*c=*first;
*first=*second;
*second=*c;
</code></pre>

<p>You see, the pointer <code>c</code> also hasn't been initialized. What you should do is not have <code>c</code> as a pointer:</p>

<pre><code>char c;
</code></pre>

<p>Then use it just like a normal variable:</p>

<pre><code>c = *first;
*first = *second;
*second = c;
</code></pre>

<p>And just a design note, you don't need the counter/for-loop. Rather, you know you're done with <code>second</code> is &lt;= to <code>first</code> (that is, we're at or have crossed the half-way point):</p>

<pre><code>while (second &gt; first)
</code></pre>

<p>Lastly, through some spaces in there! Your code is very condensed and hard to read. Don't be afraid to space things out.</p>
"
"<p>I'm writing a C program but I keep having problems with my array of chars. I keep getting garbage when I print it using prinf. here is an example of what I get when I print it:</p>

<p>char at t.symbol is <strong>Aôÿ¿</strong> <br/>
char at tabl[0].symbol is A <br/>
char at tabl[1].symbol is a <br/>
char at tabl[2].symbol is a <br/>
char at tabl[3].symbol is d <br/>
char at tabl[4].symbol is e <br/>
char at tabl[5].symbol is f <br/>
char at tabl[6].symbol is g <br/>
char at tabl[7].symbol is h <br/>
char at tabl[8].symbol is i <br/>
char at tabl[9].symbol is x <br/>
char at t[0].symbol is <strong>a0AÃ</strong> <br/>
char at t[1].symbol is <strong>b)@Ã4</strong> <br/>
char at t[2].symbol is <strong>ckU*</strong> <br/>
char at t[3].symbol is <strong>Aôÿ¿</strong> <br/>
char at t[4].symbol is <strong>gØ</strong> <br/></p>

<p>could someone tell me how to get rid off the garbage in the array of chars?</p>

<p>here is my code</p>

<pre><code>#define MAX 100
#ifndef SYMBSIZE
 #define SYMBSIZE 1
#endif    

typedef struct tableme 
{
    char symbol[SYMBSIZE];
    int value;
    int casenmbr;
    int otherinfo;
}tabletype;
int main(int argc, char **argv)
{
    tabletype t[MAX];
    t[3].symbol[0] = 'A';

    t[0].value=1;  
    t[0].casenmbr = 7;
    t[0].otherinfo = 682;

    tabletype tabl[MAX];
    tabl[0].value = 1;
    tabl[0].symbol[0] = 'A';
    tabl[1].value = 11;
    tabl[1].symbol[0]= 'a';
    tabl[2].value = 12;
    tabl[2].symbol[0] = 'a';
    tabl[3].value = 13;
    tabl[3].symbol[0] = 'd';
    tabl[4].value = 14;
    tabl[4].symbol[0] = 'e';
    tabl[5].value = 15;
    tabl[5].symbol[0] = 'f';
    tabl[6].value = 16;  
    tabl[6].symbol[0] = 'g';
    tabl[7].value = 17;
    tabl[7].symbol[0] = 'h';
    tabl[8].symbol[0] = 'i';
    tabl[9].symbol[0] = 'x';
    t[1].symbol[0] = 'b';
    t[0].symbol[0]= 'a';
    t[2].symbol[0]= 'c';

    t[4].symbol[0]= 'g';
    printf(""char at t.symbol is %s \n"", t[3].symbol);

    for( x=0;x&lt;10;x++)
    {
            printf(""char at tabl[%d].symbol is %s \n"",x, tabl[x].symbol);
    }
    int j;
    for(j = 0; j&lt;5;j++)  
    {
            printf(""char at t[%d].symbol is %s \n"",j, t[j].symbol);
    }
    return 0;
}
</code></pre>
","87234","","<p>The problem is that strings in C are null terminated. However, your array is only big enough for one character, so it cannot be null-terminated (this requires at least 2 characters)</p>

<p>Why are you getting garbage? When you say <code>tabl[0].symbol[0] = 'A';</code>, at <code>tabl[0].symbol[0]</code> in memory you have <code>A???</code> and we don't know what <code>???</code> is. Obviously, it's sometimes 0 (where you get correct output), sometimes it's not (garbage).</p>

<p>To fix this, use the <code>%c</code> format specifier to print a single character instead of a null-terminated string. If you really want to print strings, you need to make your string buffer larger and null-terminate it:</p>

<p><code>SYMBSIZE = 10</code>, then have <code>tabl[0].symbol[1] = '\0';</code> Note, you usually want to use string functions:</p>

<pre><code>// copy ""a"" to that memory location, will be null-terminated.
strcpy(tabl[0].symbol, ""a""); 
</code></pre>

<p>If your buffer isn't large enough for the string, it will overrun the buffer.</p>
"
"<p>Does <code>std::map</code> move around already inserted <strong>values</strong> when inserting new data ?</p>
","87234","","<p>The map is implemented as a tree, and when you insert a new element, the tree may need to be rebalanced.</p>

<p>This does <em>not</em> invalidate any iterators or references to elements in the tree. This balancing is done via the manipulation of pointers, so you have nothing to worry about; the nodes themselves stay put.</p>

<p>Balancing involves changing the structure of the tree by telling nodes who their children, parents, and siblings are via re-assigning pointers, but this is an implementation detail. Logically nothing has changed.</p>
"
"<p>I am always confused about return a string literal or a string from a function. I was told that there might be memory leak because you don't know when the memory will be deleted?</p>

<p>For example, in the code below, how to implement <code>foo()</code> so as to make the output of the code is ""Hello World""?</p>

<pre><code>void foo (       )              // you can add parameters here.
{

}

int main ()
{
    char *c;
    foo (    );
    printf (""%s"",c);
    return 0;
}
</code></pre>

<p>Also, if the return type of <code>foo()</code> is not void, but you can return <code>char*</code>, what should it be?</p>
","87234","","<p>I'm assuming we cannot modify main. To get your program working without a leak, you need something to have static storage:</p>

<pre><code>void foo(char*&amp; pC)  // reference
{
    static char theString[] = ""thingadongdong"";

    pC = theString;
}
</code></pre>

<p>But really, this isn't very conventional C++ code. You'd be using <code>std::string</code> and <code>std::cout</code>, so you don't <em>have</em> to worry about memory:</p>

<pre><code>std::string foo(void)
{
    return ""better thingadongdong"";
}

int main(void)
{
    // memory management is done
    std::cout &lt;&lt; foo() &lt;&lt; std::endl;
}
</code></pre>

<p>If you're wondering if something needs to be manually deallocated, it's being done wrong.</p>
"
"<p>memset is sometimes used to initialize data in a constructor like the example below. Does it work in general ? Is it a good idea in general?</p>

<pre><code>class A {
public:
   A();
private:
   int a;
   float f;
   char str[35];
   long *lp;
};

A::A()
{
   memset(this, 0, sizeof(*this));
}
</code></pre>
","87234","","<p>It's a terrible idea. You're just tromping over data, paying no heed to how objects should be initialized. If your class is virtual, you're likely to wipe out the vtable pointer as well.</p>

<p><code>memset</code> works on raw data, but C++ isn't about raw data. C++ creates abstractions, so if you want to be safe you use those abstractions. Use the initializer list to initialize members.</p>

<p>You <em>can</em> do it to POD types:</p>

<pre><code>struct nothing_fancy_here
{
    bool b;
    int i;
    void* p;
};

nothing_fancy_here x;
memset(&amp;x, 0, sizeof(x));
</code></pre>

<p>But if you're doing it on <code>this</code>, that means you're in a user-defined constructor and no longer qualify as a POD type. (Though if all your members are POD it might work, as long as none contain 0 as a trap value. I'm sure not sure if any other sources of undefined behavior come into play here.)</p>
"
"<p>I'm programming a simple text-based RPG using a switch statement for a game loop. The program works fine until I attempt to add another case statement, at which point it gives me the following three errors: ""jump to case label"" (error occurs at the line of the newly added case), and two ""crosses initialization of 'ClassName *objectName'""(errors occur when the new objects are created in case 2). I'll paste the important code, if anyone needs more, please let me know.</p>

<pre><code>int main(void)
{
    // add weapons to array
    Weapon *weaponList[12];
    // Rusty Sword
    weaponList[0] = new Weapon(0,0,0);
    weaponList[0]-&gt;SetAll(0,2,3);
    // Bronze Sword
    weaponList[1] = new Weapon(0,0,0);
    weaponList[1]-&gt;SetAll(1,5,10);
    // Bronze Battle Axe
    weaponList[2] = new Weapon(0,0,0);
    weaponList[2]-&gt;SetAll(2,15,30);
    // Iron Sword
    weaponList[3] = new Weapon(0,0,0);
    weaponList[3]-&gt;SetAll(3,25,70);

    // add armor to array
    Armor *armorList[12];
    // Worn Platemail
    armorList[0] = new Armor(0,0,0);
    armorList[0]-&gt;SetAll(0,2,3);
    // Bronze Chainmail
    armorList[1] = new Armor(0,0,0);
    armorList[1]-&gt;SetAll(1,5,8);
    // Bronze Platemail
    armorList[2] = new Armor(0,0,0);
    armorList[2]-&gt;SetAll(2,7,20);
    // Iron Chainmail
    armorList[3] = new Armor(0,0,0);
    armorList[3]-&gt;SetAll(3,15,60);

        while(gamestate != 8)
        {
            switch(gamestate)
            {
                case 0:
                cout &lt;&lt; "" /|    Welcome!\n""
                     &lt;&lt; "" ||    \n""
                     &lt;&lt; "" ||    \n""
                     &lt;&lt; "" ||    \n""
                     &lt;&lt; ""_||_   \n""
                     &lt;&lt; "" 88    \n""
                     &lt;&lt; "" 88    Name: "";
                cin  &gt;&gt; heroName;
                gamestate = GAME_STATE_MENU;
                break;

            case 1:
                cout &lt;&lt; ""\n""
                     &lt;&lt; ""'/stats' will show you your stats\n""
                     &lt;&lt; ""'/shop' will let you visit the weapon shop\n""
                     &lt;&lt; ""secret commands: /setweapon #   /setarmor #   /setheroexp #\n""
                     &lt;&lt; ""\n"";

                cout &lt;&lt; ""Command: "";
                cin  &gt;&gt; command;

                if (strcmp(command, ""/stats"") == 0)
                {
                    gamestate = 2;
                    break;
                }

                else if (strcmp(command, ""/shop"") == 0)
                {
                    gamestate = 3;
                    break;
                }

                else if (strcmp(command, ""/fight"") == 0)
                {
                    gamestate = 4;
                    break;
                }

                else if (strcmp(command, ""/setweapon"") == 0)
                {
                    cin &gt;&gt; testNum;
                    heroWeapon = testNum;
                    break;
                }

                else if (strcmp(command, ""/setarmor"") == 0)
                {
                    cin &gt;&gt; testNum;
                    heroArmor = testNum;
                    break;
                }

                else if (strcmp(command, ""/setheroexp"") == 0)
                {
                    cin &gt;&gt; testNum;
                    heroExp = testNum;
                    LevelUp();
                    break;
                }

                else if (strcmp(command, ""/exit"") == 0)
                {
                    gamestate = 8;
                    break;
                }

                else
                {
                    cout &lt;&lt; ""Please enter a valid command.\n"";
                    gamestate = 2;
                    break;
                }

            case 2:
                Weapon *wCurrent = weaponList[heroWeapon];
                Armor *aCurrent = armorList[heroArmor];
                heroWeaponPower = wCurrent-&gt;GetWeaponAttack();
                heroArmorDefense = aCurrent-&gt;GetArmorDefense();
                heroPowerDefault = ((heroLevel - 1) * 10) + 10;
                heroPower = heroPowerDefault + (heroStrength * 2) + heroWeaponPower;
                heroDefenseDefault = ((heroLevel - 1) * 2) + 5;
                heroDefense = heroDefenseDefault + (heroAgility / 5) + heroArmorDefense;
                heroHealthDefault = (heroLevel * 5) + 20;
                heroHealth = heroHealthDefault + (heroStamina * 10);
                cout &lt;&lt; ""\nS T A T S\nName: "" 
                     &lt;&lt; heroName 
                     &lt;&lt; ""\nLevel: ""
                     &lt;&lt; heroLevel
                     &lt;&lt; ""\nExp: ""
                     &lt;&lt; heroExp &lt;&lt; ""/"" &lt;&lt; expForLevel[heroLevel]
                     &lt;&lt; ""\nGold: ""
                     &lt;&lt; heroGold
                     &lt;&lt; ""\nHealth: ""
                     &lt;&lt; heroHealth
                     &lt;&lt; ""\nPower: ""
                     &lt;&lt; heroPower
                     &lt;&lt; ""\nDefense: ""
                     &lt;&lt; heroDefense
                     &lt;&lt; ""\nWeapon: ""
                     &lt;&lt; weaponNameList[heroWeapon]
                     &lt;&lt; ""\nArmor: ""
                     &lt;&lt; armorNameList[heroArmor]
                     &lt;&lt; ""\n\n"";
                system(""PAUSE"");
                gamestate = 2;
                break;

            case 3:
                break;
            }
        }

        return 0;
    }
</code></pre>
","87234","","<p>Consider the following:</p>

<pre><code>switch (x)
{
    case 0:
        int i = 0;
    case 1:
        i = 5;
}
</code></pre>

<p>What if <code>x</code> is 1? Then we skip <em>over</em> the initialization of <code>i</code> and just start using it. This is what you're getting: <code>case 3</code> has access to variables from <code>case 2</code>, but if you use them you've started using them without running their initialization.</p>

<p>The common solution is to introduce scope:</p>

<pre><code>switch (x)
{
    case 0:
    {
        int i = 0;
    }
    case 1:
    {
        i = 5; // not possible, no i in this scope
    }
}
</code></pre>
"
"<p>When I do:
<code>less /usr/include/stdio.h</code> (which is only a C library - nothing to do with C++)</p>

<p>I see <code>__THROW</code> after quite a few function declarations.
Also, comments above a few functions say that 'This function is a possible cancellation point and therefore not marked with <code>__THROW</code>'
What is all this for?</p>

<p><code>throw</code> is meant to be for exception handling...but as far as I know, C doesn't provide any support for it.</p>

<p>Please explain.</p>
","87234","","<p>This header is likely shared between the C and C++ compiler for that vendor. Did you look what <code>__THROW</code> is defined as?</p>

<p>I suspect something akin to:</p>

<pre><code>#ifdef __cplusplus
    #define __THROW throw()
#else
    #define __THROW
#endif
</code></pre>

<p>Or for actual specifications: </p>

<pre><code>#ifdef __cplusplus
    #define __THROW(x) throw(x)
#else
    #define __THROW(x)
#endif
</code></pre>

<p>As you can see, in a C build, it expands to nothing. In C++, it does what you expect. This allows vendors to reuse the same file.</p>

<hr>

<p>Just to nitpick, this isn't entirely true: <em>""(which is only a C library - nothing to do with C++)""</em></p>

<p>The C++ standard library includes the ability to use the C standard library. The actual header is <code>&lt;cxxx&gt;</code> where <code>xxx</code> is the C header name. That is, to include the C header <code>&lt;stdlib.h&gt;</code> in C++, you do <code>&lt;cstdlib&gt;</code>. So it does have to do with C++. :)</p>

<p>This is why you see the code you do. Duplicating the header for two different languages would be a nightmare for maintenance and cleanliness.</p>
"
"<pre><code>main()
{
int i=256;
char buf[i];
}
</code></pre>

<p>perfectly compile on g++ but gives an error on visual studio 8.</p>

<p>anybody know why it is happening,</p>

<p>Thanks</p>
","87234","","<p>In C++, arrays have a constant size. In C99, however, there exist something called variable-length arrays, or VLA's. This is what you're making here.</p>

<p><code>g++</code> (the C++ compiler) is a sibling of <code>gcc</code> (the C compiler), and <code>g++</code> is allowing you to use that C99 feature, while VS has no such thing. Essentially it's a non-standard C++ extension.</p>

<p>If you make <code>i</code> a compile-time constant, it would work (since that's standard C++):</p>

<pre><code>const int i = 256; // obviously cannot change at runtime.
</code></pre>

<p>If you need a dynamic array in C++, use <a href=""http://www.cplusplus.com/reference/stl/vector/"" rel=""nofollow""><code>std::vector</code></a>.</p>

<hr>

<p>Note in C++ you need to specify a return type for <code>main</code>. This is and always shall be <code>int</code>.</p>
"
"<p>Is there a difference between foo and bar:</p>

<pre><code>class A
{
  Object __o;

  void foo(Object&amp; o)
  {
    __o = o;  
  }

  void bar(Object o)
  {
    __o = o;
  } 
} 
</code></pre>

<p>As I understand it, foo performs no copy operation on object o when it is called, and one copy operation for assignment. Bar performs one copy operation on object o when it is called and another one for assignment. So I can more or less say that foo uses 2 times less memory than bar (if o is big enough). Is that correct ?</p>

<p>Is it possible that the compiler optimises the bar function to perform only one copy operation on o ? i.e. makes __o pointing on the local copy of argument o instead of creating a new copy?  </p>
","87234","","<p>It depends. For example, if the compiler decides to inline the function, obviously there will be no copy since there is no function call.</p>

<p>If you want to be sure, pass by const-reference:</p>

<pre><code>void bar(const Object&amp; o)
</code></pre>

<p>This makes no copies. Note your non-const version requires an lvalue, because the reference is mutable. <code>foo(Object())</code> wouldn't work, but temporaries (rvalues) can be bound to a const-reference.</p>

<hr>

<p>Double-underscores in identifiers are reserved for the compiler, by the way.</p>
"
"<p>Why won't GCC allow a default parameter here?</p>

<pre><code> template&lt;class edgeDecor, class vertexDecor, bool dir&gt;
 Graph&lt;edgeDecor,int,dir&gt; Graph&lt;edgeDecor,vertexDecor,dir&gt;::Dijkstra(vertex s, bool print = false) const
 {
</code></pre>

<p>This is the output I get:</p>

<pre><code>graph.h:82: error: default argument given for parameter 2 of ‘Graph&lt;edgeDecor, int, dir&gt; Graph&lt;edgeDecor, vertexDecor, dir&gt;::Dijkstra(Vertex&lt;edgeDecor, vertexDecor, dir&gt;, bool)’
graph.h:36: error: after previous specification in ‘Graph&lt;edgeDecor, int, dir&gt; Graph&lt;edgeDecor, vertexDecor, dir&gt;::Dijkstra(Vertex&lt;edgeDecor, vertexDecor, dir&gt;, bool)’
</code></pre>

<p>Can anyone see why I'm getting this?</p>
","87234","","<p>You've specified one of the template parameters:</p>

<pre><code>Graph&lt;edgeDecor,int,dir&gt; Graph&lt;edgeDecor,vertexDecor,dir&gt;::
                ^^^
</code></pre>

<p>Change it to match:</p>

<pre><code>Graph&lt;edgeDecor,vertexDecor,dir&gt; Graph&lt;edgeDecor,vertexDecor,dir&gt;::
</code></pre>
"
"<p>That's pretty much it.  I need to allocate memory and pass it to a function that takes a void *.  I'd like to use a shared_ptr but I don't know how to do it.</p>
","87234","","<p>Do you mean something like:</p>

<pre><code>boost::shared_ptr&lt;int&gt; myInt(new int(5));

call_some_function(myInt.get());
</code></pre>

<p>This only let's the function use the <code>int*</code>. It shouldn't try to delete it or take ownership.</p>

<hr>

<p>If you want just raw memory, use a <code>vector</code>:</p>

<pre><code>std::vector&lt;char&gt; memory(blockSize);

call_some_function(&amp;blockSize[0]);
</code></pre>

<p>Again, the memory belongs to the <code>vector</code>.</p>

<hr>

<p>If your function <em>does</em> want ownership, there's no need to wrap it into something, since you won't be managing it:</p>

<pre><code>call_some_function(new int);
call_some_function(new char[blockSize]);
</code></pre>

<p>Make sure the function will be releasing it with a call to <code>delete</code>/<code>delete[]</code>. If not (for example, it intends to use <code>free()</code>), you'll need to use <code>malloc</code> instead:</p>

<pre><code>template &lt;typename T&gt;
T* malloc_new(void)
{
    void* memory = std::malloc(sizeof(T));
    if (!memory)
        throw std::bad_alloc();

    try
    {
        return new (memory) T();
    }
    catch(...)
    {
        std::free(memory);
        throw;
    }
}

call_some_function(malloc_new&lt;int&gt;());
call_some_function(malloc(blockSize));
</code></pre>
"
"<p>How can I define a array of boost matrices as a member variable?</p>

<p>None of the following worked.</p>

<pre><code>boost::numeric::ublas::matrix&lt;double&gt; arrayM(1, 3)[arraySize];
boost::numeric::ublas::matrix&lt;double&gt;(1, 3) arrayM[arraySize];
boost::numeric::ublas::matrix&lt;double&gt; arrayM[arraySize](1, 3);
</code></pre>

<p>Thanks,
Ravi.</p>
","87234","","<p>The size you initialize it with has nothing to do with the type. Therefore:</p>

<pre><code>// this makes things easier!
typedef boost::numeric::ublas::matrix&lt;double&gt; matrix_type;

// this is the type (no initialization)
matrix_type arrayM[arraySize];
</code></pre>

<p>The problem comes with initializing the array. You can't do this:</p>

<pre><code>TheClass::TheClass() :
arrayM(1, 3) // nope
{}
</code></pre>

<p>Instead, you have to let them default-construct, then resize them all:</p>

<pre><code>TheClass::TheClass()
{
    std::fill(arrayM, arrayM + arraySize, matrix_type(1, 3));
}
</code></pre>

<hr>

<p>Since you're using boost, consider using <code>boost::array</code>, since it gives a nicer syntax:</p>

<pre><code>typedef boost::numeric::ublas::matrix&lt;double&gt; matrix_type;
typedef boost::array&lt;matrix_type, arraySize&gt; matrix_array;

matrix_array arrayM; // ah

TheClass::TheClass()
{
    arrayM.assign(matrix_type(1, 3));
}
</code></pre>
"
"<p>I found this typo recently:</p>

<pre><code> if (name.find('/' != string::npos))
</code></pre>

<p>Obviously the dev meant to type</p>

<pre><code>if(name.find('/') != string::npos)
</code></pre>

<p>But I was amazed that to find that the error even compiles with <code>-Wall -Werror</code> (didnt try with <code>-pedantic</code>)  </p>

<p>So, coffee quiz: does it evaluate to true or false?</p>
","87234","","<p>It depends on if <code>name</code> <em>starts</em> with a <code>char</code> equal to 1.</p>

<p>You shouldn't be amazed it compiles, there's nothing wrong about it. <code>'/' != std::string:npos</code> evaluates to true, and the only overload of <code>find</code> that would work is the <code>char c, size_t pos</code> version, as <code>bool</code> can be converted to an integer 1.</p>

<p>So now we're looking for <code>(char)1</code>, and what that returns depends on the string. If it starts with <code>(char)1</code>, it returns 0 and that's false. In any other case, it returns a non-zero integer, or true.</p>
"
"<p>I have the following code :</p>

<pre><code>std::string Utils::get() {
    std::string result;
    result.append(1, 'x');
    result.append(1, 'x');
    result.append(1, 'x');
    return result;
}
</code></pre>

<p>I expect 'xxx' to be returned.</p>

<p>However, when I run under debug mode, I get the warning</p>

<p>""Stack around the variable 'result' was corrupted""</p>

<p>Am I using append function the wrong way?</p>
","87234","","<p>Your use of <code>append</code> is correct. Something else (possibly just before calling the function, etc.) is corrupting the stack. It's only when you use the stack some more (a function call in this case) will it detect it.</p>

<p>The reason you won't see it in Release is because the function call is (likely) inlined. Ergo, the stack isn't manipulated like it is now, and the result is different. Post some more context and we'll help you track it down. </p>
"
"<p>I have Java experience and recently am doing some C++ coding. My question is that if I have class A, in which I have to instantiate class B and class C as two of the member variables of A.</p>

<p>If in the constructor of A, should I assume that allocations of class B and C never fail, and handle the bad allocation exception in the destructor of A? </p>

<p>If I don't make that assumption, meaning that I add some try catch block to catch bad_alloc of class B and class C, then if the allocation exception occurs, should I do clean up in the constructor of A? </p>

<p>What are the recommended practices? If ""new"" generates a bad allocation, what value does the pointer carry? </p>
","87234","","<p>If an exception is thrown during the construction of A, your destructor will <em>not</em> be called.</p>

<p>Obviously the solution depends on what you're doing, but ideally you won't <em>have</em> to do any cleaning up. You should utilize <a href=""http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"">RAII</a>, and your class members should clean-up themselves.</p>

<p>That is, don't use any pointers raw; wrap them up and let the wrapper take care of it. Surprise! C++ programmers hate memory management just like you. We like to wrap it up and forget about it.</p>

<p>If you truly need to, though, I think this is common:</p>

<pre><code>struct foo
{
    int* i;
    some_member_that_could_throw crap;

    foo() // do *not* new i! if the second member throws, memory is leaked.
    {     // rather:

        // okay we made it, the other member must have initialized
        i = new int;
    }
};
</code></pre>

<hr>

<p>Concerning your pointer, it's value remains unchanged. When <code>new</code> throws an exception (for whatever reason), the stack is unwound. The rest of the expression is abandoned.</p>

<hr>

<p>Here's how exceptions and object creation will work. It's a recursive process, because each member or base class will in turn follow this list. Fundamental types have no constructors; this is the base case for the recursion.</p>

<ol>
<li>First, construct each of our base classes. (Which in turn run this list.)</li>
<li>Initialize members of the class, one by one.</li>
<li>Run the constructor body.</li>
<li>finish with a fully constructed object.</li>
</ol>

<p>Obviously, if item 1 fails there isn't any cleaning up for us to do, as none of our members have been initialized. We're good there.</p>

<p>Two is different. If at any point one of those fails to construct , the initialized members <em>so far</em> will be destructed, then the constructor will stop progress and the exception goes on it's merry way. This is why when you let your members clean up after themselves you have nothing to worry about. The uninitialized have nothing to do, and the initialized are going to have their destructors run, where cleanup occurs.</p>

<p>Three even more so. now that your objects are fully initialized, you're guaranteed they will all have their destructors run. Again, wrap things up and you have nothing to worry about. <em>However</em> if you have a raw pointer lying around, this is the time for a try/catch block:</p>

<pre><code>try
{
    // some code
}
catch (..) // catch whatever
{
    delete myrawPointer; // stop the leak!
    throw; // and let the exception continue
}
</code></pre>

<p>It's much messier to write exception-safe code without RAII.</p>
"
"<p>I have following code snippet:</p>

<pre><code>class ABC{
public:
        int a;
        void print(){cout&lt;&lt;""hello""&lt;&lt;endl;}
};

int main(){
        ABC *ptr = NULL:
        ptr-&gt;print();
        return 0;
}
</code></pre>

<p>It runs successfully. Can someone explain it?</p>
","87234","","<p>It leads to undefined behavior. I put a <a href=""http://stackoverflow.com/questions/2474018/when-does-invoking-a-member-function-on-a-null-instance-result-in-undefined-behav"">bit of work</a> into explaining why. :) But that's a more technical answer.</p>

<p>Basically, undefined behavior means you are no longer guaranteed anything about the execution of the program; C++ simply has nothing to say. It could work exactly how you want, or it could crash miserably, or it could do both randomly.</p>

<p>So <em>appearing to work</em> is a perfectly fine result of undefined behavior, which is what you're seeing. The practical reason why is, on your implementation (and in honestly, every implementation), the <code>this</code> pointer (the address of the instance being invoked) isn't being used at all in your function. That said, if you tried to use the <code>this</code> pointer (for example by accessing a member variable), you'd likely crash.</p>

<p>Remember, the above paragraph is something specific to your implementation and it's current behavior. It's just a guess and something you can't rely on.</p>
"
"<p>I cannot initialize a <strong>non-const</strong> reference to type T1 from a convertible type T2. However, I can with a <strong>const</strong> reference.</p>

<pre><code>long l;
const long long &amp;const_ref = l; // fine
long long &amp;ref = l;             // error: invalid initialization of reference of
                                // type 'long long int&amp;' from expression of type
                                // 'long int'
</code></pre>

<p>Most problems I encountered were related to r-values that cannot be assigned to a non-const reference. This is not the case here -- can someone explain? Thanks.</p>
","87234","","<p>An integer promotion results in an rvalue. <code>long</code> can be promoted to a <code>long long</code>, and then it gets bound to a const reference. Just as if you had done:</p>

<pre><code>typedef long long type;
const type&amp; x = type(l); // temporary!
</code></pre>

<p>Contrarily an rvalue, as you know, cannot be bound to a non-const reference. (After all, there is no actual <code>long long</code> to refer to.)</p>
"
"<p>Consider this classic example used to explain what <em>not</em> to do with forward declarations:</p>

<pre><code>//in Handle.h file
class Body;

class Handle
{
   public:
      Handle();
      ~Handle() {delete impl_;}
   //....
   private:
      Body *impl_;
};

//---------------------------------------
//in Handle.cpp file

#include ""Handle.h""

class Body 
{
  //Non-trivial destructor here
    public:
       ~Body () {//Do a lot of things...}
};

Handle::Handle () : impl_(new Body) {}

//---------------------------------------
//in Handle_user.cpp client code:

#include ""Handle.h""

//... in some function... 
{
    Handle handleObj;

    //Do smtg with handleObj...

    //handleObj now reaches end-of-life, and BUM: Undefined behaviour
} 
</code></pre>

<p>I understand from the standard that this case is headed towards UB since Body's destructor is non trivial.
What I'm trying to understand is really the root cause of this.</p>

<p>I mean, the problem seems to be ""triggered"" by the fact that Handle's dtor is inline, and so the compiler does something like the following ""inline expansion"" (almost pseudo-code here).</p>

<pre><code>inline Handle::~Handle()
{
     impl_-&gt;~Body();
     operator delete (impl_);
}
</code></pre>

<p>In all translation units (only <code>Handle_user.cpp</code> in this case) where a Handle instance gets to be destroyed, right?
I just can't understand this: ok, when generating the above inline expansion the compiler doesn't have a full definition of the Body class, but why cannot it simply have the linker resolve for the <code>impl_-&gt;~Body()</code> thing and so have it call the Body's destructor function that's actually defined in its implementation file?</p>

<p>In other words: I understand that at the point of Handle destruction the compiler doesn't even know if a (non-trivial) destructor exists or not for Body, but why can't it do as it always does, that is leave a ""placeholder"" for the linker to fill in, and eventually have a linker ""unresolved external"" if that function is really not available?</p>

<p>Am I missing something big here (and in that case sorry for the stupid question)?
If that's not the case, I'm just curious to understand the rationale behind this.</p>
","87234","","<p>I'm just guessing, but perhaps it has to do with the ability of per-class allocation operators.</p>

<p>That is:</p>

<pre><code>struct foo
{
    void* operator new(size_t);
    void operator delete(void*);
};

// in another header, like your example

struct foo;

struct bar
{
    bar();
    ~bar() { delete myFoo; }

    foo* myFoo;
};

// in translation unit

#include ""bar.h""
#include ""foo.h""

bar::bar() :
myFoo(new foo) // uses foo::operator new
{}

// but destructor uses global...!!
</code></pre>

<p>And now we've mismatched the allocation operators, and entered undefined behavior. The only way to guarantee that can't happen is to say ""make the type complete"". Otherwise, it's impossible to ensure.</p>
"
"<p>Hey, 
looking for a forum to look at libdmtx anyone know where to find it?</p>

<p>Thanks</p>
","87234","","<p><a href=""http://sourceforge.net/mailarchive/forum.php?forum_name=libdmtx-open_discussion"" rel=""nofollow"">This</a> appears to be it.</p>
"
"<p>I've got a namespace with a ton of symbols I use, but I want to overwrite one of them:</p>

<p>external_library.h</p>

<pre><code>namespace LottaStuff
{
class LotsOfClasses {};
class OneMoreClass {};
};
</code></pre>

<p>my_file.h</p>

<pre><code>using namespace LottaStuff;
namespace MyCustomizations
{
class OneMoreClass {};
};
using MyCustomizations::OneMoreClass;
</code></pre>

<p>my_file.cpp</p>

<pre><code>int main()
{
    OneMoreClass foo; // error: reference to 'OneMoreClass' is ambiguous
    return 0;
}
</code></pre>

<p>How do I get resolve the 'ambiguous' error without resorting to replacing 'using namespace LottaStuff' with a thousand individual ""using xxx;"" statements?</p>

<p>Edit: Also, say I can't edit my_file.cpp, only my_file.h.  So, replacing OneMoreClass with MyCustomizations::OneMoreClass everywhere as suggested below wouldn't be possible.</p>
","87234","","<p>The entire point of namespaces is defeated when you say ""<code>using namespace</code>"".</p>

<p>So take it out and use namespaces. If you want a using directive, put it within main:</p>

<pre><code>int main()
{
    using myCustomizations::OneMoreClass;

    // OneMoreClass unambiguously refers
    // to the myCustomizations variant
}
</code></pre>

<p>Understand what <code>using</code> directives do. What you have is essentially this:</p>

<pre><code>namespace foo
{
    struct baz{};
}

namespace bar
{
    struct baz{};
}

using namespace foo; // take *everything* in foo and make it usable in this scope
using bar::baz; // take baz from bar and make it usable in this scope

int main()
{
    baz x; // no baz in this scope, check global... oh crap!
}
</code></pre>

<p>One or the other will work, as well as placing one within the scope for <code>main</code>. If you find a namespace truly tedious to type, make an alias:</p>

<pre><code>namespace ez = manthisisacrappilynamednamespace;

ez::...
</code></pre>

<p>But <em>never</em> use <code>using namespace</code> in a header, and probably never in global scope. It's fine in local scopes.</p>
"
"<p>Assume,</p>

<pre><code>void proc(CString&amp; str)
{
  str = ""123"";
}

void runningMethod()
{
  CString str=""ABC"";
  proc(str);
}
</code></pre>

<p>I understand that at the exit of runningMethod str will be deallocated automatically; in this case, how does C++ delete the old data (""ABC"")? </p>

<p>Thanks, </p>

<p>Gil.</p>
","87234","","<p><code>""ABC""</code> was overwritten when you said <code>= ""123""</code>.</p>

<p>Internally, a string is an array of characters. At start, it made a new buffer that contained <code>{'A', 'B', 'C', '\0'}</code>. When you assigned, it just wrote <code>'1'</code> over the <code>'A'</code>, and so on.</p>

<p>When it destructed, it deleted the buffer.</p>
"
"<p>I am starting with c++ and need to know, what should be the approach to copy one hashtable to another hashtable in C++?</p>

<p>We can easily do this in java using: <code>HashMap copyOfOriginal=new HashMap(original);</code></p>

<p>But what about C++? How should I go about it?</p>

<p><strong>UPDATE</strong></p>

<p>Well, I am doing it at a very basic level,perhaps the java example was a wrong one to give. This is what I am trying to implement using C++:</p>

<p>I have this hash array and each element of the array is the head of a linked list. Which has it's individual nodes (data and next pointer). </p>

<p>And now, I need to copy the complete hash array and the linked list each node is pointing to.</p>
","87234","","<p>Whichever hashmap you're using, I'm sure it has a copy-constructor and possibly <code>operator=</code>.</p>

<pre><code>hashmap_type newMap = oldMap; // copies
</code></pre>

<p>And that's it. C++ has no standard hash map, though.</p>
"
"<p>After some struggling I managed to get boost smart pointers to build for Windows CE/Mobile at warning level 4.</p>

<p>I found the least-resistance-way to get rid of compile errors and warnings to be</p>

<pre><code>#define BOOST_NO_MEMBER_TEMPLATES
</code></pre>

<p>What does it actually mean? Did I sell my soul to the devil? Will all hell break loose when I actually <strong>use</strong> the types?</p>
","87234","","<p>There shouldn't be any bad effects per se, just a loss of functionality.</p>

<p>A member template is a member function that is a template, for example:</p>

<pre><code>struct foo
{
    template &lt;typename T&gt;
    void i_am_not_supported_sometimes(void);
};
</code></pre>

<p>So you don't get undefined behavior or anything, you just can't program things in a most generic manner. I think a definitive ""is this bad"" answer depends on exactly what it was being used for and what the work-around was.</p>

<p>Looking at <code>smart_ptr</code>, for example, the no-member-templates version literally just takes out the member templates, such as:</p>

<pre><code>template&lt;class Y&gt;
explicit shared_ptr( Y * p ): px( p ), pn( p ) // Y must be complete
{
    boost::detail::sp_enable_shared_from_this( this, p, p );
}
</code></pre>

<p>And replaces <code>Y</code> with <code>T</code>, so you lose the ability for some automatic conversions.</p>
"
"<p>I was curious if anyone knows which of the following executes faster (I know this seems like a weird question but I'm trying to shave as much time and resources as possible off my program.)</p>

<pre><code>int i=0;

i+=1; 
</code></pre>

<p>or </p>

<pre><code>int i;

i=1;
</code></pre>

<p>and I also was curious about which comparison is faster:</p>

<pre><code>//given some integer i
// X is some constant
i &lt; X+1
</code></pre>

<p>or </p>

<pre><code>i&lt;=X
</code></pre>

<p>For those of you who already posted answers I'm sorry, I edited it so the first section is correct, I meant for if i was initialized to 0.  Again sorry for the confusion.</p>
","87234","","<p>The first operation probably has no meaning because, unless <code>i</code> is static, you've left <code>i</code> uninitialized. </p>

<p>You're misguided and focusing on the wrong things. Guessing isn't going to get you anywhere; bring out a profile, profile your code, and find out with <em>data</em> which parts need to be optimized. Optimizations are <em>design changes</em>, be them different data structures or algorithms.</p>

<p>You <strong>heavily</strong> underestimate compilers. Nothing you do is going to make a difference with such tiny changes, both will compile to whichever the compiler decides is faster. If you want an integer at one, just do: <code>int i = 1;</code> and live your life. If you want to compare if an integer is less than or equal to X, then just say so: <code>i &lt;= X;</code>. Write clean readable code. On a side note, your two comparisons are not the same when X is at it's maximal value; you'll overflow when you add one.</p>

<p>If you're really serious, again: pull out a profiler. Another thing to do is look at the generated assembly and see which instructions it generates. If you don't know how to do that, chances are you're probably not in a position to <em>need</em> optimization. :/</p>
"
"<pre><code>class CRectangle {
    int x, y;
  public:
    void set_values (int,int);
    int area (void);
  } rect;
</code></pre>

<p>In this example, what does 'rect' after the closing brace and between the semi-colon mean in this class definition? I'm having trouble finding a clear explanation. Also: Whatever it is, can you do it for structs too?</p>
","87234","","<p>It declares an instance. Just like: </p>

<pre><code>class CRectangle
{
    // ...
};

CRectangle rect;
</code></pre>

<p>There is no difference between a <code>class</code> and a <code>struct</code> in C++, except <code>struct</code>s default to public (in regards to access specifiers and inheritance)</p>
"
"<p>I want to perform a <code>printf()</code> to display when the currently executing code was last compiled. Does C/C++ provide a macro that gives you that resolves to a timestamp during compilation?</p>
","87234","","<blockquote>
  <p>16.8 Predefined macro names [cpp.predefined]<br>
  1 The following macro names shall be defined by the implementation:<br>
  <code>__LINE__</code> The line number of the current source line (a decimal constant).<br>
  <code>__FILE__</code> The presumed name of the source file (a character string literal).<br>
  <code>__DATE__</code> The date of translation of the source file (a character string literal of the form ""Mmm dd yyyy"", where the names of the months are the same as those generated by the asctime function, and the first character of dd is a space character if the value is less than 10). If the date of translation is not available, an implementation-defined valid date is supplied.<br>
  <code>__TIME__</code> The time of translation of the source file (a character string literal of the form ""hh:mm:ss"" as in the time generated by the asctime function). If the time of translation is not available, an implementation-defined valid time is supplied.<br>
  <code>__STDC__</code> Whether <code>__STDC__</code> is predefined and if so, what its value is, are implementation-defined.<br>
  <code>__cplusplus</code> The name <code>__cplusplus</code> is defined to the value 199711L when compiling a C++
  translation unit.</p>
</blockquote>

<p>You want <code>__TIME__</code> and possibly <code>__DATE__</code>.</p>
"
"<p>I have declared a class as  </p>

<pre><code>class DCFrameListener : public FrameListener, public OIS::MouseListener, public OIS::KeyListener  
{
    bool keyPressed(const OIS::KeyEvent &amp; kEvt);
    bool keyReleased(const OIS::KeyEvent &amp;kEvt);

//*******some code missing************************   
};
</code></pre>

<p>But if i try defining the members like this  </p>

<pre><code>bool DCFrameListener::keyPressed(const OIS::KeyEvent kEvt)
{
    return true;
}
</code></pre>

<p>The compiler  refuses with this error  </p>

<pre><code>error C2511: 'bool DCFrameListener::keyPressed(const OIS::KeyEvent)' : overloaded member function not found in 'DCFrameListener'  
see declaration of 'DCFrameListener'
</code></pre>

<p>Why is  this happening, yet  i declared the member <strong>keyPressed(const OIS::KeyEvent)</strong> in my function declaration.</p>

<p>any help will be appreciated. Thanks</p>
","87234","","<p>The one in the declaration has a reference:</p>

<pre><code>bool keyPressed(const OIS::KeyEvent &amp; kEvt);
                                    ^!
bool DCFrameListener::keyPressed(const OIS::KeyEvent kEvt)
                                                    ^?
</code></pre>
"
"<p>I have a such syntax in program</p>

<pre><code>/* The Object1 is allowed to be changed */
class Object1 : BaseClass {
    BaseClass *link;
    int i;
    public: 
    Object1(int a){i=a;}
    Object1(int a, Object1 /*place1*/ o) {i=a; link= &amp;o;}
};

int main(){
/* The initialization syntax must be preserved. No any new(), no other local objects b,c */
    Object1 a(1, /*place2*/ Object1(2));
    ...
}
</code></pre>

<p>What do I need in place1? I want to save a link (pointer) to the second object in the first object. Should I use in place1 reference ""&amp;""? </p>

<p>What type will have ""Object1(2)"" in place2? Is it a constructor of the anonymous object? Will it have a ""auto"" storage type?</p>

<p>Thanks</p>

<p>UPDATE:</p>

<p>In the place2, the syntax is fixed and I really must support creating of ""chain"", like</p>

<pre><code>    Object1 a(1, Object1(2, Object1(6, Object1(999753))));
</code></pre>

<p>I can't add any symbol in the definiton of a.</p>

<p>UPDATE2:
 for place1: <code>Object1(int a, Object1 &amp;o) {i=a; link= &amp;o;}</code> and <code>Object1 a(1, Object1(2));</code> in place2 I have a compile error (g++): </p>

<pre><code>main.cpp||In function `int main()':|
main.cpp|19|error: no matching function for call to `Object1::Object1(int, Object1)'|
main.cpp|9|note: candidates are: Object1::Object1(const Object1&amp;)|
main.cpp|14|note:                 Object1::Object1(int, Object1&amp;)|
main.cpp|13|note:                 Object1::Object1(int)|
</code></pre>
","87234","","<p>In ""place1"", you need a reference. <code>Object1</code> isn't fully defined, so you can't take it by value. That said, you wouldn't want to pass by value; when you take the address of it, you'd be getting the address of the copy, not the actual object.</p>

<p>Since you only want a pointer to a <code>BaseClass</code>, it might make more sense to only place that restriction on the parameter. (Of course, if you really need an <code>Object1</code>, reflect that in the type of <code>link</code>: <code>Object1* link;</code>).</p>

<p>Also consider using an initialization list:</p>

<pre><code>Object1(int a) : i(a), link(0) /* &lt;- important! */ { }
Object1(int a, BaseClass&amp; o) : i(a), link(&amp;o) { }
</code></pre>

<p>Always use an initialize list.</p>

<p>""place2"" creates an unnamed instance of <code>Object1</code> using a constructor. It has <strike>no storage(?)</strike> <code>auto</code> storage, and <a href=""http://stackoverflow.com/questions/2298781/why-do-un-named-c-objects-destruct-before-the-scope-block-ends/2298796""><em>dies at the end of the expression</em></a>.</p>

<p>That is, once you've hit the semicolon in <code>Object1 a(1, /*place2*/ Object1(2));</code>, it ceases to exist and you have a pointer to an non-existent object! This results in undefined behavior.</p>

<p>Give it a lifetime beyond the expression:</p>

<pre><code>Object1 x(2);    
Object1 a(1, x);
</code></pre>

<p>Always make sure that when you refer an object, it will live the entire time you refer to it.</p>

<hr>

<p>Your new compile error is because you can't have a reference to a temporary variable. You <em>can</em> have one with a const-reference, though. The thing is, your pointer needs to point to a <code>const BaseClass</code> now, which may dampen what you want.</p>

<p>Again, your design needs reworking, unfortunately. </p>
"
"<p>I want to insert n elements into a map where n is known ahead of time. I do not want memory allocation at each insertion. I want all memory allocation at the beginning. Is there a way to do this? If so, how? Will writing some sort of memory allocator help?</p>

<p>I ran GMan's code and got the following output. GetMem is printed from a call to ""new"" and FreeMem is printed from a call to delete. size is the number of bytes requested and ptr is the pointer returned. Clearly, allocation/deallocation is going on during insertion. How do you explain this?</p>

<p>GetMem size 40, ptr 0x8420008<br>
GetMem size 40, ptr 0x8420038<br>
GetMem size 120, ptr 0x8420068<br>
GetMem size 120, ptr 0x84200e8<br>
FreeMem ptr 0x8420068<br>
FreeMem ptr 0x8420038<br>
FreeMem ptr 0x8420008<br>
Inserting: [0,0]<br>
GetMem size 40, ptr 0x8420008<br>
FreeMem ptr 0x8420008<br>
Inserting: [1,2]<br>
GetMem size 40, ptr 0x8420008<br>
FreeMem ptr 0x8420008<br>
Inserting: [2,4]<br>
GetMem size 40, ptr 0x8420008<br>
FreeMem ptr 0x8420008<br>
Inserting: [3,6]<br>
GetMem size 40, ptr 0x8420008<br>
FreeMem ptr 0x8420008<br>
Inserting: [4,8]<br>
GetMem size 40, ptr 0x8420008<br>
FreeMem ptr 0x8420008<br>
Inserting: [5,10]<br>
GetMem size 40, ptr 0x8420008<br>
FreeMem ptr 0x8420008<br>
GetMem size 40, ptr 0x8420008<br>
FreeMem ptr 0x8420008<br>
GetMem size 40, ptr 0x8420008<br>
FreeMem ptr 0x8420008<br>
GetMem size 40, ptr 0x8420008<br>
FreeMem ptr 0x8420008<br>
GetMem size 40, ptr 0x8420008<br>
FreeMem ptr 0x8420008<br>
FreeMem ptr 0x84200e8<br>
St9bad_alloc  </p>
","87234","","<h3>Response to allocation test</h3>

<p>Add this to either of the samples I give below:</p>

<pre><code>#include &lt;cstdlib&gt;

void* allocate(size_t pAmount)
{
    std::cout &lt;&lt; ""Allocating "" &lt;&lt; pAmount &lt;&lt; "" bytes."" &lt;&lt; std::endl;

    return std::malloc(pAmount);
}

void deallocate(void* pPtr)
{
    std::cout &lt;&lt; ""Deallocating."" &lt;&lt; std::endl;

    std::free(pPtr);
}

void* operator new(size_t pAmount) // throw(std::bad_alloc)
{
    return allocate(pAmount);
}

void *operator new[](size_t pAmount) // throw(std::bad_alloc)
{
    return allocate(pAmount);
}

void *operator new(size_t pAmount, const std::nothrow_t&amp;) throw()
{
    return allocate(pAmount);
}

void *operator new[](size_t pAmount, const std::nothrow_t&amp;) throw()
{
    return allocate(pAmount);
}

void operator delete(void* pMemory) throw()
{
    deallocate(pMemory);
}

void operator delete[](void* pMemory) throw()
{
    deallocate(pMemory);
}

void operator delete(void* pMemory, const std::nothrow_t&amp;) throw()
{
    deallocate(pMemory);
}

void operator delete[](void* pMemory, const std::nothrow_t&amp;) throw()
{
    deallocate(pMemory);
}
</code></pre>

<p>(Note, these are not fully correct replacements of the allocation operators, and are for demonstration.)</p>

<p>Running the runtime-sized sample program gives me the following output:</p>

<blockquote>
  <p>Allocating 40 bytes.<br>
  Allocating 40 bytes.<br>
  Allocating 40 bytes.<br>
  Allocating 40 bytes.<br>
  Allocating 40 bytes.<br>
  Allocating 40 bytes.<br>
  Allocating 40 bytes.<br>
  Deallocating.<br>
  Deallocating.<br>
  Allocating 120 bytes.<br>
  Deallocating.<br>
  Allocating 20 bytes.<br>
  Deallocating.<br>
  Allocating 40 bytes.<br>
  Deallocating.<br>
  Deallocating.<br>
  Deallocating.<br>
  Inserting: [0,0]<br>
  Inserting: [1,2]<br>
  Inserting: [2,4]<br>
  Inserting: [3,6]<br>
  Inserting: [4,8]<br>
  Deallocating.<br>
  Deallocating.<br>
  Deallocating.<br>
  bad allocation  </p>
</blockquote>

<p>Note there are no allocations once insertion has begun. You should be getting <em>no</em> memory allocations. How are you generating your output?</p>

<hr>

<h3>The allocators</h3>

<p>What you need is a new allocator. Here's something I made now, so it's relatively untested, but it looks good to me.</p>

<p>It creates a <a href=""http://en.wikipedia.org/wiki/Free_list"" rel=""nofollow"">freelist</a> and uses that to give out memory. Construction of the allocator takes O(N), but both allocations and deallocations are O(1). (Very fast!) Also, once it's constructed, no more memory allocations take place. Though freelists have average locality, it probably beats what you'd normally get out of a map with the default allocator.</p>

<p>Here it is:</p>

<pre><code>#include &lt;cassert&gt;
#include &lt;exception&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;

// gets rid of ""unused parameter"" warnings
#define USE(x) (void)(x)

template &lt;typename T, size_t N&gt;
class freelist_allocator
{
public: 
    // types
    typedef T value_type;
    typedef const T const_value_type;

    typedef value_type&amp; reference;
    typedef const_value_type&amp; const_reference;

    typedef value_type* pointer;
    typedef const_value_type* const_pointer;

    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;

    // ensure it can hold both a pointer and T
    struct block_type
    {
        char data[sizeof(T) &gt; sizeof(void*) ?
                    sizeof(T) : sizeof(void*)];
    };

    typedef std::vector&lt;block_type&gt; buffer_type;

    // constants
    static const size_t Elements = N;

    // rebind
    template&lt;typename U, size_t M = Elements&gt;
    struct rebind
    {
        typedef freelist_allocator&lt;U, M&gt; other;
    };

    // constructor
    freelist_allocator(void) :
    mBuffer(Elements),
    mNext(0)
    {
        build_list();
    }

    freelist_allocator(const freelist_allocator&amp;) :
    mBuffer(Elements),
    mNext(0)
    {
        build_list();
    }

    template&lt;typename U, size_t M&gt;
    freelist_allocator(const freelist_allocator&lt;U, M&gt;&amp;) :
    mBuffer(Elements),
    mNext(0)
    {
        build_list();
    }

    // address
    pointer address(reference r)
    {
        return &amp;r;
    }

    const_pointer address(const_reference r)
    {
        return &amp;r;
    }

    // memory
    pointer allocate(size_type pCount, const void* = 0)
    {
        USE(pCount); // pCount unused when assert is disabled in release
        assert(pCount == 1 &amp;&amp; ""freelist_allocator is noncontiguous"");

        // end of list
        if (!mNext)
            throw std::bad_alloc();

        // remove from list
        void* memory = mNext;
        mNext = data_as_ptr(*mNext);

        return static_cast&lt;pointer&gt;(memory);
    }

    void deallocate(pointer pPtr, size_type)
    {
        // get back our block
        block_type* b = reinterpret_cast&lt;block_type*&gt;(pPtr);

        // reinsert to list
        data_as_ptr(*b) = mNext;
        mNext = b;
    }

    // size
    size_type max_size(void) const
    {
        static const size_t MaxSize = 
                    std::numeric_limits&lt;size_type&gt;::max();
        return MaxSize / sizeof(value_type);
    }

    // construction / destruction
    void construct(pointer pPtr, const T&amp; pT)
    {
        new (pPtr) T(pT);
    }

    void destroy(pointer pPtr)
    {
        USE(pPtr); // trivial destructor skips next line
        pPtr-&gt;~value_type();
    }   

private:
    // utility
    block_type*&amp; data_as_ptr(block_type&amp; pBlock)
    {
        return reinterpret_cast&lt;block_type*&amp;&gt;(pBlock.data);
    }

    void build_list(void)
    {
        // build list
        for (size_t i = 1; i &lt; mBuffer.size(); ++i)
        {
            data_as_ptr(mBuffer[i - 1]) = &amp;mBuffer[i];
        }

        mNext = &amp;mBuffer[0];
    }

    // members
    buffer_type mBuffer;
    block_type* mNext;
};

// equality
template&lt;typename T, size_t N&gt;
bool operator==(freelist_allocator&lt;T, N&gt; const&amp;,
                freelist_allocator&lt;T, N&gt; const&amp;)
{
    return false;
}

template&lt;typename T, size_t N&gt;
bool operator!=(freelist_allocator&lt;T, N&gt; const&amp; pX,
                freelist_allocator&lt;T, N&gt; const&amp; pY)
{
    return !(pX == pY);
}

#undef USE
</code></pre>

<p>And use:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

static const size_t MaxElements = 5;

typedef std::pair&lt;int, int&gt; pair_type;
typedef freelist_allocator&lt;pair_type, MaxElements&gt; allocator_type;
typedef std::map&lt;int, int,
                    std::less&lt;int&gt;, allocator_type&gt; map_type;

void do_insert(int pX, int pY, map_type&amp; pMap)
{
    std::cout &lt;&lt; ""Inserting: ["" &lt;&lt; pX &lt;&lt; "",""
        &lt;&lt; pY &lt;&lt; ""]"" &lt;&lt; std::endl;

    pMap.insert(std::make_pair(pX, pY));
}

int main(void)
{   
    try
    {
        map_type m;

        // just keep inserting
        for (int i = 0; i &lt;= std::numeric_limits&lt;int&gt;::max() / 2; ++i)
        {
            // will throw at MaxElements insertions
            do_insert(i, i * 2, m);
        }
    }
    catch (const std::exception&amp; e)
    {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}
</code></pre>

<p><strike>For now I've made the size a compile-time constant, but you want a run-time version just let me know and I'll write that up.</strike> Here's a version that takes a size at run-time:</p>

<pre><code>#include &lt;cassert&gt;
#include &lt;exception&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;

// gets rid of ""unused parameter"" warnings
#define USE(x) (void)(x)

template &lt;typename T&gt;
class freelist_allocator
{
public: 
    // types
    typedef T value_type;
    typedef const T const_value_type;

    typedef value_type&amp; reference;
    typedef const_value_type&amp; const_reference;

    typedef value_type* pointer;
    typedef const_value_type* const_pointer;

    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;

    // ensure it can hold both a pointer and T
    struct block_type
    {
        char data[sizeof(T) &gt; sizeof(void*) ?
                    sizeof(T) : sizeof(void*)];
    };

    typedef std::vector&lt;block_type&gt; buffer_type;

    // rebind
    template&lt;typename U&gt;
    struct rebind
    {
        typedef freelist_allocator&lt;U&gt; other;
    };

    // constructor
    freelist_allocator(size_t pElements) :
    mBuffer(pElements),
    mNext(0)
    {
        build_list();
    }

    freelist_allocator(const freelist_allocator&amp; pRhs) :
    mBuffer(pRhs.size()),
    mNext(0)
    {
        build_list();
    }

    template&lt;typename U&gt;
    freelist_allocator(const freelist_allocator&lt;U&gt;&amp; pRhs) :
    mBuffer(pRhs.size()),
    mNext(0)
    {
        build_list();
    }

    // address
    pointer address(reference r)
    {
        return &amp;r;
    }

    const_pointer address(const_reference r)
    {
        return &amp;r;
    }

    // memory
    pointer allocate(size_type pCount, const void* = 0)
    {
        USE(pCount); // pCount unused when assert is disabled in release
        assert(pCount == 1 &amp;&amp; ""freelist_allocator is noncontiguous"");

        // end of list
        if (!mNext)
            throw std::bad_alloc();

        // remove from list
        void* memory = mNext;
        mNext = data_as_ptr(*mNext);

        return static_cast&lt;pointer&gt;(memory);
    }

    void deallocate(pointer pPtr, size_type)
    {
        // get back our block
        block_type* b = reinterpret_cast&lt;block_type*&gt;(pPtr);

        // reinsert to list
        data_as_ptr(*b) = mNext;
        mNext = b;
    }

    // size
    size_type max_size(void) const
    {
        static const size_t MaxSize = 
                    std::numeric_limits&lt;size_type&gt;::max();
        return MaxSize / sizeof(value_type);
    }

    size_t size(void) const
    {
        return mBuffer.size();
    }

    // construction / destruction
    void construct(pointer pPtr, const T&amp; pT)
    {
        new (pPtr) T(pT);
    }

    void destroy(pointer pPtr)
    {
        USE(pPtr); // trivial destructor skips next line
        pPtr-&gt;~value_type();
    }   

private:
    // utility
    block_type*&amp; data_as_ptr(block_type&amp; pBlock)
    {
        return reinterpret_cast&lt;block_type*&amp;&gt;(pBlock.data);
    }

    void build_list(void)
    {
        // build list
        for (size_t i = 1; i &lt; mBuffer.size(); ++i)
        {
            data_as_ptr(mBuffer[i - 1]) = &amp;mBuffer[i];
        }

        mNext = &amp;mBuffer[0];
    }

    // members
    buffer_type mBuffer;
    block_type* mNext;
};

// equality
template&lt;typename T&gt;
bool operator==(freelist_allocator&lt;T&gt; const&amp;,
                freelist_allocator&lt;T&gt; const&amp;)
{
    return false;
}

template&lt;typename T, size_t N&gt;
bool operator!=(freelist_allocator&lt;T&gt; const&amp; pX,
                freelist_allocator&lt;T&gt; const&amp; pY)
{
    return !(pX == pY);
}

#undef USE
</code></pre>

<p>Use:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

static const size_t MaxElements = 5;

template &lt;typename Key, typename Value&gt;
struct map_types // helpful
{
    typedef std::pair&lt;Key, Value&gt; pair_type;
    typedef freelist_allocator&lt;pair_type&gt; allocator_type;
    typedef std::less&lt;Key&gt; predicate_type;
    typedef std::map&lt;Key, Value,
                    predicate_type, allocator_type&gt; map_type;
};

template &lt;typename Key, typename Value, typename Map&gt;
void do_insert(const Key&amp; pX, const Value&amp; pY, Map&amp; pMap)
{
    std::cout &lt;&lt; ""Inserting: ["" &lt;&lt; pX &lt;&lt; "",""
                &lt;&lt; pY &lt;&lt; ""]"" &lt;&lt; std::endl;

    pMap.insert(std::make_pair(pX, pY));
}

int main(void)
{   
    try
    {
        typedef map_types&lt;int, int&gt; map_types;

        // double parenthesis to avoid vexing parse
        map_types::map_type m((map_types::predicate_type()),
                            map_types::allocator_type(MaxElements));

        // just keep inserting
        for (int i = 0; i &lt;= std::numeric_limits&lt;int&gt;::max() / 2; ++i)
        {
            do_insert(i, i * 2, m);
        }
    }
    catch (const std::exception&amp; e)
    {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}
</code></pre>

<p>The run-time version could possibly allocate more space if there are no more remaining slots, which can be useful. But I leave that to you. (Don't resize the vector! You'll possibly lose your entire buffer. You'll need a <code>list</code> of vectors, likely.)</p>

<p>Note if you can use Boost, they have such an allocator in their <a href=""http://www.boost.org/doc/libs/1_42_0/libs/pool/doc/index.html"" rel=""nofollow"">Pool library</a>. That said, their allocator keeps track of the order you request memory, to ensure reverse construction destruction order. This turns allocations and deallocations into O(N). (A terrible choice in my opinion.) I actually wrote my own allocator around <code>boost::pool&lt;&gt;</code> to get around this.</p>
"
"<p>I'm making a small file reading and data validation program as part of my TAFE (a tertiary college) course, This includes checking and validating dates.</p>

<p>I decided that it would be best done with a seperate class, rather than integrating it into my main driver class.</p>

<p>The problem is that I'm getting a segmentation fault(core dumped) after my test program runs. Near as I can tell, the error occurs when the program terminates, popping up after the destructor is called. So far I have had no luck finding the cause of this fault, and was hoping that some enlightened soul might show me the error of my ways.</p>

<p>date.h</p>

<pre><code>#ifndef DATE_H
#define DATE_H

#include &lt;string&gt;
using std::string;

#include &lt;sstream&gt;
using std::stringstream;

#include &lt;cstdlib&gt;
using std::exit;

#include &lt;iostream&gt;
using std::cout;
using std::endl;

class date {

    public:
        explicit date();
        ~date();
        bool before(string dateIn1, string dateIn2);
        int yearsBetween(string dateIn1, string dateIn2);
        bool isValid(string dateIn);
        bool getDate(int date[], string dateIn);
        bool isLeapYear(int year);
    private:
        int days[];

};
#endif
</code></pre>

<p>date.cpp</p>

<pre><code>#include ""date.h""

date::date() {

    days[0] = 31;
    days[1] = 28;
    days[2] = 31;
    days[3] = 30;
    days[4] = 31;
    days[5] = 30;
    days[6] = 31;
    days[7] = 31;
    days[8] = 30;
    days[9] = 31;
    days[10] = 30;
    days[11] = 31;

}

bool date::before(string dateIn1, string dateIn2) {

    int date1[3];
    int date2[3];

    getDate(date1, dateIn1);
    getDate(date2, dateIn2);

    if (date1[2] &lt; date2[2]) {

        return true;

    } else if (date1[1] &lt; date2[1]) {

        return true;

    } else if (date1[0] &lt; date2[0]) {

        return true;

    }

    return false;

}

date::~date() {

    cout &lt;&lt; ""this is for testing only, plox delete\n"";

}

int date::yearsBetween(string dateIn1, string dateIn2) {

    int date1[3];
    int date2[3];

    getDate(date1, dateIn1);
    getDate(date2, dateIn2);

    int years = date2[2] - date1[2];

    if (date1[1] &gt; date2[1]) {

        years--;

    } 

    if ((date1[1] == date2[1]) &amp;&amp; (date1[0] &gt; date2[1])) {

        years--;

    }

    return years;

}

bool date::isValid(string dateIn) {

    int date[3];

    if (getDate(date, dateIn)) {

        if (date[1] &lt;= 12) {

            int extraDay = 0;

            if (isLeapYear(date[2])) {

                extraDay++;

            }

            if ((date[0] + extraDay) &lt;= days[date[1] - 1]) {

                return true;

            }

        }

    } else {

        return false;

    }

}

bool date::getDate(int date[], string dateIn) {

    string part1, part2, part3;

    size_t whereIs, lastFound;

    whereIs = dateIn.find(""/"");

    part1 = dateIn.substr(0, whereIs);

    lastFound = whereIs + 1;

    whereIs = dateIn.find(""/"", lastFound);

    part2 = dateIn.substr(lastFound, whereIs - lastFound);

    lastFound = whereIs + 1;

    part3 = dateIn.substr(lastFound, 4);

    stringstream p1(part1);
    stringstream p2(part2);
    stringstream p3(part3);

    if (p1 &gt;&gt; date[0]) {

        if (p2&gt;&gt;date[1]) {

            return (p3&gt;&gt;date[2]);

        } else {

            return false;

        }

        return false;

    }

}

bool date::isLeapYear(int year) {

    return ((year % 4) == 0);

}
</code></pre>

<p>and Finally, the test program</p>

<pre><code>#include &lt;iostream&gt;
using std::cout;
using std::endl;

#include ""date.h""

int main() {

    date d;

    cout &lt;&lt; ""1/1/1988 before 3/5/1990 ["" &lt;&lt; d.before(""1/1/1988"", ""3/5/1990"")
        &lt;&lt; ""]\n1/1/1988 before 1/1/1970 ["" &lt;&lt; d.before(""a/a/1988"", ""1/1/1970"")
        &lt;&lt;""]\n"";

    cout &lt;&lt; ""years between 1/1/1988 and 1/1/1998 ["" 
        &lt;&lt; d.yearsBetween(""1/1/1988"", ""1/1/1998"") &lt;&lt; ""]\n"";

    cout &lt;&lt; ""is 1/1/1988 valid ["" &lt;&lt; d.isValid(""1/1/1988"") &lt;&lt; ""]\n"" 
        &lt;&lt; ""is 2/13/1988 valid ["" &lt;&lt; d.isValid(""2/13/1988"") &lt;&lt; ""]\n""
        &lt;&lt; ""is 32/12/1988 valid ["" &lt;&lt; d.isValid(""32/12/1988"") &lt;&lt; ""]\n"";

    cout &lt;&lt; ""blerg\n"";

}
</code></pre>

<p>I've left in some extraneous cout statements, which I've been using to try and locate the error.</p>

<p>I thank you in advance.</p>
","87234","","<pre><code>int days[];
</code></pre>

<p>This is a non-standard extension. You must specify a size for the array, such as:</p>

<pre><code>static const MonthCount = 12;
int days[MonthCount];
</code></pre>

<p>To actually have an array to use. Otherwise you have a ""zero-sized array"" (not standard!). Your program is tromping over memory every time you use any element of your current array.</p>
"
"<p>Hi iam new to c++ and iam trying out this vector program and i am getting the following error:
error: conversion from <code>test*' to non-scalar type</code>test' requested|</p>

<p>Here is the code </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

class test{

    string s;
    vector &lt;string&gt; v;
    public:
    void read(){
        ifstream in (""c://test.txt"");
        while(getline(in,s))
        {
             v.push_back(s);
        }
        for(int i=0;i&lt;v.size();i++)
        {
        cout&lt;&lt;v[i]&lt;&lt;""\n"";
        }
    }

};
int main()
{
    cout&lt;&lt;""Opening the file to read and displaying on the screen""&lt;&lt;endl;
    test t=new test();
    t.read();

}
</code></pre>
","87234","","<p><code>new</code> is used to dynamically allocate memory. You don't need to do that, so just do:</p>

<pre><code>test t; // create an instance of test with automatic storage
t.read(); // invoke a method
</code></pre>

<p>The error is because the type of <code>new test()</code> is a <code>test*</code>, a pointer to a (newly created) <code>test</code>. You can't assign a <code>test*</code> to a <code>test</code>.</p>

<hr>

<p>The pointer version, for what it's worth, would have been:</p>

<pre><code>test* t = new test();
t-&gt;read(); // the arrow is short for (*test).
delete t; // don't forget to clean up!
</code></pre>

<p>However, it's bad style to do raw memory allocation like that. You'd use something called a smart pointer to make sure it gets deleted automatically, instead. The standard library has one in the header <code>&lt;memory&gt;</code>, called <code>auto_ptr</code>, that would suffice:</p>

<pre><code>std::auto_ptr&lt;test&gt; t(new test()); // put a new test into a pointer wrapper
t-&gt;read(); // treat it like a normal pointer
// nothing else to worry about, will be deleted automatically
</code></pre>

<p>However, all this isn't needed for you, in this case. Always prefer automatic (stack) allocation over dynamic allocation.</p>
"
"<p>I'm using MSVC++, and I want to use the special value INFINITY in my code.</p>

<p>What's the byte pattern or constant to use in MSVC++ for infinity?</p>

<p>Why does 1.0f/0.0f appear to have the value 0?</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

int main()
{
  float zero = 0.0f ;
  float inf = 1.0f/zero ;

  printf( ""%f\n"", inf ) ; // 1.#INF00
  printf( ""%x\n"", inf ) ; // why is this 0?

  printf( ""%f\n"", zero ) ; // 0.000000
  printf( ""%x\n"", zero ) ; // 0

}
</code></pre>
","87234","","<p>Use <a href=""http://en.cppreference.com/w/cpp/types/numeric_limits"" rel=""nofollow""><code>numeric_limits</code></a>:</p>

<pre><code>#include &lt;limits&gt;

float maxFloat = std::numeric_limits&lt;float&gt;::infinity();
</code></pre>
"
"<p>g++ compiler gives this <strong>error: expected `;' before 'it'</strong></p>

<pre><code>template &lt;typename T&gt;
class myList : public std::list&lt;T&gt;
{   
public:

  void foo () 
  { 
    std::list&lt;T&gt;::iterator it;       // compiler error as above mentioned, why ???
  }
};
</code></pre>

<p>Thanks.</p>
","87234","","<p>Neil's given you your answer. That said, you might want to make a slew of typedef's and use those, so your work doesn't become so tedious (and it increases readability):</p>

<pre><code>template &lt;typename T&gt;
class myList : public std::list&lt;T&gt;
{   
public:
    typedef T value_type;
    typedef const T const_value_type;
    typedef value_type&amp; reference;
    typedef const_value_type&amp; const_reference;
    typedef value_type* pointer;
    typedef const_value_type* const_pointer;

    typedef std::list&lt;T&gt; base_container;
    typedef typename base_container::iterator iterator;
    typedef typename base_container::const_iterator const_iterator;

    void foo () 
    { 
        iterator it; // easy peasy
    }
};
</code></pre>

<p>It's quite common to be liberal with your use of typedef's.</p>

<p>Also, inheriting from a standard container might be a bad idea, since they aren't really made for such a thing. For example, a free function is often the <a href=""http://punchlet.wordpress.com/2009/12/29/letter-the-fifth/"">best choice</a> if you're looking for some extensions to a container.</p>
"
"<p>I have the following two methods that (as you can see) are similar in most of its statements except for one (see below for details)</p>

<pre><code>unsigned int CSWX::getLineParameters(const SURFACE &amp; surface, vector&lt;double&gt; &amp; params)
{
    VARIANT varParams;

    surface-&gt;getPlaneParams(varParams); // this is the line of code that is different

    SafeDoubleArray sdParams(varParams);

    for( int i = 0 ;  i &lt; sdParams.getSize() ; ++i )
    {
        params.push_back(sdParams[i]);
    }

    if( params.size() &gt; 0 ) return 0;
    return 1;
}

unsigned int CSWX::getPlaneParameters(const CURVE &amp; curve, vector&lt;double&gt; &amp; params)
{
    VARIANT varParams;

    curve-&gt;get_LineParams(varParams); // this is the line of code that is different

    SafeDoubleArray sdParams(varParams);

    for( int i = 0 ;  i &lt; sdParams.getSize() ; ++i )
    {
        params.push_back(sdParams[i]);
    }

    if( params.size() &gt; 0 ) return 0;
    return 1;
}
</code></pre>

<p>Is there any technique that I can use to move the common lines of code of the two methods out to a separate method, that could be called from the two variations - OR - possibly combine the two methods to a single method?</p>

<p>The following are the restrictions:</p>

<ol>
<li>The classes SURFACE and CURVE are from 3rd party libraries and hence unmodifiable. (If it helps they are both derived from IDispatch)</li>
<li>There are even more similar classes (e.g. FACE) that could fit into this ""template"" (not C++ template, just the flow of lines of code)</li>
</ol>

<p>I know the following could (possibly?) be implemented as solutions but am really hoping there is a better solution:</p>

<ol>
<li>I could add a 3rd parameter to the 2 methods - e.g. an enum - that identifies the 1st parameter (e.g. enum::input_type_surface, enum::input_type_curve)</li>
<li>I could pass in an IDispatch and try dynamic_cast&lt;> and test which cast is NON_NULL and do an if-else to call the right method (e.g. getPlaneParams() vs. get_LineParams())</li>
</ol>

<p>The following is not a restriction but would be a requirement because of my teammates resistance:</p>

<ol>
<li>Not implement a new class that inherits from SURFACE/CURVE etc. (They would much prefer to solve it using the enum solution I stated above)</li>
</ol>
","87234","","<p>A couple ideas come to mind, but here's what I think would be best:</p>

<pre><code>namespace detail
{
    void getParameters(const SURFACE&amp; surface, VARIANT&amp; varParams)
    {
        surface-&gt;getPlaneParams(varParams);
    }

    void getParameters(const CURVE&amp; curve, VARIANT&amp; varParams)
    {
        curve-&gt;get_LineParams(varParams);
    }
}

template &lt;typename T&gt;
unsigned int getParameters(const T&amp; curve, vector&lt;double&gt; &amp; params)
{
    VARIANT varParams;
    detail::getParameters(curve, varParams);

    SafeDoubleArray sdParams(varParams);
    for( int i = 0 ;  i &lt; sdParams.getSize() ; ++i )
    {
        params.push_back(sdParams[i]);
    }

    return params.size() != 0;
}
</code></pre>

<p>What you do is delegate the task of getting parameters to some other function that is overloaded. Just add functions like that for each different type you have. (Note, I simplified your return statement.)</p>
"
"<p>I am trying to use Boost::Fusion (Boost v1.42.0) in a personal project. I get an interesting error with this code:</p>

<pre><code>#include ""boost/fusion/include/sequence.hpp""
#include ""boost/fusion/include/make_vector.hpp""
#include ""boost/fusion/include/insert.hpp""
#include ""boost/fusion/include/invoke_procedure.hpp""
#include ""boost/fusion/include/make_vector.hpp""
#include &lt;iostream&gt;

class Class1
{ 
    public:
    typedef boost::fusion::vector&lt;int,float,float,char,int,int&gt; SequenceType;
    SequenceType s;
        Class1(SequenceType v):s(v){}
};

class Class2
{
    public:
    Class2(){}
    void met(int a,float b ,float c ,char d ,int e,int f)
    {
        std::cout &lt;&lt; a &lt;&lt; "" "" &lt;&lt; b &lt;&lt; "" "" &lt;&lt; c &lt;&lt; "" "" &lt;&lt; d &lt;&lt; "" "" &lt;&lt; e &lt;&lt; std::endl;
    }
};

int main(int argn, char**)
{
Class2 p;
Class1 t(boost::fusion::make_vector(9,7.66f,8.99f,'s',7,6));
boost::fusion::begin(t.s); //OK
boost::fusion::insert(t.s, boost::fusion::begin(t.s), &amp;p); //OK
boost::fusion::invoke_procedure(&amp;Class2::met,boost::fusion::insert(t.s, boost::fusion::begin(t.s), &amp;p)); //FAILS
}
</code></pre>

<p>It fails to compile (gcc 4.4.1):</p>

<pre><code>In file included from /home/thechaos/Escriptori/of_preRelease_v0061_linux_FAT/addons/ofxTableGestures/ext/boost/fusion/include/invoke_procedur
e.hpp:10,
                 from problema concepte.cpp:11:
/home/thechaos/Escriptori/of_preRelease_v0061_linux_FAT/addons/ofxTableGestures/ext/boost/fusion/functional/invocation/invoke_procedure.hpp: I
n function ‘void boost::fusion::invoke_procedure(Function, const Sequence&amp;) [with Function = void (Class2::*)(int, float, float, char, int, in
t), Sequence = boost::fusion::joint_view&lt;boost::fusion::joint_view&lt;boost::fusion::iterator_range&lt;boost::fusion::vector_iterator&lt;const boost::f
usion::vector&lt;int, float, float, char, int, int, boost::fusion::void_, boost::fusion::void_, boost::fusion::void_, boost::fusion::void_&gt;, 0&gt;, 
boost::fusion::vector_iterator&lt;boost::fusion::vector&lt;int, float, float, char, int, int, boost::fusion::void_, boost::fusion::void_, boost::fus
ion::void_, boost::fusion::void_&gt;, 0&gt; &gt;, const boost::fusion::single_view&lt;Class2*&gt; &gt;, boost::fusion::iterator_range&lt;boost::fusion::vector_iter
ator&lt;boost::fusion::vector&lt;int, float, float, char, int, int, boost::fusion::void_, boost::fusion::void_, boost::fusion::void_, boost::fusion:
:void_&gt;, 0&gt;, boost::fusion::vector_iterator&lt;const boost::fusion::vector&lt;int, float, float, char, int, int, boost::fusion::void_, boost::fusion
::void_, boost::fusion::void_, boost::fusion::void_&gt;, 6&gt; &gt; &gt;]’:
problema concepte.cpp:39:   instantiated from here
/home/thechaos/Escriptori/of_preRelease_v0061_linux_FAT/addons/ofxTableGestures/ext/boost/fusion/functional/invocation/invoke_procedure.hpp:88
: error: incomplete type ‘boost::fusion::detail::invoke_procedure_impl&lt;void (Class2::*)(int, float, float, char, int, int), const boost::fusio
n::joint_view&lt;boost::fusion::joint_view&lt;boost::fusion::iterator_range&lt;boost::fusion::vector_iterator&lt;const boost::fusion::vector&lt;int, float, f
loat, char, int, int, boost::fusion::void_, boost::fusion::void_, boost::fusion::void_, boost::fusion::void_&gt;, 0&gt;, boost::fusion::vector_itera
tor&lt;boost::fusion::vector&lt;int, float, float, char, int, int, boost::fusion::void_, boost::fusion::void_, boost::fusion::void_, boost::fusion::
void_&gt;, 0&gt; &gt;, const boost::fusion::single_view&lt;Class2*&gt; &gt;, boost::fusion::iterator_range&lt;boost::fusion::vector_iterator&lt;boost::fusion::vector&lt;
int, float, float, char, int, int, boost::fusion::void_, boost::fusion::void_, boost::fusion::void_, boost::fusion::void_&gt;, 0&gt;, boost::fusion:
:vector_iterator&lt;const boost::fusion::vector&lt;int, float, float, char, int, int, boost::fusion::void_, boost::fusion::void_, boost::fusion::voi
d_, boost::fusion::void_&gt;, 6&gt; &gt; &gt;, 7, true, false&gt;’ used in nested name specifier
</code></pre>

<p>However, if I change the number of arguments in the vectors and the method from 6 to 5 from <code>int,float,float,char,int,int</code> to <code>int,float,float,char,int</code>,I can compile it without problems.</p>

<p>I suspected about the maximum number of arguments being a limitation, but I tried to change it through defining <code>FUSION_MAX_VECTOR_SIZE</code> without success.</p>

<p>I am unable to see what am I doing wrong. Can you reproduce this? Can it be a boost bug (i doubt it but is not impossible)?</p>
","87234","","<p>Yes indeed, you need to change some iteration limits. You're just changing the wrong one. :)</p>

<p>What you need to define is <code>BOOST_FUSION_INVOKE_PROCEDURE_MAX_ARITY</code>; by default, it is 6. You obviously need 7 (but might as well bump it to 10):</p>

<pre><code>#define BOOST_FUSION_INVOKE_PROCEDURE_MAX_ARITY 10

#include ""boost/fusion/include/sequence.hpp""
#include ""boost/fusion/include/make_vector.hpp""
#include ""boost/fusion/include/insert.hpp""
#include ""boost/fusion/include/invoke_procedure.hpp""
#include ""boost/fusion/include/make_vector.hpp""
#include &lt;iostream&gt;
.
.
.
</code></pre>

<p>There are <a href=""http://www.boost.org/doc/libs/1_42_0/libs/fusion/doc/html/fusion/functional/invocation/limits.html"" rel=""nofollow"">three total</a> within the invocation domain.</p>

<p>Whenever you're looking for the limit of something, search for ""Limits"" on the <a href=""http://www.boost.org/doc/libs/1_42_0/libs/fusion/doc/html/index.html"" rel=""nofollow"">documentation</a>. Choose the one relevant to what you're doing. From there, it tells you the defaults and what the options are.</p>

<hr>

<p>Just concerning the code itself, I should point out there is a <a href=""http://www.boost.org/doc/libs/1_42_0/libs/fusion/doc/html/fusion/algorithm/transformation/functions.html"" rel=""nofollow""><code>push_front</code></a> function:</p>

<pre><code>#include ""boost/fusion/include/push_front.hpp""

// ...

boost::fusion::invoke_procedure(&amp;Class2::met,
                                boost::fusion::push_front(t.s, &amp;p));
</code></pre>

<p>So you don't need to do the more verbose insert-at-begin.</p>
"
"<p>is there, and if, what it does?</p>

<pre><code>.*
</code></pre>
","87234","","<p>You may come across that operator when using member pointers:</p>

<pre><code>struct foo
{
    void bar(void);
};

typedef void (foo::*func_ptr)(void);

func_ptr fptr = &amp;foo::bar;
foo f;

(f.*fptr)(); // call
</code></pre>

<p>Also related is the <code>-&gt;*</code> operator:</p>

<pre><code>func_ptr fptr = &amp;foo::bar;
foo f;
foo* fp = &amp;f;

(fp-&gt;*fptr)(); // call
</code></pre>
"
"<p>Suppose I have a <code>vector&lt;int&gt; myvec</code> and I want to loop through all of the elements in reverse. I can think of a few ways of doing this:</p>

<pre><code>for (vector&lt;int&gt;::iterator it = myvec.end() - 1; it &gt;= myvec.begin(); --it)
{
    // do stuff here
}

for (vector&lt;int&gt;::reverse_iterator rit = myvec.rbegin(); rit != myvec.rend(); ++rit)
{
    // do stuff here
}

for (int i = myvec.size() - 1; i &gt;= 0; --i)
{
    // do stuff here
}
</code></pre>

<p>So my question is when should I use each? Is there a difference? I know that the first one is dangerous because if I pass in an empty vector, then <code>myvec.end() - 1</code> is undefined, but are there any other hazards or inefficiencies with this?</p>
","87234","","<p>The <code>reverse_iterator</code> version shows intent and works across all containers, regardless of their contents.</p>

<p>The first has the deficiency you describe. It also uses <code>&gt;=</code>, which won't work for non-random-access iterators. </p>

<p>The third has the problem that <code>i</code> is an <code>int</code>. It won't be able to hold as much as <code>size()</code> could potentially return. Making it unsigned works (<code>vector&lt;int&gt;::size_type</code>), but then we have the same problem as solution one. (<code>0U - 1</code> -> <code>Funky terminating checks</code> -> <code>:|</code>)</p>
"
"<p>Given an STL vector, output only the duplicates in sorted order, e.g.,</p>

<pre><code>INPUT : { 4, 4, 1, 2, 3, 2, 3 }
OUTPUT: { 2, 3, 4 }
</code></pre>

<p>The algorithm is trivial, but the goal is to make it as efficient as std::unique().  My naive implementation modifies the container in-place:</p>

<p><strong>My naive implementation:</strong></p>

<pre><code>void not_unique(vector&lt;int&gt;* pv)
{
    if (!pv)
        return;

 // Sort (in-place) so we can find duplicates in linear time
 sort(pv-&gt;begin(), pv-&gt;end());

 vector&lt;int&gt;::iterator it_start = pv-&gt;begin();
 while (it_start != pv-&gt;end())
 {
  size_t nKeep = 0;

  // Find the next different element
  vector&lt;int&gt;::iterator it_stop = it_start + 1;
  while (it_stop != pv-&gt;end() &amp;&amp; *it_start == *it_stop)
  {
   nKeep = 1; // This gets set redundantly
   ++it_stop;
  }

  // If the element is a duplicate, keep only the first one (nKeep=1).
  // Otherwise, the element is not duplicated so erase it (nKeep=0).
  it_start = pv-&gt;erase(it_start + nKeep, it_stop);
 }
}
</code></pre>

<p>If you can make this more efficient, elegant, or general, please let me know.  For example, a custom sorting algorithm, or copy elements in the 2nd loop to eliminate the erase() call.</p>
","87234","","<p>This is in the style of the standard library. Credit for algorithm <a href=""http://stackoverflow.com/questions/2550229/how-to-keep-only-duplicates-efficiently/2550393#2550393"">goes to James</a>! (If you +1 me, you better +1 him, <strong><em>or else</em></strong>). All I did was make it standard library style:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

// other stuff (not for you)
template &lt;typename T&gt;
void print(const char* pMsg, const T&amp; pContainer)
{
    std::cout &lt;&lt; pMsg &lt;&lt; ""\n    "";
    std::copy(pContainer.begin(), pContainer.end(),
        std::ostream_iterator&lt;typename T::value_type&gt;(std::cout, "" ""));
    std::cout &lt;&lt; std::endl;
}

template &lt;typename T, size_t N&gt;
T* endof(T (&amp;pArray)[N])
{
    return &amp;pArray[0] + N;
}

// not_unique functions (for you)
template &lt;typename ForwardIterator, typename BinaryPredicate&gt;
ForwardIterator not_unique(ForwardIterator pFirst, ForwardIterator pLast,
                           BinaryPredicate pPred)
{
    // correctly handle case where an empty range was given:
    if (pFirst == pLast) 
    { 
        return pLast; 
    }

    ForwardIterator result = pFirst;
    ForwardIterator previous = pFirst;

    for (++pFirst; pFirst != pLast; ++pFirst, ++previous)
    {
        // if equal to previous
        if (pPred(*pFirst, *previous))
        {
            if (previous == result)
            {
                // if we just bumped bump again
                ++result;
            }
            else if (!pPred(*previous, *result))
            {
                // if it needs to be copied, copy it
                *result = *previous;

                // bump
                ++result;
            }
        }
    }

    return result;
}

template &lt;typename ForwardIterator&gt;
ForwardIterator not_unique(ForwardIterator pFirst, ForwardIterator pLast)
{
    return not_unique(pFirst, pLast,
                std::equal_to&lt;typename ForwardIterator::value_type&gt;());
}


//test
int main()
{
    typedef std::vector&lt;int&gt; vec;

    int data[] = {1, 4, 7, 7, 2, 2, 2, 3, 9, 9, 5, 4, 2, 8};
    vec v(data, endof(data));

    // precondition
    std::sort(v.begin(), v.end());
    print(""before"", v);

    // duplicatify (it's a word now)
    vec::iterator iter = not_unique(v.begin(), v.end());
    print(""after"", v);

    // remove extra
    v.erase(iter, v.end());
    print(""erased"", v);
}
</code></pre>
"
"<p>I am very familiar with STL vector (and other container) performance guarantees, however I can't seem to find anything concrete about plain arrays. </p>

<p>Are pointer arithmetic and [] methods constant or linear time?</p>
","87234","","<p>They are constant time. (Same as <code>vector</code>.)</p>

<p>When you say <code>a[b]</code>, it becomes <code>*(a + b)</code>. Both (pointer arithmetic) addition and dereferencing are constant time.</p>

<p>When adding an integer to a pointer, it moves that many elements over:</p>

<pre><code>T* p; size_t i;

T* q = p + i; // same as:
T* q = reinterpret_cast&lt;T*&gt;(reinterpret_cast&lt;char*&gt;(p) + i * sizeof(T));
</code></pre>

<p>Every operation in there is constant time.</p>
"
"<p>Suppose I have a file X.h which defines  a class X, whose methods are implemented in X.cc.
The file X.h includes a file Y.h because it needs Y to define class X. In X.cc, we can refer
to Y because X.h has already included Y.h. Should I still include Y.h in X.cc ? </p>

<p>I understand that I don't need to and I can depend on header guards to prevent multiple inclusions.
But on the one hand, including Y.h makes X.cc a little more independent of X.h  (can't be
completely independent  of course). What is the accepted practice?</p>

<p>Another example: including <code>&lt;iostream&gt;</code> in both .h and .cc files. I see some people do this
and some don't.</p>
","87234","","<p>Be minimal. In headers, prefer forward declarations to full definitions. Use <code>iosfwd</code> instead of <code>ostream</code>, for example.</p>

<p>That said, X.h and X.cc represent the same logical unit. If your dependency on Y.h ever changed (for example, turned it into a forward declaration), you'd be changing the class anyway. So you can move <code>#include ""Y.h""</code> to X.cc justifiably.</p>

<p>In other words, X.cc and X.h go hand in hand. X.cc can reliably assume what's in X.h. So there's no need to re-include something if X.h does.</p>

<p>Dependencies where you 'include it anyway' occur with resources <em>other</em> than your own. For example, if you needed Z.h, you'd include it even if Y.h does. X.h does not get to reliably assume the contents of Y.h  because X.h doesn't go with Y.h, it uses it.</p>
"
"<p>I tried this:</p>

<pre><code>....
vector&lt;players*&gt; player;
for (int i = 0; i&lt;10; i++)
{
    player.push_back(new players());
}
...
</code></pre>

<p>And I wonder if I need to free memory for the vector? If so, how?</p>
","87234","","<p>Yes, you do need to <code>delete</code> them yourself. The vector is only going to ""destruct"" the pointers (which does nothing).</p>

<p>If you can, use the <a href=""http://www.boost.org/doc/libs/1_42_0/libs/ptr_container/doc/ptr_container.html"" rel=""nofollow"">Boost pointer containers library</a>, and you won't have to worry about it. However, if you can't you need to wrap the container up. Consider an exception is thrown between the time the container is populated and the time its elements are deleted. You will <em>not</em> execute the element delete code and leak.</p>

<p>A simple wrapper might look like:</p>

<pre><code>struct default_deleter
{
    template &lt;typename T&gt;
    void operator()(T* pPtr)
    {
        delete pPtr;
    }

};

template &lt;typename T, typename Deleter = default_deleter&gt;
struct container_wrapper
{
    typedef T container_type;
    typedef Deleter deleter_type;

    container_wrapper(container_type pContainer = container_type()) :
    container(pContainer)
    {}

    ~container_wrapper(void)
    {
         std::for_each(container.begin(), container.end(), deleter_type());
    }

    container_type container;
};
</code></pre>

<p>Use it like:</p>

<pre><code>typedef std::vector&lt;int*&gt; vec_intptr;
typedef container_wrapper&lt;vec_intptr&gt; vec;

vec v;
v.container.push_back(new int); // and never worry about it again
</code></pre>

<p>This is a <em>simple</em> wrapper. Any <code>pop_back()</code>, <code>erase()</code>, etc. operations will have the wrong effect. I strongly suggest using Boost.</p>

<p>One may think of using a container of <code>auto_ptr</code>. Contrarily, this is a bad idea; the copy-semantics of an <code>auto_ptr</code> prevent it from working. The best option is to get rid of the dynamic allocation, if possible.</p>
"
"<p>I saw this code snippet during our lab and it actually compiles in MSVC2008 and G++. </p>

<pre><code>void LinkList&lt; class T &gt;::Insert(T n)  
{  
    if (this == NULL)  
    // some code here  
}
</code></pre>

<p>As far as I know the <code>this</code> must not be null since you cannot call a class functions in c++ if it wasn't instantiated. Is this a valid code? if so what's the reason behind and where it can be useful?</p>
","87234","","<blockquote>
  <p>since you cannot call a class functions in c++ if it wasn't instantiated</p>
</blockquote>

<p>The thing is, you <em>can</em>, but it <a href=""http://stackoverflow.com/questions/2474018/when-does-invoking-a-member-function-on-a-null-instance-result-in-undefined-behav"">leads to undefined behavior</a>.</p>

<p>Such a check should probably be an assert, though such code isn't guaranteed to actually work by the standard. (If <code>this</code> is null, you're already in undefined behavior land.)</p>

<hr>

<p>The reason it's ""useful"" is to detect using an object after it's been deleted, or if it was never created:</p>

<pre><code>template &lt;typename T&gt; // I hate this function
void safe_delete(T*&amp; pPtr)
{
    delete pPtr;
    pPtr = 0;
}

T* p = new T;
safe_delete(p);

p-&gt;foo(); // this is null, and we've entered undefined behavior
</code></pre>

<p>Within <code>foo</code>, you could assert, ""hey, we messed up :/"".</p>

<p>In my opinion such use is indicative of bad design. You shouldn't have a pointer lying around that might possibly get invoked again. The last thing you do with a pointer is <code>delete</code> it; if it's still around after that, change your code so it's not.</p>
"
"<p>I recently learned that all stl containers have swap function:
i.e.  </p>

<pre><code>c1.swap(c2);  
</code></pre>

<p>will lead to object underlying c1 being assigned to c2 and vice versa.
I asked my professor if same is true in case of c1 and c2 being references.
he said same mechanism is followed.</p>

<p>I wonder how it happens since c++ references cannot be reseted.  </p>
","87234","","<p>References are aliases. If you have two references, calling swap will swap what they are referring to, not the references themselves.</p>

<pre><code>C&amp; r1 = c1; // r1 references c1
C&amp; r2 = c2; // r2 references c2

r1.swap(r2); // same as c1.swap(c2)
</code></pre>

<p>And it's not the variables that get swapped, it's what make them logically independent that gets swapped. If a container only consists of a pointer, if you swap that pointer with the pointer of another container, you've <em>effectively</em> swapped the containers. The variables themselves remain.</p>

<hr>

<p>Concrete example:</p>

<pre><code>typedef std::vector&lt;int&gt; vec;

vec c1;
vec c2;

// fill em up

c1.swap(c2);
/*
A vector, internally, has a pointer to a chunk of memory (and some other stuff).
swap() is going to swap the internal pointer (and other stuff) with the other
container. They are logically swapped.
*/

vec&amp; r1 = c1; // r1 is an alias for c1
vec&amp; r2 = c2; // r2 is an alias for c2

r1.swap(r2); // same as c1.swap(c2). they are now unswapped
</code></pre>
"
"<p>I have the following template declaration:</p>

<pre><code>template &lt;typename T&gt;
   void IterTable(int&amp;                       rIdx,
                  std::vector&lt;double&gt;&amp;       rVarVector,
                  const std::vector&lt;T&gt;&amp;      aTable,
                  const T                    aValue,
                  T              aLowerBound = -(std::numeric_limits&lt;T&gt;::max()), //illegal token on right side of '::' shows here
                  bool                       aLeftOpen = true) const;
</code></pre>

<p>Which throws the illegal token error as noted, on the line with ""-(std::numeric_limits::max())"".  I got this code from some old linux source that I'm trying to compile on Windows.  Any idea what the issue is?</p>

<p><strong>Edit:</strong> It also fails using min(), and the compiler output is:</p>

<pre><code>Error   92  error C2589: '::' : illegal token on right side of '::' c:\projects\r&amp;d\prepaydll\include\cfcdefault.h  216 PrepayDLL

Error   93  error C2059: syntax error : '::'    c:\projects\r&amp;d\prepaydll\include\cfcdefault.h  216 PrepayDLL
</code></pre>

<p>Line 216, is the line previously mentioned.</p>
","87234","","<p>My guess is that <code>max</code> has been made a macro. This happens at some point inside <code>windows.h</code>. </p>

<p>Define <code>NOMINMAX</code> prior to including to stop <code>windows.h</code> from doing that.</p>

<h3>EDIT:</h3>

<p>I'm still confident this is your problem. (Not including <code>&lt;limits&gt;</code> would result in a different error). Place <code>#undef max</code> and <code>#undef min</code> just before the function and try again. If that fixes it, I was correct, and your <code>NOMINMAX</code> isn't being defined properly. (Add it as a project setting.)</p>

<p>You can also prevent macro expansion by: <code>(std::numeric_limits&lt;T&gt;::max)()</code>.</p>

<hr>

<p>On a side note, why not do <code>std::numeric_limits&lt;T&gt;::min()</code> instead of negating the max?</p>
"
"<p>Why do I have to provide default ctor if I want to create an array of objects of my type?
Thanks for answers</p>
","87234","","<p>Because they have to be initialized.</p>

<p>Consider if it wasn't the case:</p>

<pre><code>struct foo
{
    foo(int) {}

    void bar(void) {}
};

foo a[10];
foo f = a[0]; // not default-constructed == not initialized == undefined behavior
</code></pre>

<p>Note you don't <em>have</em> to:</p>

<pre><code>int main(){
   // initializes with the int constructor
   foo a[] = {1, 2, 3};
}

// if the constructor had been explicit
int main(){
   // requires copy-constructor
   foo a[] = {foo(1), foo(2), foo(3)};
}
</code></pre>

<hr>

<p>If you really need an array of objects and you can't give a meaningful default constructor, use <code>std::vector</code>.</p>

<p>If you really need an array of of objects, can't give a meaningful default constructor, <em>and</em> want to stay on the stack, you need to lazily initialize the objects. <a href=""http://stackoverflow.com/questions/2187246/how-to-avoid-successive-deallocations-allocations-in-c"">I have written such a utility class</a>. (You would use the second version, the first uses dynamic memory allocation.)</p>

<p>For example:</p>

<pre><code>typedef lazy_object_stack&lt;foo&gt; lazy_foo;

lazy_foo a[10]; // 10 lazy foo's

for (size_t i = 0; i &lt; 10; ++i)
{
    // create a foo, on the stack, passing `i` to the constructor
    a[i].create(i); 
}

for (size_t i = 0; i &lt; 10; ++i)
    a[i].get().bar(); // and use it

// automatically destructed, of course
</code></pre>
"
"<p>I can't get this to work right. This should press left for 1 second then wait 10 seconds, then right 1 second, etc.:</p>

<pre><code>keybd_event(0x25, 0xCB, 0, 0);  // press left
cout &lt;&lt; ""Ldown\n"";              // so i know it worked

Sleep(1000);                    // hold it for 1sec
keybd_event(0x25, 0xCB, KEYEVENTF_KEYUP, 0);// let go of the key
cout &lt;&lt; ""Lup\n"";                // so i know i let go
Sleep(10000);                   // Sleep for 10secs

keybd_event(0x27, 0xCD, 0, 0);  // press right
cout &lt;&lt; ""Rdown\n"";              // so i know i pressed right
Sleep(1000);                    // sleep 1sec
keybd_event(0x27, 0xCD, KEYEVENTF_KEYUP, 0);// let go of the key
cout &lt;&lt; ""Rdown\n"";              // so i know i let go.
</code></pre>

<p>This is in a loop but it wont do anything :( Unless I close the program before the key is let go, then it will just keep the key down until I press the key again.</p>

<p>I know you can use only one key code if you want but I need to use both.</p>

<p>So what am I missing?</p>
","87234","","<p>The code seems to work for me. I cleaned it up a bit (no magic numbers!, use <code>MapVirtualKey</code>, helper functions, etc.):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;windows.h&gt;

// for key pushing
BYTE scan_code(DWORD pKey)
{
    const DWORD result = MapVirtualKey(pKey, MAPVK_VK_TO_VSC);

    return static_cast&lt;BYTE&gt;(result);
}

void press_key(DWORD pKey)
{
    keybd_event(static_cast&lt;BYTE&gt;(pKey), scan_code(pKey), 0, 0);
}

void release_key(DWORD pKey)
{
    keybd_event(static_cast&lt;BYTE&gt;(pKey), scan_code(pKey), KEYEVENTF_KEYUP, 0);
}

// for testing
#define PRESS(x) press_key(x); std::cout &lt;&lt; ""Press: "" #x &lt;&lt; std::endl
#define RELEASE(x) release_key(x); std::cout &lt;&lt; ""Release: "" #x &lt;&lt; std::endl

// test
int main(void)
{
    for (;;)
    {
        PRESS(VK_LEFT);
        Sleep(10); // hold it for 1/100'th of a second

        RELEASE(VK_LEFT);
        Sleep(1000); // wait for a second

        PRESS(VK_RIGHT);
        Sleep(10); // hold it for 1/100'th of a second

        RELEASE(VK_RIGHT);
        Sleep(1000); // wait for a second
    }
}
</code></pre>

<p>I tested by opening Notepad, typing a bunch of characters, then ran the program. The caret moved back and forth. How are you testing it?</p>
"
"<p>I am trying to understand how to use reference parameters. There are several examples in my text, however they are too complicated for me to understand why and how to use them. Could anyone give me the MOST basic example of how/why to use one, and perhaps the difference with or without it (what would happen if you didn't attach the '&amp;').</p>

<p>for example, if I've created a function: int doSomething(int&amp; a, int&amp; b), what would be the consequences of not putting in that '&amp;.' </p>

<p>I understand that reference variables are used in order to change a formal->reference, which then allows a two-way exchange of parameters. However, that is the extent of my knowledge, and a more concrete example would be of much help. Thank you.</p>
","87234","","<p>Think of a reference as <a href=""http://www.parashift.com/c++-faq-lite/references.html"">an alias</a>. When you invoke something on a reference, you're really invoking it on the object to which the reference refers.</p>

<pre><code>int i;
int&amp; j = i; // j is an alias to i

j = 5; // same as i = 5
</code></pre>

<p>When it comes to functions, consider:</p>

<pre><code>void foo(int i)
{
    i = 5;
}
</code></pre>

<p>Above, <code>int i</code> is a value and the argument passed is passed <em>by value</em>. That means if we say:</p>

<pre><code>int x = 2;
foo(x);
</code></pre>

<p><code>i</code> will be a <em>copy</em> of <code>x</code>. Thus setting <code>i</code> to 5 has no effect on <code>x</code>, because it's the copy of <code>x</code> being changed. However, if we make <code>i</code> a reference:</p>

<pre><code>void foo(int&amp; i) // i is an alias for a variable
{
    i = 5;
}
</code></pre>

<p>Then saying <code>foo(x)</code> no longer makes a copy of <code>x</code>; <code>i</code> <em>is</em> <code>x</code>. So if we say <code>foo(x)</code>, inside the function <code>i = 5;</code> is exactly the same as <code>x = 5;</code>, and <code>x</code> changes.</p>

<p>Hopefully that clarifies a bit.</p>

<hr>

<p>Why is this important? When you program, you <em>never</em> want to copy and paste code. You want to make a function that does one task and it does it well. Whenever that task needs to be performed, you use that function.</p>

<p>So let's say we want to swap two variables. That looks something like this:</p>

<pre><code>int x, y;

// swap:
int temp = x; // store the value of x
x = y;        // make x equal to y
y = temp;     // make y equal to the old value of x
</code></pre>

<p>Okay, great. We want to make this a function, because: <code>swap(x, y);</code> is much easier to read. So, let's try this:</p>

<pre><code>void swap(int x, int y)
{
    int temp = x;
    x = y;
    y = temp;
}
</code></pre>

<p>This won't work! The problem is that this is swapping <em>copies</em> of two variables. That is:</p>

<pre><code>int a, b;
swap(a, b); // hm, x and y are copies of a and b...a and b remain unchanged
</code></pre>

<p>In C, where references do not exist, the solution was to pass the address of these variables; that is, use pointers*:</p>

<pre><code>void swap(int* x, int* y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}

int a, b;
swap(&amp;a, &amp;b);
</code></pre>

<p>This works well. However, it's a bit clumsy to use, and actually a bit unsafe. <code>swap(nullptr, nullptr)</code>, swaps two nothings and dereferences null pointers...undefined behavior! Fixable with some checks:</p>

<pre><code>void swap(int* x, int* y)
{
    if (x == nullptr || y == nullptr)
        return; // one is null; this is a meaningless operation

    int temp = *x;
    *x = *y;
    *y = temp;
}
</code></pre>

<p>But looks how clumsy our code has gotten. C++ introduces references to solve this problem. If we can just alias a variable, we get the code we were looking for:</p>

<pre><code>void swap(int&amp; x, int&amp; y)
{
    int temp = x;
    x = y;
    y = temp;
}

int a, b;
swap(a, b); // inside, x and y are really a and b
</code></pre>

<p>Both easy to use, and safe. (We can't accidentally pass in a null, there are no null references.) This works because the swap happening inside the function is really happening on the variables being aliased outside the function.</p>

<p>(Note, never write a <code>swap</code> function. :) One already exists in the header <code>&lt;algorithm&gt;</code>, and it's templated to work with any type.)</p>

<hr>

<p>Another use is to remove that copy that happens when you call a function. Consider we have a data type that's very big. Copying this object takes a lot of time, and we'd like to avoid that:</p>

<pre><code>struct big_data
{ char data[9999999]; }; // big!

void do_something(big_data data);

big_data d;
do_something(d); // ouch, making a copy of all that data :&lt;
</code></pre>

<p>However, all we really need is an alias to the variable, so let's indicate that. (Again, back in C we'd pass the address of our big data type, solving the copying problem but introducing clumsiness.):</p>

<pre><code>void do_something(big_data&amp; data);

big_data d;
do_something(d); // no copies at all! data aliases d within the function
</code></pre>

<p>This is why you'll hear it said you should pass things by reference all the time, unless they are primitive types. (Because internally passing an alias is probably done with a pointer, like in C. For small objects it's just faster to make the copy then worry about pointers.)</p>

<p>Keep in mind you should be const-correct. This means if your function doesn't modify the parameter, mark it as <code>const</code>. If <code>do_something</code> above only looked at but didn't change <code>data</code>, we'd mark it as <code>const</code>:</p>

<pre><code>void do_something(const big_data&amp; data); // alias a big_data, and don't change it
</code></pre>

<p>We avoid the copy <em>and</em> we say ""hey, we won't be modifying this."" This has other side effects (with things like temporary variables), but you shouldn't worry about that now.</p>

<p>In contrast, our <code>swap</code> function cannot be <code>const</code>, because we are indeed modifying the aliases.</p>

<p>Hope this clarifies some more.</p>

<hr>

<p>*Rough pointers tutorial:</p>

<p>A pointer is a variable that holds the address of another variable. For example:</p>

<pre><code>int i; // normal int

int* p; // points to an integer (is not an integer!)
p = &amp;i; // &amp;i means ""address of i"". p is pointing to i

*p = 2; // *p means ""dereference p"". that is, this goes to the int
        // pointed to by p (i), and sets it to 2.
</code></pre>

<p>So, if you've seen the pointer-version swap function, we pass the address of the variables we want to swap, and then we do the swap, dereferencing to get and set values.</p>
"
"<p>While ASSERT_* macros cause termination of test case, EXPECT_* macros continue its evaluation.
I would like to know which is the criteria to decide whether to use one or the other.</p>
","87234","","<p>Use <code>ASSERT</code> when it's critical the test passes. (For example, if it doesn't pass then the rest of the program won't work.) Use <code>EXPECT</code> when it's a test that can afford to fail (and will allow you to run your program.)</p>

<p>The rule of thumb is: use <code>EXPECT</code> unless you need something to work for the entirety for the tests, in which case you should use <code>ASSERT</code> since going on is meaningless.</p>

<hr>

<p>This is echoed within the <a href=""http://code.google.com/p/googletest/wiki/GoogleTestPrimer"">primer</a>:</p>

<blockquote>
  <p>Usually <code>EXPECT_*</code> are preferred, as they allow more than one failures to be reported in a test. However, you should use <code>ASSERT_*</code> if it doesn't make sense to continue when the assertion in question fails. </p>
</blockquote>
"
"<p>I have used the crypt function in c to encrypt the given string.
I have written the following code,</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;

int main()
{
printf(""%s\n"",crypt(""passwd"",1000));
}
</code></pre>

<p>But the above code threw an error ,""undefined reference to `crypt'"".
What is the problem in the above code.</p>

<p>Thanks in advance.</p>
","87234","","<p>The <code>crypt</code> function is non-standard, but is supplied as an extension by the GNU C library on Linux. It's defined in <code>&lt;crypt.h&gt;</code></p>
"
"<p>I keep getting this error message every time I try to compile, and I cannot find out what the problem is.  any help would be greatly appreciated:</p>

<pre><code>C:\DOCUME~1\Patrick\LOCALS~1\Temp/ccL92mj9.o:main.cpp:(.txt+0x184): undefined reference to 'List::List()'
C:\DOCUME~1\Patrick\LOCALS~1\Temp/ccL92mj9.o:main.cpp:(.txt+0x184): undefined reference to 'List::add(int)'
collect2:  ld returned 1 exit status
</code></pre>

<p>code:</p>

<pre><code>//List.h

#ifndef LIST_H
#define LIST_H

#include &lt;exception&gt;

//brief Definition of linked list class

class List
{
    public:

    /**
    \brief Exception for operating on empty list
    */  


    class Empty : public std::exception
 {
  public:
  virtual const char* what() const throw();
 };

    /**
    \brief Exception for invalid operations other than operating on an empty list
    */

    class InvalidOperation : public std::exception
 {
  public:
  virtual const char* what() const throw();
 };

    /**
    \brief Node within List
    */


    class Node
 {
  public: 
  /** data element stored in this node */
  int element;

  /** next node in list */
  Node* next;

  /** previous node in list */
  Node* previous;

  Node (int element);
  ~Node();

  void print() const;
  void printDebug() const;
 };


    List();
    ~List();

    void add(int element);
    void remove(int element);
    int first()const;
    int last()const;
    int removeFirst();
    int removeLast();
    bool isEmpty()const;
    int size()const;
    void printForward() const;    
    void printReverse() const;
    void printDebug() const;

    /**
    enables extra output for debugging purposes
    */
    static bool traceOn;

    private:
    /** head of list */
    Node* head;
    /** tail of list */
    Node* tail;
    /** count of number of nodes */
    int count;
};
#endif
</code></pre>

<p><br />    </p>

<pre><code>//List.cpp                   I only included the parts of List.cpp that might be the issue
#include ""List.h""
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;


List::List()
{
 //List::size = NULL;
 head = NULL;
 tail = NULL;
}


List::~List()
{
 Node* current;
 while(head != NULL)
 {
  current = head-&gt; next;
  delete current-&gt;previous;
  if (current-&gt;next!=NULL)
  {
   head = current;
  }
  else
  {
   delete current;
  }
 }
}

void List::add(int element)
{
 Node* newNode;
 Node* current;
 newNode-&gt;element = element;
 if(newNode-&gt;element &gt; head-&gt;element)
 {
  current = head-&gt;next;
 }
 else
 {
  head-&gt;previous = newNode;
  newNode-&gt;next = head;
  newNode-&gt;previous = NULL;
  return;
 }

 while(newNode-&gt;element &gt; current-&gt;element)
 {
  current = current-&gt;next;
 }

 if(newNode-&gt;element &lt;= current-&gt;element)
 {
  newNode-&gt;previous = current-&gt;previous;
  newNode-&gt;next = current;
 }

}
</code></pre>

<p><br />    </p>

<pre><code>//main.cpp
#include ""List.h""
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;
//void add(int element);

int main (char** argv, int argc)
{    
 List* MyList = new List();
 bool quit = false;
 string value;
 int element;

 while(quit==false)
 {
  cin&gt;&gt;value;

  if(value == ""add"")
  {
   cin&gt;&gt;element;
   MyList-&gt;add(element);
  }
  if(value==""quit"")
  {
   quit = true;
  }
 }
    return 0;
}
</code></pre>

<p>I'm doing everything I think I'm suppose to be doing.  main.cpp isn't complete yet, just trying to get the add function to work first.  Any help will be greatly appreciated.</p>
","87234","","<p>You're not compiling <code>List.cpp</code>. Add it to the command line.</p>

<p>In <code>main.cpp</code>, it's seeing (from <code>List.h</code>) ""Hey, this class with this functionality will exist"", but since you're not actually building/linking with <code>List.cpp</code>, it can't find the functions it's looking for.</p>
"
"<p>How can I create a const boost matrix?</p>

<p>The following did not work:  </p>

<pre><code>const boost::numeric::ublas::matrix&lt;double&gt; arrayM(1, 3) = { {1.0, 2.0, 3.0} };
</code></pre>
","87234","","<p>Usually something akin to:</p>

<pre><code>typedef boost::numeric::ublas::matrix&lt;double&gt; matrix_type;

const matrix_type get_matrix(void)
{
    matrix_type result(1, 3);
    result(0, 0) = 1;
    result(0, 1) = 2;
    result(0, 2) = 3;

    return result;
}

const matrix_type arrayM = get_matrix();
</code></pre>

<hr>

<p>You might also try something like this (mostly untested):</p>

<pre><code>#include &lt;boost/numeric/ublas/matrix.hpp&gt;
#include &lt;boost/numeric/ublas/io.hpp&gt;

template &lt;typename T, typename L = boost::numeric::ublas::row_major,
            typename A = boost::numeric::ublas::unbounded_array&lt;T&gt; &gt;
class matrix_builder
{
public:
    // types
    typedef boost::numeric::ublas::matrix&lt;T, L, A&gt; matrix_type;
    typedef typename matrix_type::size_type size_type;

    // creation
    matrix_builder(size_type pRows, size_type pColumns) :
    mMatrix(pRows, pColumns),
    mRow(0),
    mColumn(0)
    {}

    matrix_builder&amp; operator()(const T&amp; pValue)
    {
        mMatrix(mRow, mColumn) = pValue;
        if (++mColumn == mMatrix.size2())
        {
            mColumn = 0;
            mRow++;
        }

        return *this;
    }

    // access
    operator const matrix_type&amp;(void) const
    {
        return mMatrix;
    }

private:
    // non copyable
    matrix_builder(const matrix_builder&amp;);
    matrix_builder&amp; operator=(const matrix_builder&amp;);

    // members
    matrix_type mMatrix;
    size_type mRow;
    size_type mColumn;
};

typedef boost::numeric::ublas::matrix&lt;double&gt; matrix_type;

static const matrix_type m1 = matrix_builder&lt;double&gt;(3, 1)
                                (1)(2)(3);

static const matrix_type m2 = matrix_builder&lt;double&gt;(3, 3)
                                (1)(2)(3)
                                (4)(5)(6)
                                (7)(8)(9);

int main(void)
{
    std::cout &lt;&lt; m1 &lt;&lt; std::endl;
    std::cout &lt;&lt; m2 &lt;&lt; std::endl;
}
</code></pre>

<p>Same idea, more generic. Also a bit more visual, which can be nice.</p>
"
"<p>Given this sample code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

class my_exception_t : std::exception
{
public:
    explicit my_exception_t()
    { }

    virtual const char* what() const throw()
    { return ""Hello, world!""; }
};

int main()
{
    try
        { throw my_exception_t(); }
    catch (const std::exception&amp; error)
        { std::cerr &lt;&lt; ""Exception: "" &lt;&lt; error.what() &lt;&lt; std::endl; }
    catch (...)
        { std::cerr &lt;&lt; ""Exception: unknown"" &lt;&lt; std::endl; }

    return 0;
}
</code></pre>

<p>I get the following output:</p>

<pre><code>Exception: unknown
</code></pre>

<p>Yet simply making the inheritance of <code>my_exception_t</code> from <code>std::exception</code> <code>public</code>, I get the following output:</p>

<pre><code>Exception: Hello, world!
</code></pre>

<p>Could someone please explain to me why the type of inheritance matters in this case? Bonus points for a reference in the standard.</p>
","87234","","<p>When you inherit privately, you cannot convert to or otherwise access that base class outside of the class. Since you asked for something from the standard:</p>

<blockquote>
  <p>§11.2/4:<br>
  A base class is said to be accessible if an invented public member of the base class is accessible. If a base class is accessible, one can implicitly convert a pointer to a derived class to a pointer to that base class (4.10, 4.11).</p>
</blockquote>

<p>Simply put, to anything outside the class it's like you never inherited from <code>std::exception</code>, because it's private. Ergo, it will not be able to be caught in the <code>std::exception&amp;</code> clause, since no conversion exists.</p>
"
"<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
    cout &lt;&lt; ""Do you need to encrypt or decrypt?"" &lt;&lt; endl;
    string message;
    getline(cin, message);

    int letter2number;

    for (int place = 1; place &lt; sizeof(message); place++)
    {
        letter2number = static_cast&lt;int&gt;(message[place]);
        cout &lt;&lt; letter2number &lt;&lt; endl;
    }
}
</code></pre>

<p>Examples of problem: I type fifteen letters but only four integers are printed. I type seven letters but only four integers are printed.</p>

<p>The loop only occurs four times on my computer, not the number of characters in the string.</p>

<p>This is the only problem I am having with it, so if you see other errors, please don't tell me. (It is more fun that way.)</p>

<p>Thank you for your time.</p>
","87234","","<p><code>sizeof</code> returns the size of an expression. For you, that's a <code>std::string</code> and for your implementation of <code>std::string</code>, that's four. (Probably a pointer to the buffer, internally.)</p>

<p>But you see, that buffer is only pointed to by the string, it has no effect on the size of the <code>std::string</code> itself. You want <code>message.size()</code> for that, which gives you the size of the string being pointed to by that buffer pointer.</p>

<p>As the <code>string</code>'s contents change, what that buffer pointer points to changes, but the pointer itself is always the same size.</p>

<hr>

<p>Consider the following:</p>

<pre><code>struct foo
{
    int bar;
};
</code></pre>

<p>At this point, <code>sizeof(foo)</code> is known; it's a compile-time constant. It's the size of an <code>int</code> along with any additional <a href=""http://en.wikipedia.org/wiki/Data_structure_alignment#Data_Structure_Padding"">padding</a> the compiler might add.</p>

<p>You can let <code>bar</code> take on any value you want, and the size stays the same because what <code>bar</code>'s value is has nothing to do with the type and size of <code>bar</code> itself.</p>
"
"<p>I would like to be able to write:  </p>

<pre><code>cout &lt;&lt; enumalpha &lt;&lt; Monday;
</code></pre>

<p>and get printed on console:</p>

<p>Monday</p>

<p>P.S. Monday is an enum type.</p>
","87234","","<p>The exact form of what you want is impossible, as far as I know. As Neil said, names are for us mere humans; the compiler deals with the values.</p>

<p>That said, you can make a utility for giving names to enums. Here's an example:</p>

<pre><code>#define ENUM_NAMES_BEGIN(pType) \
    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; pStream, pType pValue) \
            { \
                switch (pValue) \
                {

#define ENUM_NAMES_CASE_NAMED(pValue, pName) \
                case (pValue): \
                    pStream &lt;&lt; (pName); \
                    break;

#define ENUM_NAMES_CASE(pValue) ENUM_NAMES_CASE_NAMED(pValue, #pValue)

#define ENUM_NAMES_END(pDefault) \
                default: \
                    pStream &lt;&lt; (pDefault); \
                } \
                \
                return pStream; \
            }
</code></pre>

<p>You'd use it as such:</p>

<pre><code>#include &lt;iostream&gt;

enum Days
{
    Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
};

enum NotNamed
{
    DontTry, ImNotnamed
};

ENUM_NAMES_BEGIN(Days)
    ENUM_NAMES_CASE(Sunday)
    ENUM_NAMES_CASE(Monday)
    ENUM_NAMES_CASE(Tuesday)
    ENUM_NAMES_CASE(Wednesday)
    ENUM_NAMES_CASE(Thursday)
    ENUM_NAMES_CASE(Friday)
    ENUM_NAMES_CASE_NAMED(Saturday, ""Saturday: Fun day!"")
ENUM_NAMES_END("""")

int main()
{
    Days d = Saturday; // or whatever
    NotNamed n = ImNotnamed;

    std::cout &lt;&lt; ""Day: "" &lt;&lt; d &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Not Named: "" &lt;&lt; n &lt;&lt; std::endl;
}
</code></pre>

<p>Trying it with a type that is ""unnamed"" returns its numeric value.</p>

<p>Note, there isn't actually any enforcement of an enum here; you could use this to name integer values, for example. If you did, <code>operator&lt;&lt;</code> would be ambiguous.</p>

<p>If you can use Boost, use their type trait <code>is_enum</code> (which is fairly complex) and static assert that it be the case. For that the change would be:</p>

<pre><code>#include &lt;boost/static_assert.hpp&gt;
#include &lt;boost/type_traits/is_enum.hpp&gt;

#define ENUM_NAMES_BEGIN(pType) \
    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; pStream, pType pValue) \
            { \
                BOOST_STATIC_ASSERT(boost::is_enum&lt;pType&gt;::value); \
                switch (pValue) \
                {
</code></pre>

<p>Now if the type is not an enum, the compile-error at least point to the line where you're trying to define the enum names.</p>
"
"<p>Having code:</p>

<pre><code>Date::Date(const char* day, const char* month, const char* year):is_leap__(false)
{
    my_day_ = lexical_cast&lt;int&gt;(day);


    my_month_ = static_cast&lt;Month&gt;(lexical_cast&lt;int&gt;(month));

    /*Have to check month here, other ctor assumes month is correct*/
    if (my_month_ &lt; 1 || my_month_ &gt; 12)
    {
        throw std::exception(""Incorrect month."");
    }
    my_year_ = lexical_cast&lt;int&gt;(year);

    if (!check_range_year_(my_year_))
    {
        throw std::exception(""Year out of range."");
    }

    if (check_leap_year_(my_year_))//SKIPS THIS LINE
    {
        is_leap__ = true;
    }
    if (!check_range_day_(my_day_, my_month_))
    {
        throw std::exception(""Day out of range."");
    }

}

bool Date::check_leap_year_(int year)const//IF I MARK THIS LINE WITH BREAKPOINT I'M GETTING MSG THAT THERE IS NO EXECUTABLE CODE IS ASSOSIATED WITH THIS LINE
{
    if (!(year%400) || (year%100 &amp;&amp; !(year%4)))
    {
        return true;
    }
    else
    {
        return false;
    }
}
</code></pre>

<p>Which is very strange in my opinion. There is call to this fnc in my code, why compiler ignores that.<br>
P.S. I'm trying to debug in release.</p>
","87234","","<p>Trying to debug in release leads to pain. The function is being inlined, so you can't break on it. This kind of optimization will happen everywhere, values in variables will seem off, etc. Best to debug in debug.</p>

<p>By the way, just do: <code>return !(year%400) || (year%100 &amp;&amp; !(year%4));</code></p>

<hr>

<p>What I mean by ""it got inlined"" is that your code, at that part, became:</p>

<pre><code>if (!(my_year_%400) || (my_year_%100 &amp;&amp; !(my_year_%4)))
{
    is_leap__ = true;
}
</code></pre>

<p>There is <em>no</em> function call, and nothing to break on.</p>
"
"<p>How do I input <code>DEADBEEF</code> and output <code>DE</code> <code>AD</code> <code>BE</code> <code>EF</code> as four byte arrays?</p>
","87234","","<p>Sounds like you want to parse a string as hex into an integer. The C++ way:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

template &lt;typename IntType&gt;
IntType hex_to_integer(const std::string&amp; pStr)
{
    std::stringstream ss(pStr);

    IntType i;
    ss &gt;&gt; std::hex &gt;&gt; i;

    return i;
}

int main(void)
{
    std::string s = ""DEADBEEF"";
    unsigned n = hex_to_integer&lt;unsigned&gt;(s);

    std::cout &lt;&lt; n &lt;&lt; std::endl;
}
</code></pre>
"
"<p>Having code:</p>

<pre><code>struct B
{
    int* a;
    B(int value):a(new int(value))
    {   }
    B():a(nullptr){}
    B(const B&amp;);
}

B::B(const B&amp; pattern)
{

}
</code></pre>

<p>I'm getting err msg:<br>
'Error  1   error C2533: 'B::{ctor}' : constructors not allowed a return type'</p>

<p>Any idea why?<br>
P.S. I'm using VS 2010RC</p>
","87234","","<p>You're missing a semicolon after your <code>struct</code> definition.</p>

<hr>

<p>The error is correct, constructors have no return type. Because you're missing a semicolon, that entire struct definition is seen as a return type for a function, as in:</p>

<pre><code>// vvv return type vvv
struct { /* stuff */ } foo(void)
{
}
</code></pre>

<p>Add your semicolon:</p>

<pre><code>struct B
{
    int* a;
    B(int value):a(new int(value))
    {   }
    B():a(nullptr){}
    B(const B&amp;);
}; // end class definition

// ah, no return type
B::B(const B&amp; pattern)
{

}
</code></pre>
"
"<p>Say, i have a function which returns a reference and i want to make sure that the caller only gets it as a reference and should not receive it as a copy.
Is this possible in C++?</p>

<p>In order to be more clear. I have a class like this.</p>

<pre><code>class A
{
private:
    std::vector&lt;int&gt;  m_value;
    A(A&amp; a){ m_value = a.m_value; }

public:
    A() {}
    std::vector&lt;int&gt;&amp; get_value() { return m_value; }
};

int main()
{
    A a;
    std::vector&lt;int&gt; x = a.get_value();
    x.push_back(-1);
    std::vector&lt;int&gt;&amp; y = a.get_value();
    std::cout &lt;&lt; y.size();

    return 0;
}
</code></pre>

<p>Thanks,
Gokul.</p>
","87234","","<p>It ""depends"". Yes, you can hide the copy-constructor (and assignment operator), and your object becomes noncopyable:</p>

<pre><code>struct foo
{
private:
    foo(const foo&amp;); // dont define
    foo&amp; operator=(const foo&amp;); // dont define
}:
</code></pre>

<p>But if you're wondering about one specific function (i.e., normally copyable, but not for this function), no. In fact, what can you do about the caller anyway?</p>

<pre><code>const foo&amp; f = get_foo(); // okay, by reference, but...

foo f2 = foo(foo(foo(foo(foo(foo(f)))))); // :[
</code></pre>

<p>If your caller wants to do something, there isn't much you can do to stop it. </p>
"
"<p>I've decided to do it this way</p>

<ul>
<li>flip numbers 0=1, 1=0</li>
<li>add 1 to LSB</li>
<li>if carry, loop until array[i]==0</li>
</ul>

<p>But I'm stuck on the last point; how can I say that in a conditional loop?</p>
","87234","","<p>I'm not quite sure what you're doing, but maybe this will help:</p>

<pre><code>#define countof(x) (sizeof(x) / sizeof(x[0]))

// an 8-bit number
int byte[8] = {0, 1, 1, 0, 1, 1, 1, 0}; // 1 = on, 0 = off

// flip all bits
for (size_t i = 0; i &lt; countof(byte); ++i)
{
    byte[i] = !byte[i];
}

// add one
for (size_t i = 0; i &lt; countof(byte); ++i)
{
    if (byte[i]) // if on
    {
        byte[i] = 0; // ""add 1, reset to zero"", and carry (no break)
    }
    else // if off
    {
        byte[i] = 1; // turn on
        break; // nothing to carry, stop adding
    }

}
</code></pre>

<p>(I don't know how to push you in the right direction without just explaining the code, sorry. I think you're close enough this is still helpful.)</p>

<p>You see, when you add one, if the bit is already one, reset it to zero, and continue along the bits. If the bit is zero, set it to one, then break out of the loop. (Nothing to carry, so we're done adding.)</p>

<p>Hope that helps. By the way, you'll note the bits are being stored ""backwards"" in the code above. The LSB is at index 0.</p>
"
"<p>I'm using std::getline to read lines from a file,
how can I move forward a few lines? do I have to use getline the number of lines I want to skip?</p>

<p>thanks!</p>
","87234","","<p>For what it's worth:</p>

<pre><code>void skip_lines(std::istream&amp; pStream, size_t pLines)
{
    std::string s;
    for (; pLines; --pLines)
        std::getline(pStream, s);
}
</code></pre>
"
"<p>I have the following code to assign a value to all the elements of a vector:</p>

<pre><code>x = 100;

for (int i=0;i&lt;vect.size();i++)
{
    vect[i] = x;
}
</code></pre>

<p>It's straightforward enough, but I'm wondering if there is a function in the STL that does the same thing; something like for_each, but for assignment.</p>
","87234","","<p>Use <a href=""http://www.cplusplus.com/reference/algorithm/fill/"" rel=""nofollow""><code>std::fill</code></a>:</p>

<pre><code>std::fill(vect.begin(), vect.end(), 100);
</code></pre>

<hr>

<p>Note if you want to initialize a vector to have all the same value, you can use the appropriate constructor:</p>

<pre><code>std::vector&lt;int&gt; v(5, 100); // 5 elements set to 100
</code></pre>

<p><code>assign</code> can be used to ""reset the vector"", but if you're just making the vector, use the constructor.</p>
"
"<p>Double has range more than a 64-bit integer, but its precision is less dues to its representation (since double is 64-bit as well, it can't fit more actual values). So, when representing larger integers, you start to lose precision in the integer part.</p>

<pre><code>#include &lt;boost/cstdint.hpp&gt;
#include &lt;limits&gt;

template&lt;typename T, typename TFloat&gt;
void
maxint_to_double()
{
    T i = std::numeric_limits&lt;T&gt;::max();
    TFloat d = i;
    std::cout
        &lt;&lt; std::fixed
        &lt;&lt; i &lt;&lt; std::endl
        &lt;&lt; d &lt;&lt; std::endl;
}

int
main()
{
    maxint_to_double&lt;int, double&gt;();
    maxint_to_double&lt;boost::intmax_t, double&gt;();
    maxint_to_double&lt;int, float&gt;();
    return 0;
}
</code></pre>

<p>This prints:</p>

<pre><code>2147483647
2147483647.000000
9223372036854775807
9223372036854775800.000000
2147483647
2147483648.000000
</code></pre>

<p>Note how max <code>int</code> can fit into a <code>double</code> without loss of precision and <code>boost::intmax_t</code> (64-bit in this case) cannot. <code>float</code> can't even hold an <code>int</code>.</p>

<p>Now, the question: <em>is there a way in C++ to check if the entire range of a given integer type can fit into a loating point type without loss of precision?</em></p>

<p>Preferably,</p>

<ul>
<li>it would be a compile-time check that can be used in a static assertion,</li>
<li>and would not involve enumerating the constants the compiler should know or can compute.</li>
</ul>
","87234","","<p>Just a little predicate:</p>

<pre><code>#include &lt;limits&gt;

template &lt;typename T, typename U&gt;
struct can_fit
{
    static const bool value = std::numeric_limits&lt;T&gt;::digits
                            &lt;= std::numeric_limits&lt;U&gt;::digits;
};

#include &lt;iostream&gt;

int main(void)
{
    std::cout &lt;&lt; std::boolalpha;

    std::cout &lt;&lt; can_fit&lt;short, float&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; can_fit&lt;int, float&gt;::value &lt;&lt; std::endl;

    std::cout &lt;&lt; can_fit&lt;int, double&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; can_fit&lt;long long, double&gt;::value &lt;&lt; std::endl;

    std::cout &lt;&lt; can_fit&lt;short, int&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; can_fit&lt;int, short&gt;::value &lt;&lt; std::endl;
}
</code></pre>

<p>Tests if the binary precision available in a <code>T</code> exists in a <code>U</code>. Works on all types.</p>

<hr>

<p>""Boostified"":</p>

<pre><code>// this is just stuff I use
#include &lt;boost/type_traits/integral_constant.hpp&gt;

template &lt;bool B&gt;
struct bool_type : boost::integral_constant&lt;bool, B&gt;
{
    static const bool value = B;
};

typedef const boost::true_type&amp; true_tag;
typedef const boost::false_type&amp; false_tag;

// can_fit type traits
#include &lt;limits&gt;

namespace detail
{
    template &lt;typename T, typename U&gt;
    struct can_fit
    {
        static const bool value = std::numeric_limits&lt;T&gt;::digits
                                &lt;= std::numeric_limits&lt;U&gt;::digits;
    };
}

template &lt;typename T, typename U&gt;
struct can_fit : bool_type&lt;detail::can_fit&lt;T, U&gt;::value&gt;
{
    typedef T type1;
    typedef U type2;

    static const bool value = detail::can_fit&lt;T, U&gt;::value;
};

// test
#include &lt;iostream&gt;

namespace detail
{
    void foo(true_tag)
    {
        std::cout &lt;&lt; ""T fits in U"" &lt;&lt; std::endl;
    }

    void foo(false_tag)
    {
        std::cout &lt;&lt; ""T does not fit in U"" &lt;&lt; std::endl;
    }
}

// just an example
template &lt;typename T, typename U&gt;
void foo(void)
{
    detail::foo(can_fit&lt;T, U&gt;());
}

int main(void)
{
    foo&lt;int, double&gt;();
}
</code></pre>
"
"<p>I try to call a function which passed as function pointer with no argument, but I can't make it work.</p>

<pre><code>void *disconnectFunc;

void D::setDisconnectFunc(void (*func)){
    disconnectFunc = func;
}

void D::disconnected(){
    *disconnectFunc;
    connected = false;
}
</code></pre>
","87234","","<p>The correct way to do this is:</p>

<pre><code>typedef void (*callback_function)(void); // type for conciseness

callback_function disconnectFunc; // variable to store function pointer type

void D::setDisconnectFunc(callback_function pFunc)
{
    disconnectFunc = pFunc; // store
}

void D::disconnected()
{
    disconnectFunc(); // call
    connected = false;
}
</code></pre>
"
"<p>I have a abstract base class A and a set of 10 derived classes. The infix operator is overloaded in all of the derived classes</p>

<pre><code>class A{
 public:
    void printNode( std::ostream&amp; os )
    {
           this-&gt;printNode_p();
    } 
  protected:
    virtual void printNode_p( std::ostream&amp; os )
    {
           os &lt;&lt; (*this);
    }
};
</code></pre>

<p>There is a container which stores the base class pointers. I want to use boost::bind function to call the overloaded infix operator in each of its derived class. I have written like this</p>

<pre><code>std::vector&lt;A*&gt; m_args
....
std::ostream os;
for_each( m_args.begin(), m_args.end(), bind(&amp;A::printNode, _1, os) );
</code></pre>

<p>What is the problem with this code? In visual studio i am getting an error like this</p>

<blockquote>
  <p>error C2248:
  'std::basic_ios&lt;_Elem,_Traits>::basic_ios'
  : cannot access private member
  declared in class
  'std::basic_ios&lt;_Elem,_Traits>'</p>
</blockquote>

<p>Thanks,
Gokul.</p>
","87234","","<p>Consider this, which works as expected:</p>

<pre><code>#include &lt;iostream&gt;

struct base
{
    virtual ~base(void) {}

    virtual void print(std::ostream&amp; pStream) = 0;
};

struct foo : base
{
    void print(std::ostream&amp; pStream) { pStream &lt;&lt; ""foo"" &lt;&lt; std::endl; }
};

struct bar : base
{
    void print(std::ostream&amp; pStream) { pStream &lt;&lt; ""bar"" &lt;&lt; std::endl; }
};

#include &lt;boost/bind.hpp&gt;
#include &lt;boost/ptr_container/ptr_vector.hpp&gt;
#include &lt;algorithm&gt;

int main(void)
{
    boost::ptr_vector&lt;base&gt; v;
    v.push_back(new foo);
    v.push_back(new bar);

    std::for_each(v.begin(), v.end(),
                  boost::bind(&amp;base::print, _1, boost::ref(std::cout)));
}
</code></pre>

<p>First off, since you're using boost you may as well use <code>ptr_vector</code> to handle memory management for you. So, that's in there.</p>

<p>Secondly, your error is because <em>streams are not copyable</em>; however, <code>boost::bind</code> will make a copy of all it's arguments when constructing the functor. Wrap it in a <code>boost::reference_wrapper</code> (using the <code>boost::ref</code> utility function), which is copyable. When the time comes, the wrapper will convert to the necessary type and you won't notice the difference.</p>

<p>(This is one of the situations <code>boost::ref</code> was made for.)</p>

<hr>

<p>That all said, consider using <code>BOOST_FOREACH</code>, which in my opinion generates the cleanest code:</p>

<pre><code>#include &lt;boost/foreach.hpp&gt;
#include &lt;boost/ptr_container/ptr_vector.hpp&gt;
#include &lt;algorithm&gt;

#define foreach BOOST_FOREACH

int main(void)
{
    boost::ptr_vector&lt;base&gt; v;
    v.push_back(new foo);
    v.push_back(new bar);

    foreach (base* b, v)
    {
        v-&gt;print(std::cout);
    }
}
</code></pre>
"
"<p>The basic pseudo code looks like this:</p>

<pre><code>void myFunction()
{

int size = 10;

int * MyArray;

MyArray = new int[size];

cout &lt;&lt; size &lt;&lt; endl;

cout &lt;&lt; sizeof(MyArray) &lt;&lt; endl;

}
</code></pre>

<p>The first cout returns 10, as expected, while the second cout returns 4.</p>

<p>Anyone have an explanation?</p>
","87234","","<p><a href=""http://stackoverflow.com/questions/2570329/sizeof-continues-to-return-4-instead-of-actual-size"">Related to a recent question.</a></p>

<p>A pointer is a pointer, regardless of what it points <em>at</em>. You have to keep track of the size yourself. Better is to use a <code>std::vector</code>.</p>

<hr>

<p><code>sizeof</code> returns the size of an expression, which in this case is the size of the type <code>int*</code>. This always has the same size, regardless of its value.</p>

<p>For comparison, consider:</p>

<pre><code>int i = 0;
i = 23434634;
</code></pre>

<p>No matter what value <code>i</code> takes on, the size of <code>i</code> itself is still only <code>sizeof(i) == sizeof(int)</code>. A pointer is the same, it just holds a different kind of value.</p>
"
"<p>I am looking for a way to set a warning that the caller will have to respond to. In a sense I would like to use a late exception mechaninism that occurs after the function already finished executing and returned the wanted value.</p>

<pre><code>SomeObject Foo(int input)
{
   SomeObject result;      
   // do something. oh, we need to warn the caller. 

   return result;
}

void Main()
{
   SomeObject object;
   object = Foo(1); // after copy constructor is done I would like an exception to be thrown


}
</code></pre>
","87234","","<p>You have to make a more concrete decision, I think. It's very unorthodox to (somehow) warn the user of a function while giving them a result.</p>

<p>For example, you could return a <code>std::pair&lt;SomeObject, std::string&gt;</code>, where the warning is in the string, if any. But it'll be very easy for people to ignore that.</p>

<p>An exception isn't the solution: if you can continue execution in a meaningful way, it's not an exceptional situation. It's possible to come up with some system of letting them finish with an exception ""in queue"" somewhere, but when should it be thrown? And for what purpose? Surely it will end up cutting of the remainder of the work anyway.</p>

<p>I think what you want is an <code>assert</code>. <code>assert</code> that a condition holds true; if it doesn't, the programmer will be notified and can handle the situation accordingly. Remember, <code>assert</code>'s are for programmers, exceptions are for the program.</p>

<p>Perhaps if you give us a more concrete example, we'd be able to suggest the best course of action.</p>
"
"<p>I noticed today that a source code file in a project was compiling even though it had junk at the top of it.  It got me wondering what all would pass without error through the compiler.  Here is an example of code that will not generate any error messages:</p>

<pre><code>what kind of weird behaviour is this???

#include ""stdafx.h""

// what is up?

int foo(int bar)
{
    bla bla bla?????
    return bar;
}

and more junk???
</code></pre>

<p>What in the world is the compiler doing to allow this code to compile without giving any error messages?  I'm using Visual Studio 2008 and this is unmanaged C++ code.  The foo function isn't actually generated in the object file so it can't be used but why no errors???</p>
","87234","","<blockquote>
  <p>""The foo function isn't actually generated in the object file so it can't be used""</p>
</blockquote>

<p>This should be your hint it's not being compiled. Why would the compiler ""compile"" something for no output?</p>

<p>Either it's not included, you're looking at the wrong file (technically a variation of the previous), or it has the same name as another source file in the project, in which case only one will be compiled.</p>
"
"<pre><code>        cout &lt;&lt; ""Input street number: "";
        cin &gt;&gt; streetnum;
        cout &lt;&lt; ""Input street name: "";
        cin &gt;&gt; streetname;
        cout &lt;&lt; ""Input resource name: "";
        cin &gt;&gt; rName;
        cout &lt;&lt; ""Input architectural style: "";
        cin &gt;&gt; aStyle;
        cout &lt;&lt; ""Input year built: "";
        cin &gt;&gt; year;
</code></pre>

<p>The problem with the above code happens if you enter in spaces between words.  For example if I enter ""Ampitheater Parkway"" for streetname, then it puts ""Ampitheater"" in streetname, skips the prompt for resource name and enters ""Parkway"" into the next field.  How can I fix this?</p>
","87234","","<p>That's because when you use the extraction operator with a string as the right-hand side, it stops at the first white space character.</p>

<p>What you want is the <a href=""http://www.cplusplus.com/reference/string/getline/"" rel=""nofollow""><code>getline</code></a> free function:</p>

<pre><code>std::getline(std::cin, streetnum); // reads until \n
</code></pre>

<p>You can specify some other delimiter if you want:</p>

<pre><code>char c = /* something */;
std::getline(std::cin, streetnum, c); // reads until c is encountered
</code></pre>

<hr>

<p>Even better is to make a little function to use:</p>

<pre><code>void prompt(const std::string&amp; pMsg, std::string&amp; pResult)
{
    std::cout &gt;&gt; pMsg &gt;&gt; "": "";

    std::getline(std::cin, pResult);
}

prompt(""Street Number"", streetnum);
prompt(""Street Name"", streetname);
// etc.
</code></pre>

<p>:)</p>
"
"<p>I have the following class definition:</p>

<pre><code>template&lt;typename QueueItemT&gt;
class QueueBC
{
protected:
    QueueBC() {}
    virtual ~QueueBC() {}

private:
    virtual IItemBuf* constructItem(const QueueItemT&amp; item) = 0;
} 
</code></pre>

<p>I created the following sub-class:</p>

<pre><code>class MyQueue
    : public QueueBC&lt;MyItemT&gt;
{
public:

    MyQueue() {}
    virtual ~MyQueue() {}
};
</code></pre>

<p>This compiles fine under VS2005, yet I haven't implemented <code>constructItem()</code> in the <code>MyQueue</code> class.  Any idea why?</p>
","87234","","<p>Try using it:</p>

<pre><code>MyQueue m;
</code></pre>

<p>You can't <em>instantiate</em> an abstract class, but you can define one (obviously, as you defined <code>QueueBC</code>). <code>MyQueue</code> is just as abstract.</p>

<p>For example:</p>

<pre><code>struct base // abstract
{
    virtual void one() = 0;
    virtual void two() = 0;
};

struct base_again : base // just as abstract as base
{
};

struct foo : base_again // still abstract
{
    void one() {}
};

struct bar : foo // not abstract
{
    void two() {}
};
</code></pre>
"
"<p>What exactly happens, in terms of memory, when i declare something like:
char arr[4];</p>

<p>How many bytes are reserved for arr?</p>

<p>How is null string accommodated when I 'strcpy' a string of length 4 in arr?</p>

<p>I was writing a socket program, and when I tried to suffix NULL at arr[4] (i.e. the 5th memory location), I ended up replacing the values of some other variables of the program (overflow) and got into a big time mess.</p>

<p>Any descriptions of how compilers (gcc is what I used) manage memory?</p>
","87234","","<p><code>sizeof(arr)</code> bytes are saved* (plus any padding the compiler wants to put around it, though that isn't <em>for</em> the array per se). On an implementation with a stack, this just means moving the stack pointer <code>sizeof(arr)</code> bytes down. (That's where the storage comes from. This is also why automatic allocation is fast.)</p>

<p><code>'\0'</code> isn't accommodated. If you copy ""abcd"" into it, you get a buffer overrun, because that takes up 5 bytes total, but you only have 4. You enter undefined behavior land, and anything could happen.</p>

<p>In practice you'll corrupt the stack and crash sooner or later, or experience what you did and overwrite nearby variables (because they too are allocated just like the array was.) But nobody can say for certain what happens, because it's undefined.</p>

<p><sub>* Which is <code>sizeof(char) * 4</code>. <code>sizeof(char)</code> is <em>always</em> 1, so 4 bytes.</sub></p>
"
"<p>I'm learning C++ from scratch, and as such I don't have an expert understanding of C. In C++, you can't cast a void pointer to whatever, and I understand the reasons behind that. However, I know that in C, you can. What are the possible reasons for this? It just seems like it's be a huge hole in type safety, which (to me) seems like a bad thing.</p>
","87234","","<p>You can cast a <code>void*</code> to another pointer in <em>both</em> languages. Perhaps you meant implicitly.</p>

<p>It's very convenient in C to not have to be explicit about it. In C++ we have templates, so to write generic code there's no need for <code>void*</code> casting and whatnot. In C there is no choice. A generic container has to hold <code>void*</code> to objects, and it's much easier to repeatedly say <code>mydata* d = node;</code> then it is <code>mydata* d = (mydata*)node;</code>.</p>

<p>So it's pretty much like you said. In C type safety in general didn't receive as much emphasis as it did in C++, especially when it came to <code>void*</code> because it was suppose to be a simple generic pointer to whatever. There's no need for that in C++, so better make it explicit when you're dealing with it.</p>
"
"<p>I find such examples in Boost code.</p>

<pre><code>namespace boost {
   namespace {
     extern ""C"" void *thread_proxy(void *f)
     {
       ....
     }

   } // anonymous
   void thread::thread_start(...)
   {
       ...
       pthread_create(something,0,&amp;thread_proxy,something_else);
       ...
   }
} // boost
</code></pre>

<p>Why do you actually need this <code>extern ""C""</code>?</p>

<p>It is clear that <code>thread_proxy</code> function is private internal and I do not expect that it
would be mangled as ""thread_proxy"" because I actually do not need it mangled at all.</p>

<p>In fact in all my code that I had written and that runs on may platforms I never used
extern ""C"" and this had worked as-as with normal functions.</p>

<p>Why extern ""C"" is added?</p>

<hr>

<p>My problem is that extern ""C"" function pollute global name-space and they do not actually
hidden as author expects.</p>

<p><strong>This is not duplicate!</strong></p>

<p>I'm not talking about mangling and external linkage. It is obvious in this code that
external linkage is unwanted!</p>

<p><strong>Answer:</strong> Calling convention of C and C++ functions are not necessary the same, so you need to create one with C calling convention. See 7.5 (p4) of C++ standard.</p>
","87234","","<blockquote>
  <p>It is clear that thread_proxy function is private internal and I do not expect that it would be mangled as ""thread_proxy"" because I actually do not need it mangled at all.</p>
</blockquote>

<p>Regardless, it's still going to be mangled. (Had it not been <code>extern ""C""</code>) That's just how the compiler works. I agree it's conceivable a compiler could say ""this doesn't necessarily need to be mangled"", but the standard says nothing on it. That said, mangling doesn't come into play here, as we aren't trying to link to the function.</p>

<blockquote>
  <p>In fact in all my code that I had written and that runs on may platforms I never used extern ""C"" and this had worked as-as with normal functions.</p>
</blockquote>

<p>Writing on different platforms has nothing to do with <code>extern ""C""</code>. I expect all standard C++ code to work on all platforms that have a standard C++ compliant compiler.</p>

<p><code>extern ""C""</code> has to do with interfacing with C, which pthread is a library of. Not only does it not mangle the name, it makes sure it's callable withe C calling convention. It's the calling convention that needs to be guaranteed., and because we can't assume we are running on a certain compiler, platform, or architecture, the best way to try and do that is with the functionality given to us: <code>extern ""C""</code>.</p>

<blockquote>
  <p>My problem is that extern ""C"" function pollute global name-space and they do not actually hidden as author expects.</p>
</blockquote>

<p>There's nothing polluting about the above code. It's in an unnamed namespace, and not accessible outside the translation unit.</p>
"
"<p>I have a <code>std::list</code> of <code>boost::shared_ptr&lt;T&gt;</code> and I want to remove an item from it but I only have a pointer of type T* which matches one of the items in the list.</p>

<p>However I cant use <code>myList.remove( tPtr )</code> I'm guessing because shared_ptr does not implement <code>==</code> for its template argument type.</p>

<p>My immediate thought was to try <code>myList.remove( shared_ptr&lt;T&gt;(tPtr) )</code> which is syntactically correct but it will crash from a double delete since the temporary <code>shared_ptr</code> has a separate use_count.</p>

<pre><code>std::list&lt; boost::shared_ptr&lt;T&gt; &gt; myList;

T* tThisPtr = new T(); // This is wrong; only done for example code.
                       // stand-in for actual code in T using 
                       // T's actual ""this"" pointer from within T
{
   boost::shared_ptr&lt;T&gt; toAdd( tThisPtr ); // typically would be new T()
   myList.push_back( toAdd );
}

{
   //T has pointer to myList so that upon a certain action, 
   // it will remove itself romt the list

   //myList.remove( tThisPtr);                      //doesn't compile
   myList.remove( boost::shared_ptr&lt;T&gt;(tThisPtr) ); // compiles, but causes
                                                    // double delete
}  
</code></pre>

<p>The only options I see remaining are to use std::find with a custom compare, or to loop through the list brute force and find it myself, but it seems there should be a better way.</p>

<p>Am I missing something obvious, or is this just too non-standard a use to be doing a remove the clean/normal way?</p>
","87234","","<p>You're correct, we can't directly compare the pointers. But there does exist <code>remove_if</code>, and we can specify our own predicate. The solution:</p>

<pre><code>template &lt;typename T&gt;
struct ptr_contains_predicate
{
    ptr_contains_predicate(T* pPtr) :
    mPtr(pPtr)
    {}

    template &lt;typename P&gt;
    bool operator()(const p&amp; pPtr) const
    {
        return pPtr.get() == mPtr;
    }

    T* mPtr;
};

template &lt;typename T&gt;
ptr_contains_predicate&lt;T&gt; ptr_contains(T* pPtr)
{
    return ptr_contains_predicate&lt;T&gt;(pPtr);
}
</code></pre>

<p>Just keep the above predicate in a header somewhere, and you can use it wherever you want.</p>

<pre><code>myList.remove_if(ptr_contains(tThisPtr));
</code></pre>

<p>The best solution is to never lose hold of the <code>shared_ptr</code> in the first place, so we can just use <code>remove</code>, but the above is harmless anyway.</p>
"
"<p>In the following code:</p>

<pre><code>class A {
};
class B : public A {
};
class C : public A {
   int x;
};

int main (int argc, char** argv) {
   A* b = new B();
   A* c = new C();

   //in both cases, only ~A() is called, not ~B() or ~C()
   delete b; //is this ok?
   delete c; //does this line leak memory?

   return 0;
}
</code></pre>

<p>When calling delete on a class with a non-virtual destructor with member functions (like class C), can the memory allocator tell what the proper size of the object is? If not, is memory leaked?</p>

<p>Secondly, if the class has no member functions, and no explicit destructor behaviour (like class B), is everything ok?</p>

<p>I ask this because I wanted to create a class to extend <code>std::string</code>, (which I know is not recommended, but for the sake of the discussion just bear with it), and overload the <code>+=</code>, <code>+</code> operator. -Weffc++ gives me a warning because <code>std::string</code> has a non virtual destructor, but does it matter if the sub-class has no members and does not need to do anything in its destructor?</p>

<p>FYI the <code>+=</code> overload was to do proper file path formatting, so the path class could be used like:</p>

<pre><code>class path : public std::string {
    //... overload, +=, +
    //... add last_path_component, remove_path_component, ext, etc...
};

path foo = ""/some/file/path"";
foo = foo + ""filename.txt"";
std::string s = foo; //easy assignment to std::string
some_function_taking_std_string (foo); //easy implicit conversion
//and so on...
</code></pre>

<p>I just wanted to make sure someone doing this:</p>

<pre><code>path* foo = new path();
std::string* bar = foo;
delete bar;
</code></pre>

<p>would not cause any problems with memory allocation?</p>
","87234","","<p>No, it's not safe to publically inherit from classes without virtual destructors, because if you delete the derived through a base you enter undefined behavior. The definition of the derived class is irrelevant (data members or not, etc.):</p>

<blockquote>
  <p>§5.3.5/3: In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand’s dynamic type <strong>and the static type shall have a virtual destructor or the behavior is undefined.</strong> <sub>(Emphasis mine.)</sub></p>
</blockquote>

<p>Both of those examples in your code lead to undefined behavior. You can inherit non-publicly, but that obviously defeats the purpose of using that class then extending it. (Since it's not longer possible to delete it through a base pointer.)</p>

<p>This is (one reason*) why you shouldn't inherit from standard library classes. The <a href=""http://punchlet.wordpress.com/2009/12/29/letter-the-fifth/"">best solution</a> is to extend it with free-functions. In fact, even if you could you should <a href=""http://www.gotw.ca/gotw/084.htm"">prefer free-functions anyway</a>.</p>

<hr>

<p><sub>*Another being: Do you really want to replace all your string usage with a new string class, just to get some functionality? That's a lot of unnecessary work.</sub></p>
"
"<p>I have a bunch of templates that are used for rpc and was wondering if there is a way to simplify them down as it repeats it self allot. I know varags for templates is coming in the next standard but can you do default values for templates?</p>

<p>Also is there a way to handle void returning functions as normal functions? Atm i have to separate them and treat them as two different things every where due to templates not picking up void as type.</p>

<pre><code>template &lt;typename R&gt;
R functionCall(IPC::IPCClass* c, const char* name)
{
 IPC::IPCParameterI* r = c-&gt;callFunction( name, false );
 return handleReturn&lt;R&gt;(r);
}

template &lt;typename R, typename A&gt;
R functionCall(IPC::IPCClass* cl, const char* name, A a)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, false, IPC::getParameter(a));
 return handleReturn&lt;R&gt;(r);
}

template &lt;typename R, typename A, typename B&gt;
R functionCall(IPC::IPCClass* cl, const char* name, A a, B b)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, false, IPC::getParameter(a), IPC::getParameter(b) );
 return handleReturn&lt;R&gt;(r);
}

template &lt;typename R, typename A, typename B, typename C&gt;
R functionCall(IPC::IPCClass* cl, const char* name, A a, B b, C c)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, false, IPC::getParameter(a), IPC::getParameter(b), IPC::getParameter(c) );
 return handleReturn&lt;R&gt;(r);
}

template &lt;typename R, typename A, typename B, typename C, typename D&gt;
R functionCall(IPC::IPCClass* cl, const char* name, A a, B b, C c, D d)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, false, IPC::getParameter(a), IPC::getParameter(b), IPC::getParameter(c), IPC::getParameter(d) );
 return handleReturn&lt;R&gt;(r);
}

template &lt;typename R, typename A, typename B, typename C, typename D, typename E&gt;
R functionCall(IPC::IPCClass* cl, const char* name, A a, B b, C c, D d, E e)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, false, IPC::getParameter(a), IPC::getParameter(b), IPC::getParameter(c), IPC::getParameter(d), IPC::getParameter(e) );
 return handleReturn&lt;R&gt;(r);
}

template &lt;typename R, typename A, typename B, typename C, typename D, typename E, typename F&gt;
R functionCall(IPC::IPCClass* cl, const char* name, A a, B b, C c, D d, E e, F f)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, false, IPC::getParameter(a), IPC::getParameter(b), IPC::getParameter(c), IPC::getParameter(d), IPC::getParameter(e), IPC::getParameter(f) );
 return handleReturn&lt;R&gt;(r);
}








inline void functionCallV(IPC::IPCClass* cl, const char* name)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, false );
 handleReturnV(r);
}

template &lt;typename A&gt;
void functionCallV(IPC::IPCClass* cl, const char* name, A a)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, false, IPC::getParameter(a));
 handleReturnV(r);
}

template &lt;typename A, typename B&gt;
void functionCallV(IPC::IPCClass* cl, const char* name, A a, B b)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, false, IPC::getParameter(a), IPC::getParameter(b) );
 handleReturnV(r);
}

template &lt;typename A, typename B, typename C&gt;
void functionCallV(IPC::IPCClass* cl, const char* name, A a, B b, C c)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, false, IPC::getParameter(a), IPC::getParameter(b), IPC::getParameter(c) );
 handleReturnV(r);
}

template &lt;typename A, typename B, typename C, typename D&gt;
void functionCallV(IPC::IPCClass* cl, const char* name, A a, B b, C c, D d)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, false, IPC::getParameter(a), IPC::getParameter(b), IPC::getParameter(c), IPC::getParameter(d) );
 handleReturnV(r);
}

template &lt;typename A, typename B, typename C, typename D, typename E&gt;
void functionCallV(IPC::IPCClass* cl, const char* name, A a, B b, C c, D d, E e)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, false, IPC::getParameter(a), IPC::getParameter(b), IPC::getParameter(c), IPC::getParameter(d), IPC::getParameter(e) );
 handleReturnV(r);
}

template &lt;typename A, typename B, typename C, typename D, typename E, typename F&gt;
void functionCallV(IPC::IPCClass* cl, const char* name, A a, B b, C c, D d, E e, F f)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, false, IPC::getParameter(a), IPC::getParameter(b), IPC::getParameter(c), IPC::getParameter(d), IPC::getParameter(e), IPC::getParameter(f) );
 handleReturnV(r);
}










inline void functionCallAsync(IPC::IPCClass* cl, const char* name)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, true );
 handleReturnV(r);
}

template &lt;typename A&gt;
void functionCallAsync(IPC::IPCClass* cl, const char* name, A a)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, true, IPC::getParameter(a));
 handleReturnV(r);
}

template &lt;typename A, typename B&gt;
void functionCallAsync(IPC::IPCClass* cl, const char* name, A a, B b)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, true, IPC::getParameter(a), IPC::getParameter(b) );
 handleReturnV(r);
}

template &lt;typename A, typename B, typename C&gt;
void functionCallAsync(IPC::IPCClass* cl, const char* name, A a, B b, C c)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, true, IPC::getParameter(a), IPC::getParameter(b), IPC::getParameter(c) );
 handleReturnV(r);
}

template &lt;typename A, typename B, typename C, typename D&gt;
void functionCallAsync(IPC::IPCClass* cl, const char* name, A a, B b, C c, D d)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, true, IPC::getParameter(a), IPC::getParameter(b), IPC::getParameter(c), IPC::getParameter(d) );
 handleReturnV(r);
}

template &lt;typename A, typename B, typename C, typename D, typename E&gt;
void functionCallAsync(IPC::IPCClass* cl, const char* name, A a, B b, C c, D d, E e)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, true, IPC::getParameter(a), IPC::getParameter(b), IPC::getParameter(c), IPC::getParameter(d), IPC::getParameter(e) );
 handleReturnV(r);
}

template &lt;typename A, typename B, typename C, typename D, typename E, typename F&gt;
void functionCallAsync(IPC::IPCClass* cl, const char* name, A a, B b, C c, D d, E e, F f)
{
 IPC::IPCParameterI* r = cl-&gt;callFunction( name, true, IPC::getParameter(a), IPC::getParameter(b), IPC::getParameter(c), IPC::getParameter(d), IPC::getParameter(e), IPC::getParameter(f) );
 handleReturnV(r);
}
</code></pre>

<p>extra code as requested:</p>

<pre><code>template &lt;typename R&gt;
R handleReturn(IPC::IPCParameterI* r)
{
    if (r-&gt;getType() == PException::getTypeS())
    {
        gcException gce((gcException*)r-&gt;getValue());
        safe_delete(r);
        throw gce;
    }

    R temp = IPC::getParameterValue&lt;R&gt;(r, true);
    safe_delete(r);
    return temp;
}

inline void handleReturnV(IPC::IPCParameterI* r)
{
    if (r-&gt;getType() == PException::getTypeS())
    {
        gcException gce((gcException*)r-&gt;getValue());
        safe_delete(r);
        throw gce;
    }

    safe_delete(r);
    return;
}
</code></pre>
","87234","","<p>For variable arguments, there isn't much you can do. You could use <a href=""http://www.boost.org/doc/libs/1_42_0/libs/preprocessor/doc/index.html"" rel=""nofollow"">Boost.Preprocessor</a> to generate the functions, but if that were an option you might as well use their <a href=""http://www.boost.org/doc/libs/1_42_0/libs/bind/bind.html"" rel=""nofollow"">Boost.Bind</a> library.</p>

<blockquote>
  <p>Also is there a way to handle void functions as normal functions</p>
</blockquote>

<p>You actually can. The following is a-ok:</p>

<pre><code>void foo(void)
{
    // sup
}

void bar(void)
{
    return foo();
}

void baz(void)
{
    return bar();
}

void lolwut(void)
{
    return baz();
}
</code></pre>

<p>It just doesn't do anything, return-wise.</p>

<hr>

<p>So what you'd want is:</p>

<pre><code>// snipping for conciseness, obviously this applies to all variants
template &lt;typename R&gt;
R functionCall(IPC::IPCClass* c, const char* name)
{
    IPC::IPCParameterI* r = c-&gt;callFunction( name, false );
    return handleReturn&lt;R&gt;(r);
}

template &lt;typename R, typename A&gt;       // taking as const&amp; to avoid copy
R functionCall(IPC::IPCClass* cl, const char* name, const A&amp; a)
{
    IPC::IPCParameterI* r = cl-&gt;callFunction( name, false, IPC::getParameter(a));
    return handleReturn&lt;R&gt;(r);
}
</code></pre>

<p>You just call it like normal, and when the return type is <code>void</code> put <code>void</code> as <code>R</code>. The returns will be treated as <code>return;</code>.</p>

<p>The problem then becomes the <code>handleReturn</code> function. You need a compile-time if-statement to route to the correct function based on whether <code>R</code> is <code>void</code> or not. Here's a basic type-traits (as such queries on types are called) framework:</p>

<pre><code>// any constant-expression can be turned into a type
// that can be instantiated, true and false generate
// different types
template &lt;bool B&gt;
struct bool_type
{
    static const bool value = B;
};

// the two fundamental types that will be generated
typedef bool_type&lt;true&gt; true_type; // the expression was true
typedef bool_type&lt;false&gt; false_type; // the expression was false

// mark functions that take a bool_type result...
typedef const true_type&amp; true_tag; // ...as ""the result was true""
typedef const false_type&amp; false_tag; // ...or ""the result was false""
</code></pre>

<p>This is the very core of a type-traits system. Consider:</p>

<pre><code>void foo(true_tag); // B was true
void foo(false_tag); // B was not true

void foo(void)
{
    static const bool B = true;
    foo( bool_type&lt;B&gt;() );
}
</code></pre>

<p>Depending on whether <code>B</code> is true or not, we will route to a different version of <code>foo</code>, either the <code>true_tag</code> variant, or the <code>false_tag</code> variant. Make sure you understand this part before moving on.</p>

<p>We now use template specialization to generate a type that inherits from <code>bool_type</code>, and is either a <code>true_type</code> or <code>false_type</code> depending on if that trait is true. For us:</p>

<pre><code>template &lt;typename T&gt; // in general, T is not a void...
struct is_void : bool_type&lt;false&gt;
{
    typedef T type;    
};

template &lt;&gt; // ...but in this case it is
struct is_void&lt;void&gt; : bool_type&lt;true&gt;
{
    typedef void type;
};
</code></pre>

<p>Now we can choose a function based off whether or not a certain type is <code>void</code>:</p>

<pre><code>void foo(true_tag); // R was void
void foo(false_tag); // R was not void

template &lt;typename R&gt;
void foo(void)
{
    // either inherits from true_type or false_type
    // and goes to the respective function
    foo( is_void&lt;R&gt;() );
}
</code></pre>

<p>Or applied to our situation:</p>

<pre><code>// I put all my detail functions in a namespace called detail,
// whether or not you do the same is up to you
namespace detail 
{
    template &lt;typename R&gt; // not void variant
    R getReturn(IPC::IPCParameterI* r, false_tag)
    {
        R temp = IPC::getParameterValue&lt;R&gt;(r, true);
        safe_delete(r);
        return temp;
    }

    template &lt;typename R&gt; // void variant
    R getReturn(IPC::IPCParameterI*, true_tag)
    {
        // do nothing
    }
}

template &lt;typename R&gt;
R handleReturn(IPC::IPCParameterI* r)
{
    // applies to both
    if (r-&gt;getType() == PException::getTypeS())
    {
        gcException gce((gcException*)r-&gt;getValue());
        safe_delete(r);
        throw gce;
    }

    // but now route to the correct version
    return detail::getReturn&lt;R&gt;(r, is_void&lt;R&gt;());
}
</code></pre>

<p>This code has minimal repetition in concerns to <code>void</code> return types.</p>
"
"<p>gcc 4.1.2 c99</p>

<p>I have the following enum's in this file ccsmd.h :</p>

<pre><code>enum options_e
{
    acm = 0,
    anm,
    smd,
    OPTIONS_LAST_ENTRY,

    OPTIONS_ENTRY_COUNT = OPTIONS_LAST_ENTRY
};

enum function_mode_e
{
    play = 0,
    record,
    bridge,
    MODE_LAST_ENTRY,

    MODE_ENTRY_COUNT = MODE_LAST_ENTRY
};

error: redeclaration of enumerator ‘LAST_ENTRY’
error: previous definition of ‘LAST_ENTRY’ was here
error: redeclaration of enumerator ‘ENTRY_COUNT’
error: previous definition of ‘ENTRY_COUNT’ was here
</code></pre>

<p>I have the LAST_ENTRY so that I can use that as the index of an array. So I like to keep it the same across all enums.</p>

<p>Many thanks for any advice,</p>
","87234","","<p>Enumeration values exist in the same namespace as the enumeration is defined. That is, in regards to <code>LAST_ENTRY</code>, it's similar (used <em>very</em> loosely here) to:</p>

<pre><code>enum options_e { /* ... */ );

// for the LAST_ENTRY value in options_e
static const int LAST_ENTRY = /* whatever */;

enum function_mode_e { /* ... */ );

// for the LAST_ENTRY value in function_mode_e
static const int LAST_ENTRY = /* whatever */;
</code></pre>

<p>As you can see, you're redefining <code>LAST_ENTRY</code>, hence the error. It's better to prefix your enum values with something to differentiate them:</p>

<pre><code>enum options_e
{
    options_e_acm = 0,
    options_e_anm,
    options_e_smd,
    options_e_LAST_ENTRY,
    options_e_ENTRY_COUNT = options_e_LAST_ENTRY // note this is redundant 
};

enum function_mode_e
{
    function_mode_e_play = 0,
    function_mode_e_record,
    function_mode_e_bridge,
    function_mode_e_LAST_ENTRY,

    function_mode_e_ENTRY_COUNT = function_mode_e_LAST_ENTRY
};
</code></pre>

<p>Though now you lose whatever you were going for before. (Could you clarify what that was?)</p>
"
"<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

int main
{
    int num1, num2;
    ifstream infile;
    ostream outfile;

    infile.open(""input.dat"");
    outfile.open(""output.dat"");

    infile &gt;&gt; num 1 &gt;&gt; num 2;

    outfile &lt;&lt; ""Sum = "" &lt;&lt; num1 + num2 &lt;&lt; endl;

    infile.close()
    outfile.close()
    return 0;
}
</code></pre>

<p>This is what I did and when I compile it, I got this error that said</p>

<pre><code>error C2470: 'main' : looks like a function definition, but there is no
parameter list; skipping apparent body
</code></pre>

<p>Please don't hate me :( I am new at this computer science....</p>
","87234","","<p>I don't hate you. <strong>♥</strong></p>

<p>Functions have parameters, such as:</p>

<pre><code>void foo(/* parameters here */);
</code></pre>

<p>If your function takes none you don't omit the list, but leave it empty or put <code>void</code>:</p>

<pre><code>int main()
// or:
int main(void)
</code></pre>

<p>Which you use is up to you. I prefer explicitly stating <code>void</code>.</p>

<hr>

<p>Note, there are other variants you'll encounter. This is the second most common variant:</p>

<pre><code>int main(int argc, char *argv[])
</code></pre>

<p>It gives you a count of the arguments and what they were. Such as:</p>

<pre><code>myExe andAOne andATwo andIDontHateYou
</code></pre>

<p>You would be able to access those arguments. There can be more, but that should cover it for now. Don't worry about that stuff till later. &lt;3</p>

<hr>

<p>Concerning your code:</p>

<pre><code>int main(void) // no parameters
{
    int num1, num2;
    ifstream infile;
    ostream outfile;

    infile.open(""input.dat"");
    outfile.open(""output.dat"");

    infile &gt;&gt; num1 &gt;&gt; num2; // no spaces in you variable names

    outfile &lt;&lt; ""Sum = "" &lt;&lt; num1 + num2 &lt;&lt; endl;

    infile.close(); // missing semicolon
    outfile.close(); // missing semicolon

    return 0; // fun fact: optional. In C++, return 0 in main is implicit
}
</code></pre>

<p>That should get you started.</p>

<hr>

<p>The rest of this may not make sense, and that's okay. I'm merely including it for completeness. If it doesn't make sense, ignore it for now:</p>

<pre><code>int main(void)
{
    ifstream infile(""input.dat""); // use the constructor to open it
    ostream outfile(""output.dat"");

    int num1, num2; // don't declare variables until you need them
    infile &gt;&gt; num1 &gt;&gt; num2;

    outfile &lt;&lt; ""Sum = "" &lt;&lt; num1 + num2 &lt;&lt; endl;

    // closing is done automatically in the destructor of the fstream
}
</code></pre>
"
"<p>I have a class</p>

<pre><code>class foo {
public:
   foo();
   foo( int );
private:
   static const string s;
};
</code></pre>

<p>Where is the best place to initialize the string s in the source file?</p>
","87234","","<p>In a translation unit within the same namespace, usually at the top:</p>

<pre><code>// foo.h
struct foo
{
    static const std::string s;
};

// foo.cpp
const std::string foo::s = ""thingadongdong""; // this is where it lives

// bar.h
namespace baz
{
    struct bar
    {
        static const float f;
    };
}

// bar.cpp
namespace baz
{
    const float bar::f = 3.1415926535;
}
</code></pre>
"
"<p>I've got a small bit of DRY going on in code I and others have written that I'd like to reduce but I'm failing to figure out how to get it done.  This is legacy COM code but it's interfering with the readability.  I'd like to do the following:</p>

<pre><code>bool queryInterface&lt;class T, class V&gt;(T &amp;_input, V &amp;_output, Logger &amp;_logger){
    if( FAILED( _input-&gt;QueryInterface( &amp;_output ) ) ){
        _logger.error() &lt;&lt; ""Failed to Query Interface between "" &lt;&lt; MAGICHAPPENS&lt;T&gt;() 
                        &lt;&lt; "" and "" &lt;&lt; MAGICHAPPENS&lt;V&gt;();

        return false;
    }
    if( _output == NULL ){
        _logger.warn() &lt;&lt; ""Unable to Query Interface between "" &lt;&lt; MAGICHAPPENS&lt;T&gt;()
                       &lt;&lt; "" and "" &lt;&lt; MAGICHAPPENS&lt;V&gt;();

        return false;
    }
}
</code></pre>

<p>Wherein the ""MAGICHAPPENS()"" function would spit out the name of the variable type.  Such that if ""V"" were a <code>IQueryFilter</code> I'd get back a string of ""IQueryFilter.""  I can't think of any reasonable solution without having to write a bunch of template specializations totally defeating the point in the first place.</p>

<p>Is there a way to write ANDMAGICHAPPENS?</p>
","87234","","<p>You can use RTTI to get the variable name:</p>

<pre><code>#include &lt;typeinfo&gt;

template &lt;typename T&gt;
const char* type_name(void)
{
    // this, unfortunately, is implementation defined
    // and is allowed to be an empty string (useless!)
    return typeid(T).name(); 
}

_logger.error() &lt;&lt; ""Failed to Query Interface between "" &lt;&lt; type_name&lt;T&gt;() 
                    &lt;&lt; "" and "" &lt;&lt; type_name&lt;V&gt;();
</code></pre>

<p>Like the comments say, <code>name()</code> isn't guaranteed to be any particular formatting of the name, or any name at all. But it does require RTTI, which some people dislike.</p>
"
"<pre><code>include/TestBullet.h:12: error: expected constructor, destructor, or type conver
sion before '(' token
</code></pre>

<p>I hate C++ error messages... lol ^^</p>

<p>Basically, I'm following what was written in <a href=""http://stackoverflow.com/questions/582331/c-is-there-a-way-to-instantiate-objects-from-a-string-holding-their-class-name/582456#582456"">this post</a> to try to create a factory class for bullets so they can be instantiated from a string, which will be parsed from an xml file, because I don't want to have a function with a switch for all of the classes because that looks ugly.</p>

<p>Here is my TestBullet.h:</p>

<pre><code>#pragma once

#include ""Bullet.h""
#include ""BulletFactory.h""

class TestBullet : public Bullet {
public:
    void init(BulletData&amp; bulletData);
    void update();
};

REGISTER_BULLET(TestBullet);  &lt;-- line 12
</code></pre>

<p>And my BulletFactory.h:</p>

<pre><code>#pragma once

#include &lt;string&gt;
#include &lt;map&gt;
#include ""Bullet.h""

#define REGISTER_BULLET(NAME) BulletFactory::reg&lt;NAME&gt;(#NAME)
#define REGISTER_BULLET_ALT(NAME, CLASS) BulletFactory::reg&lt;CLASS&gt;(NAME)

template&lt;typename T&gt; Bullet * create() { return new T; }

struct BulletFactory {
    typedef std::map&lt;std::string, Bullet*(*)()&gt; bulletMapType;
    static bulletMapType map;

    static Bullet * createInstance(char* s) {
        std::string str(s);
        bulletMapType::iterator it = map.find(str);
        if(it == map.end())
            return 0;
        return it-&gt;second();
    }

    template&lt;typename T&gt; 
    static void reg(std::string&amp; s) { 
        map.insert(std::make_pair(s, &amp;create&lt;T&gt;));
    }
};
</code></pre>

<p>Thanks in advance. </p>

<p>And unrelated to the error, but is there a way to let Bullet include BulletFactory without creating tons of errors (because of circular inclusion)? This way I would be able to remove <code>#include ""BulletFactory.h""</code> from the top of all of the bullet subclasses.</p>
","87234","","<p>Here's how you get what you want. (Not using your code, exactly, skips including headers, etc. Just for the idea.):</p>

<pre><code>// bullet_registry.hpp
class bullet;

struct bullet_registry
{
    typedef bullet* (*bullet_factory)(void); 

    std::map&lt;std::string, bullet_factory&gt; mFactories;
};

bullet_registry&amp; get_global_registry(void);

template &lt;typename T&gt;
struct register_bullet
{
    register_bullet(const std::string&amp; pName)
    {
        get_global_registry().mFactories.insert(std::make_pair(pName, create));
    }

    static bullet* create(void)
    {
        return new T();
    }
};

#define REGISTER_BULLET(x) \
        namespace \
        { \
            register_bullet _bullet_register_##x(#x); \
        }

// bullet_registry.cpp
bullet_registry&amp; get_global_registry(void)
{
    // as long as this function is used to get
    // a global instance of the registry, it's
    // safe to use during static initialization
    static bullet_registry result;

    return result; // simple global variable with lazy initialization
}

// bullet.hpp
struct my_bullet : bullet { };

// bullet.cpp
REGISTER_BULLET(my_bullet)
</code></pre>

<p>This works by making a global variable, which will be initialized at some point during static initialization. When that happens, in its constructor it accesses the global registry and registers it with the name, and the function used to create bullets.</p>

<p>Since static initialization order is unspecified, we put the global manager in a function, so when that function is called the first time the manager is created on-demand and used. This prevents us from using an uninitialized manager, which could be the case if it were a simple global object.</p>

<p>Free free to ask for clarifications.</p>
"
"<p>Is there a way to initialize an array of primitives, say a integer array, to 0? Without using a for loop? Looking for concise code that doesn't involve a for loop.</p>

<p>:)</p>
","87234","","<pre><code>int array[10] = {}; // to 0

std::fill(array, array + 10, x); // to x
</code></pre>

<hr>

<p>Note if you want a more generic way to get the end:</p>

<pre><code>template &lt;typename T, size_t N&gt;
T* endof(T (&amp;pArray)[N])
{
    return &amp;pArray[0] + N;
}
</code></pre>

<p>To get:</p>

<pre><code>std::fill(array, endof(array), x); // to x (no explicit size)
</code></pre>

<hr>

<p>It should be mentioned <code>std::fill</code> is just a wrapper around the loop you're trying to avoid, and <code>= {};</code> might be implemented in such terms.</p>
"
"<p>I stumbled upon this while doing a review and the author is not available:</p>

<pre><code>int n = Convert.ToInt32(text);
if (((n &gt; 0) || (n &lt; 0)) || (n == 0))
{
  return 1;
}
</code></pre>

<p>The code in general looks solid and it's hard for me to believe that the only purpose of this snippet is to confuse reviewers, but I don't see a way for this condition to fail. Am I missing something? </p>
","87234","","<p>It will always return true, assuming it gets there.</p>

<p>Consider:</p>

<pre><code>bool x = (n &gt; 0) || (n &lt; 0);
bool y = (n == 0);

if (x || y)
{
    return 1;
}
</code></pre>

<p>If <code>n</code> is not zero then either <code>n &gt; 0</code> or <code>n &lt; 0</code> is true, so <code>x</code> is true and <code>y</code> is false.</p>

<p>If <code>n</code> is zero, <code>n == 0</code> is true, so <code>x</code> is false and <code>y</code> is true.</p>

<p>Either way, one side of the OR is true.</p>
"
"<p>Assuming <code>MyClass</code> uses the default destructor (or no destructor), and this code:</p>

<pre><code>MyClass *buffer = new MyClass[i];
// Construct N objects using placement new
for(size_t i = 0; i &lt; N; i++){
    buffer[i].~MyClass();
}
delete[] buffer;
</code></pre>

<p>Is there any optimizer that would be able to remove this loop?</p>

<p>Also, is there any way for my code to detect if <code>MyClass</code> is using an empty/default constructor?</p>

<p>EDIT: Sorry about my horrible code. I think this is correct now..</p>
","87234","","<p>There are a few things wrong with this code.</p>

<p>Firstly, you don't need to be calling the destructor. <code>MyClass buffer* = new MyClass[i]; delete[] buffer;</code> does that just fine. (Note, not the array syntax.)</p>

<p>That said, you comment leads me to believe you meant something else, like:</p>

<pre><code>// vector, because raw memory allocation is bad
std::vector&lt;char&gt; memory(sizeof(MyClass) * count); 

std::vector&lt;MyClass*&gt; objs; objs.reserve(count);
for (size_t i = 0; i &lt; count; ++i)
    objs.push_back(new (memory[sizeof(MyClass) * i]) MyClass()); // place it
</code></pre>

<p>Then later:</p>

<pre><code>for (size_t i = 0; i &lt; count; ++i)
    objs[i].~MyClass(); // destruct (note syntax)
</code></pre>

<p>Of course there's no need to delete anything, since we used a vector. This is the correct syntax for calling a destructor.</p>

<p>Will it be optimized? It depends of the compiler can determine if the destructor does nothing. If the destructor is compiler-generated, I'm sure it'll remove the worthless loop. If the destructor is user-defined but in the header, it'll also be able to see it does nothing and remove the loop.</p>

<p>However, if it's in some other object file, I don't think it will, even if it's empty. That depends on your compilers ability to optimize during the linking phase. The best way to know is to look at the generated assembly.</p>
"
"<p>In a comparison operator:</p>

<pre><code>template&lt;class R1, class R2&gt;
bool operator==(Manager&lt;R1&gt; m1, Manager&lt;R2&gt; m2) {
    return m1.internal_field == m2.internal_field;
}
</code></pre>

<p>Is there any way I could enforce that R1 and R2 must have a supertype or subtype relation?  That is, I'd like to allow either R1 to be derived from R2, or R2 to be derived from R1, but disallow the comparison if R1 and R2 are unrelated types.</p>
","87234","","<p>A trait you want might look like this:</p>

<pre><code>template &lt;typename B, typename D&gt;
struct is_base_of // check if B is a base of D
{
    typedef char yes[1];
    typedef char no[2];

    static yes&amp; test(B*);
    static no&amp; test(...);

    static D* get(void);

    static const bool value = sizeof(test(get()) == sizeof(yes);
};
</code></pre>

<p>Then you just need a static assert of some sort:</p>

<pre><code>// really basic
template &lt;bool&gt;
struct static_assert;

template &lt;&gt;
struct static_assert&lt;true&gt; {}; // only true is defined

#define STATIC_ASSERT(x) static_assert&lt;(x)&gt;()
</code></pre>

<p>Then put the two together:</p>

<pre><code>template&lt;class R1, class R2&gt;
bool operator==(Manager&lt;R1&gt; m1, Manager&lt;R2&gt; m2)
{
    STATIC_ASSERT(is_base_of&lt;R1, R2&gt;::value || is_base_of&lt;R2, R1&gt;::value);

    return p1.internal_field == p2.internal_field;
}
</code></pre>

<p>If one does not derive from the other, the function will not compile. (Your error will be similar to ""<code>static_assert&lt;false&gt;</code> not defined"", and it will point to that line.)</p>
"
"<p>A z buffer is just a 3d array that shows what object should be written in front of another object. each element in the array represents a pixel that holds a value from 0.0 to 1.0. My question is if that is all a z buffer does, then why are some buffers 24bit, 32bit, and 16 bit ?? </p>
","87234","","<p>A Z-Buffer is not a 3D array. It's a 2D array that has a value at each pixel. That value represents the depth of the last pixel written to that position.</p>

<p>If the pending pixel has a depth that's behind the current value on the Z-Buffer, the pixel is not visible and so it is skipped. This is what allows objects to be rendered in any order: pixel behind won't overwrite pixel in front; they will be discarded.</p>

<p>The thing is, that value has differing precision. That's where the bits come in. A 16-bit Z-Buffer takes half as much memory as a 32-bit Z-Buffer, but cannot represent the same range.</p>

<p>Memory is not exactly cheap (well, that's changing, but still), so if you don't need lots of precision use 16-bit and save memory. (This was more important in the past, where memory truly was scarce.)</p>

<p>Trying to store too many values in a buffer that can't hold them will cause them to combine (16.5 and 15.5 both becoming 16, for example), and you get artifacts.</p>
"
"<p>I am not asking an unexpected exception, but an exception that is not captured.</p>

<p>Crashed? Or terminated?</p>
","87234","","<p>According to §15.3/9:</p>

<blockquote>
  <p><strong>If no matching handler is found in a program, the function terminate() is called</strong>; whether or not the stack is unwound before this call to terminate() is implementation-defined (15.5.1). <sub>Emphasis mine</sub></p>
</blockquote>

<p>What happens after that is up to your OS. In practice: a crash. (Or if you're in a debugger, ""Hey, you didn't catch this."")</p>
"
"<p>This is probably really easy, but I'm lost on how to ""make sure"" it is in this range..</p>

<p>So basically we have <code>class Color</code> and many functions to implement from it.</p>

<p>this function I need is:</p>

<p>Effects: corrects a color value to be within 0-255 inclusive. If value is outside this range, adjusts to either 0 or 255, whichever is closer.</p>

<p>This is what I have so far:</p>

<pre><code>static int correctValue(int value)
{
    if(value&lt;0)
        value=0;
    if(value&gt;255)
        value=255;
}
</code></pre>

<p>Sorry for such a simple question ;/</p>
","87234","","<p>It's good. I'd recommend making a <code>clamp</code> function for re-usability:</p>

<pre><code>template &lt;typename T&gt;
void clamp(T&amp; pValue, const T&amp; pMin, const T&amp; pMax)
{
    pValue = std::min(std::max(pValue, pMin), pMax);
}

template &lt;typename T&gt;
T clamp_copy(T pValue, const T&amp; pMin, const T&amp; pMax)
{
    clamp(pValue, pMin, pMax);
    return pValue;
}
</code></pre>

<p>That gives you an in-place and copying <code>clamp</code>:</p>

<pre><code>int i = 50;

j = clamp_copy(i, 0, 10);
k = clamp_copy(i, 100, 1000);
clamp(i, 0, 100);

// i = 50
// j = 10
// k = 100
</code></pre>
"
"<p>Suppose I have some pointer, which I want to reinterpret as static dimension array reference:</p>

<pre><code>double *p;
double (&amp;r)[4] = ?(p); // some construct?

// clarify
template&lt; size_t N&gt; void function(double (&amp;a)[N]);
...
 double *p;
function(p); // this will not work.
//  I would like to cast p as to make it appear as  double[N]
</code></pre>

<p>Is it possible to do so?
how do I do it?</p>
","87234","","<p>It's ugly:</p>

<pre><code>double arr[4];
double* d = arr;

double (&amp;a)[4] = *static_cast&lt;double(*)[4]&gt;(static_cast&lt;void*&gt;(d));
</code></pre>

<p>Be sure the array type matches what the pointer originally came from.</p>
"
"<p>Hi Could anyone give me a sample program to ""Create an ApplyRemoveConst template that
constructs a new typelist with remove_const applied to each element""</p>

<p>For example:</p>

<pre><code>typedef TYPELIST_3(A, const B, B) TL;
typedef ApplyRemoveConst&lt;TL&gt;::Result TL2;
// TL2 is the same as TYPELIST_3(A, B, B)


//Typelist Definition:

template&lt;class T, class U&gt;
struct Typelist
{
    typedef T Head;
    typedef U Tail;
    // Lets us a print a typelist
    inline static ostream &amp;print(ostream &amp;os) {
        return printInternal(os, ""["");
    }
    inline static ostream &amp;printInternal(ostream &amp;os, string delimiter) {
        os &lt;&lt; delimiter &lt;&lt; typeid(Head).name();
        return Tail::printInternal(os, "", "");
    }
private:
    Typelist(); // Cannot create!
};

#define TYPELIST_1(T1)  Typelist&lt;T1, NullType&gt;
#define TYPELIST_2(T1, T2) Typelist&lt;T1, TYPELIST_1(T2)&gt;
#define TYPELIST_3(T1, T2, T3) Typelist&lt;T1, TYPELIST_2(T2, T3)&gt;

// Null type definition 

class NullType{
public:
    // NullType ends a typelist (just like NULL ends a C string)
    inline static ostream &amp;printInternal(ostream &amp;os, string delimiter) {
        return os &lt;&lt; ""]"";
    }
};
</code></pre>
","87234","","<p>I think what you want is something like this:</p>

<pre><code>template &lt;typename, template &lt;typename&gt; class&gt;
struct transform;

template &lt;template &lt;typename&gt; class Func&gt;
struct transform&lt;NullType, Func&gt;
{
    typedef NullType type; // nothing to do
};

template &lt;typename T, typename U, template &lt;typename&gt; class Func&gt;
struct transform&lt;Typelist&lt;T, U&gt;, Func&gt;
{
    typedef typename Func&lt;T&gt;::type Head; // apply to head
    typedef typename transform&lt;U, Func&gt;::type Tail; // tail is transformed tail

    typedef Typelist&lt;Head, Tail&gt; type; // put together
};
</code></pre>

<p>This applies something recursively. It makes a new list, by applying to the head, then taking everything else as the tail, applied. That in turn applies the head, and so on, until a <code>NullType</code> is reached in which we just get <code>NullType</code>.</p>

<p>Then you just need a meta-functor:</p>

<pre><code>template &lt;typename T&gt;
struct remove_const
{
    typedef T type;
};

template &lt;typename T&gt;
struct remove_const&lt;const T&gt;
{
    typedef T type;
};
</code></pre>

<p>Then put them together:</p>

<pre><code>typedef TYPELIST_3(A, const B, B) TL;
typedef transform&lt;TL, remove_const&gt;::type TL2;
// TL2 is the same as TYPELIST_3(A, B, B)
</code></pre>

<p><sub>It should be noted I haven't tried any of this.</sub></p>
"
"<p>I have a project that has a GUI (written in QT) and a command-line version.  I made use of the rectangle class included in QT: <a href=""http://doc.trolltech.com/4.6/qrectf.html"" rel=""nofollow"">QRect</a>.  I would like to break the command-line version's dependency on QT, so I need a drop-in rectangle class that supports intersection and union.  I could write one, but I'd prefer including one if possible.</p>

<p>Any ideas?</p>
","87234","","<p>If you're going to find one to include, it's probably part of another dependency. So your best bet is to try to write your own. Now is a good time to practice making a template class. :)</p>

<pre><code>template &lt;typename T&gt;
struct point
{
    // or maybe you'd prefer to make these private
    T x;
    T y;
};

template &lt;typename T&gt;
struct rectangle
{
public:
    typedef point&lt;T&gt; point_type;

    bool contains(const point_type&amp; pPoint)
    {
        return !(pPoint.x &lt; topleft.x) &amp;&amp; (pPoint.x &lt; bottomright.x) &amp;&amp; 
                !(pPoint.y &lt; topleft.y) &amp;&amp; (pPoint.y &lt; bottomright.y);
    }

    T width(void) const
    {
        return bottomright.x - topleft.x;
    }

    // and more stuff

    // or maybe you'd prefer to make these private, nor
    // is this the only way to represent a rectangle.
    point_type topleft;
    point_type bottomright;
};
</code></pre>

<p>Sorry it's not the answer you're expecting. </p>

<hr>

<p>Just about your design, I hope you're not taking your GUI version, performing a copy, then modifying it into a console version. Better would be to make a library; then GUI versus console is merely a matter of presentation.</p>
"
"<p>I have a derived derived class from an abstract class. The code is below. I have a FishTank class which is derived from an Aquarium and Aquarium is derived from item. My question is that should I put the definition of virtual int minWidth() const = 0; in aquarium again or is the code below sufficient?</p>

<pre><code>class Item{
public:
   virtual int minWidth() const = 0;
};

class Aquarium: public Item{
public:
  virtual int calWidth() = 0;   // Pure virtual function.
};

class FishTank : public Aquarium{
    public:
       FishTank(int base1, int base2, int height);
       ~FishTank();
    int calWidth();
        int minWidth();
};
</code></pre>
","87234","","<p>There's no reason to do it again. It only serves to waste space and give you the opportunity to get compile errors from typos. :) Once you inherit, it's just like it had been there anyway.</p>

<p>However, you don't actually ever implement it! Why? You're missing <code>const</code> in <code>FishTank</code>:</p>

<pre><code>int minWidth() const; // &lt;-- const!
</code></pre>
"
"<p>So here's a snippet of my code.</p>

<pre><code>
void RoutingProtocolImpl::removeAllInfinity()
{
  dv.erase(std::remove_if(dv.begin(), dv.end(), hasInfCost), dv.end()); 
}

bool RoutingProtocolImpl::hasInfCost(RoutingProtocolImpl::dv_entry *entry)
{
  if (entry->link_cost == INFINITY_COST)
  {
    free(entry);
    return true;
  }
  else
  {
    return false;
  }
}

</code></pre>

<p>I'm getting the following error when compiling:
<pre><code>
RoutingProtocolImpl.cc:368: error: argument of type <code>bool (RoutingProtocolImpl::)(RoutingProtocolImpl::dv_entry*)' does not match</code>bool (RoutingProtocolImpl::*)(RoutingProtocolImpl::dv_entry*)'
</pre></code></p>

<p>Sorry, I'm kind of a C++ newb.</p>
","87234","","<p>The problem is that this: <code>bool RoutingProtocolImpl::hasInfCost(...)</code> is a <em>nonstatic member function</em>.</p>

<p>It requires an instance of the class to invoke on, ala: <code>obj-&gt;hasInfCost(...)</code>. However, <code>remove_if</code> cares not and tries to call it as <code>hasInfCost(...)</code>. These are incompatible.</p>

<p>What you can do is make it <code>static</code>:</p>

<p><code>static bool RoutingProtocolImpl::hasInfCost(RoutingProtocolImpl::dv_entry *entry)</code> This no longer requires an instance of the class to invoke. (It has no member variables, no <code>this</code> pointer, etc.). It can be treated as a ""normal"" function.</p>
"
"<p>I'm writing a class, and this doubt came up. Is this undef. behaviour? On the other hand, I'm not sure its recommended, or if its a good practice. Is it one if I ensure no exceptions to be thrown in the init function?</p>

<pre><code>//c.h
class C{

    float vx,vy;
    friend void init(C&amp; c);
public:
    C();

};


//c.cpp
C::C()
{
   init(*this);
}

void init(C&amp; c) //throws() to ensure no exceptions ?
{
  c.vx = 0;
  c.vy = 0;
}
</code></pre>

<p>Thanks in advance</p>
","87234","","<p>It's completely fine. Once you enter the body of the constructor, all the members have been initialized and they are ready to use. (The body is then to finish up any more work that needs to be done to create a fully constructed object.)</p>

<p>But it is poor style. Better is just:</p>

<pre><code>C::C() :
vx(), vy() // or vx(0), vy(0) if you prefer to be explicit
{}
</code></pre>

<p>And do away with all the mess.</p>

<hr>

<p>Exceptions have nothing to do with safety, constructors are free to throw. In fact, if you can't successfully construct an object then throwing an exception is the preferred course of action.</p>
"
"<p>I am trying to use boost lambda to avoid having to write trivial functors.
For example, I want to use the lambda to access a member of a struct or call a method of a class, eg:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;algorithm&gt;
#include &lt;boost/lambda/lambda.hpp&gt;

using namespace std;
using namespace boost::lambda;

vector&lt; pair&lt;int,int&gt; &gt; vp;

vp.push_back( make_pair&lt;int,int&gt;(1,1) );
vp.push_back( make_pair&lt;int,int&gt;(3,2) );
vp.push_back( make_pair&lt;int,int&gt;(2,3) );

sort(vp.begin(), vp.end(), _1.first &gt; _2.first );
</code></pre>

<p>When I try and compile this I get the following errors:</p>

<pre><code>error C2039: 'first' : is not a member of 'boost::lambda::lambda_functor&lt;T&gt;'
        with
        [
            T=boost::lambda::placeholder&lt;1&gt;
        ]
error C2039: 'first' : is not a member of 'boost::lambda::lambda_functor&lt;T&gt;'
        with
        [
            T=boost::lambda::placeholder&lt;2&gt;
        ]
</code></pre>

<p>Since vp contains <code>pair&lt;int,int&gt;</code> I thought that _1.first should work.  What I am doing wrong?</p>
","87234","","<p>What you want is something akin to:</p>

<pre><code>#include &lt;boost/lambda/bind.hpp&gt; // new header

// typedefs make code easier
typedef pair&lt;int,int&gt; pair_type;
typedef vector&lt;pair_type&gt; vector_type;

vector_type vp;

vp.push_back( make_pair(1,1) ); // don't specify template arguments!
vp.push_back( make_pair(3,2) ); // the entire point of make_pair is
vp.push_back( make_pair(2,3) ); // to deduce them.

sort(vp.begin(), vp.end(),
        bind(&amp;pair_type::first, _1) &gt; bind(&amp;pair_type::first, _2) );
</code></pre>
"
"<p>I have a small program I want to execute to test something</p>

<pre><code>#include &lt;map&gt;
#include &lt;iostream&gt;
using namespace std;

struct _pos{
        float xi;
        float xf;

        bool operator&lt;(_pos&amp; other){

                return this-&gt;xi &lt; other.xi;
        }
};

struct _val{

        float f;
};

int main()
{
        map&lt;_pos,_val&gt; m;

        struct  _pos k1 = {0,10};
        struct  _pos k2 = {10,15};

        struct  _val v1 = {5.5};
        struct  _val v2 = {12.3};                                                                   

        m.insert(std::pair&lt;_pos,_val&gt;(k1,v1));
        m.insert(std::pair&lt;_pos,_val&gt;(k2,v2));

        return 0;
}
</code></pre>

<p>The problem is that when I try to compile it, I get the following error</p>

<pre><code>$ g++ m2.cpp -o mtest
In file included from /usr/include/c++/4.4/bits/stl_tree.h:64,
                 from /usr/include/c++/4.4/map:60,
                 from m2.cpp:1:
/usr/include/c++/4.4/bits/stl_function.h: In member function ‘bool std::less&lt;_Tp&gt;::operator()(const _Tp&amp;, const _Tp&amp;) const [with _Tp = _pos]’:
/usr/include/c++/4.4/bits/stl_tree.h:1170:   instantiated from ‘std::pair&lt;typename std::_Rb_tree&lt;_Key, _Val, _KeyOfValue, _Compare, _Alloc&gt;::iterator, bool&gt; std::_Rb_tree&lt;_Key, _Val, _KeyOfValue, _Compare, _Alloc&gt;::_M_insert_unique(const _Val&amp;) [with _Key = _pos, _Val = std::pair&lt;const _pos, _val&gt;, _KeyOfValue = std::_Select1st&lt;std::pair&lt;const _pos, _val&gt; &gt;, _Compare = std::less&lt;_pos&gt;, _Alloc = std::allocator&lt;std::pair&lt;const _pos, _val&gt; &gt;]’
/usr/include/c++/4.4/bits/stl_map.h:500:   instantiated from ‘std::pair&lt;typename std::_Rb_tree&lt;_Key, std::pair&lt;const _Key, _Tp&gt;, std::_Select1st&lt;std::pair&lt;const _Key, _Tp&gt; &gt;, _Compare, typename _Alloc::rebind&lt;std::pair&lt;const _Key, _Tp&gt; &gt;::other&gt;::iterator, bool&gt; std::map&lt;_Key, _Tp, _Compare, _Alloc&gt;::insert(const std::pair&lt;const _Key, _Tp&gt;&amp;) [with _Key = _pos, _Tp = _val, _Compare = std::less&lt;_pos&gt;, _Alloc = std::allocator&lt;std::pair&lt;const _pos, _val&gt; &gt;]’
m2.cpp:30:   instantiated from here
/usr/include/c++/4.4/bits/stl_function.h:230: error: no match for ‘operator&lt;’ in ‘__x &lt; __y’
m2.cpp:9: note: candidates are: bool _pos::operator&lt;(_pos&amp;)
$ 
</code></pre>

<p>I thought that declaring the operator&lt; on the key would solve the problem, but its still there.</p>

<p>What could be wrong?</p>

<p>Thanks in advance.</p>
","87234","","<p>The problem is this:</p>

<pre><code>bool operator&lt;(_pos&amp; other)
</code></pre>

<p>Should be this:</p>

<pre><code>bool operator&lt;(const _pos&amp; other) const {
//             ^^^^               ^^^^^
</code></pre>

<p>Without the first <code>const</code>, the right-hand side of the comparison (<code>b</code> in <code>a &lt; b</code>) cannot be <code>const</code>, since without <code>const</code> the function may modify its argument.</p>

<p>Without the second <code>const</code>, the left-hand side of the comparison (<code>a</code> in <code>a &lt; b</code>) cannot be <code>const</code>, since without <code>const</code> the function may modify <code>this</code>.</p>

<p>Internally, the key's of a map are always <code>const</code>.</p>

<hr>

<p>It should be noted that you should prefer to use nonmember functions. That is, better is a free-function:</p>

<pre><code>bool operator&lt;(const _pos&amp; lhs, const _pos&amp; rhs)
{
    return lhs.xi &lt; rhs.xi;
}
</code></pre>

<p>In the same namespace as your class. (For our example, just underneath it.)</p>

<hr>

<p>By the way, in C++ there is no need to prefix the declaration of a struct type variable with <code>struct</code>. This is perfect, and preferred:</p>

<pre><code>    _pos k1 = {0,10};
    _pos k2 = {10,15};

    _val v1 = {5.5};
    _val v2 = {12.3};
</code></pre>

<p>(Though your type names are admittedly named in an unorthodox manner. :P)</p>

<hr>

<p>Lastly, you should prefer the <code>make_pair</code> utility function for making pairs:</p>

<pre><code>    m.insert(std::make_pair(k1,v1));
    m.insert(std::make_pair(k2,v2));
</code></pre>

<p>It saves you from having to write out the types for the pair, and is generally easier to read. (Especially when longer type names come along.)</p>
"
"<p>I have a <code>std::multiset</code> which stores elements of <code>class A</code>. I have provided my own implementation of <code>operator&lt;</code> for this class. My question is if I insert two equivalent objects into this multiset is their order guaranteed? For example, first I insert a object <code>a1</code> into the set and then I insert an equivalent object <code>a2</code> into this set. Can I expect the <code>a1</code> to come before <code>a2</code> when I iterate through the set? If no, is there any way to achieve this using multiset?</p>
","87234","","<p>In C++03 you are not guaranteed that <code>insert</code> and <code>erase</code> preserve <em>relative ordering</em>. However, this is changed in C++0x:</p>

<blockquote>
  <p>n3092, §23.2.4/4: An associative container supports unique keys if it may contain at most one element for each key. Otherwise, it supports equivalent keys. The set and map classes support unique keys; the multiset and multimap classes support equivalent keys. <strong>For multiset and multimap, insert and erase preserve the relative ordering of equivalent elements.</strong> <sub>Emphasis mine.</sub></p>
</blockquote>

<p>This is discussed in this <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233"">defect report</a>. <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1780.html"">This page</a> is the collection of comments on the issue, it's well-written and quite fleshed-out. (I very much recommend reading this one over the previous ""overview"" link.)</p>

<p>From that comment page you'll find a comparison of current implementations, so you can check if the implementations you intend to use follow what you expect.</p>

<p>I can't think of a way to force the ordering you want off the top of my head. :/</p>
"
"<p>why pointer is more efficient or superior than declaring array?</p>
","87234","","<p>You're comparing apples to oranges.</p>

<p>A pointer holds a value which is the address of another variable. An array is a contiguous collection of items. They aren't the same.</p>

<p>If you clarify your question, we could give you a better answer. As it stands, it's pretty meaningless.</p>
"
"<p>I have a parent class which is templated, and a child class which implements it.</p>

<p><code>template&lt; typename T1, typename T2&gt;<br>
class ParentClass{ . . . };</code></p>

<p><code>class ChildClass : public ParentClass&lt;MyT1, MyT2&gt; { . . . };</code></p>

<p>And I want to have a pointer which I can use polymorphically:</p>

<p><code>ParentClass&lt;T1, T2&gt;* ptr;<br>
ptr = static_cast&lt;ParentClass&lt;MyT1, MyT2&gt;* &gt;(new ChildClass() );</code></p>

<p>No matter how I cast it, I always get a C2664 which has the same expression: </p>

<p>error C2664: cannot convert parameter 1 from 'ParentClass&lt; T1,T2> *' to 'ParentClass&lt; T1,T2> *'</p>

<p>Is it not possible to cast pointer types between inherited types if the parent is templated, even if the types specified in the templates are the same?</p>
","87234","","<p>There is no need for a static cast. Consider this code, which works as expected:</p>

<pre><code>template &lt;typename T&gt;
struct base
{ virtual ~base(){} };

struct child : base&lt;int&gt;
{};

int main(void)
{
    base&lt;int&gt;* b = new child;
    // could be = static_cast&lt;base&lt;int&gt;*&gt;(new child);, but useless

    delete b;
}
</code></pre>

<p>Are you sure the base template parameters are the same?</p>
"
"<p>Just curious to know if anyone has ever used gametutorials.com products for learning directX. I was debating on whether I should buy it or not. I read online that most of his tutorials were written in the source code. It's nice to heavily comment your code but if most of the tutorial is in his code then I don't think that is necessarily the best way to do a tutorial. But anyhow, I am not sure about that, I am just checking for clarification. and checking to see if it would be a good investment. </p>
","87234","","<p>The problem is that the site is trying to teach you C++ and game programming at the same time. I think trying to do both at the same time is a <em>terrible idea</em>. Game programming is tough, and if you don't know C++ you're just setting yourself up to either fail, or get by with sloppy (and sometimes downright awful) code. So don't do both at the same time: you must learn C++ first, then get into making games. And GameTutorials isn't a resource to help you do that.*</p>

<hr>

<p>If you don't know C++ yet, do not learn it from any online resource. Books are always a better choice here. I recommend <a href=""http://rads.stackoverflow.com/amzn/click/0201721481"" rel=""nofollow"">C++ Primer</a> or <a href=""http://rads.stackoverflow.com/amzn/click/020170353X"" rel=""nofollow"">Accelerated C++</a>. There's a more complete list <a href=""http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">here</a>.</p>

<p>Both of those costs half as much, and give you a full fleshed-out C++ learning experience. The site I can't speak for, but it doesn't appear to give too fleshed out a tutorial, partly because it keeps mixing it with gaming stuff. You're better off getting tried-and-true books.</p>

<p>If you know C++, then you'd be wasting money on stuff you already know. Get a good Direct3D book. I don't have any modern books on me to recommend, but here's a <a href=""http://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Dstripbooks&amp;field-keywords=direct3d&amp;x=0&amp;y=0"" rel=""nofollow"">big list</a>. :) The two (one for DX10, one for DX9) by Luna seem to be good looking, but I don't really know. In any case, a bit more research will tell you what Direct3D book to buy.</p>

<hr>

<p><sub>
*I don't like to speak against things that mean well, but I think the site is really just in a poor position. Teaching C++ and Game Programming shouldn't go hand-in-hand.
</sub></p>
"
"<p>If I create an object on the stack and push it into a list, then the object loses scope (outside of the for loop in the example below) will the object still exist in the list?  If the list still holds the object, is that data now invalid/possibly corrupt?  </p>

<p>Please let me know, and please explain the reasoning..</p>

<p>Thanks,
jbu</p>

<pre><code>class SomeObject{
public:
   AnotherObject x;
}

//And then...
void someMethod()
{
   std::list&lt;SomeObject&gt; my_list;
   for(int i = 0; i &lt; SOME_NUMBER; i++)
   {
      SomeObject tmp;
      my_list.push_back(tmp);

      //after the for loop iteration, tmp loses scope
   }

   my_list.front(); //at this point will my_list be full of valid SomeObjects or will the SomeObjects no longer be valid, even if they still point to dirty data
}
</code></pre>

<p>EDIT: so what if it were a <code>std::list&lt;SomeObject*&gt; my_list</code>; instead of list...in that case would it be invalid?</p>
","87234","","<p><em>All</em> containers make a copy of what they store. It's a requirement that an object be copy-constructible and assignable, if it is to be used in a container.</p>

<p>So yes, <code>vector</code>, <code>list</code>, etc. all make a copy of your object.</p>

<hr>

<p>An even shorter example:</p>

<pre><code>struct foo {};
std::vector&lt;foo&gt; v;

v.push_back(foo()); 
// makes a copy of the temporary, which dies at the semicolon.
</code></pre>

<p>If it didn't make a copy, the above code would be bad.</p>

<hr>

<p>The following code is <em>not</em> ok:</p>

<pre><code>struct foo {};
std::vector&lt;foo*&gt; v;

{
    foo f;
    v.push_back(&amp;f); // fine, but...
} // ...now f stops existing and...

v.front(); // ...points to a non-existent object.
</code></pre>
"
"<p>I have a map and I want to find the minimum value (right hand side) in the map. Right now here is how I did it</p>

<pre><code>bool compare(std::pair&lt;std::string ,int&gt; i, pair&lt;std::string, int&gt; j) {
  return i.second &lt; j.second;
}
////////////////////////////////////////////////////
std::map&lt;std::string, int&gt; mymap;

mymap[""key1""] = 50;
mymap[""key2""] = 20;
mymap[""key3""] = 100;

std::pair&lt;char, int&gt; min = *min_element(mymap.begin(), mymap.end(), compare); 
std::cout &lt;&lt; ""min "" &lt;&lt; min.second&lt;&lt; "" "" &lt;&lt; std::endl;
</code></pre>

<p>This works fine and I'm able to get the minimum value the problem is when I put this code inside my class it doesn't seem to work</p>

<pre><code>int MyClass::getMin(std::map&lt;std::string, int&gt; mymap) {
  std::pair&lt;std::string, int&gt; min = *min_element(mymap.begin(), mymap.end(), 
                                                 (*this).compare);
                                                 //error probably due to this

  return min.second; 
}

bool MyClass::compare(
    std::pair&lt;std::string, int&gt; i, std::pair&lt;std::string, int&gt; j) { 
  return i.second &lt; j.second; 
}
</code></pre>

<p>Also is there a better solution not involving to writing the additional <code>compare</code> function</p>
","87234","","<p>The problem is that this:</p>

<pre><code>bool MyClass::compare
</code></pre>

<p>Requires an instance of the class to be called on. That is, you can't just call <code>MyClass::compare</code>, but you need <code>someInstance.compare</code>. However, <code>min_element</code> needs the former.</p>

<p>The easy solution is to make it <code>static</code>:</p>

<pre><code>static bool MyClass::compare

// ...

min_element(mymap.begin(), mymap.end(), &amp;MyClass::compare);
</code></pre>

<p>This no longer requires an instance to be called on, and your code will be fine. You can make it more general with a functor, though:</p>

<pre><code>struct compare2nd
{
    template &lt;typename T&gt;
    bool operator()(const T&amp; pLhs, const T&amp; pRhs)
    {
        return pLhs.second &lt; pRhs.second;
    }
};

min_element(mymap.begin(), mymap.end(), compare2nd());
</code></pre>

<p>All this does is grab the second from each pair and grab them, works with any pair. It could be made for general, but that's a bit too much.</p>

<p>If you need to look up by value enough, I recommend you use Boost's <a href=""http://www.boost.org/doc/libs/1_42_0/libs/bimap/doc/html/index.html"" rel=""nofollow"">Bimap</a>. It's a bi-directional map, so both the key and value can be used to lookup. You would simply get the front of the value-key map.</p>

<p>Lastly, you can always just keep track of the minimum element going into your map. Every time you insert a new value, check if it's lower than your current value (and that should be probably be a pointer to a map pair, start it as null), and if it's lower, point to the new lowest. Requesting the lowest becomes as simple as dereferencing a pointer.</p>
"
"<p>I have a class that has a vector of objects. What do I need to do to return one of this objects and change it outside the class, keeping the changings? Is it possible to do with regular pointers? Is there a standard procedure? (And yes, my background is in Java.)</p>
","87234","","<p>Your question is a bit vague, but here's an example:</p>

<pre><code>class foo
{
public:
    foo()
    {
        vec.resize(100);
    }

    // normally would be operator[]
    int&amp; get(size_t pIndex)
    { // the return type is a reference. think of it as an alias
        return vec[pIndex]; // now the return value is an alias to this value
    }

private:
    std::vector&lt;int&gt; vec;
};

foo f;
f.get(10) = 5;
// f.get(10) returned an alias to f.vec[10], so this is equivalent to
// f.vec[10] = 5
</code></pre>

<p>The FAQ has a nice <a href=""http://www.parashift.com/c++-faq-lite/references.html"" rel=""nofollow"">section on references</a>.</p>

<p><sub>Also, if you're new to C++ don't try learn with online resources. If you haven't got a book, <a href=""http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">you should</a>, they're really the only good way to learn the language.</sub></p>
"
"<pre><code>int myInt;
cout &lt;&lt; myInt; // Garbage like 429948, etc
</code></pre>

<p>If I output and/or work with unitialized variables in C++, what are their assumed values?</p>

<ul>
<li>Actual values in the memory from the ""last user""?</li>
</ul>

<p>e.g.: Program A is closed, it had an int with the value <code>1234</code> at <code>0x1234</code> -> I run my program, <code>myInt</code> gets the address <code>0x1234</code>, I output it like above -> 1234</p>

<ul>
<li>Is it just random garbage?</li>
</ul>
","87234","","<p>Its value is indeterminate. (§8.5/9)</p>

<p>There's no use trying to get meaningful data from it. In practice, it's just whatever happened to be there.</p>

<p>Most compilers will pack ""meaningful"" debug data in there in a debug build. For example, MSVC will initialize things to 0xCCCCCCCC. This is removed in an optimized build, of course.</p>
"
"<p>Is it possible or makes sense to have static dynamic variables on a class, initialized with new operator?</p>
","87234","","<p>And if you want to make sure it gets cleaned up after program exit:</p>

<pre><code>struct foo
{
    static double* d;
};

namespace
{
    void delete_double(void)
    {
        delete foo::d;
    }

    double* get_double(void)
    {
        double* result = new double();
        atexit(delete_double);

        return result;
    }
}

double* foo::d = get_double();
</code></pre>

<p>Or use a smart pointer (see <a href=""http://stackoverflow.com/questions/2662963/c-static-variables-dynamic/2662982#2662982"">Johannes answer</a>.)</p>
"
"<ul>
<li>Does vector::operator= change vector capacity?  If so, how?</li>
<li>Does vector's copy constructor copy capacity?</li>
</ul>

<p>I looked through documentation but could not find a specific answer.  Is it implementation dependent?</p>
","87234","","<p>All you're guaranteed is that:</p>

<ol>
<li>The vector has enough capacity to store its elements. (Obviously.)</li>
<li>The vector won't get a new capacity until it's current capacity is full.*</li>
</ol>

<p>So how much extra or little an implementation wants to put is up to the implementation. I think most will make capacity match size, when copying, but it cannot lower capacity. (Because of number 2 above; reallocating while there's enough room is not allowed.)</p>

<p><sub>* Mostly. See Charles' comments below.</sub></p>
"
"<p>i am trying to use following pattern.</p>

<pre><code>#ifndef TRACER_H
#include ""Tracer.h""
#endif
</code></pre>

<p>This is statement is added to each file in the code such that tracer.h is added only once.
Still i am getting an error saying multiple objects</p>

<p>Also Tracer.h contains</p>

<pre><code>#ifndef TRACER_H
#define TRACER_H
</code></pre>

<p>here is the error
i tried prgma onece as well</p>

<pre><code>1&gt;Generating Code...
1&gt;Linking...
1&gt;LINK : \\stu05-fsrv.ad.syr.edu\akbhat$\Visual Studio 2008\Projects\Project3\Debug\Project3.exe not found or not built by the last incremental link; performing full link
1&gt;SemiExpression.obj : error LNK2005: ""class std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt; &amp; __cdecl operator&lt;&lt;(class std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt; &amp;,class tracer &amp;)"" (??6@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@AAVtracer@@@Z) already defined in main.obj
1&gt;SemiExpression.obj : error LNK2005: ""private: static class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; tracer::log"" (?log@tracer@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A) already defined in main.obj
1&gt;Tokenizer.obj : error LNK2005: ""class std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt; &amp; __cdecl operator&lt;&lt;(class std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt; &amp;,class tracer &amp;)"" (??6@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@AAVtracer@@@Z) already defined in main.obj
1&gt;Tokenizer.obj : error LNK2005: ""private: static class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; tracer::log"" (?log@tracer@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A) already defined in main.obj
1&gt;\\stu05-fsrv.ad.syr.edu\akbhat$\Visual Studio 2008\Projects\Project3\Debug\Project3.exe : fatal error LNK1169: one or more multiply defined symbols found
1&gt;Build log was saved at ""file://\\stu05-fsrv.ad.syr.edu\akbhat$\Visual Studio 2008\Projects\Project3\Project3\Debug\BuildLog.htm""
</code></pre>
","87234","","<p>Firstly, header guards go inside the file. It makes it much easier:</p>

<pre><code>// some_header.h
#ifndef SOME_HEADER_INCLUDED_H
#define SOME_HEADER_INCLUDED_H

// ...

#endif
</code></pre>

<p>Secondly, these guards only protect from multiple includes <em>per-translation-unit</em>. If you have <code>main.cpp</code> and <code>foo.cpp</code>, and each contains:</p>

<pre><code>#include ""some_header.h""
#include ""some_header.h"" // again

// ...
</code></pre>

<p>The contents in-between the include guards will be included only once <em>per-unit</em>, but will be defined twice, one in each unit.</p>

<p>When link time comes, you'll get multiple-definition errors. You need to have those static variables defined in <em>one</em> source file, and only declare it in the header.</p>
"
"<p>I will keep it short and just show you a code example:</p>

<pre><code>class myClass
{
public:
  myClass();
  int a;
  int b;
  int c;
}

// In the myClass.cpp or whatever
myClass::myClass( )
{
 a = 0;
 b = 0;
 c = 0;
}
</code></pre>

<p>Okay. If I know have an instance of myClass and set some random garbage to a, b and c.</p>

<ul>
<li>What is the best way to reset them all to the state after the class constructor was called, so: 0, 0 and 0?</li>
</ul>

<p>I came up with this way:</p>

<pre><code>myClass emptyInstance;
myUsedInstance = emptyInstance; // Ewww.. code smell?
</code></pre>

<p>Or..</p>

<pre><code>myUsedInstance.a = 0; myUsedInstance.c = 0; myUsedInstance.c = 0; 
</code></pre>

<ul>
<li>I think you know what I want, is there any better way to achieve this?</li>
</ul>
","87234","","<p>Just assign to a default-constructed class, like you have. Just use a temporary, though:</p>

<pre><code>struct foo
{
    int a, b, c;

    foo() :
    a(), b(), c()
    {} // use initializer lists
};

foo f;
f.a = f.b =f.c = 1;

f = foo(); // reset
</code></pre>
"
"<p>I know vectors can be constructed to a predefined size</p>

<pre><code>vector&lt;int&gt; foo(4);
</code></pre>

<p>But is there a way to specify the dimensions of nested vectors?</p>

<pre><code>vector&lt; vector&lt;int&gt; &gt; bar(4);
</code></pre>

<p>Lets say I wanted a vector of size 4 containing vector's of size 4... like a 4x4 multidimensional array of ints?</p>
","87234","","<p>The second argument to <a href=""http://en.cppreference.com/w/cpp/container/vector/vector"" rel=""nofollow"">that constructor</a> is the value to initialize with. Right now you're getting 4 default-constructed vectors. To clarify with a simpler 1D example:</p>

<pre><code>// 4 ints initialized to 0
vector&lt;int&gt; v1(4);

// *exactly* the same as above, this is what the compiler ends up generating
vector&lt;int&gt; v2(4, 0); 

// 4 ints initialized to 10
vector&lt;int&gt; v3(4, 10); 
</code></pre>

<p>So you want:</p>

<pre><code>vector&lt; vector&lt;int&gt; &gt; bar(4, vector&lt;int&gt;(4));
//              this many ^   of these ^
</code></pre>

<p>This creates a vector of vectors of ints, initialized to contain 4 vectors that are initialized to contain 4 ints, initialized to 0. (You could specify a default value for the int to, if desired.)</p>

<p>A mouth-full, but not too hard. :)</p>

<hr>

<p>For a pair:</p>

<pre><code>typedef std::pair&lt;int, int&gt; pair_type; // be liberal in your use of typedef
typedef std::vector&lt;pair_type&gt; inner_vec;
typedef std::vector&lt;inner_vec&gt; outer_vec;

outer_vec v(5, inner_vec(5, pair_type(1, 1)); // 5x5 of pairs equal to (1, 1)
//             this many ^ of these ^
//this many ^      of these ^
</code></pre>
"
"<p>I have the following code:</p>

<pre><code>template &lt;class T&gt;
struct pointer
{
  operator pointer&lt;const T&gt;() const;
};


void f(pointer&lt;const float&gt;);

template &lt;typename U&gt;
void tf(pointer&lt;const U&gt;);

void g()
{
  pointer&lt;float&gt; ptr;
  f(ptr);
  tf(ptr);
}
</code></pre>

<p>When I compile the code with gcc 4.3.3 I get a message (<code>aaa.cc:17: error: no matching function for call to ‘tf(pointer&lt;float&gt;&amp;)’</code>) indicating that the compiler called <code>'operator pointer&lt;const T&gt;'</code> for the non-templated function f(), but didn't for the templated function tf(). Why and is there any workaround short of overloading tf() with a const and non-const version?</p>

<p>Thanks in advance for any help.</p>
","87234","","<p>The reason is that you don't get implicit type conversions during template deduction, it never gets to that point.</p>

<p>Consider:</p>

<pre><code>template &lt;typename T&gt;
struct foo {};

template &lt;typename U&gt;
void bar(foo&lt;U&gt;)
{}

foo&lt;int&gt; f;
bar(f);
</code></pre>

<p>For that call to bar, the compiler can deduce that <code>U</code> is an <code>int</code>, and instantiate the function. However, consider:</p>

<pre><code>template &lt;typename U&gt;
void bar(foo&lt;const U&gt;)
{}  // note  ^^^^

foo&lt;int&gt; f;
bar(f);
</code></pre>

<p>There is no <code>U</code> the compiler can deduce such that the type of <code>foo</code> matches the type of the parameter. Ergo, template instantiation fails. There is no chance for the conversion to happen.</p>
"
"<p>I have a class </p>

<pre><code>class ChartLine{

protected:
        vector&lt;Point&gt; line; // points connecting the line
        CString name; //line name for legend        
        CPen pen; //color, size and style properties of the line
};
</code></pre>

<p>where Point is a structure</p>

<pre><code>struct Point{
    CString x;
    double y;    
};
</code></pre>

<p>In <code>main()</code> I dynamically allocate objects of type <code>ChartLine</code> with <code>new</code> operator.
If I use <code>delete</code> afterwards, will default destructor <code>~ChartLine()</code> properly dealocate (or clear) member <code>ChartLine::line</code>(which is vector btw) or I would have to clear that vector in <code>~ChartLine()</code> manually?</p>

<p>Thanks in advance.
Cheers.</p>
","87234","","<p>The implicitly created destructor will call the destructor of all the members (in the reverse order they are declared in the class.) The <code>vector</code> will clean up after itself. You don't need to define a destructor yourself.</p>

<p>This is why you should prefer automatic allocation in combination with RAII. When objects clean themselves, your code as safer and easier. Hint: Don't use new and delete, put it in a smart pointer!</p>

<pre><code>std::auto_ptr&lt;int&gt; p(new int(5));
boost::shared_ptr&lt;int&gt; p = boost::make_shared&lt;int&gt;(5);
</code></pre>

<p>Both of those will delete automatically, and now you're exception safe as well. (Note, the two above do not do the same thing. There are <a href=""http://www.boost.org/doc/libs/1_42_0/libs/smart_ptr/smart_ptr.htm"" rel=""nofollow"">more types</a> of smart pointers as well.)</p>
"
"<p>I can use <code>__LINE__</code> as a method parameter just fine, but I would like an easy way to use it in a function that uses strings.</p>

<p>For instance say I have this:</p>

<pre><code>11    string myTest()
12    {
13     if(!testCondition)
14       return logError(""testcondition failed"");
15    }
</code></pre>

<p>And I want the result of the function to be: </p>

<blockquote>
  <p>""myTest line 14: testcondition failed""</p>
</blockquote>

<p>How can I write logError? Does it have to be some monstrosity of a macro?</p>
","87234","","<p>There's no reason to do any run-time work for this:</p>

<pre><code>#include &lt;iostream&gt;

// two macros ensures any macro passed will
// be expanded before being stringified
#define STRINGIZE_DETAIL(x) #x
#define STRINGIZE(x) STRINGIZE_DETAIL(x)

// test
void print(const char* pStr)
{
    std::cout &lt;&lt; pStr &lt;&lt; std::endl;
}

int main(void)
{
    // adjacent strings are concatenated
    print(""This is on line #"" STRINGIZE(__LINE__) ""."");
}
</code></pre>

<hr>

<p>Or:</p>

<pre><code>#define STOP_HAMMER_TIME(x) #x
#define STRINGIFICATE(x) STOP_HAMMER_TIME(x)
</code></pre>

<p>If you're a cool person like James.</p>
"
"<p>What is the best way to throw exception from the constructor initializer?</p>

<p>For example:</p>

<pre><code>class C {
  T0 t0; // can be either valid or invalid, but does not throw directly
  T1 t1; // heavy object, do not construct if t0 is invalid,  by throwing before
  C(int n)
    : t0(n), // throw exception if t0(n) is not valid
      t1() {}
};
</code></pre>

<p>I thought maybe making wrapper, e.g. <code>t0(throw_if_invalid(n))</code>.</p>

<p>What is the practice to handle such cases?</p>
","87234","","<p>There are multiple ways of going about this, I think. From what I understand, <code>n</code> can only take on a specific range of numbers. For that, you might prevent the constructor from even being run:</p>

<pre><code>template &lt;typename T, T Min, T Max&gt;
class ranged_type_c
{
public:
    typedef T value_type;

    ranged_type_c(const value_type&amp; pX) :
    mX(pX)
    {
        check_value();
    }

    const value_type&amp; get(void) const
    {
        return mX;
    }

    operator const value_type&amp;(void) const
    {
        return get();
    }

    // non-const overloads would probably require a proxy
    // of some sort, to ensure values remain valid

private:
    void check_value(void)
    {
        if (mX &lt; Min || mX &gt; Max)
            throw std::range_error(""ranged value out of range"");
    }

    value_type mX;
};
</code></pre>

<p>Could be more fleshed out, but that's the idea. Now you can clamp the range:</p>

<pre><code>struct foo_c
{
    foo_c(ranged_value_c&lt;int, 0, 100&gt; i) :
    x(i)
    {}

    int x;
};
</code></pre>

<p>If you pass a value that does not lie from 0-100, the above would throw. </p>

<hr>

<p>At runtime, I think your original idea was best:</p>

<pre><code>template &lt;typename T&gt;
const T&amp; check_range(const T&amp; pX, const T&amp; pMin, const T&amp; pMax)
{
    if (pX &lt; pMin || pX &gt; pMax)
        throw std::range_error(""ranged value out of range"");

    return pValue;
}

struct foo
{
    foo(int i) :
    x(check_range(i, 0, 100))
    {}

    int x;
}
</code></pre>

<p>And that's it. Same as above, but 0 and 100 can be replaced with a call to some function that returns the valid minimum and maximum.</p>

<p>If you do end up using a function call to get valid ranges (recommended, to keep clutter to a minimum and organization higher), I'd add an overload:</p>

<pre><code>template &lt;typename T&gt;
const T&amp; check_range(const T&amp; pX, const std::pair&lt;T, T&gt;&amp; pRange)
{
    return check_range(pX, pRange.first, pRange.second); // unpack
}
</code></pre>

<p>To allow stuff like this:</p>

<pre><code>std::pair&lt;int, int&gt; get_range(void)
{
    // replace with some calculation
    return std::make_pair(0, 100);
}

struct foo
{
    foo(int i) :
    x(check_range(i, get_range()))
    {}

    int x;
}
</code></pre>

<p>If I were to choose, I'd pick the runtime methods even if the range was compile-time. Even with low optimization the compiler will generate the same code, and it's much less clumsy and arguably cleaner to read than the class version.</p>
"
"<p>Im trying to change from big endian to little endian on a double. One way to go is to use</p>

<pre><code>double val, tmp = 5.55;

((unsigned int *)&amp;val)[0] = ntohl(((unsigned int *)&amp;tmp)[1]);
((unsigned int *)&amp;val)[1] = ntohl(((unsigned int *)&amp;tmp)[0]);
</code></pre>

<p>But then I get a warning: ""dereferencing type-punned pointer will break strict-aliasing rules"" and I dont want to turn this warning off.</p>

<p>Another way to go is:</p>

<pre><code>#define ntohll(x) ( ( (uint64_t)(ntohl( (uint32_t)((x &lt;&lt; 32) &gt;&gt; 32) )) &lt;&lt; 32) | ntohl( ((uint32_t)(x &gt;&gt; 32)) ) ) 

val = (double)bswap_64(unsigned long long(tmp)); //or
val = (double)ntohll(unsigned long long(tmp));
</code></pre>

<p>But then a lose the decimals.
Anyone know a good way to swap the bits on a double without using a for loop?</p>
","87234","","<p>I'd probably try something like this:</p>

<pre><code>template &lt;typename T&gt;
void swap_endian(T&amp; pX)
{
    // should static assert that T is a POD

    char&amp; raw = reinterpret_cast&lt;char&amp;&gt;(pX);
    std::reverse(&amp;raw, &amp;raw + sizeof(T));
}
</code></pre>

<p>Short and sweet (and relatively untested). The compiler will make all the necessary optimizations. The above is well-defined for any POD type, and doesn't rely on any implementation details.</p>

<p>A copy version, for when you don't want to modify the argument:</p>

<pre><code>template &lt;typename T&gt;
T swap_endian_copy(T pX)
{
    swap_endian(pX);
    return pX;
}
</code></pre>
"
"<p>As a common rule, it is very often considered a bad practice to use <code>const_cast&lt;&gt;()</code> in C++ code as it reveals (most of the time) a flaw in the design.</p>

<p>While I totally agree with this, I however wonder what are the cases were using <code>const_cast&lt;&gt;()</code> is <em>ok</em> and the <em>only solution</em>.</p>

<p>Could you guys please give me some examples you know/you encountered ?</p>

<p>Thank you very much.</p>
","87234","","<p>Like others have said, it's primary purpose to to remove <code>const</code> from objects to pass to non-const correct functions you know won't modify the argument.</p>

<p>There is a trick (by Meyers?) to avoid code duplication, and it goes like this:</p>

<pre><code>struct foo
{
    const return_type&amp; get(void) const
    {
        // fancy pants code that you definitely
        // don't want to repeat

        return theValue; // and got it
    }

    return_type&amp; get(void)
    {
        // well-defined: Add const to *this,
        // call the const version, then
        // const-cast to remove const (because
        // *this is non-const, this is ok)
        return const_cast&lt;return_type&amp;&gt;(static_cast&lt;const foo&amp;&gt;(*this).get());
    }
};
</code></pre>
"
"<p>I'm trying to create a simple date class, but I get an error on my main file that says, ""call of overloaded Date() is ambiguous.""  I'm not sure why since I thought as long as I had different parameters for my constructor, I was ok.  Here is my code:</p>

<p>header file:</p>

<pre><code>#ifndef DATE_H
#define DATE_H
using std::string;

class Date
{
public:
    static const int monthsPerYear = 12; // num of months in a yr
    Date(int = 1, int = 1, int = 1900); // default constructor
    Date(); // uses system time to create object
    void print() const; // print date in month/day/year format
    ~Date(); // provided to confirm destruction order
    string getMonth(int month) const; // gets month in text format
private:
    int month; // 1 - 12
    int day; // 1 - 31 
    int year; // any year

    int checkDay(int) const;
};

#endif
</code></pre>

<p>.cpp file</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;ctime&gt;
#include ""Date.h""
using namespace std;

Date::Date()
{
    time_t seconds = time(NULL);
    struct tm* t = localtime(&amp;seconds);
    month = t-&gt;tm_mon;
    day = t-&gt;tm_mday;
    year = t-&gt;tm_year;
}

Date::Date(int mn, int dy, int yr)
{
    if (mn &gt; 0 &amp;&amp; mn &lt;= monthsPerYear)
        month = mn;
    else
    {
        month = 1; // invalid month set to 1
        cout &lt;&lt; ""Invalid month ("" &lt;&lt; mn &lt;&lt; "") set to 1.\n"";
    }

    year = yr; // could validate yr
    day  = checkDay(dy); // validate the day

    // output Date object to show when its constructor is called
    cout &lt;&lt; ""Date object constructor for date "";
    print();
    cout &lt;&lt; endl;
}

void Date::print() const
{
    string str;
    cout &lt;&lt; month &lt;&lt; '/' &lt;&lt; day &lt;&lt; '/' &lt;&lt; year &lt;&lt; '\n';

    // new code for HW2
    cout &lt;&lt; setfill('0') &lt;&lt; setw(3) &lt;&lt; day;  // prints in ddd
    cout &lt;&lt; "" "" &lt;&lt; year &lt;&lt; '\n';             // yyyy format

    str = getMonth(month);

    // prints in month (full word), day, year
    cout &lt;&lt; str &lt;&lt; "" "" &lt;&lt; day &lt;&lt; "", "" &lt;&lt; year &lt;&lt; '\n';
}
</code></pre>

<p>and my main.cpp</p>

<pre><code>#include &lt;iostream&gt;
#include ""Date.h""
using std::cout;

int main()
{
    Date date1(4, 30, 1980);
    date1.print();
    cout &lt;&lt; '\n';

    Date date2;
    date2.print();


}
</code></pre>
","87234","","<pre><code>Date(int = 1, int = 1, int = 1900); // default constructor
Date(); // uses system time to create object
</code></pre>

<p>These are both callable with no parameters. It can't be default constructed, because it's ambiguous how to construct the object.</p>

<p>Honestly, having those three with default parameters doesn't make much sense. When would I specify one but not the others?</p>
"
"<p>I do some heavy numbercrunching and for me floating-point performance is very important.
I like performance of Intel compiler very much and quite content with quality of assembly it produces.</p>

<p>I am thinking at some point to try C++0x mainly for sugar parts, like <code>auto</code>, initializer list, etc, but also lambdas.  at this point I use those features in regular C++ by the means of boost.</p>

<p>How good of assembly code do compilers C++0x generate?  specifically Intel and gcc compilers.
Do they produce SSE code?  is performance comparable to C++?  are there any benchmarks?</p>

<p>My Google search did not reveal much.</p>

<p>Thank you.</p>

<p>ps: at some point am going to test it myself but would like to know what to expect relative to C++.</p>
","87234","","<p>You can expect the same optimization for your code, because the compiler certainly didn't get worse at optimizing. So only using the new C++0x features might impact it. But I doubt your core routines would suddenly be completely changed to somehow use C++0x-only features.</p>

<p>Keep in mind things like <code>auto</code> and lambda are just syntactic sugar. That will have no effect on compiler optimization because they're just methods of generating the same code you would anyway. So you'd only need to worry about the new ""stuff"" like initializer lists. But I'd be surprised if that was inefficient as well.</p>

<p>You should also expect many improvements, because of move-semantics. No longer must you copy data around but merely move it around. Design your code to take advantage of this for most benefit.</p>
"
"<p>I've got a compiler error but I can't figure out why.</p>

<p>the .hpp:</p>

<pre><code>#ifndef _CGERADE_HPP
#define _CGERADE_HPP
#include ""CVektor.hpp""
#include &lt;string&gt;

class CGerade
{

protected:
    CVektor o, rv;

public:

    CGerade(CVektor n_o, CVektor n_rv);

    CVektor getPoint(float t);

    string toString();
};
</code></pre>

<p>the .cpp:</p>

<pre><code>#include ""CGerade.hpp""

CGerade::CGerade(CVektor n_o, CVektor n_rv)
{
    o = n_o;
    rv = n_rv.getUnitVector();
}
</code></pre>

<p>the error message:</p>

<pre><code>CGerade.cpp:10: error: no matching function for call to ‘CVektor::CVektor()’
CVektor.hpp:28: note: candidates are: CVektor::CVektor(float, float, float)
CVektor.hpp:26: note:                 CVektor::CVektor(bool, float, float, float)
CVektor.hpp:16: note:                 CVektor::CVektor(const CVektor&amp;)
CGerade.cpp:10: error: no matching function for call to ‘CVektor::CVektor()’
CVektor.hpp:28: note: candidates are: CVektor::CVektor(float, float, float)
CVektor.hpp:26: note:                 CVektor::CVektor(bool, float, float, float)
CVektor.hpp:16: note:                 CVektor::CVektor(const CVektor&amp;)
</code></pre>
","87234","","<p>From the looks of it, your <code>CVektor</code> class has no default constructor, which <code>CGerade</code> uses in your constructor:</p>

<pre><code>CGerade::CGerade(CVektor n_o, CVektor n_rv)
{ // &lt;-- by here, all members are constructed
    o = n_o;
    rv = n_rv.getUnitVector();
}
</code></pre>

<p>You could (and probably should) add one, but better is to use the initialization list to initialize members:</p>

<pre><code>CGerade::CGerade(CVektor n_o, CVektor n_rv) :
o(n_o),
rv(n_rv.getUnitVector())
{}
</code></pre>

<p>Which specifies how the members are initialized. (And above, it was defaulting to the non-existent default-constructor.)</p>
"
"<p>Why must a copy constructor be passed its parameter by reference?</p>
","87234","","<p>Because if it's not by reference, it's by value. To do that you make a copy, and to do that you call the copy constructor. But to do that, we need to make a new value, so we call the copy constructor, and so on...</p>

<p>(You would have infinite recursion because ""to make a copy, you need to make a copy"".)</p>
"
"<p>I have setup the following header file to create a Stack which uses an Array.  I get the following at line 7:</p>

<blockquote>
  <p>error: ISO C++ forbids declaration of 'Stack"" with no type.  </p>
</blockquote>

<p>I thought the type was the input value.  Appreciate your help.  Thank you.  </p>

<pre><code>#ifndef ARRAYSTACKER_H_INCLUDED
#define ARRAYSTACKER_H_INCLUDED
// ArrayStacker.h: header file
class ArrayStack {
    int MaxSize;
    int EmptyStack;
    int top;
    int* items;
public:
    Stacker(int sizeIn);
    ~Stacker();
    void push(int intIn);
    int pop();
    int peekIn();
    int empty();
    int full();
};
#endif // ARRAYSTACKER_H_INCLUDED
</code></pre>
","87234","","<p>The constructor and destructor have the name of the class, which is <code>ArrayStack</code>, not <code>Stacker</code>.</p>
"
"<p>Is this possible? I wanted to convert this into a char* so I could later retrieve this values.</p>
","87234","","<p>Sure:</p>

<pre><code>int array[4] = {1, 2, 3, 4};
char* c = reinterpret_cast&lt;char*&gt;(array);
</code></pre>

<p>The valid range is from <code>c</code> to <code>c + sizeof(array)</code>. You are allowed to do this to any POD type.</p>

<p>You can cast back from a sequence of bytes:</p>

<pre><code>// assuming c above
int (&amp;pArray)[4] = *reinterpret_cast&lt;int(*)[4]&gt;(c);
</code></pre>

<p>This is guaranteed to work. But, it seems you're trying to send stuff across a network, which can introduce other problems</p>

<hr>

<p>The process you're looking for is called <em>serialization</em> (and has a <a href=""http://www.parashift.com/c++-faq-lite/serialization.html"" rel=""nofollow"">FAQ entry</a>). This is when you take an object, transform it into a series of bits, which can later be ""deserialized"" into the original object.</p>

<p>Making this work across multiple platforms can be tricky, because you need to make sure you serialize into a specific format, and that each platform knows how it should read from that format. (For example, a big-endian platform might always convert to little-endian before sending, and likewise convert back to big-endian when receiving.) You cannot treat non-POD types as a stream of bytes (such as <code>std::string</code>), so you need to write serialization functions for those, to transform their data into a stream of bytes, and deserialization functions to transform it back.</p>

<p>I particularly like that way Boost does this, and if you can I'd use their <a href=""http://www.boost.org/doc/libs/1_42_0/libs/serialization/doc/index.html"" rel=""nofollow"">serialization library</a>. They basically first define routines for serializing fundamental types, then you can serialize more complex types by building off that. Of course, Boost also has their <a href=""http://www.boost.org/doc/libs/1_42_0/doc/html/boost_asio.html"" rel=""nofollow"">ASIO library</a> to do sockets for you.</p>
"
"<p>I have a section of code where the user enters input from the keyboard. I want to do something when ENTER is pressed. I am checking for '\n' but it's not working. How do you check if the user pressed the ENTER key?</p>

<pre><code>if( shuffle == false ){
    int i=0;
    string line;
    while( i&lt;20){
        cout &lt;&lt; ""Playing: "";
        songs[i]-&gt;printSong();
        cout &lt;&lt; ""Press ENTER to stop or play next song: "";
        getline(cin, line);            
        if( line.compare(""\n"") == 0 ){
            i++;
        }
    }
}
</code></pre>
","87234","","<p><code>getline</code> isn't going to return until enter is pressed. If you want to check if <em>only</em> entered was pressed, check if the <code>line</code> is empty: <code>if (line.empty())</code></p>
"
"<p>I was just <a href=""http://stackoverflow.com/questions/2686542/converting-integer-to-a-bit-representation/2687562#2687562"">checking an answer</a> and realized that <code>CHAR_BIT</code> isn't defined by headers as I'd expect, not even by <code>#include &lt;bitset&gt;</code>, on newer GCC.</p>

<p>Do I really have to <code>#include &lt;climits&gt;</code> just to get the ""functionality"" of <code>CHAR_BIT</code>?</p>
","87234","","<p>As you may know, whether or not an implementation wants to include other headers is unspecified. It's allowed, but not mandated. (§17.4.4.1) So you either have to be explicit or know your guarantees.</p>

<p>The only time a C++ header <em>must</em> include another is if it requires a definition in another. For example, <code>&lt;bitset&gt;</code> is required to include <code>&lt;cstddef&gt;</code> for <code>std::size_t</code>, as this is explicitly stated in the standard. (§23.3.5, for this example)</p>

<p>For a counter-example, consider <code>&lt;limits&gt;</code>. It <em>may</em> include <code>&lt;climits&gt;</code> and define the values for <code>numeric_limits</code> in terms of the macros within, and it often does since that's easiest for an implementation. But all the standard says is things like: ""<em>Equivalent</em> to <code>CHAR_MIN</code>, <code>SHRT_MIN</code>, <code>FLT_MIN</code>, <code>DBL_MIN</code>, etc."" but doesn't say it <em>must</em> to be implemented in terms of those, which means <code>&lt;climits&gt;</code> doesn't have to be included.</p>

<p>So the only way you can be <em>guaranteed</em> that a <code>CHAR_BIT</code> is defined is by including <code>&lt;climits&gt;</code> or some other header where it's explicitly stated it must include it. And as far as I can tell, none have to; an implementation is free to just hard-code the value everywhere it's needed, for example, or include <code>&lt;limits&gt;</code> and use <code>std::numeric_limits&lt;unsigned char&gt;::digits</code> (which is equivalent).</p>
"
"<p>I often have classes that are mostly just wrappers around some STL container, like this:</p>

<pre><code>class Foo {
public:
  typedef std::vector&lt;whatever&gt; Vec;
  typedef Vec::size_type size_type;
  const Vec&amp; GetVec() { return vec_; }
  size_type size() { return vec_.size() }
private:
  Vec vec_;
};
</code></pre>

<p>I am not so sure about returning <code>size_type</code>. Often, some function will call <code>size()</code> and pass that value on to another function and that one will use it and maybe pass it on. Now everyone has to include that Foo header, although I'm really just passing some size value around, which should just be <code>unsigned int</code> anyway ...? What is the right thing to do here? Is it best practice to really use <code>size_type</code> everywhere?</p>
","87234","","<p>It <em>should</em> be <code>vector&lt;&gt;::size_type</code> like you have, this is the most correct way.</p>

<p>That said, I know many people, including myself, will just use <code>size_t</code> instead. Although it's not mandated to be the same, <code>vector&lt;&gt;::size_type</code> is <code>size_t</code> for every implementation I know. You should be fine with that.</p>
"
"<p>Consider this program:</p>

<pre><code>#include &lt;map&gt;
#include &lt;vector&gt;
typedef std::vector&lt;int&gt; IntVector;
typedef std::map&lt;IntVector,double&gt; Map;
void foo(Map&amp; m,const IntVector&amp; v)
{
   Map::iterator i = m.find(v);
   i-&gt;first.push_back(10);
};
int main()
{
   Map m;
   IntVector v(10,10);
   foo(m,v);
   return 0;
}
</code></pre>

<p>Using g++ 4.4.0, I get his compilation error:</p>

<pre><code>test.cpp: In function 'void foo(Map&amp;, const IntVector&amp;)':
test.cpp:8: error: passing 'const std::vector&lt;int, std::allocator&lt;int&gt; &gt;' as 'this' argument of 'void std::vector&lt;_Tp, _Alloc&gt;::push_back(const _Tp&amp;) [with _Tp = int, _Alloc = std::allocator&lt;int&gt;]' discards qualifiers
</code></pre>

<p>I would expect this error if I was using <code>Map::const_iterator</code> inside foo but not using a non-const iterator.</p>

<p>What am I missing, why do I get this error?</p>
","87234","","<p>The keys in a map are constant. A map is a tree, and you can't just going around changing the keys or you'll break its invariants. The <code>value_type</code> of a map with <code>Key</code> and <code>Value</code> is <code>std::pair&lt;const Key, Value&gt;</code>, to enforce this.</p>

<p>Your design needs some changing. If you really need to modify the key, you need to remove the element, change its key, and re-insert it with the new key.</p>

<p>Also concerning your example specifically, you will get undefined behavior (if this did work). Your map is empty when you call <code>foo</code>, so the iterator returned by <code>find</code> will be <code>m.end()</code>; the element doesn't exist. But then you'd go on to modify this non-existent element: ka-boom. Whenever you <code>find</code> something, you should check that it was found before you attempt to use it.</p>
"
"<p>I can have</p>

<pre><code>std::bitset&lt; 10 &gt; bitsetA;
</code></pre>

<p>or    </p>

<pre><code>const size_t LengthB = 20;
std::bitset&lt; LengthB &gt; bitsetB;
</code></pre>

<p>without any problem. </p>

<p>But, if the length is not <code>const</code></p>

<pre><code>size_t LengthC = 30;
std::bitset&lt; LengthC &gt; bitsetC;  // Line 30, say
</code></pre>

<p>I face the following compilation error</p>

<pre><code>'LengthC' cannot appear in a constant-expression
template argument 1 is invalid
</code></pre>

<p>What is the reason for that?</p>

<p>What would be the problem, for compiler and for user code, if line 30 was to be accepted? Is it because LengthC might have some alias?</p>
","87234","","<p>Templates instantiate new types based off their template parameters, which is done at compile-time. You cannot instantiate new types at run-time, because C++ is statically-typed.</p>

<p>So when you have a non-const variable, it can't be passed as a template parameter because it can't be guaranteed to be that value (you'd have to potentially ""instantiate a new type at run-time""). Only when it's const are you ensured the value is indeed constant, and therefore usable in a template parameter.</p>
"
"<p>I'm using VS2008 to build a plain old C++ program (not C++/CLI). I have an abstract base class and a non-abstract derived class, and building this:</p>

<pre><code>Base* obj;
obj = new Derived();
</code></pre>

<p>fails with the error ""'Derived': cannot instantiate abstract class"". (It may be worth noting, however, that if I hover over <code>Base</code> with the cursor, VS will pop up a tooltip saying ""class Base abstract"", but hovering over <code>Derived</code> will only say ""class Derived"" (no ""abstract"")).</p>

<p>The definitions of these classes are fairly large and I'd like to avoid manually checking if each method has been overridden. Can VS do this for me somehow? Any general tips on pinpointing the exact parts of the class' definition that make it abstract?</p>
","87234","","<p>The compiler should tell you in the error message. The following:</p>

<pre><code>struct base
{
    virtual void foo(void) = 0;
    virtual void bar(void) = 0;
};

struct derived : base
{
    virtual void foo(void){}
};

int main(void)
{
    derived d;
}
</code></pre>

<p>Produces:</p>

<blockquote>
  <p>error C2259: 'derived' : cannot instantiate abstract class<br>
  due to following members:<br>
  'void base::bar(void)' : is abstract<br>
  see declaration of 'base::bar'  </p>
</blockquote>

<p>It also does the same with dynamic allocation.</p>
"
"<p>I have a struct that I'd like to output using either 'std::cout' or some other output stream.
Is this possible without using classes?</p>

<p>Thanks</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
template &lt;typename T&gt;
struct point{
  T x;
  T y;
};

template &lt;typename T&gt;
std::ostream&amp; dump(std::ostream &amp;o,point&lt;T&gt; p) const{
  o&lt;&lt;""x: "" &lt;&lt; p.x &lt;&lt;""\ty: "" &lt;&lt; p.y &lt;&lt;std::endl;
}


template&lt;typename T&gt;
std::ostream&amp; operator &lt;&lt; (std::ostream &amp;o,const point&lt;T&gt; &amp;a){
  return dump(o,a);
}


int main(){
  point&lt;double&gt; p;
  p.x=0.1;
  p.y=0.3;
  dump(std::cout,p);
  std::cout &lt;&lt; p ;//how?
  return 0;
}
</code></pre>

<p>I tried different syntax' but I cant seem to make it work.</p>
","87234","","<p>Perhaps it's a copy-paste error, but there are just a few things wrong. Firstly, free-functions cannot be <code>const</code>, yet you have marked <code>dump</code> as such. The second error is that <code>dump</code> does not return a value, which is also easily remedied. Fix those and it should work:</p>

<pre><code>template &lt;typename T&gt; // note, might as well take p as const-reference
std::ostream&amp; dump(std::ostream &amp;o, const point&lt;T&gt;&amp; p)
{
    return o &lt;&lt; ""x: "" &lt;&lt; p.x &lt;&lt; ""\ty: "" &lt;&lt; p.y &lt;&lt; std::endl;
}
</code></pre>
"
"<p>In general, I want warnings of unsigned vs signed.</p>

<p>However, in this particular case, I want it suppressed;</p>

<pre><code>std::vector&lt;Blah&gt; blahs;

for(int i = 0; i &lt; blahs.size(); ++i) { ...
</code></pre>

<p>I want to kill this comparison.</p>

<p>Thanks!</p>

<p>(using g++)</p>
","87234","","<p>You should fix, not suppress. Use an unsigned type:</p>

<pre><code>for (size_t i = 0; i &lt; blahs.size(); ++i)
</code></pre>

<p>You can also use <code>unsigned</code>, but <code>size_t</code> is more appropriate here (and may have a different, larger, range). If you're only using <code>i</code> to iterate and don't need its value in the loop, use iterators instead:</p>

<pre><code>for (auto iter = blahs.begin(), end = blahs.end(); iter != end; ++iter)
</code></pre>

<p>If your compiler does not support <code>auto</code>, replace <code>auto</code> with <code>T::iterator</code> or <code>T::const_iterator</code>, where <code>T</code> is the type of <code>blahs</code>. If your compiler supports a fuller subset of C++11, though, do this:</p>

<pre><code>for (auto&amp; element : blahs)
</code></pre>

<p>Which is best of all.</p>

<hr>

<p>Strictly speaking, the above is not ""correct"". It should be:</p>

<pre><code>typedef std::vector&lt;Blah&gt; blah_vec;
blah_vec blahs;

for (blah_vec::size_type i = 0; i &lt; blahs.size(); ++i)
</code></pre>

<p>But this can be verbose, and every implementation I know uses <code>size_t</code> as <code>size_type</code> anyway.</p>

<hr>

<p>If for some reason you really need a signed integer type for <code>i</code>, you'll have to cast:</p>

<pre><code>// assumes size() will fit in an int
for (int i = 0; i &lt; static_cast&lt;int&gt;(blahs.size()); ++i)

// assumes i will not be negative (so use an unsigned type!)
for (int i = 0; static_cast&lt;size_t&gt;(i) &lt; blahs.size(); ++i)

// and the technically correct way, assuming i will not be negative
for (int i = 0; static_cast&lt;blah_vec::size_type&gt;(i) &lt; blahs.size(); ++i)
</code></pre>
"
"<p>I am just wondering would it be better to do this:</p>

<pre><code>if((fd = open(filename, O_RDWR)) == -1)
{
fprintf(stderr, ""open [ %s ]\n"", strerror(errno));

return 1;
}
</code></pre>

<p>or this</p>

<pre><code>fd = open(filename, O_RDWR);
if(fd == -1)
{
    fprintf(stderr, ""open [ %s ]\n"", strerror(errno));

    return 1;
}
</code></pre>

<p>Many thanks for any suggestions,</p>
","87234","","<p>Yuck, split it up. What do you gain by mashing it all on one line? Let's compare and contrast:</p>

<p>Single-line:  </p>

<ul>
<li>Advantages:</li>
<li>Disadvantages: Hard to read, prone to error. (Consider your first revision.)</li>
</ul>

<p>Multi-line:  </p>

<ul>
<li>Advantages: Easy to read, less error-prone.</li>
<li>Disadvantages: </li>
</ul>

<p>I think it's clear. :)</p>

<hr>

<p>""Sometimes putting it on one line makes more sense, for example: <code>while ((c=getchar())!=EOF)</code>""</p>

<p>That's fine, but that isn't the case here. There <em>are</em> times when not splitting it up makes more sense, but <em>in general</em>, don't.</p>

<hr>

<p>""It saves more vertical space""</p>

<p>If one line is killing your ability to see the function, you need to 1) buy a monitor with a resolution higher than 640x480, and 2) Write smaller functions.</p>

<p>Really, I've <em>never</em> understood that argument for anything, functions should <em>easily</em> fit on any screen, regardless of a one-line difference.</p>

<hr>

<p>""Multiple lines make it look complex""</p>

<p>Not really, shoving it on one line is arguably harder to read and more complex looking. Splitting things up makes it simpler to process one bit at a time, one shouldn't assume two lines makes it twice as complex.</p>
"
"<p>I'm building an interpreter and as I'm aiming for raw speed this time, every clock cycle matters for me in this (raw) case.</p>

<p>Do you have any experience or information what of the both is faster: Vector or Array?
All what matters is the speed I can access an element (opcode receiving), I don't care about inserting, allocation, sorting, etc.</p>

<p>I'm going to lean myself out of the window now and say:</p>

<ul>
<li><strong>Arrays are at least a bit faster than vectors in terms of accessing an element i.</strong></li>
</ul>

<p>It seems really logical for me. With vectors you have all those security and controlling overhead which doesn't exist for arrays.</p>

<p>(Why) Am I wrong?</p>

<p>No, I can't ignore the performance difference - even if it is <em>so</em> small - I have already optimized and minimized every other part of the VM which executes the opcodes :)</p>
","87234","","<p>You're comparing apples to oranges. Arrays have a constant-size and are automatically allocated, while vectors have a dynamic size and are dynamically allocated. Which you use depends on what you need.</p>

<p>Generally, arrays are ""faster"" to allocate (in quotes because comparison is meaningless) because dynamic allocation is slower. However, accessing an element should be the same. (Granted an array is probably more likely to be in cache, though that doesn't matter after the first access.)</p>

<p>Also, I don't know what ""security"" you're talking about, <code>vector</code>'s have plenty of ways to get undefined behavior just like arrays. Though they have <code>at()</code>, which you don't need to use if you know the index is valid.</p>

<p>Lastly, profile and look at the generated assembly. Nobody's guess is gonna solve anything.</p>
"
"<p>So, I'm wanting to get a better grasp on how string literals in C++ work. I'm mostly concerned with situations where you're assigning the address of a string literal to a pointer, and passing it around. For example: </p>

<pre><code>char* advice = ""Don't stick your hands in the toaster."";
</code></pre>

<p>Now lets say I just pass this string around by copying pointers for the duration of the program. Sure, it's probably not a good idea, but I'm curious what would actually be going on behind the scenes. </p>

<p>For another example, let's say we make a function that returns a string literal: </p>

<pre><code>char* foo()
{
    // function does does stuff
    return ""Yikes!""; // somebody's feeble attempt at an error message
}
</code></pre>

<p>Now lets say this function is called very often, and the string literal is only used about half the time it's called: </p>

<pre><code>// situation #1: it's just randomly called without heed to the return value
foo(); 

// situation #2: the returned string is kept and used for who knows how long
char* retVal = foo();
</code></pre>

<p>In the first situation, what's actually happening? Is the string just created but not used, and never deallocated? </p>

<p>In the second situation, is the string going to be maintained as long as the user finds need for it? What happens when it isn't needed anymore... will that memory be freed up then (assuming nothing points to that space anymore)? </p>

<p>Don't get me wrong, I'm not planning on using string literals like this. I'm planning on using a container to keep my strings in check (probably std::string). I'm mostly just wanting to know if these situations could cause problems either for memory management or corrupted data. </p>
","87234","","<p>String-literals have the type <code>const char[N]</code> (where <code>N</code> is the length + 1) and are statically allocated. You need not worry about memory issues; if a string is used in your program it is all handled for you, and resides somewhere in program memory (usually read-only).</p>

<p>That is, these are ""the same"":</p>

<pre><code>static const char str[] = ""a string"";
""a string""
</code></pre>

<p>When you point to a string literal, you are pointing to the first character at the array. In fact, because the type is <code>const char[]</code>, it's only safe to point to it via <code>const char*</code>. The conversion from string literal to <code>char*</code> is deprecated, and unsafe.</p>

<pre><code>// the ""same""
static const char str[] = ""a string"";
const char* strPtr = str; // decays

const char* s1 = ""a string"";
char* s2 = ""a string""; // allowed, implicit const_cast

*s1 = 'A'; // not allowed, it's const
*s2 = 'B'; // allowed, it's not const (but leads to undefined behavior)
</code></pre>
"
"<p>In C++, are bitsets actually a set of bools? Doesn't this defeat the purpose of using a BitSet because bools are 32 bits (I think...)?</p>
","87234","","<p>They <em>represent</em> a collection of <code>bool</code>'s, but those values are really stored as bits in an <code>unsigned long</code>.</p>

<p>The size of a <code>bool</code> is not necessary any number of bits, neither is an <code>unsigned long</code>. (Though the minimum number of bits for any data type is 8, and for an <code>unsigned long</code> it must be at least 32.)</p>
"
"<p>I would like to copy the content of one std::map into another. Can I use <code>std::copy</code> for that? Obviously, the following code won't work:</p>

<pre><code>int main() {
  typedef std::map&lt;int,double&gt; Map;
  Map m1;
  m1[3] = 0.3;
  m1[5] = 0.5;
  Map m2;
  m2[1] = 0.1;
  std::copy(m1.begin(), m1.end(), m2.begin());
  return 0;
}
</code></pre>

<p>This won't work because <code>copy</code> will call <code>operator*</code> on <code>m2.begin()</code> to ""dereference"" it and assign a value (all values are of type <code>std::pair&lt;const int, double&gt;</code>). Then it will call <code>operator++</code> to move to the next space in <code>m2</code>. Both of these operations don't work because of the <code>const</code> in <code>const int</code> and there is no space reserved for any new elements.</p>

<p>Is there any way to make it work with <code>std::copy</code>? </p>

<p>Thanks!</p>
","87234","","<p>You need a variant of an <a href=""http://www.cplusplus.com/reference/std/iterator/"">insert iterator</a>:</p>

<pre><code>std::copy(m1.begin(), m1.end(), std::inserter(m2, m2.end()) );
</code></pre>

<p><a href=""http://www.cplusplus.com/reference/std/iterator/inserter/""><code>inserter</code></a> is defined in <code>&lt;iterator&gt;</code>. It requires a place to insert into (hence the <code>m2.end()</code>), and returns an <a href=""http://www.cplusplus.com/reference/std/iterator/insert_iterator/""><code>insert_iterator</code></a>.</p>
"
"<p>Suppose I have a variadic template function like</p>

<pre><code>template&lt;typename... Args&gt;
unsigned length(Args... args);
</code></pre>

<p>How do I find the length of the parameter list using the length function ? </p>
","87234","","<p>Use <code>sizeof...</code>:</p>

<pre><code>template&lt;typename... Args&gt;
constexpr std::size_t length(Args...)
{
    return sizeof...(Args);
}
</code></pre>

<p>Note you shouldn't be using <code>unsigned</code>, but <code>std::size_t</code> (defined in <code>&lt;cstddef&gt;</code>). Also, the function should be a constant expression.</p>

<hr>

<p>Without using <code>sizeof...</code>:</p>

<pre><code>namespace detail
{
    template&lt;typename T&gt;
    constexpr std::size_t length(void)
    {
        return 1; // length of 1 element
    }

    template&lt;typename T, typename... Args&gt;
    constexpr std::size_t length(void)
    {
        return 1 + length&lt;Args...&gt;(); // length of one element + rest
    }
}

template&lt;typename... Args&gt;
constexpr std::size_t length(Args...)
{
    return detail::length&lt;Args...&gt;(); // length of all elements
}
</code></pre>

<p><sup>Note, everything is completely untested.</sup></p>
"
"<p>I saw that @GMan implemented <a href=""http://stackoverflow.com/questions/2770474/how-to-find-the-length-of-a-parameter-pack/2770496#2770496"">a version of <code>sizeof...</code></a> for variadic templates which (as far as I can tell) is equivalent to the built in <code>sizeof...</code>. Doesn't this go against the second design principle: <a href=""http://public.research.att.com/~bs/C++0xFAQ.html"" rel=""nofollow""><em>prefer libraries to language extensions</em></a>?</p>
","87234","","<p><code>sizeof...</code> is just sugar, I think.</p>

<p><code>sizeof</code> is indeed core to the language as is <code>...</code>, and although a <code>countof</code> function could exist we already have <code>sizeof</code> and <code>...</code> reserved so we might as well make it convenient to get the count that way.</p>

<p>Contrarily, if <code>sizeof</code> and <code>...</code> weren't reserved, the idea of adding such a thing would have probably failed because new keywords tend to be frowned upon. (The less the better.)</p>
"
"<p>Is there a way to map floats to ints or unsigned ints so that with the exception of NaN, order is preserved?</p>

<p>So if a and b are floats, and F is the mapping function,</p>

<p>a &lt; b implies F(a) &lt; F(b)
and 
a == b implies F(a) == F(b)</p>
","87234","","<p>Hm, just out of the <code>DawsonCompare</code> routine in Game Programming Gems 6, it's a normal bit-cast followed by a sign flip (since negative floats order opposite then negative integers). I'll borrow that idea.</p>

<p>You have:</p>

<pre><code>// utility
template &lt;typename R, typename T&gt;
R&amp; bit_cast(T&amp; pX)
{
    return reinterpret_cast&lt;R&amp;&gt;(pX);
}

// int32_t defined in &lt;boost/cstdint.hpp&gt;. 
boost::int32_t float_to_int_bits(float pX)
{
    boost::int32_t x = bit_cast&lt;boost::int32_t&gt;(pX);

    if (x &lt; 0)
        x = 0x80000000 - x;

    return x;
}
</code></pre>

<p>If you can guarantee your <code>int</code> is 32 bits, you can just use that.</p>

<hr>

<p>Fun fact: The book goes on to use this (note, not with the exact code I present, since I stripped out the float-to-int part) to compare floating point values with tolerance:</p>

<pre><code>bool DawsonCompare(float pX, float pY, int pDiff)
{
    int x = float_to_int_bits(pX);
    int y = float_to_int_bits(pY);

    int diff = x - y;
    return abs(diff) &lt; pDiff;
}
</code></pre>

<p>This compares floats as true if their integer representations are within a certain range. (He uses 1000 as a good default.) A branch-less version called the <code>LomontCompare</code> is presented with the same idea, but you have to buy the book for that. :)</p>
"
"<p>Where do I find the lib files for linking my program when using some Boost libraries?
Decided to try its threading functionality but I am getting</p>

<blockquote>
  <p>Error 6   fatal error LNK1104: cannot
  open file
  'libboost_thread-vc90-mt-gd-1_42.lib' InterviewPractice</p>
</blockquote>

<p>after I include</p>

<blockquote>
  <p>Error 6   fatal error LNK1104: cannot
  open file
  'libboost_thread-vc90-mt-gd-1_42.lib' InterviewPractice</p>
</blockquote>

<p>I can't find where to get the .lib files for proper linking on the boost website?
Any tips? :)</p>
","87234","","<p>Some of the Boost libraries need to be built (the ones that use OS-specific functions, for example). You can <a href=""http://www.boost.org/doc/libs/1_42_0/more/getting_started/windows.html"">build them yourself</a>, or download a <a href=""http://www.boostpro.com/download"">pre-built package</a>.</p>
"
"<p>Every stl container take an allocator as a parameter:</p>

<pre><code>template &lt; class T, class Allocator = allocator&lt;T&gt; &gt; class vector;
</code></pre>

<p>If you write your own class It is possible to use your own allocator.
But is it possible to write your own allocator without using templates?</p>

<p>For example, writing this function is not easy if you are not allowed to use templates</p>

<pre><code> pointer allocate(size_type n, const_pointer = 0) {
    void* p = std::malloc(n * sizeof(T));
    if (!p)
      throw std::bad_alloc();
    return static_cast&lt;pointer&gt;(p);
  }
</code></pre>

<p>Because how could you know the size of T?</p>
","87234","","<p>Well, if you wrote one that wasn't a template class, it would have to be for a single type only. Just replace <code>T</code> with whichever type you want an allocator for.</p>

<p>Seems like a pointless exercise, since you do in fact have templates available to you to use.</p>
"
"<p>My Herb Schildt book on C++ says: ""... In C++, if a function is declared as returning a value, it <strong>must</strong> return a value."" However, if I write a function with a non-void return type and do not return anything, the compiler issues a warning instead of an error: ""Control reaches end of non-void function.""</p>

<p>I use gcc (MinGW) and have set the -pedantic flag.</p>
","87234","","<p>§6.6.3/2:</p>

<blockquote>
  <p>Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior in a value-returning function.</p>
</blockquote>

<p>So it depends on your definition of mandatory. Do you <em>have</em> to? No. But if you want your program to have well-defined behavior, yes.*</p>

<p><sup>*<code>main</code> is an exception, see §3.6.1/5. If control reaches the end of <code>main</code> without a <code>return</code>, it will have the effect of <code>return 0;</code>.</sup></p>
"
"<p>This is probably an easy one, but is the right way to calculate volume for a sphere in C++?  My <code>getArea()</code> seems to be right, but when I call <code>getVolume()</code> it doesn't output the right amount.  With a sphere of <code>radius = 1</code>, it gives me the answer of <code>pi</code>, which is incorrect:</p>

<pre><code>double Sphere::getArea() const
{
    return 4 * Shape::pi * pow(getZ(), 2);
}

double Sphere::getVolume() const
{
    return (4 / 3) * Shape::pi * pow(getZ(), 3);
}
</code></pre>
","87234","","<p>In <code>(4 / 3)</code>, these are both integers so you get integer division. That means the result will be truncated (1.333... becomes 1). Make one of them a double so the other gets promoted to a double during division, yielding a correct result.</p>

<p>I prefer to use <code>(4.0 / 3.0)</code>.</p>
"
"<p>I have some functions that can be grouped together, but don't belong to some object / entity and therefore can't be treated as methods. </p>

<p>So, basically in this situation I would create a new namespace and put the definitions in a <code>header</code> file, the implementation in <code>cpp</code> file. Also (if needed) I would create an anonymous namespace in that <code>cpp</code> file and put all additional functions that don't have to be exposed / included to my namespace's interface there.</p>

<p>See the code below (probably not the best example and could be done better with another program architecture, but I just can't think of a better sample...)</p>

<p><em>Sample code (<code>header</code>)</em></p>

<pre><code>namespace algorithm {
   void HandleCollision(Object* object1, Object* object2);
}
</code></pre>

<p><em>Sample code (<code>cpp</code>)</em></p>

<pre><code>#include ""header""

// Anonymous namespace that wraps 
// routines that are used inside 'algorithm' methods
// but don't have to be exposed
namespace {
   void RefractObject(Object* object1) {
      // Do something with that object
      // (...)
   }
}

namespace algorithm {
   void HandleCollision(Object* object1, Object* object2) {
      if (...) RefractObject(object1);
   }
}
</code></pre>

<p><strong>So far so good.</strong> I guess this is a good way to manage my code, but I don't know what should I do if I have some template-based functions and want to do basically the same.</p>

<p>If I'm using templates, I have to put all my code in the <code>header</code> file. Ok, but how should I conceal some implementation details then? </p>

<p>I want to hide <code>RefractObject</code> function from my interface, but I can't simply remove its declaration (just because I have all my code in a <code>header</code> file)...</p>

<p>The only approach I came up with was something like:</p>

<p><em>Sample code (<code>header</code>)</em></p>

<pre><code>namespace algorithm {
   // Is still exposed as a part of interface!
   namespace impl {
      template &lt;typename T&gt;
      void RefractObject(T* object1) {
         // Do something with that object
         // (...)
      }
   }

   template &lt;typename T, typename Y&gt;
   void HandleCollision(T* object1, Y* object2) {
      impl::RefractObject(object1);
      // Another stuff
   }
}
</code></pre>

<p>Any ideas how to make this better in terms of code designing?</p>
","87234","","<p>That's a pretty common solution. Boost does it, and I do it as well, but with the <code>detail</code> namespace instead. Just make it a rule: ""don't look inside <code>detail</code>!""</p>

<p>File-wise, I recommend giving details their own file, and tucking it away in a detail folder. That is, my code would be akin to:</p>

<pre><code>//           v
#include ""detail/RefractObject.hpp""

namespace algorithm {

   template &lt;typename T, typename Y&gt;
   void HandleCollision(T* object1, Y* object2) {
      detail::RefractObject(object1);
      // Another stuff
   }
}
</code></pre>

<p>This is just good code practice in general (keep things split up and re-usable) and keeps the header file cleaner of implementation details.</p>
"
"<p>I have a class</p>

<pre><code>template&lt;size_t N, size_t M&gt;
class Matrix {
    // ....
};
</code></pre>

<p>I want to make a <code>typedef</code> which creates a <code>Vector</code> (column vector) which is equivalent to a <code>Matrix</code> with sizes N and 1. Something like that:</p>

<pre><code>typedef Matrix&lt;N,1&gt; Vector&lt;N&gt;;
</code></pre>

<p>Which produces compile error. The following creates something similar, but not exactly what I want:</p>

<pre><code>template &lt;int N&gt;
class Vector: public Matrix&lt;N,1&gt;
{ };
</code></pre>

<p>Is there a solution or a not too expensive workaround / best-practice for it? Thanks in advance!</p>
","87234","","<p>C++11 added <em>alias declarations</em>, which are generalization of <code>typedef</code>, allowing templates:</p>

<pre><code>template &lt;size_t N&gt;
using Vector = Matrix&lt;N, 1&gt;;
</code></pre>

<p>The type <code>Vector&lt;3&gt;</code> is equivalent to <code>Matrix&lt;3, 1&gt;</code>.</p>

<hr>

<p>In C++03, the closest approximation was:</p>

<pre><code>template &lt;size_t N&gt;
struct Vector
{
    typedef Matrix&lt;N, 1&gt; type;
};
</code></pre>

<p>Here, the type <code>Vector&lt;3&gt;::type</code> is equivalent to <code>Matrix&lt;3, 1&gt;</code>.</p>
"
"<p>I was just writing a generic object factory and using the boost preprocessor meta-library to make a variadic template (using 2010 and it doesn't support them).  My function uses rval references and std::forward to do perfect forwarding and it got me thinking...when C++0X comes out and I had a standard compiler I would do this with real variadic templates.  How though, would I call std::forward on the arguments?</p>

<p><pre><code></p>

<p>template &lt; typename ... Params >
void f(Params ... params) // how do I say these are rvalue reference?
{
  y(std::forward(...params)); //? - I doubt this would work.
}
</pre></code></p>

<p>Only way I can think of would require manual unpacking of ...params and I'm not quite there yet either.  Is there a quicker syntax that would work?</p>
","87234","","<p>You would do:</p>

<pre><code>template &lt;typename ...Params&gt;
void f(Params&amp;&amp;... params)
{
    y(std::forward&lt;Params&gt;(params)...);
}
</code></pre>

<p>The <code>...</code> pretty much says ""take what's on the left, and for each template parameter, unpack it accordingly."" </p>
"
"<p>I have a problem  regarding multiple inclusion of header file in C++ code.</p>

<p>say for example, i have three class X,Y,Z. X and Y are derived from Base class Z. And i want to create an instance of X in Y. The code will go like this.</p>

<pre><code>class Z{some code}

class X:public Z{some code};//here #include header of class Z added

class Y:public Z //here #include header of class Z added as well as of X class

{private:
   X* mX;//instance of X 

 some code};
</code></pre>

<p>So in this multiple definition of all methods of base class arises. how can i cope with this problem</p>
","87234","","<p>You use what are called include guards or header guards. They go something like this:</p>

<pre><code>// within some_header.h
#ifndef SOME_HEADER_H
#define SOME_HEADER_H

// stuff goes here

#endif
</code></pre>

<p>Essentially, the first time around the macro hasn't been defined so everything inside is included. However, after the first time subsequent includes will have no effect.</p>

<p>The naming scheme, like all naming schemes, is completely arbitrary and up to you. I like to include the file name as a minimum, as I did above, in that fashion. I also include namespaces and project names in my real projects.</p>

<p>There are a couple of things to watch out for. You might be tempted to do things like this:</p>

<pre><code>#define _SOME_HEADER_H__
</code></pre>

<p>To obfuscate it a bit. However, names that begin with an underscore followed by a capital letter, or contain double-underscores are <em>reserved</em> identifiers, and you cannot use them.</p>
"
"<p>in c++ i have following code</p>

<pre><code>class Foobar{
public:
  Foobar * operator()(){
      return new Foobar;
 };
</code></pre>

<p>My quesion is how to call the ();
if i do Foobar foo() the constructor gets called 
i am confused about behaviour of () 
can some explain me </p>
","87234","","<p>Like this:</p>

<pre><code>Foobar f;
Foobar* p = f(); // f() invokes operator()
delete p;
</code></pre>

<hr>

<p>Also this is very weird, in terms of returning a pointer like that and it being a rather useless function. (I ""need"" a <code>Foobar</code> to make a new one?)</p>
"
"<p>I am having trouble writing C++ code that uses a header file designed for a C file.  In particular, the header file used a variable name called class:</p>

<pre><code>int BPY_class_validate(const char *class_type, PyObject *class, PyObject *base_class, BPY_class_attr_check* class_attrs, PyObject **py_class_attrs);
</code></pre>

<p>This works in C as class isn't taken as a keyword, but in C++, class is.  So is there anyway I can #include this header file into a c++ file, or am I out of luck?</p>

<p>Thank you.</p>
","87234","","<p>If this is declaration only, then the variable names don't matter at all. You can completely remove them or change them how you please. This is because the declaration merely defines the name and type of the function, which is:</p>

<pre><code>int BPY_class_validate(const char *, PyObject *, PyObject *,
                        BPY_class_attr_check*, PyObject **);
</code></pre>

<p>But if you want the names (to be a bit more descriptive), you can just throw an underscore at the end of what you have:</p>

<pre><code>int BPY_class_validate(const char *class_type, PyObject *class_,
                        PyObject *base_class, BPY_class_attr_check* class_attrs, 
                        PyObject **py_class_attrs);
</code></pre>

<p>This won't break any other code.</p>
"
"<p>Today in my interview, the interviewer asked: printf is a function and every function returns something; int, void, float, etc.  Now what does printf return as it's a function? </p>
","87234","","<p>Not every function returns something, which is indicated by using <code>void</code>:</p>

<pre><code>void function_returns_nothing(void);
</code></pre>

<hr>

<p><code>printf</code> is a function (declared in <code>&lt;stdio.h&gt;</code>) and it returns an <code>int</code>, which is the number of characters outputted. If an error occurs, the number is negative.</p>
"
"<p>I have a string of class string</p>

<pre><code>string str;
</code></pre>

<p>how can I check if it is a number or not, str can only have 3 possible types described below like</p>

<pre><code>abcd
</code></pre>

<p>or a number like</p>

<pre><code>123.4
</code></pre>

<p>or a number with a parenthesis attach to the end it for example</p>

<pre><code>456)
</code></pre>

<p>note the parenthesis at the end of ""str"" is the only possible combination of number and none number</p>

<p>where the bottom two are considered valid numbers, I know I could use lexical_cast if only the first 2 cases occur, but how about considering all 3 possible cases to occur?
I don't need to do anything fancy with str, I just need to know whether it is a valid number as I described</p>
","87234","","<p>You have to define ""number"". There isn't a generic ""number"" type (for example, your first number is a double while the second is an integer).</p>

<p>That said, as shown in <a href=""http://stackoverflow.com/questions/1243428/convert-string-to-int-with-bool-fail-in-c/1243435#1243435"">this answer</a>, <code>lexical_cast</code> simply checks that the destination <em>and only</em> the destination exists:</p>

<pre><code>template &lt;typename R, typename T&gt;
R lexical_cast(const T&amp; pX)
{
    std::stringstream ss;
    ss &lt;&lt; pX;

    R result;               // take out any whitespace, make sure nothing is left
    if ((ss &gt;&gt; result).fail() || !(ss &gt;&gt; std::ws).eof())
    {
        throw std::bad_cast();
    }

    return result;
}
</code></pre>

<p>So just make a new function:</p>

<pre><code>template &lt;typename R, typename T&gt;
R weak_lexical_cast(const T&amp; pX)
{
    std::stringstream ss;
    ss &lt;&lt; pX;

    R result;
    if ((ss &gt;&gt; result).fail())
    {
        throw std::bad_cast();
    }

    return result;
}
</code></pre>

<p>It's basically a <code>lexical_cast</code> but doesn't care about any remaining characters (allowing your second number to work.)</p>
"
"<p>In answering <a href=""http://stackoverflow.com/questions/2847410/goal-of-cs-auto-keyword/2847490#2847490"">this question</a> the question arose as to whether the traditional <strong>C</strong> meaning of the keyword <code>auto</code> (automatic storage) is still valid in <strong>C++0x</strong> now that it means type deduction.</p>

<p>I remember that the old meaning of <code>auto</code> should remain where relevant but others disagreed. </p>

<pre><code>auto char c = 42; // either compilation error or c = '*'
</code></pre>

<p>Looking at compilers I see the current division.</p>

<ol>
<li>Old meaning of auto is no longer allowed<br>
<ul>
<li>VS10</li>
<li>g++  </li>
</ul></li>
<li>Old meaning of auto is used where relevant
<ul>
<li><a href=""http://www.comeaucomputing.com/tryitout/"" rel=""nofollow"">Comeau</a></li>
</ul></li>
</ol>

<p>Do you know which is the correct behaviour?</p>
","87234","","<p>No, it is not. In fact, §7.1.6.​4/3 gives the following example:</p>

<pre><code>auto x = 5; // OK: x has type int
const auto *v = &amp;x, u = 6; // OK: v has type const int*, u has type const int
static auto y = 0.0; // OK: y has type double
auto int r; // error: auto is not a storage-class-specifier
</code></pre>

<p>As you can see, it results in an error. §7.1.6.​5 pretty much seals the deal with:</p>

<blockquote>
  <p>A program that uses auto in a context not explicitly allowed in this section is ill-formed.</p>
</blockquote>
"
"<p>I' m implementing a custom <strong>STL map</strong>. I need to make sure that <strong>any data type (basic or user defined) key</strong> will work with it. I declared the Map class as a template which has two parameters for the key and the value. My question is if I need to use a string as the key type, <strong>how can I overload the &lt; and > operators for string type keys only??</strong> In template specialization we have to specialize the whole class with the type we need as I understand it.
Is there any way I can do this in a better way?? What if I add a separate Key class and use it as the template type for Key?</p>

<p>Thank You!!</p>
","87234","","<p>You should factor out the comparison as a type, like the normal <code>std::map</code> does. That is, have a utility class <code>less_compare</code>:</p>

<pre><code>template &lt;typename T&gt;
struct less_compare
{
    bool operator()(const T&amp; pLhs, const T&amp; pRhs) const
    {
        return pLhs &lt; pRhs;
    }
};
</code></pre>

<p>And then:</p>

<pre><code>template &lt;typename Key, typename Value, typename Compare = less_compare&lt;Key&gt; &gt;
class map
{
    // ...

private:
    Compare mCompare;
};
</code></pre>

<p>And to compare two values, do: <code>if (mCompare(someThing, someOtherThing))</code>, which will be true with <code>someThing</code> is ""less than"" <code>someOtherThing</code>. Note this factoring also allows user-defined comparisons (which is why ""less than"" is quoted). This is known as policy-based design.</p>

<p>And now you can specialize just the <code>less_compare</code> class for C-strings. (And also provide <code>greater_compare</code> and kin.)</p>

<hr>

<p>Do keep in mind, unless this is for learning, you should not be implementing your own map. Also note that <code>std::string</code> has <code>operator&lt;</code> overloaded already.</p>
"
"<p>I am currently writing some glsl like vector math classes in c++, and I just implemented an abs() function like this:</p>

<pre><code>    template&lt;class T&gt;
    static inline T abs(T _a)
    {
        return _a &lt; 0 ? -_a : _a;
    }
</code></pre>

<p>I compared its speed to the default c++ abs from math.h like this:</p>

<pre><code>clock_t begin = clock();
    for(int i=0; i&lt;10000000; ++i)
    {
        float a = abs(-1.25);
    };

    clock_t end = clock();
    unsigned long time1 = (unsigned long)((float)(end-begin) / ((float)CLOCKS_PER_SEC/1000.0));

    begin = clock();
    for(int i=0; i&lt;10000000; ++i)
    {
        float a  = myMath::abs(-1.25);
    };
    end = clock();
    unsigned long time2 = (unsigned long)((float)(end-begin) / ((float)CLOCKS_PER_SEC/1000.0));

    std::cout&lt;&lt;time1&lt;&lt;std::endl;
    std::cout&lt;&lt;time2&lt;&lt;std::endl;
</code></pre>

<p>Now the default abs takes about 25ms while mine takes 60. I guess there is some low level optimisation going on. Does anybody know how math.h abs works internally? The performance difference is nothing dramatic, but I am just curious!</p>
","87234","","<p>Since they are the implementation, they are free to make as many assumptions as they want. They know the format of the <code>double</code> and can play tricks with that instead.</p>

<p>Likely (as in almost not even a question), your <code>double</code> is the <a href=""http://en.wikipedia.org/wiki/Double_precision_floating-point_format"">binary64 format</a>. This means the sign has it's own bit, and an absolute value is merely clearing that bit. For example, as a specialization, <strong>a compiler implementer may do the following</strong>:</p>

<pre><code>template &lt;&gt;
double abs&lt;double&gt;(const double x)
{
    // breaks strict aliasing, but compiler writer knows this behavior for the platform
    uint64_t i = reinterpret_cast&lt;const std::uint64_t&amp;&gt;(x);
    i &amp;= 0x7FFFFFFFFFFFFFFFULL; // clear sign bit

    return reinterpret_cast&lt;const double&amp;&gt;(i);
}
</code></pre>

<p>This removes branching and may run faster.</p>
"
"<p>When I try to compile my program the compiler complains about this line in a .h file that I #included.</p>

<pre><code>ostream &amp; Print (ostream &amp; stream);
</code></pre>

<p>How can this be fixed?</p>
","87234","","<p>If you <code>#include &lt;ostream&gt;</code>, <code>ostream</code> will be defined in the <code>std</code> namespace:</p>

<pre><code>#include &lt;ostream&gt;

// ...

std::ostream &amp; Print (std::ostream &amp; stream);
</code></pre>
"
"<p>I'm trying to initialize an int array with everything set at -1.</p>

<p>I tried the following, but it doesn't work. It only sets the first value at -1.</p>

<pre><code>int directory[100] = {-1};
</code></pre>

<p>Why doesn't it work right?</p>
","87234","","<p>I'm surprised at all the answers suggesting <code>vector</code>. They aren't even the same thing!</p>

<p>Use <a href=""http://en.cppreference.com/w/cpp/algorithm/fill""><code>std::fill</code></a>, from <code>&lt;algorithm&gt;</code>:</p>

<pre><code>int directory[100];
std::fill(directory, directory + 100, -1);
</code></pre>

<hr>

<p>Not concerned with the question directly, but you might want a nice helper function when it comes to arrays:</p>

<pre><code>template &lt;typename T, size_t N&gt;
T* end(T (&amp;pX)[N])
{
    return pX + N;
}
</code></pre>

<p>Giving:</p>

<pre><code>int directory[100];
std::fill(directory, end(directory), -1);
</code></pre>

<p>So you don't need to list the size twice.</p>
"
"<p>What I want to do is this:</p>

<pre><code>#include &lt;memory&gt;

class autostr : public std::auto_ptr&lt;char&gt;
{
public:
    autostr(char *a) : std::auto_ptr&lt;char&gt;(a) {}
    autostr(autostr &amp;a) : std::auto_ptr&lt;char&gt;(a) {}
    // define a bunch of string utils here...
};

autostr test(char a)
{
    return autostr(new char(a));
}

void main(int args, char **arg)
{
    autostr asd = test('b');
    return 0;
}
</code></pre>

<p>(I actually have a copy of the auto_ptr class that handles arrays as well, but the same error applies to the stl one)</p>

<p>The compile error using GCC 4.3.0 is:</p>

<pre>main.cpp:152: error: no matching function for call to `autostr::autostr(autostr)'
main.cpp:147: note: candidates are: autostr::autostr(autostr&)
main.cpp:146: note:                 autostr::autostr(char*)</pre>

<p>I don't understand why it's not matching the autostr argument as a valid parameter to autostr(autostr&amp;).</p>
","87234","","<p>The <code>autostr</code> that is returned from the function is a temporary. Temporary values can only be bound to references-to-const (<code>const autostr&amp;</code>), but your reference is non-const. (And ""rightly so"".)</p>

<p>This is a <em>terrible</em> idea, almost none of the standard library is intended to be inherited from. I already see a bug in your code:</p>

<pre><code>autostr s(""please don't delete me...oops"");
</code></pre>

<p>What's wrong with <code>std::string</code>?</p>
"
"<p>I want to convert  vector of double to array of double. Can any one help me to do this</p>
","87234","","<p>What for? You need to clarify: Do you need a pointer to the first element of an array, or an array?</p>

<p>If you're calling an API function that expects the former, you can do <code>do_something(&amp;v[0], v.size())</code>, where <code>v</code> is a vector of <code>double</code>s. The elements of a vector are contiguous.</p>

<p>Otherwise, you just have to copy each element:</p>

<pre><code>double arr[100];
std::copy(v.begin(), v.end(), arr);
</code></pre>

<p>Ensure not only thar <code>arr</code> is big enough, but that <code>arr</code> gets filled up, or you have uninitialized values.</p>
"
"<p>This question came about as a result of some mixed-language programming. I had a Fortran routine I wanted to call from C++ code. Fortran passes all its parameters by reference (unless you tell it otherwise).</p>

<p>So I thought I'd be clever (bad start right there) in my C++ code and define the Fortran routine something like this:</p>

<pre><code>extern ""C"" void FORTRAN_ROUTINE (unsigned &amp; flag);
</code></pre>

<p>This code worked for a while but (of course right when I needed to leave) suddenly started blowing up on a return call. Clear indication of a munged call stack.</p>

<p>Another engineer came behind me and fixed the problem, declaring that the routine <strong>had</strong> to be defined in C++ as </p>

<pre><code>extern ""C"" void FORTRAN_ROUTINE (unsigned * flag);
</code></pre>

<p>I'd accept that except for two things. One is that it seems rather counter-intuitive for the compiler to not pass <strong>reference parameters</strong> by reference, and I can find no documentation anywhere that says that. The other is that he changed a whole raft of other code in there at the same time, so it theoretically could have been another change that fixed whatever the issue was.</p>

<p>So the question is, how does C++ actually pass reference parameters? Is it perhaps free to do copy-in, copy-out for small values or something? In other words, are reference parameters utterly useless in mixed-language programming? I'd like to know so I don't make this same code-killing mistake ever again.</p>
","87234","","<p>C++ doesn't define how implementations should be, it's just a language. So there isn't ""a"" implementation of references.</p>

<p>That said, references are implemented with pointers. This leads to a lot of confusion (""references are just pointers"", ""references are just pointers with the mundane parts taken out"") but that is <em>not</em> the case. References are aliases and will always be aliases.</p>

<p>The compiler will pass the address of a variable, and operate with that pointer. This has the same effect (but not the same semantics!). To be more concrete, a compiler might ""replace"" this:</p>

<pre><code>void make_five(int&amp; i)
{
    i = 5;
}

int main(void)
{
    int i = 0;
    make_five(i);
}
</code></pre>

<p>With this:</p>

<pre><code>void make_five(int* const i)
{
    *i = 5;
}

int main(void)
{
    int i = 0;
    make_five(&amp;i);
}
</code></pre>

<p>(In  practice such a simple function would be inlined, but you get the point.) Hence why your colleague suggested you use a pointer.</p>

<p>Keep in mind references are to be preferred. This is where the distinction between references and pointers is important. Do you want to alias a variable, or do you want to point at it? Most of the times, the former. In C, you had to use a pointer to do this, and this contributes to the common C-programmer misconception that references are actually pointers.</p>

<p>To get similar semantics (since you are now pointing to a variable, and not aliasing it), you should ensure the value of the pointer is not null:</p>

<pre><code>extern ""C"" void FORTRAN_ROUTINE (unsigned * flag)
{
    assert(flag); // this is normally not a problem with references, 
                  // since the address of a variable cannot be null.

    // continue...
}
</code></pre>

<p>Just to be safe.</p>
"
"<p>Hi<br>
Looking for a way to do a portable, safe, elements count for c-style arrays, I found this solution:</p>

<pre><code>template &lt;typename T, unsigned N&gt;  char (&amp;arrayCountofHelper(T(&amp;)[N]))[N];
#define ARRAY_COUNTOF(arr) (sizeof(arrayCountofHelper(arr)))
</code></pre>

<p>It seems like arrayCountofHelper is actually a reference to a function, and the macro ARRAY_COUNTOF uses the fact that the size of a function is the size of it's returned type.<br>
It works just fine.<br>
However, when I tried to check if it's portable, I didn't find any evidence for that. I couldn't find any reference to sizeof(function reference) in the standard (14882/1998) and, in fact, I am not entirely sure I am allowed to even create a function reference any more (although the standard does mention it several times).<br>
So, does someone know where in the standard I should look? (Or, if I misinterpreted the declaration some how, what is the correct interpretation?)</p>

<p>Thanks<br>
Oren  </p>

<p>P.S. (for those of you who think I didn't find the appropriate solution for my problem)<br>
I know I can always use</p>

<pre><code>#define ARRAY_COUNTOF sizeof(arr)/sizeof(arr[0])
</code></pre>

<p>or even</p>

<pre><code>template &lt;typename T, unsigned N&gt; size_t arrayCountof(T(&amp;)[N]) {return N;}
</code></pre>

<p>but the first will not check if arr is a array (or pointer) and the second is not usable inside static_assert.<br>
(and I would have used std::tr1::array or std::vector, but this is a legacy code I am maintaining)</p>
","87234","","<p>We will pick this apart loosely, I'm using INCITS+ISO+IEC+14882-2003. I'll quote the small stuff, but some of the more complex stuff is too large to quote.</p>

<p><code>sizeof</code> is defined in §5.3.3, and it says (abridged):</p>

<blockquote>
  <p>The sizeof operator yields the number of bytes in the object representation of its operand. The operand is either an expression, which is not evaluated, or a parenthesized type-id.</p>
</blockquote>

<p>In other words, it yields the size of a type in bytes or finds the type of an expression and yields the size of that. We don't have a type, we have the expression <code>arrayCountofHelper(arr)</code>.</p>

<p>You can dissect this expression by looking at the definitions of <code>primary-expression</code> and <code>postfix-expression</code> as defined in §5.1 and §5.2 respectively. You will find it is a <code>postfix-expression</code> and fits the requirements of a function call (§5.2.2).</p>

<p>Now back to <code>sizeof</code>. We only care about the type of this function call expression (so we can yield the size of it), and §5.2.2/3 says:</p>

<blockquote>
  <p>The type of the function call expression is the return type of the statically chosen function [...]. This type shall be a complete object type, a reference type or the type <code>void</code>.</p>
</blockquote>

<p>So we need to find the return type of the function that would be called (remember, this is all unevaluated) with <code>arrayCountofHelper(arr)</code>. <code>arrayCountofHelper</code> is a function template which we would be instantiating (§14.7), so we need to do that before we have an instantiated function to get the return type of.</p>

<p>All the template parameters need to have values (§14.8.2), and by using the rules defined in §14.8.2.1 we will find <code>T</code> and <code>N</code> by matching the array passed to the function with the functions parameter (which is a reference to an array). (For example, if <code>arr</code> was <code>int[10]</code>, <code>T</code> would be <code>int</code> and <code>N</code> would be 10.) Once we have those, the function can be instantiated.</p>

<p>Once instantiated, the return type of the function would be <code>char(&amp;)[N]</code>*, a reference to an array of <code>N</code> <code>char</code>'s. (If you need help parsing, see §8.3.5. There are also questions on SO on how to parse ""complex"" types.) So now we've found the type of the expression, we must take the size of it.</p>

<p>§5.3.3/2 defines how <code>sizeof</code> works with references and arrays (emphasis mine):</p>

<blockquote>
  <p><strong>When applied to a reference or a reference type, the result is the size of the referenced type.</strong> When applied to a class, the result is the number of bytes in an object of that class including any padding required for placing objects of that type in an array. The size of a most derived class shall be greater than zero (1.8). The result of applying sizeof to a base class subobject is the size of the base class type.70) <strong>When applied to an array, the result is the total number of bytes in the array. This implies that the size of an array of n elements is n times the size of an element.</strong></p>
</blockquote>

<p>The size of a reference type is the size of its referenced type, so we need to size of <code>char[N]</code>. The size of this is <code>N * sizeof(char)</code>. <code>char</code> is fundamental as it is the smallest type there is; that is, <code>sizeof(char)</code> is <em>always</em> one. (§5.3.3/1) So the size yielded by this expression is <code>1 * N</code>, or what we wanted the whole time: <code>N</code>.</p>

<p>And that's how it works.</p>

<hr>

<p>The reason this one is preferred over your last example of <code>arrayCountof</code> is because the result of <code>sizeof</code> is a <em>constant expression</em>, so can be used in places where a constant expression is required.</p>

<p>It should be noted that in C++0x, we can get our clean no-macro syntax with:</p>

<pre><code>template &lt;typename T, unsigned N&gt;
constexpr size_t arrayCountof(T(&amp;)[N]) {return N;}
</code></pre>

<hr>

<p><sub>* The reason the function return type is a reference to an array and not an array is simply because you cannot return arrays. If you could, either choice would suffice.</sub></p>
"
"<p>I am porting some C++ code to GCC, and apperantly it isn't happy with C++ style casting when sapces are involved, as in <code>unsigned int(-1)</code>, <code>long long(ShortVar)</code> etc... It gives an <code>error: expected primary-expression before 'long'</code>.</p>

<p>Is there any way to make peace with GCC without going over each one of those and rewrite in  c-style?</p>
","87234","","<p>You want <code>static_cast&lt;unsigned int&gt;(-1)</code> and kin. Those tend to be viewed as the more C++-style casts, and don't have the same problem.</p>

<p>For what it's worth, you'd have to do:</p>

<pre><code>template &lt;typename T&gt;
struct identity
{
    typedef T type;
};
</code></pre>

<p>And then:</p>

<pre><code>identity&lt;unsigned int&gt;::type(-1);
</code></pre>

<p><sub>
Or in C++0x:</p>

<pre><code>template &lt;typename T&gt;
using id = T;

id&lt;unsigned int&gt;(-1);
</code></pre>

<p></sub></p>
"
"<p>A quick question:</p>

<p>When i pass a variable to a function, does the program make a copy of that variable to use in the function?  </p>

<p>If it does and I knew that the function would only read the variable and never write to it, is it possible to pass a variable to the function without creating a copy of that variable or should I just leave that up to the compiler optimizations to do that automatically for me?</p>
","87234","","<p>Yes, parameters passed by value are copied. However, you can also pass variables by reference. A reference is an alias, so this makes the parameter an alias to a variable, rather than a copy. For example:</p>

<pre><code>void foo(int x) {}
void bar(int&amp; x) {}

int i;

foo(i); // copies i, foo works with a copy
bar(i); // aliases i, bar works directly on i
</code></pre>

<p>If you mark it as const, you have a read-only alias:</p>

<pre><code>void baz(const int&amp;);

baz(i); // aliases i, baz reads-only i
</code></pre>

<p>In general, always pass by const-reference. When you need to modify the alias, remove the const. And lastly, when you need a copy, just pass by value.*</p>

<p><sub>* And as a good rule of thumb, fundamental types (int, char*, etc.) and types with <code>sizeof(T) &lt; sizeof(void*)</code> should be passed by value instead of const-reference, because their size is small enough that copying will be faster than aliasing.</sub></p>
"
"<p>I have just started learning pthreads API and I am following the tutorial <a href=""https://computing.llnl.gov/tutorials/pthreads/#Abstract"" rel=""nofollow"">here</a></p>

<p>However, in an example program of <code>pthread_create</code>, the sample program creates a long variable and <strong>passes its value</strong>, typecasted as <code>void*</code>. In the thread entry function, it dereferences it just like a long. </p>

<p>Is this legit?
I understand if I pass the address of variable <code>t</code>, every thread would be acting on the same variable and not on a copy of it. Can we do this because it's a <code>void*</code> and the compiler has no idea about what type we are sending?</p>

<pre><code>#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

#define NUM_THREADS     5

void *PrintHello(void *threadid)
{
   long tid;
   tid = (long)threadid;
   printf(""Hello World! It's me, thread #%ld!\n"", tid);
   pthread_exit(NULL);
}

int main (int argc, char *argv[])
{
   pthread_t threads[NUM_THREADS];
   int rc;
   long t;
   for(t=0; t&lt;NUM_THREADS; t++){
      printf(""In main: creating thread %ld\n"", t);
      rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *)t);
      if (rc){
         printf(""ERROR; return code from pthread_create() is %d\n"", rc);
         exit(-1);
      }
   }
   pthread_exit(NULL);
}
</code></pre>
","87234","","<p>This works as long as <code>sizeof(long) &lt;= sizeof(void*)</code>, and that every value of <code>long</code> can be represented as a <code>void*</code>.</p>

<p>Better would be to pass the address of the variable. You can cast from a <code>T*</code> to <code>void*</code>, and back again safely and without assumption.</p>
"
"<p>I have a function where I provide a pointer to a std::vector.</p>

<p>I want to make x = to vector[element] but i'm getting compiler errors.</p>

<p>I'm doing:</p>

<pre><code>void Function(std::vector&lt;int&gt; *input)
{
   int a;
   a = *input[0];
}
</code></pre>

<p>What is the right way to do this?
Thanks</p>
","87234","","<p>Should be:</p>

<pre><code>void Function(std::vector&lt;int&gt; *input)
{
    // note: why split the initialization of a onto a new line?
    int a = (*input)[0]; // this deferences the pointer (resulting in)
                         // a reference to a std::vector&lt;int&gt;), then
                         // calls operator[] on it, returning an int.
}
</code></pre>

<p>Otherwise you've got <code>*(input[0])</code>, which is <code>*(input + 0)</code>, which is <code>*input</code>. Of course, why not just do:</p>

<pre><code>void Function(std::vector&lt;int&gt;&amp; input)
{
    int a = input[0];
}
</code></pre>

<p>And if you don't modify <code>input</code>, mark it as <code>const</code>:</p>

<pre><code>void Function(const std::vector&lt;int&gt;&amp; input)
{
    int a = input[0];
}
</code></pre>
"
"<pre><code>class A {};

class B {};

class C {};

class D {};

//A+B , A+C, B+C , A+D, D+C  namely all of these combinations will be possible just one functions 
</code></pre>
","87234","","<pre><code>template &lt;typename T, typename U&gt;
void foo(const T&amp; pX, const U&amp; pY)
{
    // do stuff
}
</code></pre>

<p>This isn't what you want, per se, as it makes a new function for each different combination of <code>T</code> and <code>U</code>, but it is one function template.</p>

<hr>

<p>This prohibits <code>T</code> and <code>U</code> from being the same:</p>

<pre><code>template &lt;bool&gt; struct static_assert {};
template &lt;&gt; struct&lt;true&gt; static_assert {};

#define STATIC_ASSERT(pValue) static_assert&lt;(pValue)&gt;()

// ...

template &lt;typename T, typename U&gt;
struct is_different
{
    static const bool value = true;
};

template &lt;typename T&gt;
struct is_different&lt;T, T&gt;
{
    static const bool value = false;
};

// ...

template &lt;typename T, typename U&gt;
void foo(const T&amp; pX, const U&amp; pY)
{
    STATIC_ASSERT(is_different&lt;T, U&gt;::value);

    // do stuff
}
</code></pre>
"
"<p>what is the syntax for defining virtual functions outside the class body?</p>

<pre><code>class random{

public:
   random(int i = 0);
   virtual ~random(){};
   virtual void print() const;
protected:
   int id;      

};
</code></pre>

<p>is it?</p>

<pre><code>virtual void random::print() {


}
</code></pre>

<p>?</p>
","87234","","<p>Just:</p>

<pre><code>struct foo
{
    virtual void bar(void) const;
};

void foo::bar(void) const
{
}
</code></pre>

<p><code>virtual</code> only goes on the declaration.</p>
"
"<p>I've managed to wrap my head around some of C++'s functional capacities (for_each, mapping functions, using iterators...) but the construction of the templates and function argument lists for taking in generic containers and iterators still eludes me. I have a practical example I'm hoping someone can illustrate for me:</p>

<p>Take the following function that processes an incoming std::vector and builds a running total of many data-points/iterations of a process:</p>

<pre><code>/* the for-loop method - not very savvy */
void UpdateRunningTotal (int_vec&amp; total, int_vec&amp; data_point) {
  for (int i = 0; i &lt; V_SIZE; i++) {
    total[i] += data_point[i];
  }
}

typedef int_vec std::vector&lt;int&gt;;
int_vec running_total (V_SIZE, 0);  // create a container to hold all the ""data points"" over many iterations
/* further initialization, and some elaborate loop to create data points */

UpdateRunningTotal (running_total, iteration_data);
/* further processing */
</code></pre>

<p>The above works, but I'd much rather have a function that takes iterators and performs this summation. Even better, have a generic parameter list with the type deduced instead of specifying the container type, i.e.:</p>

<pre><code>UpdateRunningTotal (iteration_data.begin(), iteration_data.end(), running_total.begin());
</code></pre>

<p>I'm really lost at this point and need a little guidance to find how to define the template and argument lists to make the function generic. What would the template and function definition look like? I'm already familiar with a way to perform this specific task using STL functionality - I'm looking for illustration of the generic function/template definition.</p>
","87234","","<p>You could use <a href=""http://www.cplusplus.com/reference/algorithm/transform/""><code>std::transform</code></a> and <a href=""http://www.cplusplus.com/reference/std/functional/plus/""><code>std::plus</code></a>:</p>

<pre><code>std::transform(iteration_data.begin(), iteration_data.end(),
                running_total.begin(), iteration_data.begin(), std::plus&lt;int&gt;());
</code></pre>

<p>And in your function, that would be:</p>

<pre><code>template &lt;typename Iter1, typename Iter2&gt;
void UpdateRunningTotal(Iter1 pBegin, Iter1 pEnd, Iter2 pBegin2)
{
    typedef typename std::iterator_traits&lt;Iter1&gt;::value_type value_type;

    std::transform(pBegin, pEnd, pBegin2, pBegin, std::plus&lt;value_type&gt;());
}
</code></pre>
"
"<p>I'm not afraid to admit that I'm somewhat of a C++ newbie, so this might seem like a silly question but....</p>

<p>I see DWORD used all over the place in code examples. When I look up what a DWORD truly means, its apparently just an unsigned int (0 to 4,294,967,295). So my question then is, why do we have DWORD? What does it give us that the integral type 'unsigned int' does not? Does it have something to do with portability and machine differences?</p>
","87234","","<p><code>DWORD</code> is not a C++ type, it's defined in <code>&lt;windows.h&gt;</code>.</p>

<p>The reason is that <code>DWORD</code> has a specific range and format Windows functions rely on, so if you require that specific range use that type. (Or as they say ""When in Rome, do as the Romans do."") For you, that happens to correspond to <code>unsigned int</code>, but that might not always be the case. To be safe, use <code>DWORD</code> when a <code>DWORD</code> is expected, regardless of what it may actually be.</p>

<p>For example, if they ever changed the range or format of <code>unsigned int</code> they could use a different type to underly <code>DWORD</code> to keep the same requirements, and all code using <code>DWORD</code> would be none-the-wiser. (Likewise, they could decide <code>DWORD</code> needs to be <code>unsigned long long</code>, change it, and all code using <code>DWORD</code> would be none-the-wiser.)</p>

<hr>

<p>Also note <code>unsigned int</code> does <em>not</em> necessary have the range 0 to 4,294,967,295. See <a href=""http://stackoverflow.com/questions/271076/what-is-the-difference-between-an-int-and-a-long-in-c/271132#271132"">here</a>.</p>
"
"<p>I'm trying to create a WCHAR:</p>

<pre><code>LONG bufferSize = foo.bar() + 1;
WCHAR wszBaz[bufferSize];
</code></pre>

<p>The compiler issues an error:</p>

<pre><code>error C2057: expected constant expression
error C2466: cannot allocate an array of constant size 0
error C2133: 'wszBaz' unknown size
</code></pre>

<p>What am I doing wrong?</p>

<p><strong>UPDATE</strong>: I added <code>const</code> but it still gives the same error:</p>

<pre><code>const LONG bufferSize = foo.bar() + 1;
WCHAR wszBaz[bufferSize];
</code></pre>
","87234","","<p>The size of an array is a constant expression. <code>bufferSize</code> is not a constant expression.</p>

<p>Use a <code>vector</code>: <code>std::vector&lt;WCHAR&gt; wszBaz(bufferSize);</code>, or a <code>std::wstring</code>.</p>
"
"<p>i just moved from C to C++, and now work with lists.
i have a class called ""message"", and i need to have a class called ""line"",
which should have a list of messages in its properties. as i learned, the object's properties should be initialized in the constructor's initialization list, and i had the ""urge"" to initialize the messages list in addition to the rest of the properties (some strings and doubles). is that ""urge"" justified? does the list need to be initialized?<br>
thank you in advance.</p>

<p>here is my code.<br>
the purpose is to create an empty list of lines, and the constructor i'm talking about is the one in line.cpp
<br></p>

<pre><code>//-------------------
//Code for line.h:
//-------------------

#ifndef LINE_H_
#define LINE_H_

#include ""message.h""
#include &lt;string&gt;
#include &lt;list&gt;
using namespace std;

namespace test
{
    using std::string;

    class Line
    {
        public:
            // constractor with parameters
            Line(const string&amp; phoneStr, double callRate, double messageRate);

            //function to get phone string
            string getPhoneStr() const;

            double getCallRate() const;

            double getMessageRate() const;

            double getLastBill() const;

            void addMessage(const string&amp; phoneStr);


        private:
            string mPhoneStr;
            list&lt;Message&gt; mMessages;
            double mMessageRate;
            double mLastBill;
    };
}

#endif /* LINE_H_ */


//-------------------
//Code for line.cpp:
//-------------------

#include ""line.h""

namespace test
{
    Line::Line(const string&amp; phoneStr, double callRate, double messageRate)
        : mPhoneStr(phoneStr), mCallRate(callRate), mMessageRate(messageRate),
        mLastBill(0) {}

    //getters:

    string Line::getPhoneStr() const
    {
        return mPhoneStr;
    }

    double Line::getCallRate() const
    {
        return mCallRate;
    }

    double Line::getMessageRate() const
    {
        return mMessageRate;
    }

    double Line::getLastBill() const
    {
        return mLastBill;
    }


}


//-------------------
//Code for message.h:
//-------------------

#ifndef MESSAGE_H_
#define MESSAGE_H_

#include &lt;string&gt;

namespace test
{
    using std::string;

    class Message
    {
        public:
            // constractor with parameters
            Message(const string&amp; phoneStr);

            //function to get phone string
            string getPhoneStr() const;

            //function to set new phone string
            void setPhoneStr(const string&amp; phoneStr);


        private:
            string mPhoneStr;
    };
}
#endif /* MESSAGE_H_ */

//-----------------------------------------------------------------------

//---------------------
//code for message.cpp:
//---------------------


#include ""message.h""

namespace test
{

    Message::Message(const string&amp; phoneStr) : mPhoneStr(phoneStr) {}

    string Message::getPhoneStr() const
    {
        return mPhoneStr;
    }

    void Message::setPhoneStr(const string&amp; phoneStr)
    {
        mPhoneStr = phoneStr;
    }

}
</code></pre>
","87234","","<p>The initialization list is for initializing any base classes and member variables. The body of the constructor is meant to run any other code that you need before the object can be considered initialized.</p>

<p>I'm having a hard time understanding your situation, but hopefully the above helps. </p>
"
"<p>now what is wrong with this code!</p>

<p>Header:</p>

<pre><code>#pragma once
#include &lt;string&gt;
using namespace std;

class Menu
{
public:
    Menu(string []);
    ~Menu(void);

};
</code></pre>

<p>Implementation:</p>

<pre><code>#include ""Menu.h""

string _choices[];

Menu::Menu(string items[])
{
    _choices = items;
}

Menu::~Menu(void)
{
}
</code></pre>

<p>compiler is complaining:</p>

<pre><code>error C2440: '=' : cannot convert from 'std::string []' to 'std::string []'
There are no conversions to array types, although there are conversions to references or pointers to arrays
</code></pre>

<p>there is no conversion! so what is it on about?</p>

<p>please help, just need to pass a bloody array of strings and set it to Menu class _choices[] attribute.</p>

<p>thanks</p>
","87234","","<p>Array's cannot be assigned, and your arrays have no sizes anyway. You probably just want a <code>std::vector</code>: <code>std::vector&lt;std::string&gt;</code>. This is a dynamic array of strings, and can be assigned just fine.</p>

<pre><code>// Menu.h
#include &lt;string&gt;
#include &lt;vector&gt;

// **Never** use `using namespace` in a header,
// and rarely in a source file.

class Menu
{
public:
    Menu(const std::vector&lt;std::string&gt;&amp; items); // pass by const-reference

    // do not define and implement an empty
    // destructor, let the compiler do it
};

// Menu.cpp
#include ""Menu.h""

// what's with the global? should this be a member?
std::vector&lt;std::string&gt; _choices;

Menu::Menu(const std::vector&lt;std::string&gt;&amp; items)
{
    _choices = items; // copies each element
}
</code></pre>
"
"<p><strong>Background:</strong> </p>

<p>I have been working on a platformer game written in C++ for a few months.  The game is currently written entirely in C++, though I am intrigued by the possibility of using Lua for enemy AI and possibly some other logic.  However, the project was designed without Lua in mind, and I have already written working C++ code for much of the AI.  I am hoping Lua can improve the extensibility of the game, but don't know if it would make sense to convert existing C++ code into Lua.</p>

<p><strong>The question:</strong></p>

<p>When, if ever, is it appropriate to take fully functional C++ code and refactor it into a scripting language like Lua?</p>

<p>The question is intentionally a bit vague, so feel free give answers that are not relevant to the given background.</p>
","87234","","<p>Scripting languages are useful for things that might change frequently or be extended, and can afford the trade from speed.</p>

<p>It wouldn't make sense to use a scripting language in your core libraries, because those are relatively static (all they do is process stuff over and over) and need to be quick. But for things like AI, it's a perfect idea. You may tweak the AI without recompiling, and allow future changes quite nicely. Once you ship, you can pre-compile the scripting language and call it good.</p>

<p>It's also best for extensibility. Provide a Lua interface to your game and anybody can write plugins using a simple language, without the need for compiling. The more fleshed out your Lua interface, the more expressive and powerful those plugins can be.</p>

<p>If you've already got everything working, unless you intend on trying to improve it or allow extensions I don't really see a reason to strip it out; you're done. It would be something to keep in mind for your next game engine.</p>

<p>That said, if you're not completely done and this is a hobby/practice kind of thing, I would recommend you do. It will be your introduction into adding scripting capabilities to the game engine. When you get to making larger and more complex engines you won't need to worry about something new.</p>
"
"<p>I have a String class and I want to overload + to add two String* pointers.
something like this doesn't work:</p>

<pre><code>String* operator+(String* s1, String* s2);
</code></pre>

<p>Is there any way to avoid passing by reference.
Consider this example:</p>

<pre><code>String* s1 = new String(""Hello"");
String* s2 = new String(""World"");

String* s3 = s1 + s2;
</code></pre>

<p>I need this kind of addition to work. Please suggest.</p>
","87234","","<p>You can't. You cannot overload operators for built-in types. In any case, why use pointers at all? Avoid dynamic allocation as much as possible!</p>

<pre><code>String s1(""Hello"");
String s2(""World"");

String s3 = s1 + s2;
</code></pre>

<p>That's much better, and doesn't leak. Now you can overload:</p>

<pre><code>String operator+(const String&amp; s1, const String&amp; s2);
</code></pre>

<p>how you desire. This is, of course, a waste of time because <code>std::string</code> exists. :)</p>
"
"<p>What does 'Conditional expressions can be only boolean, not integral.' mean? I do not know Java and I know C++ deffenetly not enought to understend what it means.. Please help (found in <a href=""http://www.javacoffeebreak.com/articles/thinkinginjava/comparingc++andjava.html"" rel=""nofollow"">http://www.javacoffeebreak.com/articles/thinkinginjava/comparingc++andjava.html</a> in Comparing C++ and Java item 7 sub item 1)</p>
","87234","","<p>It means you need a boolean for a conditional, a conversion from an integral type won't be implicit. Instead of <code>if (x)</code> you'd need <code>if (x != 0)</code>, etc.</p>

<p>The former is an <code>int</code> which will be implicitly converted to <code>bool</code> in C++ (via <code>!= 0</code>), but the latter expression yields a boolean directly.</p>
"
"<p>I have this class:</p>

<pre><code>class A {
private:
 int player;
public:
 A(int initPlayer = 0);
 A(const A&amp;);
 A&amp; operator=(const A&amp;);
 ~A();
 void foo() const;
};
</code></pre>

<p>and I have function which contains this row:</p>

<pre><code> A *pa1 = new A(a2);
</code></pre>

<p>can somebody please explain what exactly is going on, when I call <code>A(a2)</code> compiler calls copy constructor or constructor, thanks in advance</p>
","87234","","<p>Assuming <code>a2</code> is an instance of <code>A</code>, this calls the copy constructor.</p>

<p>It will call <code>operator new</code> to get dynamic memory for the object, then it will copy-construct a new object into the memory, then return a pointer to that memory.</p>
"
"<p>Compile error in vs2010(Win32 Console Application Template) for the code below. How can I fix it.</p>

<pre><code>unsigned long long int Fibonacci[numFibs]; // error occurred here
</code></pre>

<p>error C2057: expected constant expression</p>

<p>error C2466: cannot allocate an array of constant size 0</p>

<p>error C2133: 'Fibonacci' : unknown size</p>

<p><strong>Complete code attached</strong>(It's a sample code from programming In c -3E book. No any modify)</p>

<pre><code>int main()
{

 int i, numFibs;

 printf(""How may Fibonacci numbers do you want (between 1 to 75)? "");
 scanf(""%i"", &amp;numFibs);

 if ( numFibs &lt; 1 || numFibs &gt; 75){
  printf(""Bad number, sorry!\n"");
  return 1;
 }

 unsigned long long int Fibonacci[numFibs];

 Fibonacci[0] = 0; // by definition
 Fibonacci[1] = 1; // ditto

 for ( i = 2; i &lt; numFibs; ++i)
  Fibonacci[i] = Fibonacci[i-2] + Fibonacci[i-1];

 for ( i = 0; i &lt; numFibs; ++i)
  printf(""%11u"",Fibonacci[i]);

 printf(""\n"");

 return 0;

}
</code></pre>
","87234","","<p>VS2010 is a C++ compiler by default, and C++ does not support variable length arrays. You can change your project to compile code as C code, but VS2010 still doesn't really support C99.</p>

<p>I would recommend you use <code>gcc</code> for C code, it's much more conformant. </p>
"
"<p>Suppose I have a bunch of fruit:</p>

<pre><code>class Fruit { ... };
class Apple : public Fruit { ... };
class Orange: public Fruit { ... };
</code></pre>

<p>And some polymorphic functions that operate on said fruit:</p>

<pre><code>void Eat(Fruit* f, Pesticide* p)   { ... }
void Eat(Apple* f, Pesticide* p)   { ingest(f,p); }
void Eat(Orange* f, Pesticide* p)   { peel(f,p); ingest(f,p); }
</code></pre>

<p>OK, wait. Stop right there. Note at this point that any sane person would make Eat() a virtual member function of the Fruit classes. But that's not an option, because I am not a sane person. Also, I don't want that Pesticide* in the header file for my fruit class.</p>

<p>Sadly, what I want to be able to do next is exactly what member functions and dynamic binding allow:</p>

<pre><code>typedef list&lt;Fruit*&gt; Fruits;
Fruits fs;
...
for(Fruits::iterator i=fs.begin(), e=fs.end(); i!=e; ++i)
    Eat(*i);
</code></pre>

<p>And obviously, the problem here is that the pointer we pass to Eat() will be a Fruit*, not an Apple* or an Orange*, therefore nothing will get eaten and we will all be very hungry.</p>

<p>So what I really want to be able to do instead of this:</p>

<pre><code>Eat(*i);
</code></pre>

<p>is this:</p>

<pre><code>Eat(MAGIC_CAST_TO_MOST_DERIVED_CLASS(*i));
</code></pre>

<p>But to my limited knowledge, such magic does not exist, except possibly in the form of a big nasty if-statement full of calls to dynamic_cast.</p>

<p>So is there some run-time magic of which I am not aware? Or should I implement and maintain a big nasty if-statement full of dynamic_casts? Or should I suck it up, quit thinking about how I would implement this in Ruby, and allow a little Pesticide to make its way into my fruit header?</p>

<p><b>Update:</b> Instead of the contrived bit with the bare Eat functions and Pesticide, suppose instead that I just don't want to put Eat in the fruit because it makes no sense. A fruit that knows how to eat itself? Pshaw. Instead I need an Eater class with an Eat function, with different code for eating each kind of fruit, and some default code in case it's a fruit that the eater doesn't recognize:</p>

<pre><code>class Eater
{
public:
  void Eat(Apple* f) { wash(); nom(); }
  void Eat(Orange* f) { peel(); nom(); }
  void Eat(Fruit* f) { nibble(); }
};
...
Eater me;
for(Fruits::iterator i=fs.begin(), e=fs.end(); i!=e; ++i)
  me.Eat(*i);  //me tarzan! me eat!
</code></pre>

<p>But again, this doesn't work, and the straightforward solution in C++ seems to be a bunch of calls to dynamic_cast.</p>

<p>However, as one of the answers suggests, there may be another clever solution. What if Fruits exposed the qualities that mattered to eaters, with functions like MustPeel() and MustWash()? Then you could get by with a single Eat() function ...</p>

<p><b>Update:</b> Daniel Newby points out that using Visitor also solves the problem as presented ... but this requires a bit of a semantic headstand (Fruit::use or Fruit::beEaten?).</p>

<p>While I'd like to accept several answers, I think psmears's answer is actually the best one for future readers. Thanks, everyone.</p>
","87234","","<p>You need to redesign. Namely, do everything you seem to be avoiding (for what reason, who knows.)</p>

<p>Polymorphic behavior requires polymorphic functions. This means a <code>virtual</code> function. (Or your ladder of <code>dynamic_cast</code>'s, which completely defeats the purpose...)</p>

<pre><code>// fruit.h
class Pesticide; // you don't need a complete type

struct Fruit
{
    virtual void Eat(Pesticide*) = 0;
};

// apple.h
class Apple : public Fruit
{
    void Eat(Pesticide* p) { ... }
};

// orange.h
class Orange : public Fruit
{
    void Eat(Pesticide* p) { ... }
};
</code></pre>

<p>If you still want a free function*:</p>

<pre><code>void Eat(Fruit* f, Pesticide* p)   { f-&gt;Eat(p); }
</code></pre>

<hr>

<p>*Note that your post is already indicative of bad design; namely the first <code>Eat</code> function:</p>

<pre><code>void Eat(Fruit* f, Pesticide* p)   { }
</code></pre>

<p>When does doing nothing to a fruit equate to eating the fruit? A pure virtual function is a much better interface choice.</p>
"
"<p>I have a question about the following code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;boost/scoped_ptr.hpp&gt;

class Interface
{
};

class A : public Interface
{
    public:
        A() { std::cout &lt;&lt; ""A()"" &lt;&lt; std::endl; }
        virtual ~A() { std::cout &lt;&lt; ""~A()"" &lt;&lt; std::endl; }
};


Interface* get_a()
{
    A* a = new A;
    return a;
}

int main()
{
    {
        std::cout &lt;&lt; ""1"" &lt;&lt; std::endl;
        boost::scoped_ptr&lt;Interface&gt; x(get_a());
        std::cout &lt;&lt; ""2"" &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; ""3"" &lt;&lt; std::endl;
}
</code></pre>

<p>It creates the following output:</p>

<pre><code>1
A()
2
3
</code></pre>

<p>As you can see, it doesn't call the destructor of A.
The only way I see to get the destructor of A being called, is to add a destructor for the Interface class like this:</p>

<pre><code>virtual ~Interface() { }
</code></pre>

<p>But I really want to avoid any Implementation in my Interface class and <code>virtual ~Interface() = 0;</code> doesn't work (produces some linker errors complaining about a non existing implementation of <code>~Interface()</code>.</p>

<p>So my question is: What do I have to change in order to make the destructor being called, but (if possible) leave the Interface as an Interface (only abstract methods).</p>
","87234","","<p>You must define a virtual destructor in the base class, otherwise you'll get no polymorphic behavior.</p>

<p>And more importantly, you get undefined behavior otherwise; §5.3.5/3:</p>

<blockquote>
  <p>If the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand’s dynamic type and <em>the static type shall have a virtual destructor or the behavior is undefined</em>.</p>
</blockquote>

<p><sub>Emphasis mine.</sub></p>

<hr>

<p>I'd argue the best is this one:</p>

<pre><code>class Interface
{
public:
    virtual ~Interface(void) = 0;
};

inline Interface::~Interface(void) {}
</code></pre>

<p>The compiler can easily inline this, unlike a solution where the implementation resides in a source file. (Speaking of which, this solution doesn't even mandate you have one.) It also leaves the class pure virtual.</p>
"
"<p>I have a struct <code>Foo</code>. In pseudocode:</p>

<pre><code>def FindFoo:
   foo = results of search
   foundFoo = true if a valid foo has been found  

   return foo if foundFoo else someErrorCode
</code></pre>

<p>How can I accomplish this in C++? </p>

<p><strong>Edited</strong> to remove numerous inaccuracies. </p>
","87234","","<p>C++ objects can never be null or empty. Pointers can hold a null pointer value indicating they point at nothing.</p>

<p>The typical solution would be to throw an exception. Otherwise, use a pointer; just make sure you aren't returning the address of a temporary.</p>

<p>I wouldn't recommend trying to teach yourself C++ with knowledge from other languages, you'll hurt yourself. Grab a <a href=""http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">good beginner-level book</a>, it's the best way to learn. </p>
"
"<p>I have two functions in C:</p>

<pre><code>function1(){
// do something
}

function2(){
// do something while doing that
}
</code></pre>

<p>How would i run these two at the exact same time?
If possible, please provide an example!</p>
","87234","","<p>It's not possible to do in a standard way. You'll need to rely on some third-party method. Namely, <a href=""https://computing.llnl.gov/tutorials/pthreads/"" rel=""nofollow"">pthreads</a> or <a href=""http://msdn.microsoft.com/en-us/library/ms684847%28VS.85%29.aspx"" rel=""nofollow"">Win32 threads</a>.</p>

<p>POSIX example:</p>

<pre><code>#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void* print_once(void* pString)
{
    printf(""%s"", (char*)pString);

    return 0;
}

void* print_twice(void* pString)
{
    printf(""%s"", (char*)pString);
    printf(""%s"", (char*)pString);

    return 0;
}

int main(void)
{
    pthread_t thread1, thread2;

    // make threads
    pthread_create(&amp;thread1, NULL, print_once, ""Foo"");
    pthread_create(&amp;thread2, NULL, print_twice, ""Bar"");

    // wait for them to finish
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL); 

    return 0;
}
</code></pre>

<p>Win32 example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;windows.h&gt;

DWORD print_once(LPVOID pString)
{
    printf(""%s"", (char*)pString);

    return 0;
}

DWORD print_twice(LPVOID pString)
{
    printf(""%s"", (char*)pString);
    printf(""%s"", (char*)pString);

    return 0;
}

int main(void)
{
    HANDLE thread1, thread2;

    // make threads
    thread1 = CreateThread(NULL, 0, print_once, ""Foo"", 0, NULL);
    thread2 = CreateThread(NULL, 0, print_once, ""Bar"", 0, NULL);

    // wait for them to finish
    WaitForSingleObject(thread1, INFINITE);
    WaitForSingleObject(thread2, INFINITE);

    return 0;
}
</code></pre>

<p>There are Windows ports of POSIX if you want to use it on both platforms.</p>
"
"<p>How rigorous is the bounds checking on vectors compared to heap arrays? How exactly is it checking bounds and how does that compare with how a heap array is checked?</p>
","87234","","<p>A <code>vector</code> will do bounds checking if you use the <code>at()</code> function, for example:</p>

<pre><code>std::vector&lt;int&gt; v(5);
v.at(3) = 10; 
v.at(5) = 20; // throws an exception, std::out_of_range
</code></pre>

<p>However, if you use <code>operator[]</code>, there is no bounds checking. (And accessing non-existent elements leads to undefined behavior.)</p>

<p><sub>It should be noted, though, that most implementations will have the possibility to include bounds-checking on all iterators, which is discussed in the answers <a href=""http://stackoverflow.com/questions/1290396/how-to-make-stdvectors-operator-compile-doing-bounds-checking-in-debug-but-n"">here</a>. By default, VS2008 and below have it on in Debug and Release, VS2010 does only in Debug. gcc requires you define <code>_GLIBCXX_DEBUG</code> to get checked iterators.</sub></p>
"
"<p>I've got the following bit of code, which I've narrowed down to be causing a memory leak (that is, in Task Manager, the Private Working Set of memory increases with the same repeated input string). I understand the concepts of heaps and stacks for memory, as well as the general rules for avoiding memory leaks, but something somewhere is still going wrong:</p>

<pre><code>while(!quit){
   char* thebuffer = new char[210]; 
   //checked the function, it isn't creating the leak
   int size = FuncToObtainInputTextFromApp(thebuffer); //stored in thebuffer
   string bufferstring = thebuffer;
   int startlog = bufferstring.find(""$"");
   int endlog = bufferstring.find(""&amp;"");
   string str_text="""";
   str_text = bufferstring.substr(startlog,endlog-startlog+1);
   String^ str_text_m = gcnew String(str_text_m.c_str());
   //some work done
   delete str_text_m;
   delete [] thebuffer; 
}
</code></pre>

<p>The only thing I can think of is it might be the creation of 'string str_text' since it never goes out of scope since it just reloops in the while? If so, how would I resolve that? Defining it outside the while loop wouldn't solve it since it'd also remain in scope then too. Any help would be greatly appreciated.</p>
","87234","","<p>You should use scope-bound resource management (also known as RAII), it's good practice in any case. Never allocate memory manually, keep it in an automatically allocated class that will clean up the resource for you in the destructor.</p>

<p>You code might read:</p>

<pre><code>while(!quit)
{
    // completely safe, no leaks possible
    std::vector&lt;char&gt; thebuffer(210);
    int size = FuncToObtainInputTextFromApp(&amp;thebuffer[0]);

    // you never used size, this should be better
    string bufferstring(thebuffer, size);

    // find does not return an int, but a size_t
    std::size_t startlog = bufferstring.find(""$"");
    std::size_t endlog = bufferstring.find(""&amp;"");

    // why was this split across two lines?
    // there's also no checks to ensure the above find
    // calls worked, be careful
    string str_text = bufferstring.substr(startlog, endlog - startlog + 1);

    // why copy the string into a String? why not construct 
    // this directly?
    String^ str_text_m = gcnew String(str_text_m.c_str());

    // ...

    // don't really need to do that, I think,
    // it's garbage collected for a reason
    // delete str_text_m; 
}
</code></pre>

<p>The point is, you won't get memory leaks if you're ensured your resources are freed by themselves. Maybe the garbage collector is causing your leak detector to mis-fire.</p>

<p>On a side note, your code seems to have lots of unnecessary copying, you might want to rethink how many times you copy the string around. (For example, find <code>""$""</code> and <code>""&amp;""</code> while it's in the vector, and just copy from there into <code>str_text</code>, no need for an intermediate copy.)</p>
"
"<p>I have an generic math-method, that operates under a set of functions (with a lot of variables and states, so it can't be static). I've implemented method in parent class and I want to declare a different set of functions in every child-class.<br>
I've try to do something like this:</p>

<pre><code>class A {
public:
    typedef int (A::*func)();
    func * fs;
    void f() { /*call functions from this-&gt;fs*/ }
};

class B : public A {
public:
    int smth;

    B(int smth) {
         this-&gt;smth = smth; //user-provided variables

        //there may be a lot of functions with same interface
        this-&gt;fs = new func[1];
        fs[0] = &amp;B::f;
    }

    int f() {
        return smth + 1;
    }
};
</code></pre>

<p>It fails with this error:
error C2440: '=' : cannot convert from 'int (__thiscall B::* )(void)' to 'A::func'  </p>

<p>Or ""IntelliSense: a pointer to a bound function may only be used to call the function"" if I try to use &amp;this->f;</p>
","87234","","<p>Maybe an array of <code>boost::function</code> would work:</p>

<pre><code>#include &lt;boost/function.hpp&gt;
#include &lt;boost/lambda/bind.hpp&gt;
#include &lt;vector&gt;

struct A
{
    virtual ~A(void) {}; // base classes should always have virtual destructors

    typedef std::vector&lt;boost::function&lt;int(void)&gt; &gt; function_array;
    function_array mFunctions;
};

struct B : A
{
    B(int pX) : mX(pX) // use initializer lists
    {
        mFunctions.push_back(boost::lambda::bind(&amp;B::foo, this));
    }

    int foo(void)
    {
        return mX + 1;
    }

    int mX;
};

int main(void)
{
    B b(5);
    A&amp; a(b);

    int x = a.mFunctions[0]();
    // x is 6
}
</code></pre>

<p>Your goals are still unclear. (In the above, it doesn't really make sense for <code>A</code> to be a base class. Why not have a function like <code>get_functions</code> that just returns an array of functions all setup and ready to use, for example?)</p>

<hr>

<p>What's your bigger picture here? Sounds like you're looking for virtual functions:</p>

<pre><code>struct A
{
    virtual ~A(void) {} // base classes should always have virtual destructors

    virtual int foo(void) const = 0;
};

struct B : A
{
    B(int pX) : mX(pX) {}

    int foo(void) const
    {
        return mX + 1;
    }

    int mX;
};

int main(void)
{
    B b(5);
    A* a = &amp;b;

    int x = a-&gt;f(); // calls B::foo(), polymorphic behavior thanks to virtual
    // x is 6
}
</code></pre>
"
"<p>Hi I did A Google search and couldn't find anything,</p>

<p>so I wanna learn Qt/C++ my University (I'm a first year CompSci Student) won't be teaching C++ next year which is a big disappointment</p>

<p>I already know Python
and dabbled in LaTeX, Javascript, C++</p>

<p>I'm currently helping out a free software project <a href=""http://code.google.com/p/clementine-player/"">Clementine</a> but it's programmed in Qt/C++ and I don't know enough of both to help out enough.</p>

<p>Is there any tips, Tutorial, howtos out there?</p>
","87234","","<p>Don't learn both at the same time. Learn C++, then learn Qt. Grab a <a href=""http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">book about C++</a>, then a <a href=""http://rads.stackoverflow.com/amzn/click/1593271476"">book about Qt</a>; there is no substitute for a good book.</p>

<p>Trying to learn C++ and Qt at the same time is like trying to learn the alphabet while reading Shakespeare.</p>
"
"<p>I have a piece of C code that is used from a C++ function.  At the top of my C++ file I have the line: <code>#include ""prediction.h""</code></p>

<p>In <code>prediction.h</code> I have this:</p>

<pre><code>#ifndef prediction  
#define prediction  

#include ""structs.h""  

typedef struct {  
    double estimation;  
    double variance;  
} response;

response runPrediction(int obs, location* positions, double* observations,
                        int targets, location* targetPositions);

#endif
</code></pre>

<p>I also have <code>prediction.c</code>, which has:</p>

<pre><code>#include ""prediction.h""  

response runPrediction(int obs, location* positions, double* observations,
                        int targets, location* targetPositions) {  
    // code here  
}
</code></pre>

<p>Now, in my C++ file (which as I said includes prediction.h) I call that function, then compile (through Xcode) I get this error:</p>

<blockquote>
  <blockquote>
    <p>""runPrediction(int, location*, double*, int, location*)"", referenced from:<br>
    mainFrame::respondTo(char*, int)in mainFrame.o<br>
    ld: symbol(s) not found<br>
    collect2: ld returned 1 exit status  </p>
  </blockquote>
</blockquote>

<p>prediction.c is marked for compilation for the current target.  I don't have any problems with other .cpp files not being compiled.  Any thoughts here?</p>
","87234","","<p>Likely the name of the function is being <a href=""http://en.wikipedia.org/wiki/Name_mangling"" rel=""nofollow"">mangled</a>*. You need to do the following:</p>

<pre><code>extern ""C"" response runPrediction(int obs, location* positions,
                   double* observations, int targets, location* targetPositions);
</code></pre>

<p>Which tells it to treat it as a C function declaration.</p>

<p><sub>*C++ mangles function names to give them unique names during the linking phase, for function overloading. C has no function overloading so does no such thing.</sub></p>

<hr>

<p>Just so you know, you can also make an <code>extern ""C""</code> block, if you have multiple things to extern:</p>

<pre><code>extern ""C""
{
    response runPrediction(int obs, location* positions,
                   double* observations, int targets, location* targetPositions);

    // other stuff
}
</code></pre>

<p>And like <a href=""http://stackoverflow.com/questions/3065643/function-referenced-from-symbols-not-found/3065701#3065701"">Paul</a> suggests, to allow the header to be used in both use <code>__cplusplus</code> to condition it:</p>

<pre><code>#ifdef __cplusplus
    #define EXTERN_C extern ""C""
#else
    #define EXTERN_C
#endif

EXTERN_C response runPrediction(int obs, location* positions,
                   double* observations, int targets, location* targetPositions);
</code></pre>
"
"<p>I have a header file which contains a member variable declaration of a static char array:</p>

<pre><code>class ABC 
{ 
public:
static char newArray[4];
// other variables / functions
private:
void setArray(int i, char * ptr);
}
</code></pre>

<p>In the CPP file, I have the array initialized to NULL:</p>

<pre><code>char ABC::newArray[4] = {0};
</code></pre>

<p>In the ABC constructor, I need to overwrite this value with a value constructed at runtime, such as the encoding of an integer:</p>

<pre><code>ABC::ABC()
{ 
int i; //some int value defined at runtime
memset(newArray, 0, 4); // not sure if this is necessary
setArray(i,newArray);
} 

...

void setArray(int i, char * value)
{
    // encoding i to set value[0] ... value [3]
}
</code></pre>

<p>When I return from this function, and print the modified newArray value, it prints out many more characters than the 4 specified in the array declaration.</p>

<p>Any ideas why this is the case.
I just want to set the char array to 4 characters and nothing further.</p>

<p>Thanks...</p>
","87234","","<p>How are you printing it? In C++ (and C), strings are terminated with a nul. (<code>\0</code>). If you're doing something like:</p>

<pre><code>char arr[4] = {'u', 'h', 'o', 'h'};
std::cout &lt;&lt; arr;
</code></pre>

<p>It's going to print ""uhoh"" along with anything else it runs across until it gets to a <code>\0</code>. You might want to do something like:</p>

<pre><code>for (unsigned i = 0; i &lt; 4; ++i)
    std::cout &lt;&lt; arr[i];
</code></pre>

<p>(Having a <code>static</code> tied to instances of a class doesn't really make sense, by the way. Also, you can just do <code>= {}</code>, though it's not needed since <code>static</code> variables are zero-initialized anyway. Lastly, no it doesn't make sense to <code>memset</code> something then rewrite the contents anyway.)</p>
"
"<p>I am trying to print the address of a virtual member function.
If I only wants to print the address of the function I can write:</p>

<pre><code>print(""address: %p"", &amp;A::func);
</code></pre>

<p>But I want to do something like this:</p>

<pre><code>A *b = new B();

printf(""address: %p"", &amp;b-&gt;func); 
printf(""address: %p"", &amp;b-&gt;A::func);
</code></pre>

<p>however this does not compile, is it possible to do something like this even do 
looking up the address in the vtable is done in runtime?</p>
","87234","","<p>From what I can tell in the standard, the only time you get dynamic binding is during a virtual function <em>call</em>. And once you've called a function, you're executing the statements within the function (i.e., you can't ""stop halfway"" into the call and get the address.)</p>

<p>I think it's impossible.</p>
"
"<p>Alright so i have two identical string methods...</p>

<pre><code>string CreateCust() { 
    string nameArray[] ={""Tom"",""Timo"",""Sally"",""Kelly"",""Bob"",""Thomas"",""Samantha"",""Maria""};
    int d = rand() % (8 - 1 + 1) + 1;   
    string e =  nameArray[d];
    return e;
   }      

string CreateFood()  {
     string nameArray[] = {""spagetti"", ""ChickenSoup"", ""Menudo""};
     int d = rand() % (3 - 1 + 1) + 1;   
     string f =  nameArray[d];
     return f;
} 
</code></pre>

<p>however no matter what i do it the guts of CreateFood it will always crash. i created a test chassis for it and it always fails at the <code>cMeal = CreateFood();</code></p>

<pre><code>        Customer Cnow;        
        cout &lt;&lt; ""test1"" &lt;&lt; endl;
        cMeal = Cnow.CreateFood();
        cout &lt;&lt; ""test1"" &lt;&lt; endl;
        cCustomer = Cnow.CreateCust();
        cout &lt;&lt; ""test1"" &lt;&lt; endl;
</code></pre>

<p>i even switched CreateCust with CreateFood and it still fails at the CreateFood Function... </p>

<p>NOTE: if i make createFood a int method it does work...</p>

<p>Also guys even if i changed CreateFood to just COUT a message and nothing more it still crashed...</p>
","87234","","<p>Take out the <code>+ 1</code> on both of them, you access arrays starting from 0:</p>

<pre><code>int d = rand() % (8 - 1 + 1);  // 0-7, not 1-8
int d = rand() % (3 - 1 + 1);  // 0-2, not 1-3
</code></pre>

<p>Otherwise you're accessing a non-existent element, and this is undefined behavior. (That means it could appear to work, like in <code>CreateCust</code>, crash like in <code>CreateFood</code>, do nothing, or do anything.)</p>

<hr>

<p>I'm not sure what the purpose of subtracting 1 then adding 1 is. In any case, now is the perfect time to learn: Don't Repeat Yourself. Even if you do something just twice, make a function out of it, it'll be less cryptic and more concise:</p>

<pre><code>int random(int min, int max)
{
    return rand() % ((b - a) + 1) + a;
}
</code></pre>

<p>This is a simple function that returns a random number between <code>a</code> and <code>b</code>, inclusive. (Means it can include both <code>a</code> and <code>b</code> in the results.) Now your code reads:</p>

<pre><code>// I'll leave CreateCust up to you

string CreateFood(void)
{
     string nameArray[] = {""spagetti"", ""ChickenSoup"", ""Menudo""};

     int d = random(0, 2); // either 0, 1, or 2, randomly   
     string f =  nameArray[d];
     return f;
} 
</code></pre>

<p>And you'll see even just one function makes it much easier to read; your goal is to make your code easy to read by humans. Also, this is much more concise:</p>

<pre><code>string CreateFood(void)
{
     string nameArray[] = {""spagetti"", ""ChickenSoup"", ""Menudo""};

     return nameArray[random(0, 2)];
} 
</code></pre>

<p>Another bad thing to do is hardcode magic numbers into your program. For example, why 3 or 8? It can be <em>deduced</em> those are array sizes, but that doesn't stand on its own. What you might want is something like:</p>

<pre><code>string CreateFood(void)
{
     const size_t ArraySize = 3; // 3 elements, 0-2
     string nameArray[ArraySize] = {""spagetti"", ""ChickenSoup"", ""Menudo""};
                    // ^ Ensure it matches

     return nameArray[random(0, ArraySize - 1)];
} 
</code></pre>

<p>Now the range for the number number makes sense up front.</p>

<hr>

<p>The rest may be a bit advanced (which you won't understand until you get to templates), but shows how we might go on:</p>

<pre><code>template &lt;typename T, size_t N&gt;
char (&amp;countof_detail(T (&amp;)[N]))[N];

#define countof(pX) sizeof(countof_detail(pX))
</code></pre>

<p>This nifty tool will give you the number of elements in an array. The code might turn into this</p>

<pre><code>string CreateFood(void)
{
     string nameArray[] = {""spagetti"", ""ChickenSoup"", ""Menudo""};
                    // ^ no explicit size

     return nameArray[random(0, countof(nameArray) - 1)];
} 
</code></pre>

<p>We got rid of any numbers altogether, you can just manipulate the array as you please. Lastly, we're repeating ourselves again: getting a random element from an array. We should make a function for that:</p>

<pre><code>template &lt;typename T, size_t N&gt;
T&amp; random_element(T (&amp;pArray)[N])
{
    return pArray[random(0, N - 1)];
}
</code></pre>

<p>This returns a random element from any array. Your function would then simply be:</p>

<pre><code>string CreateFood(void)
{
     string nameArray[] = {""spagetti"", ""ChickenSoup"", ""Menudo""};

     return random_element(nameArray);
} 
</code></pre>

<p>Note in this refactoring (refactoring is taking code and factoring it into new, simpler parts) it reads much better: To get a food, we have an array of foods and we pick one at random.</p>

<p>Keep this kind of stuff in mind while you work, and as you learn C++ you can make better code. Anytime you repeat a task that isn't trivial, make it a function. Suddenly that task is trivial, because you don't care about how the function works (that's in the function), just what the function does (that's the function name).</p>
"
"<p>Recently I am having many problem with typedef and incomplete type when I changed certain containers, allocators in my code.</p>

<p>What I had previously</p>

<pre><code>struct foo;//incomplete type.
typedef std::vector&lt;foo&gt; all_foos;
typedef all_foos::reference foo_ref;
</code></pre>

<p>Though not completely not sure whether the above lines are legal, but this worked on every implementation I used. When I thought that I can do the job with <code>std::tr1::array</code>, changed the above two lines with</p>

<pre><code>typedef std::tr1::array&lt;foo,5&gt; all_foos;
typedef all_foos::reference foo_ref;
</code></pre>

<p>Here everything breaks, as the compiler tries to instantiate <code>array</code> and fails as <code>foo</code> is incomplete type. What all I needed is a reference to <code>foo</code>, and not much interested on 'other parts' of the array. foo will definitely be completely available when I create such an array.</p>

<p>The same is problem when typedef <code>std::allocator&lt;foo&gt;::pointer foo_ptr</code> got replaced by typedef <code>stack_alloc&lt;foo,10&gt;::pointer foo_ptr</code>. where a <code>stack_alloc</code> implementation is like</p>

<pre><code>template&lt;typename T,unsigned N&gt;
struct stack_alloc
{
  typedef T* pointer;
  typedef std::tr1::aligned_storage&lt;sizeof(T)*N, std::tr1::alignment_of&lt;T&gt;::value&gt; buffer;
};
</code></pre>

<p>Presuming that, <code>value_type</code>, <code>pointer</code>, <code>reference</code>, <code>iterator</code> etc does not depend on the completeness of <code>T</code>, and knowing that the class can not be instantiate without complete type, how such typedef can be made in generic way independent of specific container or allocator?  </p>

<p>NOTE: </p>

<ul>
<li>Just for completeness, in 'real' code I use a small local memory with <code>vector</code> rather than replacing it with <code>std::array</code>, though the problem remains same.</li>
<li><code>stack_alloc</code> code is far from complete, and only shows the part of the problem.</li>
<li>I know that array, sizeof etc needs complete type available. But I am NOT creating object of type <code>all_foos</code> with incomplete <code>foo</code>.</li>
<li>My assertion is that pointer,reference etc should not depend on completeness of a type. Otherwise construct like <code>struct foo{ foo_ptr p;};</code> can not be defined. Though probably <code>foo_ref</code> can not be anything other than <code>foo&amp;</code>, but <code>foo_ptr</code> can be. Surprisingly GCC implementation doesn't have nested pointer type for <code>tr1::array</code>.</li>
<li>Know mostly what can not be done, and interested to know what can be done in this situation. So expecting a good design as a solution.</li>
</ul>
","87234","","<p>A type must be complete to be used in a standard container, or the behavior is undefined (§17​.4.3.6/2). So the only standard solution is to not make that <code>typedef</code> until the class is defined.</p>

<p>I don't get what the intermediate container is for:</p>

<pre><code>struct foo;//incomplete type.
typedef foo&amp; foo_ref;
</code></pre>

<p>In any case, you'll just have to have the complete type defined first, really. To get a <code>typedef</code> defined in a class, that class <em>must</em> be instantiated, which means the <em>entire</em> thing must be able to use <code>T</code> as desired.</p>

<p>For example, <code>stack_alloc</code> must have <code>T</code> be a complete type (for <code>sizeof(T)</code> to work), otherwise the class cannot be instantiated. If the class can't be instantiated, you cannot get the <code>typedef</code> out of it. Ergo, you'll <em>never</em> get the <code>typedef</code> out of it if <code>T</code> is incomplete.</p>
"
"<p>I've got a type that can't be moved or copied (by making the necessary constructors and operators private). But when I tried to compile a std::list of them, the operation failed with a very strange error (class name snipped for brevity).</p>

<pre><code>1&gt;C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\xmemory(202)
: error C2248: 'T::T' : cannot access private member declared in class 'T'
</code></pre>

<p>Surely it's not incumbent of a type in a linked list to be movable or copyable.</p>

<p>When these members are made public, the code compiles fine- even though, if the std::list had tried to access them, it would be an unresolved external, since they're only declared private. Makes no sense :(</p>
","87234","","<p>As of C++03, elements must be copy constructible and copy assignable. §23.1/3:</p>

<blockquote>
  <p>The type of objects stored in these components must meet the requirements of CopyConstructible types (20.1.3), and the additional requirements of Assignable types.</p>
</blockquote>

<p>In C++0x, requirements are put on a per-operation basis, but in general it's safe to say elements must be move constructible and move assignable. (Though some operations require copy constructibility and assign-ability, etc.)</p>

<p>A typical solution to your problem is to store pointers to objects, via <code>shared_ptr</code> or some other smart pointer.</p>
"
"<p>If I have two classes ""A"" and ""B"", is it OK to derive B from A and then make B a Singleton?.</p>

<p>Thanks for your help.</p>
","87234","","<p>Um, sure. Nobody is going to stop you.</p>

<p>If it's okay to make ""some class"" a singleton<sup>*</sup>, just imagine B being a new ""some class"". (It just happens to be derived from A.)</p>

<p><sup>*</sup>Though, <a href=""http://jalf.dk/blog/2010/03/singletons-solving-problems-you-didnt-know-you-never-had-since-1995/"" rel=""nofollow"">do you really need a singleton</a>? (No.)</p>
"
"<p>I'm writing a NES emulator in C/C++ for Mac OS (I've already written one, so I know the basics). Since many hardware registers are mapped to memory locations, I was wondering if there was some syscall I could use to map an address to the result of a function: when it would be accessed, the function would be called. (I'm pretty sure I can't, but hey, it's worth asking.)</p>

<p>Here is what I'd like to do:</p>

<pre><code>int getStatusRegisterValue()
{
    return 0xCAFEBABE;
}

// obviously, more parameters than just this would be involved I suppose
int* statusRegister = syscall_to_map_function_to_address(getStatusRegisterValue);

// from here on, doing (*statusRegister) should call getStatusRegisterValue and
// return its value
*statusRegister == 0xCAFEBABE;
</code></pre>

<p>This project is going to be my try at LLVM, and my goal is to recompile the ROM to LLVM bytecode. That's why it would be convenient if the simple memory access could trigger the function (just like on real NES hardware). The two other obvious possibilities to solve my problem are to either cache the register values and store them in actual memory, or call a function from the recompiled code to map the memory locations to whatever they really are.</p>

<p>Thanks!</p>
","87234","","<p>This almost sounds just like normal function pointers:</p>

<pre><code>typedef int(*function_type)(void);

function_type = &amp;getStatusRegisterValue; // store
int i = function_type(); // call
</code></pre>

<p>Different syntax, same idea?</p>
"
"<p>I want to use some functions from a .cpp source file that has a main function in my .cpp source file.  (I'm building with make and gcc.)</p>

<p>Here's the rule from my Makefile:</p>

<pre><code>$(CXX) $(CXXFLAGS) $(INCLUDES) $(SRCS) $(LIBS) -o $@
</code></pre>

<p>And here's the output (with some names changed to prevent distraction):</p>

<pre><code>$ make foo
g++ -g -Wall -m32 -Ilinux/include foo.cpp bar.cpp -o foo
/tmp/ccJvCgT3.o: In function `main':
/home/dspitzer/stuff/bar.cpp:758: multiple definition of `main'
/tmp/ccUBab2r.o:/home/dspitzer/stuff/foo.cpp:68: first defined here
collect2: ld returned 1 exit status
make: *** [foo] Error 1
</code></pre>

<p>How do I indicate to gcc that I want to use the main from foo.cpp?</p>

<p><strong>Update:</strong> I should have added that ""bar.cpp"" is ""someone else's"" code, and has it's own reason for a main.  (It sounds like I should work with that someone else to have him split the shared functions into a separate file.)</p>
","87234","","<p>It's not about which <code>main</code> to use as your ""main"", because you won't even get that far.</p>

<p>You can't have redefinitions of functions, it breaks the One Definition Rule. In the same way you can't do:</p>

<pre><code>void foo(void)
{
    // number one
}

void foo(void)
{
    // number two
}

// two foo's? ill-formed.
</code></pre>

<p>You can't try to compile multiple <code>main</code>'s. You'll need to delete the other ones.</p>
"
"<pre><code>     HANDLE  hThread;
     DWORD   dwThreadId;

         hThread = CreateThread( 
     NULL,                   // default security attributes
     0,                      // use default stack size  
     MyThreadFunction,       // thread function name
     0,                      // argument to thread function 
     0,                      // use default creation flags 
     &amp;dwThreadId);           // returns the thread identifier  &lt;--Debugger takes me to this line?
</code></pre>

<p>The error specifies the 3rd parameter but when i double click on the error it takes me to the last parameter?<br>
Trying to run the msdn CreateThread example <a href=""http://msdn.microsoft.com/en-us/library/ms682453%28VS.85%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/ms682453%28VS.85%29.aspx</a></p>

<pre><code>error C2664: 'CreateThread' : cannot convert parameter 3 from 'void (void)' to 'unsigned long (__stdcall *)(void *)'
        None of the functions with this name in scope match the target type
</code></pre>
","87234","","<p>The debugger is just taking you to the end of the statement.</p>

<p>In any case, your function signature is wrong and needs to match the function pointer type. For <a href=""http://msdn.microsoft.com/en-us/library/ms682453%28VS.85%29.aspx"" rel=""nofollow""><code>CreateThread</code></a>, it should be:</p>

<pre><code>DWORD WINAPI ThreadProc(LPVOID lpParameter);
</code></pre>
"
"<p>I have a pointer (uint8_t *myPointer), that I pass as parameter to a method, and then this method sets a value to this pointer, but I want to know how many bytes are used (pointed at ?) by the myPointer variable.</p>

<p>Thanks in advance.</p>
","87234","","<p>The size of the pointer: <code>sizeof(myPointer)</code> (Equal to <code>sizeof(uint8_t*)</code>)<br>
The size of the pointee: <code>sizeof(*myPointer)</code> (Equal to <code>sizeof(uint8_t)</code>)</p>

<p>If you meant that this points to an array, there is no way to know that. A pointer just points, and cares not where the value is from.</p>

<p>To pass an array via a pointer, you'll need to also pass the size:</p>

<pre><code>void foo(uint8_t* pStart, size_t pCount);

uint8_t arr[10] = { /* ... */ };
foo(arr, 10);
</code></pre>

<p>You can use a template to make passing an entire array easier:</p>

<pre><code>template &lt;size_t N&gt;
void foo(uint8_t (&amp;pArray)[N])
{
    foo(pArray, N); // call other foo, fill in size.
    // could also just write your function in there, using N as the size
}

uint8_t arr[10] = { /* ... */ };
foo(arr); // N is deduced
</code></pre>
"
"<p>This is a basic question about what options are available for defining the scope of some parameters. I'd particularly like to have a sense of the tradeoffs in speed, memory, code clarity, ease of implementation, and code safety. My programming experience is clearly modest, and I have little formal training. I suspect one or two options will be obvious 'right' answers.</p>

<p>I have a simulation encapsulated in its own class called <code>Simulation</code>. Some of the parameters used in the simulation are read in from a set of files when the Simulation is initialized, and these parameters are currently stored in a few two-dimensional arrays. These arrays, <code>demPMFs</code> and <code>serotypePars</code>, are currently both private members of <code>Simulation</code>:</p>

<pre><code>// Simulation.h

class Simulation
{
 Simulation( int simID );
 ~Simulation();

 public:
  // ...[code snipped]...

 private:
  double demPMFs[ NUM_SOCIODEM_FILES ][ INIT_NUM_AGE_CATS ];
  double serotypePars[ NUM_EPID_FILES ][ INIT_NUM_STYPES ];
  // ...[code snipped]...
};
</code></pre>

<p>The simulations mostly involve modifying instances of class <code>Host</code>. Member functions of class <code>Host</code> frequently need access to parameter values stored in <code>serotypePars</code>. Previously, I had all the data now in <code>serotypePars</code> stored as <code>const</code> numerics interpreted at compile time, but now that these parameters are read from a file, things are a little more complicated (for me, anyway).</p>

<p><strong>What is the fastest and safest way for me to grant all members of class <code>Host</code> 'read-only' access to <code>serotypePars</code>?</strong> Fastest deserves priority: There are no other classes in my program, so <code>global</code> is a (crude) potential solution; all simulations will run from identical parameter sets. I'm reluctant to pass the array to individual functions that act on <code>Host</code> members, since there are probably a dozen and some are quite nested. (For example, I have intermediate wrapper structs that cannot take two-dimensional arrays as arguments, and I'm unsure what syntactical work-arounds there might be. I would like to stick with arrays for speed purposes, and my non-uniform prng generators all expect arrays.) </p>

<p>I would greatly appreciate knowing what would require the least modification of the existing code while not introducing huge dangers. </p>

<p>Thanks for any insight you can offer.</p>

<hr>

<p>A related challenge I have is not knowing exactly how to access Simulation members from the Host class, unless these members are passed to the Host function. Here's basically what happens:</p>

<pre><code>// main.cpp

int main() {
  for ( int s = 1; s &lt; NUM_SIMS+1; s++ ) {
   Simulation thisSim(s);
   thisSim.runDemSim();
   thisSim.runEpidSim();
   // ... code snipped ...
 }
}
</code></pre>

<p>Function <code>Simulation::runDemSim()</code> and <code>Simulation::runEpidSim()</code> create, modify, and destroy many instances of class <code>Host</code>. Pointers to these instances are stored in a Boost MultiIndex container, which is where the intermediate wrapper functions come in. One of the many modifications involves ultimately calling <code>Host::calcRecovery</code>, which needs access to <code>serotypePars</code>:</p>

<pre><code>// Host.cpp

// ... code snipped ...

double Host::calcRecovery( int s, double currentTime, double infectionTime, boost::mt19937&amp; rng ) {
  // ...code snipped...
  effectiveMean = serotypePars[ MEAN_DURATION_INDEX ][ s ] * currentInfections * pastInfections;
  double rt = rgamma( effectiveMean, serotypePars[ VAR_DURATION_INDEX ][ s ], rng );
}
</code></pre>

<p>(Apologies if TMI.) Simply declaring <code>serotypePars</code> public in the <code>Simulation</code> class definition resulted in a ""serotypePars was not declared in this scope"" error in Host.cpp.</p>

<hr>

<p><strong>Solution summary</strong></p>

<p>GMan's suggestion that I package all the simulation parameters in a private class, e.g., <code>SimulationPars</code>, seems like the most elegant and extensible route. An instance of <code>SimulationPars</code> could belong in every <code>Simulation</code>, and a pointer to <code>SimulationPars</code> can be passed to the constructor of every <code>Host</code> within a given <code>Simulation</code>. Thanks to everyone for the thoughtful discussions.</p>
","87234","","<p>This is normal:</p>

<pre><code>class Simulation
{ 
public:
    // typedef's should be used liberally, it's easier to read
    typedef double pmf_type[NUM_SOCIODEM_FILES][INIT_NUM_AGE_CATS];
    typedef double sero_type[NUM_EPID_FILES][INIT_NUM_STYPES];

    // accessors
    const pmf_type&amp; get_pmf(void) const
    {
        return demPMFs;
    }

    const sero_type&amp; get_sero(void) const
    {
        return serotypePars;
    }

private:
    pmf_type demPMFs;
    sero_type serotypePars;
};
</code></pre>
"
"<p>I would like to make an std::list of arrays. specifically, I want a list of arrays of Borland Code Builders AnsiStrings. </p>

<p>the real kicker being that I would like the arrays to be allocated dynamically. How do I define the list? Im so lost here i dont know were to begin. </p>

<pre><code>std::list&lt;???&gt; myList;
</code></pre>

<p>What am I putting inside the angle brackets? nothing i have tried will work. </p>
","87234","","<pre><code>typedef std::vector&lt;char&gt; char_array;
typedef std::list&lt;char_array&gt; char_array_list;
</code></pre>

<p>Or more appropriately:</p>

<pre><code>typedef std::list&lt;std::string&gt; string_list;
</code></pre>
"
"<p>I need some answers to basic questions. I'm lost again. :(</p>

<p>q1 - Is this statement valid:<br>
<code>Whenever we define the function to be pure virtual function, 
this means that function has no body.</code>    </p>

<p>q2 - And what is the concept of Dynamic Binding? I mean if the Compiler optimizes the code using VTABLEs and VPTRs then how is it Run-Time Polymorphism? </p>

<p>q3 - What are VTABLES AND VPTRs and how do their sizes change?</p>

<p>q4 - Please see this code:</p>

<pre><code>class base
{
    public:
        virtual void display()
        {
            cout&lt;&lt;""Displaying from base"";
        }
};

class derived:public base
{
    public:
        void display(){cout&lt;&lt;""\nDisplaying from derived"";}
};

int main()
{
    base b,*bptr;
    derived d;
    bptr=&amp;b;
    bptr-&gt;display();
    bptr=&amp;d;
    bptr-&gt;display();
} 
</code></pre>

<p>Output:</p>

<pre><code>Displaying from base
Displaying from derieved
</code></pre>

<p>Please can somebody answer why a pointer of base class can point the member function of a derived class and the vice-versa is not possible, why ?</p>
","87234","","<ol>
<li><p>False. It just means any derived classes must implement said function. You can still provide a definition for the function, and it can be called by <code>Base::Function()</code>.*</p></li>
<li><p>Virtual tables are a way of implementing virtual functions. (The standard doesn't mandate this is the method, though.) When making a polymorphic call, the compiler will look up the function in the function table and call that one, enabling run-time binding. (The table is generated at compile time.)</p></li>
<li><p>See above. Their sizes change as there are more virtual functions. However, instances don't store a table but rather a pointer to the table, so class size only has a single size increase. </p></li>
<li><p><a href=""http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">Sounds like you need a book.</a></p></li>
</ol>

<p><sub>
*A classic example of this is here:</p>

<pre><code>struct IBase
{
    virtual ~IBase(void) = 0;
};

inline IBase::~IBase(void) {}
</code></pre>

<p>This wouldn't be an abstract class without a pure virtual function, but a destructor requires a definition (since it will be called when derived classes destruct.)</p>

<p></sub></p>
"
"<p>I need some help in writing a macro for 'if-condition' which compiles only when a DEBUG flag is defined by the #define directive.</p>

<p>Here is an example which illustrates what I want. first piece of code shows the usual way of writing an if condition with a #ifdef.</p>

<pre><code>#ifdef DEBUG
if( rv == false )
{
     string errorStr = ""error in return value"" ;
     cout &lt;&lt; errorStr &lt;&lt; endl ;
     throw( Exception(errorStr) ) ;
}
</code></pre>

<p>I want to write it in a way similar as below:</p>

<pre><code>DEBUG_IF( rv==false )
{
     same code as above
}
</code></pre>

<p>It seems to be simple but I am having trouble defining a macro which can do this. If someone has experienced this before, kindly help.</p>

<p>Thanks.</p>
","87234","","<p>Do you want the <code>if</code> to be conditional, so that in Release the code runs unconditionally? (As the title suggests.) Or do you want the entire block to be conditional? (So it Release there is no block.) You're missing the #endif in your equivalence code so it's impossible to tell.</p>

<p>For the former, you could use this:</p>

<pre><code>#ifdef DEBUG
    #define DEBUG_IF(x) if (x)
#else
    #define DEBUG_IF(x) if (false)
#endif
</code></pre>

<p>The code in the block will be compiled, but discarded by the compiler, as it's dead code. If you only want the conditional to be changed, do this:</p>

<pre><code>#ifdef DEBUG
    #define DEBUG_IF(x) if (x)
#else
    #define DEBUG_IF(x)
#endif
</code></pre>

<p>Without <code>DEBUG</code>, the entire conditional ceases to exist. Fix your question to make it clear what you want.</p>
"
"<p>Both <code>free(NULL)</code> and <code>::operator delete(NULL)</code> are allowed.  Does the allocator concept (e.g. std::allocator also allow <code>deallocate(NULL,1)</code>, or is it required to put your own guard around it?</p>
","87234","","<p>You'll need to add your own check.</p>

<p>According to §20.4.​1.1/8, <code>deallocate</code> requires:</p>

<blockquote>
  <p>p shall be a pointer value obtained from allocate(). n shall equal the value passed as the
  first argument to the invocation of allocate which returned p.</p>
</blockquote>

<p><code>allocate</code> throws an exception when storage can't be given (§20.4.​1.1/7). In other words, <code>allocate</code> never returns 0, and therefore <code>deallocate</code> should never get a 0. Passing a 0 would lead to undefined behavior.</p>
"
"<p>It is known how to catch the float division-by-zero exception with the usage of</p>

<pre><code>signal(SIGFPE, handler)
</code></pre>

<p>but it doesn't catch integer division-by-zero problem even if I setup control word with</p>

<pre><code>_control87(0, _MCW_EM ); (MS VC 2010)
</code></pre>

<p>SubQuestion_1: How to catch integer division-by-zero in C program in Windows without usage of SEH EXCEPTION_INT_DIVIDE_BY_ZERO? (In Unix/Linux this can be done with usage of the standard signal/SIGFPE techinque)</p>

<p>EDIT: 
signal is ANSI C signal handling approach. <br/>
_control87 is the standard Windows function to set float control word.</p>

<p>Similar question: <a href=""http://stackoverflow.com/questions/2155442/how-to-handle-all-errors-including-internal-c-library-errors-uniformly"">http://stackoverflow.com/questions/2155442/how-to-handle-all-errors-including-internal-c-library-errors-uniformly</a></p>

<p>NOTE (from ISO/IEC 9899:TC2 Annex H.2.2):</p>

<p>""The signed C integer types int, long int, long long int, and the corresponding
unsigned types are compatible with LIA−1. ... C’s unsigned integer types are ‘‘modulo’’ in the LIA−1 sense in that overflows or out-of-bounds results silently wrap. An implementation that defines signed integer types as also being modulo need not detect integer overflow, in which case, <em>only integer divide-by-zero need be detected.</em>""</p>

<p>?FINAL SOLUTION:</p>

<p>For Windows: it throws SEH exception. So it can be caught by usage of __try __except.
 As possible solution SEH translation could be used to handle SEH exception and translate them to call of needed function. It is not a ""natural"" way, but it seems that it's the only way.</p>

<p>For Unix: it could be caught with signal/SIGFPE solution. Or check wiki for FPE_INTDIV solution ( <a href=""http://rosettacode.org/wiki/Detect_division_by_zero#C"" rel=""nofollow"">http://rosettacode.org/wiki/Detect_division_by_zero#C</a> ).</p>

<p>As GMan was right about ""undefined behaviour"" I'm choosing his answer as correct.</p>

<p>Note: It is interesting to check VC\crt\src\winxfltr.c: _XcptActTab array : )</p>
","87234","","<p>Division by zero leads to undefined behavior, there is no C language construct that can do anything about it. Your best bet is to not divide by zero in the first place, by checking the denominator.</p>

<p>If you want to ""catch"" (note, C has no exceptions) this error, it will be dependent on your compiler and OS, which you haven't listed. By the way, <code>_control87</code> has only to do with floating-point operations, and nothing to do with integer operations.</p>
"
"<pre><code>class A { 
 public:
  A() { } 
  ~A() { cout &lt;&lt; ""A Destructor \n"" ; } 
};

class B :public A{ 
   public:
   B() { } 
   virtual ~B() { cout &lt;&lt; ""B Destructor \n"" ; } 
};

class C : public B {
   public:
   C() { }
   ~C() { cout &lt;&lt; ""C Destructor \n""; }
};

int main()
{

   A *pointA = new A;
   A *pointB = new B;
   A *pointC = new C;

   delete pointA;
   delete pointB;
   delete pointC;
}
</code></pre>
","87234","","<p>It will invoke undefined behavior at the second (and third) delete, because A's destructor is not virtual. </p>

<p>§5.3.5/3:</p>

<blockquote>
  <p>if the static type of the operand is different from its dynamic type, the
  static type shall be a base class of the operand’s dynamic type and the static type shall have a virtual destructor or the behavior is undefined.</p>
</blockquote>

<hr>

<p>If you make the destructor of A virtual, you get well-defined behavior, and the destructor of the dynamic type is called. (And each of those in turn calls the base destructor.) Your output would be:</p>

<blockquote>
  <p>A destructor<br>
  B destructor<br>
  A destructor<br>
  C destructor<br>
  B destructor<br>
  A destructor  </p>
</blockquote>

<hr>

<p>For what it's worth, when you're that close to a compilable snippet, you should leave the includes. Also, just use <code>struct</code> instead of <code>class</code> to be concise about the <code>public</code> stuff, and leave out empty constructors.</p>
"
"<p>How can i decide or understand whether any statement or expression has left to right or right to left associativity?</p>
","87234","","<p>You may find a nice table <a href=""http://www.difranco.net/compsci/C_Operator_Precedence_Table.htm"" rel=""nofollow"">here</a>.</p>
"
"<p>What's wrong with this:</p>

<pre><code>wchar_t * t = new wchar_t;

t = ""Tony"";
</code></pre>

<p>I thought I could use a wchar_t pointer as a string...</p>
","87234","","<p>A pointer just points to a single value. This is important.</p>

<p>All you've done is allocated room for a single <code>wchar_t</code>, and point at it. Then you try to set the pointer to point at a string (remember, just at the first character), but the string type is incorrect.</p>

<p>What you have is a string of <code>char</code>, it ""should"" be <code>L""Tony""</code>. But all you're doing here is leaking your previous memory allocation because the pointer holds a new value.</p>

<p>Rather you want to allocate enough room to hold the entire string, then <em>copy</em> the string into that allocated memory. This is terrible practice, though; never do anything that makes you need to explicitly free memory.</p>

<p>Just use <code>std::wstring</code> and move on. <code>std::wstring t = L""Tony"";</code>. It handles all the details, and you don't need to worry about cleaning anything up.</p>
"
"<p>I need to generate a container of filenames within a directory in C++ and it must be cross platform compatible. Someone recommended using the <code>WIN32_FIND_DATA</code> data structure. Is this the best option and if so how would I implement it?</p>

<p>The user will not enter the filenames, but rather the C++ function will automatically search the directory and create a container of filenames. I don't know how to read in filenames like this either. </p>

<p>I have a strong focus on standards too, so <code>&lt;dirent.h&gt;</code> is not an ideal solution because it is not ISO C standard even though its a header in the C POSIX library. </p>
","87234","","<p>I would use <a href=""http://www.boost.org/doc/libs/1_43_0/libs/filesystem/doc/index.htm"" rel=""nofollow"">Boost.FileSystem</a>. Untested:</p>

<pre><code>#include ""boost/filesystem.hpp""
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

namespace bf = boost::filesystem;
typedef std::vector&lt;bf::path&gt; path_container;

path_container enumerate_files(const bf::path&amp; pDirectory)
{
    path_container result;

    if (!bf::exists(pDirectory))
        return result;

    bf::directory_iterator iter(pDirectory);
    bf::directory_iterator last;

    for (; iter != last; ++iter)
        if (bf::is_regular_file(iter-&gt;status()))
            result.push_back(iter-&gt;path());

    return result;
}

int main(void)
{
    path_container c = enumerate_files(""./"");

    std::copy(c.begin(), c.end(),
        std::ostream_iterator&lt;bf::path&gt;(std::cout, ""\n""));
}
</code></pre>
"
"<p>As a C++ programmer I sometimes need deal with memory buffers using techniques from C. For example:</p>

<pre><code>char buffer[512];
sprintf(buffer, ""Hello %s!"", userName.c_str());
</code></pre>

<p>Or in Windows:</p>

<pre><code>TCHAR buffer[MAX_PATH+1]; // edit: +1 added
::GetCurrentDirectory(sizeof(buffer)/sizeof(TCHAR), &amp;buffer[0]);
</code></pre>

<p>The above sample is how I usually create local buffers (a local stack-allocated char array). However, there are many possible variations and so I'm very interested in your answers to the following questions:</p>

<ul>
<li>Is passing the buffer as <code>&amp;buffer[0]</code> better programming style than passing <code>buffer</code>? (I prefer <code>&amp;buffer[0]</code>.)</li>
<li>Is there a maximum size that is considered safe for stack allocated buffers?
<ul>
<li><i>Update:</i> I mean, for example, the highest value that can be considered safe for cross-platform desktop applications on Mac, Windows, Linux desktops (not mobile!).</li>
</ul></li>
<li>Is a static buffer (<code>static char buffer[N];</code>) faster? Are there any other arguments for or against it?</li>
<li>When using static buffers you can use return type <code>const char *</code>. Is this (generally) a good or a bad idea? (I do realize that the caller will need to make his own copy to avoid that the next call would change the previous return value.)</li>
<li>What about using <code>static char * buffer = new char[N];</code> , never deleting the buffer and reusing it on each call.</li>
<li>I understand that heap allocation should be used when (1) dealing with large buffers or (2) maximum buffer size is unknown at compile time. Are there any other factors that play in the stack/heap allocation decision?</li>
<li>Should you prefer the <code>sprintf_s</code>, <code>memcpy_s</code>, ... variants? (Visual Studio has been trying to convince me of this for a long time, but I want a second opinion :p )</li>
</ul>
","87234","","<ul>
<li>It's up to you, just doing <code>buffer</code> is more terse but if it were a <code>vector</code>, you'd need to do <code>&amp;buffer[0]</code> anyway.</li>
<li>Depends on your intended platform.</li>
<li>Does it matter? Have you determined it to be a problem? Write the code that's easiest to read and maintain before you go off worrying if you can obfuscate it into something faster. But for what it's worth, allocation on the stack is very fast (you just change the stack pointer value.)</li>
<li>You should be using <code>std::string</code>. If performance becomes a problem, you'd be able to reduce dynamic allocations by just returning the internal buffer. But the <code>std::string</code> return interface is way nicer and safer, and performance is your last concern.</li>
<li>That's a memory leak. Many will argue that's okay, since the OS free's it anyway, but I feel it terrible practice to just leak things. Use a static <code>std::vector</code>, you should <em>never</em> be doing any raw allocation! If you're putting yourself into a position where you might leak (because it needs to be done explicitly), you're doing it wrong.</li>
<li>I think your (1) and (2) just about cover it. Dynamic allocation is almost always slower than stack allocation, but you should be more concerned about which makes sense in your situation.</li>
<li>You shouldn't be using those at all. Use <code>std::string</code>, <code>std::stringstream</code>, <code>std::copy</code>, etc.</li>
</ul>
"
"<p>In the course of asking about catching 'divide by 0' exception, I found that with C++, we can't do that. I mean, divide by 0 doesn't throw an std::exception. </p>

<p>Some of the hints that I found were I have to check the value, and throw the exception by self.</p>

<p>I say it's confusing, as I've thought that C++ adopted the exception idea in order to replace the 'good old C/UNIX report error by returning value method'.</p>

<p>Here are my questions</p>

<ul>
<li>Q1 : Why C++ doesn't throw std::exception error for divide by 0? Is there any reason behind that?</li>
<li>Q2 : Normally, what error processing scheme the C++ users use? Always throw an error, and the exception is the divide by 0 error?</li>
<li>Q3 : In general, OOP languages prefer (or even enforce) using exception. Is this correct?</li>
</ul>
","87234","","<p>C++ assumes you know what you're doing, doesn't pay for things you don't ask for, and makes no assumptions about the platforms it's intended for.</p>

<p>If you want to divide numbers, it would be quite inefficient to mandate the compiler check the denominator and throw before dividing. (We didn't ask it to do that.) So that option is out; we can't have this check on every division, and it's especially wasteful since most divisions are not by zero.</p>

<p>So, how can we just divide by zero and find out if it worked? Because C++ cannot assume anything about it's platform, it cannot assume there is a way to check the result, hardware-wise. That is to say, while many CPU's will jump to an interrupt of some sort when division by zero occurs, the C++ language cannot guarantee such a thing.</p>

<p>The only option then is to let the behavior be undefined. And that's exactly what you get: undefined behavior.</p>

<hr>

<p>OOP languages might do something or another, it doesn't matter since OOP isn't well-defined and C++ isn't an OOP language anyway. In general, use the tool that's most appropriate. (Exceptions are for exceptional situations.)</p>
"
"<p>One is to use C++ exceptions: try catch blocks. But freeing dynamic memory will be an issue when an exception is raised.</p>

<p>Second is to use C style: errno variable</p>

<p>Third is just to return -1 on error and 0 on success :)</p>

<p>Which way should be chosen for a mid-size project and why? Any other better approach..?</p>
","87234","","<blockquote>
  <p>But freeing dynamic memory will be an issue when an exception is raised.</p>
</blockquote>

<p>No it's not. <code>std::vector&lt;int&gt; v(100);</code> Done.</p>

<p>The concept here is called Scope-Bound Resource Management (SBRM), also known by the much more common (and awkward) name Resource Acquisition Is Initialization (RAII). Basically, all resources are contained in some object which will clean up the resource in the destructor (which is always guaranteed to be run for an automatically allocated object). So whether or not the function exists normally or via exception, the destructor is run and your resource is cleaned up.</p>

<p>Never do an allocation where you need to free it explicitly, use containers and smart pointers.</p>
"
"<p>i m decreasing the resolution of a bitmap. i found a method on a site which is as follows</p>

<p>Average the values of all surrounding pixels, store that value in the choosen pixel location, then delete all the surrounding pixels.so a 4*6 matrix becomes a 4 x 3 matrix.</p>

<p>i am accessing pixels by this code</p>

<pre><code>for(int y = 0; y &lt; bmp.bmHeight; y++)   
  {      
      for(int x = 0; x &lt; bmp.bmWidth; x++)     
      {         
          COLORREF rgb = dc.GetPixel(x, y);     
          BYTE r = GetRValue(rgb);       
          BYTE g = GetGValue(rgb);     
          BYTE b = GetBValue(rgb);            
          dc.SetPixel(x, y, RGB(r,g,b));      
      }   
  } 
</code></pre>

<p>tell me how can i delete a pixel?   </p>
","87234","","<p>You can't really delete a pixel, a bitmap is a matrix of pixels. Rather, you should make a new bitmap of the intended size, and copy pixels into that.</p>
"
"<p>Example routine:</p>

<pre><code>const Armature* SceneFile::findArmature(const Str&amp; name){
    for (int i = 0; i &lt; (int)armatures.size(); i++)
        if (name == armatures[i].name)
            return &amp;armatures[i];
    return 0;
}
</code></pre>

<p>Routine's purpose is (obviously) to find a value within an array of elements, based on element's member variable, where comparing member variable with external ""key"" is search criteria.</p>

<p>One way to do it is to iterate through array in loop. Another is to use some kind of ""map"" class (std::map, some kind of vector sorted values + binarySearch, etc, etc). It is also possible to make a class for std::find or for std::for_each and use it to ""wrap"" the iteration loop.</p>

<p>What are other ways to do that?</p>

<p>I'm looking for alternative ways/techniques to extract the required element. 
Ideally - I'm looking for a language construct, or a template ""combo"", or a programming pattern I don't know of that would collapse entire loop or entire function into one statement. Preferably using standard C++/STL features (no C++0x, until it becomes a new standard) AND without having to write additional helper classes (i.e. if helper classes exist, they should be generated from existing templates). </p>

<p>I.e. something like std::find where comparison is based on class member variable, and a variable is extracted using standard template function, or if variable (the one compared against ""key""(""name"")) in example can be selected as parameter.</p>

<p>The purpose of the question is to discover/find language feature/programming technique I don't know yet. I suspect that there <em>may</em> be an applicable construct/tempalte/function/technique similar to for_each, and knowing this technique may be useful. Which is the main reason for asking.</p>

<p>Ideas?</p>
","87234","","<p>Why 5 lines? Clean doesn't have a number attached to it. In fact, clean code might take more lines in the utility classes, which can then be reused over and over. Don't restrict yourself unnecessarily.</p>

<pre><code>class by_name
{
public:
    by_name(const std::string&amp; pName) :
    mName(pName)
    {}

    template &lt;typename T&gt;
    bool operator()(const T&amp; pX)
    {
        return pX.name == pName;
    }

private:
    std::string mName;
};
</code></pre>

<p>Then:</p>

<pre><code>const Armature* SceneFile::findArmature(const char* name)
{
    // whatever the iterator type name is
    auto iter = std::find_if(armatures.begin(), armatures.end(), by_name(name));
    return iter == armatures.end() ? 0 : &amp;(*iter);
}
</code></pre>

<hr>

<p>Within restriction:</p>

<pre><code>class by_name { public: by_name(const std::string&amp; pName) : mName(pName) {} template &lt;typename T&gt; bool operator()(const T&amp; pX) { return pX.name == pName; } private: std::string mName; };
</code></pre>

<p>Then:</p>

<pre><code>const Armature* SceneFile::findArmature(const char* name)
{
    // whatever the iterator type name is
    auto iter = std::find_if(armatures.begin(), armatures.end(), by_name(name));
    return iter == armatures.end() ? 0 : &amp;(*iter);
}
</code></pre>

<p>:)</p>

<hr>

<p>C++0x has ranged-based for-loops, which I think would make the most elegant solution:</p>

<pre><code>const Armature* SceneFile::findArmature(const std::string&amp; pName) const
{
    for (auto a : armatures)
    {
        if (a.name = pName) return &amp;a;
    }

    return 0;
}
</code></pre>
"
"<p>If you see this code,</p>

<pre><code>class A{
public:
    A(int a):var(a){}
    int var;
};

int f(A obj) {
    return obj.var;
}

int main() {
    //std::cout&lt;&lt;f(23);    // output: 23
    std::cout&lt;&lt;f(23, 23);  // error: too many arguments to function 'int f(A)'
    return 0;
}
</code></pre>

<p><code>f(23, 23)</code> does not compile because the comma acts as a separator here and not as a comma operator.</p>

<p>Where all does a comma <strong>not</strong> work as a comma operator? Or the other way around?</p>
","87234","","<p>This has to do with the language definition of expressions, which is quite complex.</p>

<p><code>f(1, 2)</code> is a function call expression with two parameters. Contrarily, <code>f((1, 2))</code> is a function call expression with one parameter, which is the sub-expression <code>1, 2</code>, which will evaluate to 2.</p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/1847789/segmentation-fault-on-large-array-sizes"">Segmentation fault on large array sizes</a>  </p>
</blockquote>



<p>Hi all</p>

<p>I am trying to create a very big array in the VS 2010 using C++.</p>

<p>When I try to create a array like below</p>

<pre><code>int dp[4501][4501]
or
int dp[1000][1000]
</code></pre>

<p>It threw an exception ""Stack Overflow""
Then I change it to:</p>

<pre><code>int dp[100][100]
</code></pre>

<p>everything is fine.</p>

<p>So if I want to create a big array like above, what should I do?</p>

<p>Best Regards,</p>
","87234","","<p>You should use dynamic allocation:</p>

<pre><code>typedef std::vector&lt;int&gt; int_vector;
int_vector dp(10000);
</code></pre>

<p>A double array can be simulated by nesting arrays:</p>

<pre><code>typedef std::vector&lt;int_vector&gt; int_double_vector;
int_double_vector dp(4501, int_vector(4501));
</code></pre>
"
"<p>how can i add ""for each"" support for my class in c++0x and visual studio 2010?</p>
","87234","","<p>I think the best way would be to add iterator support, with <code>begin()</code> and <code>end()</code> functions. The ranged-based for-loop uses them, and this also gives your class the richer set of functionality iterators provide.</p>
"
"<p>How can I pass a multidimensional array to a function in C/C++ ?</p>

<p>The dimensions of array are not known at compile time </p>
","87234","","<p>You could pass a pointer and sizes, or use a <code>std::vector</code>. But the ""real"" solution is with a template:</p>

<pre><code>template &lt;size_t N, size_t M&gt;
void foo(int (&amp;pArray)[N][M]);
</code></pre>

<p>This function template accepts a N by M array of ints, by reference. Note this is a function template, not a function, so you do get a different instantiated function per array type. </p>
"
"<p>The exact error I'm getting is:</p>

<p>Cannot dynamic_cast 'object' (of type 'void*') to type 'class udDator(int)*' 
(source is not a pointer to a class)</p>

<p>This is happening inside an overridden operator delete. I'm attempting to create a templated memory management class that can inherit into any other class, managing memory through references. This would be in place of something like a smart shared_ptr, in an attempt to make memory management even more invisible, and without extra typing ( shared_ptr&lt; someClass > shared( new someClass() ) is kinda long... ).</p>

<p>Anyway, here is the relevant code. If I have forgotten to mention any details, or do not have some code that you need to see, just let me know.</p>

<p>Overridden operator:</p>

<pre><code>template&lt; class T &gt;
class udSharedMemory
{
public:
    void operator delete( void *object )
    {         
        T *temp = dynamic_cast&lt; T* &gt;( object ); //&lt;------ ERROR!
        assert( temp &amp;&amp; ""Something went wrong during casting"" );
        temp-&gt;release();
    }
}
</code></pre>

<p>Templated class:</p>

<pre><code>template&lt; class T &gt;
class udDator : public udMemoryManaged, public udSharedMemory&lt; udDator&lt; T &gt; &gt;
{
// stuff
};
</code></pre>

<p>Usage of the templated class:</p>

<pre><code>udDator&lt; int &gt; *test = new udDator&lt; int &gt;( ""5"" );
</code></pre>
","87234","","<p>Dynamic cast requires polymorphic behavior, which <code>void</code> does not have. Use a <code>static_cast</code> instead.</p>
"
"<p>I have a class here that is defined like this:</p>

<pre><code>struct USERFPOINT
{
    POINTFLOAT UserPoint;
    POINTFLOAT LeftHandle;
    POINTFLOAT RightHandle;
    bool isBezier;
};

struct SHAPEOUTLINE {
    GLuint OutlineVBO;
    int OutlineSize;
    int OutlineWidth;
    ARGBCOLORF OutlineColor;
};

struct SHAPECONTOUR{

    std::vector&lt;USERFPOINT&gt; UserPoints;
    std::vector&lt;std::vector&lt;GLdouble&gt;&gt; DrawingPoints;
    SHAPEOUTLINE Outline;

};
struct SHAPEGRADIENT{
    GLuint TextureId;
    bool IsParent;
    bool active;
    int type;
    std::vector&lt;ARGBCOLORF&gt; colors;
};

struct SHAPEDIMENSIONS {
    POINTFLOAT Dimensions;
    POINTFLOAT minima;
    POINTFLOAT maxima;
};

class OGLSHAPE
{
private:
    int WindingRule;
    GLuint TextureCoordsVBOInt;
    GLuint ObjectVBOInt;
    UINT ObjectVBOCount;
    UINT TextureCoordsVBOCount;
    SHAPEGRADIENT Gradient;
    SHAPEDIMENSIONS Dimensions;
    void SetCubicBezier(USERFPOINT &amp;a,USERFPOINT &amp;b, int &amp;currentcontour);

    void GenerateLinePoly(const std::vector&lt;std::vector&lt;GLdouble&gt; &gt; &amp;input, int width);
public:
    std::string Name;
    ARGBCOLORF MainShapeColor;
    std::vector&lt;SHAPECONTOUR&gt; Contour;
    OGLSHAPE(void);

    void UpdateShape();
    void SetMainColor(float r, float g, float b, float a);
    void SetOutlineColor( float r, float g, float b, float a,int contour );
    void SetWindingRule(int rule);
    void Render();
    void Init();
    void DeInit();
    ~OGLSHAPE(void);
};
</code></pre>

<p>Here is what I did as a test. I created a global <code>std::vector&lt;OGLSHAPE&gt;</code> test .</p>

<p>In the function I was using, I created</p>

<p>OGLSHAPE t.</p>

<p>I then pushed 50,000 copies of t into test.</p>

<p>I then instantly cleared test and used the swap trick to really deallocate it.</p>

<p>I noticed that all the memory was properly freed as I would expect.</p>

<p>I then did the same thing but before pushing t into test, I pushed a SHAPECONTOUR (which I had just created without modifying or adding anything into the contour) before pushing t into test. </p>

<p>This time after clearing test, 3 more megabytes had been allocated. I did it again allocating twice as many and now 6MB we remaining. The memory usage of the program peaked at 150MB and it went down to 12MB, but it should be at 8.5MB. Therefore, this must be classified as a memory leak, although I do not see how. There is nothing that I see that could do that. SHAPECONTOUR is merely a structure of vectors with a nested structure of vectors.</p>

<p>Why would this cause a leak, and how could I fix it?</p>

<p>Thanks</p>
","87234","","<p>If you've deleted everything, there is no leak, by definition. I don't see any unwrapped pointers, ergo everything gets deleted. Therefore, you have no leaks.</p>

<p>Likely, the OS has simply decided to leave that memory available to your program, for whatever reason. (It hasn't ""reclaimed"" it.) Or maybe it needs to allocate in groups of4MB, and so going from 12MB to 8MB wouldn't leave enough required memory. Or...</p>

<p>You're cutting out other reasons entirely; you should use a real memory leak tool to find memory leaks.</p>
"
"<p>Please look at the following code:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

class A {
  public:
    A() {};    
    virtual void foo(double d) { cout &lt;&lt; d &lt;&lt; endl; }
    virtual void foo(double d, int a) = 0;
  };

class B : public A {
  public: 
    B() {};
    virtual void foo(double d, int a) { cout &lt;&lt; d &lt;&lt; endl &lt;&lt; a &lt;&lt; endl; }  
  };

int main()
  {
  B b;
  b.foo(3.14);
  return 0;
  }
</code></pre>

<p>The compiler (tried g++ and visual c++ 2008) says that there's no function like  B:foo(double). The exact message of g++ is:</p>

<blockquote>
  <p>main.cpp:21: error: no matching function for call to ‘B::foo(double)’</p>
</blockquote>

<p>It looks like the effect of <a href=""http://www.parashift.com/c++-faq-lite/strange-inheritance.html#faq-23.9"" rel=""nofollow"">hiding rule</a>, but in my opinion the rule should not be used here, since I'm not overriding foo(double) and both foo methods are defined in base class. </p>

<p>I know that I can fix the problem with </p>

<pre><code>using A::foo;
</code></pre>

<p>declaration in the derived class B. </p>

<p>Can you explain why the code does not compile and what rules of C++ apply here? </p>
","87234","","<p>Names shadow, not specific functions. Once you make a <code>foo</code> in <code>B</code>, all base <code>foo</code>'s (note, by name!) are shadowed. </p>
"
"<p>Let's say I am writing an API, and one of my functions take a parameter that represents a channel, and will only ever be between the values 0 and 15.  I could write it like this:</p>

<pre><code>void Func(unsigned char channel)
{
    if(channel &lt; 0 || channel &gt; 15)
    { // throw some exception }
    // do something
}
</code></pre>

<p>Or do I take advantage of C++ being a strongly typed language, and make myself a type:</p>

<pre><code>class CChannel
{
public:
    CChannel(unsigned char value) : m_Value(value)
    {
        if(channel &lt; 0 || channel &gt; 15)
        { // throw some exception }
    }
    operator unsigned char() { return m_Value; }
private:
    unsigned char m_Value;
}
</code></pre>

<p>My function now becomes this:</p>

<pre><code>void Func(const CChannel &amp;channel)
{
    // No input checking required
    // do something
}
</code></pre>

<p>But is this total overkill?  I like the self-documentation and the guarantee it is what it says it is, but is it worth paying the construction and destruction of such an object, let alone all the additional typing?  Please let me know your comments and alternatives.</p>
","87234","","<p>If you wanted this simpler approach generalize it so you can get more use out of it, instead of tailor it to a specific thing. Then the question is not ""should I make a entire new class for this specific thing?"" but ""should I use my utilities?""; the latter is always yes. And utilities are always helpful.</p>

<p>So make something like:</p>

<pre><code>template &lt;typename T&gt;
void check_range(const T&amp; pX, const T&amp; pMin, const T&amp; pMax)
{
    if (pX &lt; pMin || pX &gt; pMax)
        throw std::out_of_range(""check_range failed""); // or something else
}
</code></pre>

<p>Now you've already got this nice utility for checking ranges. Your code, even without the channel type, can already be made cleaner by using it. You can go further:</p>

<pre><code>template &lt;typename T, T Min, T Max&gt;
class ranged_value
{
public:
    typedef T value_type;

    static const value_type minimum = Min;
    static const value_type maximum = Max;

    ranged_value(const value_type&amp; pValue = value_type()) :
    mValue(pValue)
    {
        check_range(mValue, minimum, maximum);
    }

    const value_type&amp; value(void) const
    {
        return mValue;
    }

    // arguably dangerous
    operator const value_type&amp;(void) const
    {
        return mValue;
    }

private:
    value_type mValue;
};
</code></pre>

<p>Now you've got a nice utility, and can just do:</p>

<pre><code>typedef ranged_value&lt;unsigned char, 0, 15&gt; channel;

void foo(const channel&amp; pChannel);
</code></pre>

<p>And it's re-usable in other scenarios. Just stick it all in a <code>""checked_ranges.hpp""</code> file and use it whenever you need. It's never bad to make abstractions, and having utilities around isn't harmful.</p>

<p>Also, never worry about overhead. Creating a class simply consists of running the same code you would do anyway. Additionally, clean code is to be preferred over anything else; performance is a last concern. Once you're done, then you can get a profiler to measure (not guess) where the slow parts are.</p>
"
"<p>I just read a <a href=""http://stackoverflow.com/questions/3197434/c-initialize-a-member-pointer-to-null"">comment by GMan</a> that </p>

<pre><code>class A
{
public:
   A() :
      m_ptr() // m_ptr is implicitly initialized to NULL
   { }
};
</code></pre>

<p>should be preferred over</p>

<pre><code>class A
{
public:
   A() :
      m_ptr(NULL) // m_ptr is explicitly initialized to NULL
   { }
};
</code></pre>

<p>Notice the lack of <code>NULL</code> in the first example.</p>

<p>Is GMan right?  This might kinda subjective, so <em>""Do you prefer empty initializers for default initialization?""</em> might be more appropriate.</p>

<p>Also if you prefer empty initializers, do does this apply to other integral members?</p>

<pre><code>class B
{
public:
   B() :
      m_count(),
      m_elapsed_secs()
   {}
private:
   std::size_t m_count;
   float m_elapsed_secs;  //the elapsed time since instantiation
};
</code></pre>

<p>Of course, please defend your view point with a description of why one should be preferred over the other.</p>
","87234","","<p>Firstly, I said it's arguably better, not that it is. :) Also, it was more about getting rid of <code>NULL</code>; I just happen to use nothing instead of 0. But an interesting question anyway.</p>

<p>It's probably just a matter of style, but it's important to note, <a href=""http://stackoverflow.com/questions/3197434/c-initialize-a-member-pointer-to-null/3197557#3197557"">as Johannes did</a>, that it's not just syntactical style; they do different things. It's just easy to make those different things the same.</p>

<p>I prefer value-initialization, because I'm not taking any part of how the value is being initialized; I'm simply saying ""be initialized."" Contrarily, once you introduce a value you are influencing how the value is initialized.</p>

<p>I think you'd be hard-pressed to find a situation where value-initialization is <em>clearly</em> better, just pick which one suits you more.</p>
"
"<p>I have a situation where I will need an amount of memory determined at runtime to pass to a function. I am using a larger buffer on the stack, then only creating on the heap the space that is necessary:</p>

<pre><code>Foo largeBuf[1024];

int sizeUsed = fillBuff(largeBuf, 1024);

Foo* smallerBuf = new Foo[sizeUsed];

for (UINT i = 0; i &lt; sizeUsed; i++)
{
 smallerBuf[i] = largeBuf[i];
} 
</code></pre>

<p>Is there a better way to do this? Some standard array copying function? </p>
","87234","","<p>Firstly, you should be using <code>std::vector</code>. There's no reason not to use it. Then use <code>std::copy</code>:</p>

<pre><code>// surely the pointer was an accident
Foo largeBuf[1024];

// int? design should be changed to use an unsigned type
int sizeUsed = fillBuff(largeBuf, 1024); 

// vector, no memory leaks
std::vector&lt;Foo&gt; smallerBuf;
smallerBuf.reserve(sizeUsed);

// copy
std::copy(largeBuf, largeBuf + sizeUsed, std::back_inserter(smallerBuf));
</code></pre>

<hr>

<p>Or just cut to the chase at the end with:</p>

<pre><code>std::vector&lt;Foo&gt; smallerBuf(largeBuf, largeBuf + sizeUsed);
</code></pre>

<hr>

<p>Or another approach:</p>

<pre><code>std::vector&lt;Foo&gt; buf(1024); // this replaces your stack array
buf.resize(fillBuff(&amp;buf[0], 1024)); // copies directly into it, resizes
</code></pre>

<p>Note after this last approach, the memory will still be in use. You can force the capacity to shrink with the <a href=""http://www.gotw.ca/gotw/054.htm"" rel=""nofollow"">copy-swap trick</a>:</p>

<pre><code>template &lt;typename T, typename A&gt;
void shrink_to_fit(std::vector&lt;T, A&gt;&amp; pVector)
{
    std::vector&lt;T, A&gt;(pVector).swap(pVector);
}

// ...

shrink_to_fit(buf);
</code></pre>

<hr>

<p>Most ideal, <code>fillBuf</code> would have a way (or another function) to just return the number of elements it will return given a buffer. Then you can just do:</p>

<pre><code>std::vector&lt;Foo&gt; buf(buffSize()); // or whatever
fillBuff(&amp;buf[0], buf.size());
</code></pre>
"
"<p>I'm maintaining a VB6 app.  For boolean functions, the original authors store the return value in a boolean variable before checking the result in an If Statement.  I prefer to place the function directly in the If Statement.  Is this a matter of preference or am I missing a potential pitfall in my style?  </p>

<p><strong>Original Author Style</strong></p>

<pre><code>bReturn = IsThisFun(maintainingVb6)
If bReturn = True Then
    'You haven't used .NET
Else
    'blah
End If
</code></pre>

<p><strong>My Style</strong></p>

<pre><code>If IsThisFun(maintainingVb6) Then
    'You haven't used .NET
Else
    'blah
End If
</code></pre>

<p>I'm not sure if there is a proper terminology for these different approaches which may have allowed me to miss a previous post on this topic.</p>

<p>Thanks</p>
","87234","","<p>Strictly speaking, it's a matter of style.</p>

<p>The rule of thumb is: what's more readable.  Yours is probably to be preferred, because his code is redundant and most people prefer to remove redundancy. (The least he could do is remove the <code>= True</code>, which is totally redundant.)</p>

<p>If the boolean was a result of a longer function call, where the <code>If Then</code> was getting in the way, I would make the result a separate variable to make seeing the function call easier, but that's just me.</p>
"
"<p>The following compiles in Visual Studio but fails to compile under g++.</p>

<pre><code>int main()
{
    int a = unsigned char('0');
    return 0;
}
</code></pre>

<p>Is unsigned char() a valid way to cast in C++?</p>
","87234","","<p>No, it's not legal.</p>

<p>A function-style explicit type conversion requires a <em>simple-type-specifier</em>, followed by a parenthesized <em>expression-list</em>. (§5.2.3) <code>unsigned char</code> is <em>not</em> a <em>simple-type-specifier</em>; this is related to a question brought up by <a href=""http://stackoverflow.com/questions/2144012/explicit-type-conversion-and-multiple-simple-type-specifiers"">James</a>.</p>

<p>Obviously, if <code>unsigned char</code> was a <em>simple-type-specifier</em>, it would be legal. A work-around is to use <code>std::identity</code>:</p>

<pre><code>template &lt;typename T&gt;
struct identity
{
    typedef T type;
};
</code></pre>

<p>And then:</p>

<pre><code>int a = std::identity&lt;unsigned char&gt;::type('0');
</code></pre>

<p><code>std::identity&lt;unsigned char&gt;::type</code> is a <em>simple-type-specifier</em>, and its type is simply the type of the template parameter.</p>

<p>Of course, you get a two-for-one with <code>static_cast</code>. This is the preferred casting method anyway.</p>
"
"<p>These are functions and Struct declarations I have, and I'm not allowed to change them.</p>

<pre><code>DerivedA giveDerivedA ();
DerivedB giveDerivedB ();

struct Base{
    QString elementId;
    QString elementType;
};

struct DerivedA : Base {
    int a;
    int b;
};

struct DerivedB : Base {
    int c;
    int d;
};
</code></pre>

<p>But what I need is something like this:</p>

<pre><code>struct DerivedA : Base {
    int a;
    int b;
    void create();
    QString doc;
};
</code></pre>

<p>How can I add these method and member to structs I got?</p>

<p>My first idea is:</p>

<pre><code>struct myA: DerivedA {
    void create();
    QString doc;
};
</code></pre>

<p>Do you have any suggestion?</p>

<p>Edit: 2nd Alternative(Choosed)</p>

<pre><code>struct myA{
    void create();
    QString doc;
    private:
      DerivedA derivedA;
};
</code></pre>
","87234","","<p>This is similar to the problem people have extending standard library classes. If your base class doesn't have a virtual destructor, you can't safely inherit from it. In that case, you must either use free-functions (preferred anyway), or composition.</p>

<p>Otherwise, what you have there is good.</p>
"
"<p>What's a good policy for when to use ""new"" to make an instance of a class? I've been hobby programming C++ for a while but I'm still not for sure when is the best time to do this:</p>

<pre><code>MyClass thing(param1, param2);
</code></pre>

<p>over this:</p>

<pre><code>MyClass* thing;
thing = new MyClass(param1, param2);
</code></pre>

<p>Any advice?</p>
","87234","","<p>Design-wise, <em>use automatic (stack) allocation as much as possible</em>. Whenever you need to extend the lifetime of an object beyond a certain scope, then dynamically allocate it.</p>

<p>And even so, never dynamically allocate things <em>raw</em>. Always keep them wrapped into some sort of wrapper that implements Scope-Bound Resource Management (SBRM, first known under the dumb/awkward name Resource-Acquisition Is Initialization or RAII.) That is, dynamic allocations should be kept in automatic objects that will clean up automatically!</p>

<p>A good example of this is <code>std::vector</code>: you cannot leak the memory internal to a <code>vector</code>, because it's destructor is run in every scenario when memory should be free'd, and it will free it for you. <code>auto_ptr</code> is the first and only smart pointer available in the standard library, but it's pretty bad. Better is to use <code>shared_ptr</code>, or many of the other popular smart pointers available in Boost and/or TR1 and/or C++0x.</p>

<p>Performance-wise, objects allocated on the stack can be done so <em>very</em> quickly (the stack size is increased per-function-call, so all the required memory has been allocated up-front by a simple move of a pointer.) Contrarily, dynamic allocation generally requires much more time. It's quite possible to get speedy dynamic allocations with custom allocation schemes, but even the best will still be slower than stack allocation.</p>

<p>Occasionally, you might find you spend too much time copying objects around. In this case, it may be worth it to dynamically allocate it and merely move pointers around. However, please note I said ""find"". This kind of change is something you find by profiling and measuring, never guessing.</p>

<p>So: Automatic allocation when possible, dynamic allocation when needed.</p>
"
"<p>What is the output of the following and what's the reason behind this?</p>

<pre><code>main()
{
    printf(""%%%%"");
}
</code></pre>

<p>The answer is ""%%"", but I don't know why.</p>
","87234","","<p><code>%</code> is the beginning of a format-specifier. (For example, <code>""%d""</code> means ""print an <code>int</code>"".) A <code>%</code> after the format-specifier escapes it, printing a single ""%"".</p>

<p>That is, in the same way <code>""\\""</code> results in a single backslash, <code>""%%""</code> results in a single percent-sign.</p>
"
"<p>I get some strange behavior when inserting values into a map: I always insert at the end of the map, but sometimes the entries get out of order.</p>

<p>If I do a straight forward test, then I get no problems- the numbers are correctly ordered:</p>

<pre><code>map&lt;int,int&gt; testMap;
for(int i = 0; i &lt; 100; ++i)
{
    // everything is ordered correctly here
    testMap.insert(testMap.end(), pair&lt;int,int&gt;(i,i));
}
</code></pre>

<p>But when I parse a string and I try to insert the values in the same order as I read them, then things don't work out that well:</p>

<pre><code>const string INPUT_TWO =
""=VAR STRING1 \""MYSTRING\""\n\
=VAR STRING2 \""EXAMPLE\""\n\
=VAR NUMBER1 12345\n\
=VAR NUMBER2 23456\n\
=VAR DUMMY 1111\n"";

const string VAL_STRING = ""VAR"";

vector&lt;pair&lt;string, string&gt;&gt; parse_fields(const string &amp; input)
{
    map&lt;string, string&gt; fieldsMap;
    vector&lt;pair&lt;string, string&gt;&gt; sequenceFields;
    vector&lt;string&gt; lines = split(input, '\n');
    for(size_t i = 0; i &lt; lines.size(); ++i)
    {
        if(lines[i].find(VAL_STRING)!=string::npos)
        {
            vector&lt;string&gt; vals = split(lines[i], ' ');
            if(vals.size()==3)
            {
                fieldsMap.insert(fieldsMap.end(), pair&lt;string,string&gt;(vals[1], remove_quotes(vals[2])));
                sequenceFields.push_back(pair&lt;string,string&gt;(vals[1], remove_quotes(vals[2])));
            }
        }
    }

    // at the end the map looks like:
    // ""DUMMY"", ""1111""
    // ""NUMBER1"", ""12345""
    // ""NUMBER2"", ""23456""
    // ""STRING1"", ""MYSTRING""
    // ""STRING2"", ""EXAMPLE""

    // the vector of pairs looks like:
    // ""STRING1"", ""MYSTRING""
    // ""STRING2"", ""EXAMPLE""
    // ""NUMBER1"", ""12345""
    // ""NUMBER2"", ""23456""
    // ""DUMMY"", ""1111""

    return sequenceFields;
}
</code></pre>

<p>For your reference, I have pasted all the additional code in a <a href=""http://pastie.org/1038592"" rel=""nofollow"">pastie</a>.</p>

<p>Does anybody know why this may be happening?</p>
","87234","","<p>A <code>std::map</code> is an ordered container, this is what allows it the look-up times it has. If you need both the mapping and listing, consider using <a href=""http://www.boost.org/doc/libs/1_43_0/libs/multi_index/doc/index.html"" rel=""nofollow"">Boost.MultiIndex</a>. </p>
"
"<p>So I need to read flags in bits and set flags in bits. These bits are in various sizes of integer: int16, int32, int64, etc.</p>

<p>I would like to have a function that does something like this:</p>

<pre><code>static integertype function(integertype data, char startbit, char endbit);
</code></pre>

<p>I don't want to code what will be the same code to isolate bits from for different sizes of integers in separate but identical functions (for the multitude of bit functions I want to write).</p>

<p>I thought about using a void pointer for the data so everything could run through one function. Is this a bad design? What about as far as efficiency goes? I have no concept of bad/good design due to my inexperience.</p>

<pre><code>static int function(void *data, char startbit, char endbit)
</code></pre>

<p>These flags have to be looked at very often as this is for a data acquisition system. Would a void pointer implementation be reasonably efficient?</p>

<p>I know premature optimization is bad, but I would like to know what things are generally less or more efficient than others so I can make good decisions.</p>

<p>Thanks in advance for taking me to school.</p>
","87234","","<p>Generally, if you need generic functionality you use templates:</p>

<pre><code>template &lt;typename T&gt;
T function(T data, char startbit, char endbit);
</code></pre>

<p>But keep in mind we have <a href=""http://www.cplusplus.com/reference/stl/bitset/""><code>std::bitset</code></a>.</p>
"
"<p>Is there a maximum number of allowable <code>enum</code> elements in C++?</p>

<p>(Question arose from answer to my previous question on <a href=""http://stackoverflow.com/questions/3199761/define-bit0-bit1-bit2-etc-without-define/3199817#3199817"">defines</a>)</p>
","87234","","<p>There isn't any specified maximum or minimum, it depends on your implementation. However, note that Annex B states:</p>

<blockquote>
  <p>— Enumeration constants in a single enumeration [4096].</p>
</blockquote>

<p>As a recommendation. But this is strictly a recommendation, not a requirement.</p>
"
"<p>How can I accomplish what is suggested by the following?:</p>

<pre><code>template&lt;typename T&gt;
class Base{...};
...
class Derived : public Base&lt;int&gt;{...};
</code></pre>
","87234","","<p>Yes, it's legal.</p>

<p><code>Base</code> is a class template, and when provided all its template parameters it can be instantiated, which makes it an instantiated class. So <code>Base&lt;int&gt;</code> is a class name, and you can inherit from it just fine.</p>
"
"<p>I have to implement a function that takes an iterator. The iterator must dereference to a certain type, say int:</p>

<pre><code>template&lt;typename iter&gt;
  void f(iter i) {
  // do something here ...
  int t = *i;
  // do something here ...
}
</code></pre>

<p>The problem with this code is that if a user calls the function like this</p>

<pre><code>vector&lt;string&gt; v;
v.push_back(""aaa"");
f(v.begin());
</code></pre>

<p>he will see an error pointing to some place in my code, not in his code (which will be confusing to him). I want the error to be in user's code to ease debugging.</p>
","87234","","<p>You could do something like this:</p>

<pre><code>#include &lt;boost/type_traits/is_convertible.hpp&gt;
#include &lt;boost/typeof/typeof.hpp&gt;
#include &lt;boost/mpl/assert.hpp&gt;

template &lt;typename Iter&gt;
void foo(Iter pIter)
{
    BOOST_MPL_ASSERT_MSG(
        (boost::is_convertible&lt;BOOST_TYPEOF(*pIter), int&gt;::value),
        DEREFERENCED_ITERATOR_MUST_BE_CONVERTIBLE_TO_INT,
        (int));

    // ...
}

#include &lt;vector&gt;
#include &lt;string&gt;

int main(void)
{
    std::vector&lt;std::string&gt; v(5);

    foo(v.begin());
}
</code></pre>

<p>Which makes the message quite visible:</p>

<blockquote>
  <p>error C2664: 'boost::mpl::assertion_failed' : cannot convert parameter 1 from 'boost::mpl::failed <strong><em>*</em>**<em>*</em></strong>(__thiscall foo::DEREFERENCED_ITERATOR_MUST_BE_CONVERTIBLE_TO_INT::* <strong><em>*</em>****</strong>)(int)' to 'boost::mpl::assert::type'</p>
</blockquote>

<p>But like James says, most compilers give plenty of information to find out what happened anyway.</p>
"
"<p>I am using the <code>cstdio (stdio.h)</code> to read and write data from binary files. I have to use this library due to legacy code and it must be cross-platform compatible with Windows and Linux. I have a <code>FILE* basefile_</code> which I use to read in the variables <code>configLabelLength</code> and <code>configLabel</code>, where <code>configLabelLength</code> tells me how much memory to allocate for <code>configLabel</code>.</p>

<pre><code>unsigned int configLabelLength; // 4 bytes
char* configLabel = 0;          // Variable length

fread((char *) &amp;configLabelLength, 1, sizeof configLabelLength, baseFile_);
configLabel = new char[configLabelLength];
fread(configLabel,1, configLabelLength,baseFile_);

delete [] configLabel; // Free memory allocated for char array
configLabel = 0; // Be sure the deallocated memory isn't used
</code></pre>

<p>Is there a way to read in <code>configLabel</code> without using a pointer? For example is there a solution where I can use the c++ vector library or something where I do not have to worry about pointer memory management. </p>
","87234","","<p>Just do:</p>

<pre><code>unsigned int configLabelLength; // 4 bytes*
fread((char *) &amp;configLabelLength, 1, sizeof configLabelLength, baseFile_);

std::vector&lt;char&gt; configLabel(configLabelLength);
fread(&amp;configLabel[0], 1, configLabel.size(), baseFile_);
</code></pre>

<p>The elements in a vector are contiguous.</p>

<hr>

<p><sup>* </sup>I assume you know that <code>unsigned int</code> isn't necessary always 4 bytes. If you pay attention to your implementation details that's fine, but it'll be a bit easier if you adopt Boost's <code>cstdint.hpp</code> and just use <code>uint32_t</code>.</p>
"
"<p>For example we have <code>priority_queue&lt;int&gt; s;</code> which contains some elements. What will be correct form of the following code:</p>

<pre><code>while (!s.empty()) {
    int t=s.pop();// this does not retrieve the value from the queue
    cout&lt;&lt;t&lt;&lt;endl;
}
</code></pre>
","87234","","<p>Refer to your documentation and you'll see <code>pop</code> has no return value. There are <a href=""http://stackoverflow.com/questions/2756233/why-should-pop-take-an-argument/2756265#2756265"">various reasons for this</a>, but that's another topic.</p>

<p>The proper form is:</p>

<pre><code>while (!s.empty())
{
    int t = s.top();
    s.pop();

    cout &lt;&lt; t &lt;&lt; endl;
}
</code></pre>

<p>Or:</p>

<pre><code>for (; !s.empty(); s.pop())
{
    cout &lt;&lt; s.top(); &lt;&lt; endl;
}
</code></pre>
"
"<p>Good Evening (depending on where u are right now).
I am a little confused with the stl stuff for sorted sets...
I want to store pointers of a custom class in my set and I want them to be sorted by my own 
criterion and not just the pointer size.</p>

<p>Anyone has an idea how to do this? Since it is impossible
to do it like operator&lt;(const foo &amp;*rhs, const foo &amp;*lhs){..};</p>

<p>Any suggestions?
Thanks in advance and kind regards.</p>
","87234","","<p><code>std::set</code>'s second template parameter is the method it uses for comparisons. So you can do something like this:</p>

<pre><code>struct dereference_compare
{
    template &lt;typename T&gt;
    bool operator()(const T* pX, const T* pY) const
    {
        return *pX &lt; *pY;
    }
};

typedef std::set&lt;T*, dereference_compare&gt; set_type;
</code></pre>
"
"<p>If a float overflow occurs on a value, I want to set it to zero, like this...</p>

<pre><code>m_speed += val;
if ( m_speed &gt; numeric_limits&lt;float&gt;::max()) { // This might not even work, since some impls will wraparound after previous line
  m_speed = 0.f
}
</code></pre>

<p>but once <code>val</code> has been added to <code>m_speed</code>, the overflow has already occurred (and I'm assuming that the same problem would occur if i did <code>if (( m_speed + val ) &gt; ..)</code>.</p>

<p>How can I check to make sure an overflow is going to occur, without causing an overflow?</p>
","87234","","<p>You could do:</p>

<pre><code>if (numeric_limits&lt;float&gt;::max() - val &lt; m_speed)
{
    m_speed = 0;
}
else
{
    m_speed += val;
}
</code></pre>

<p>Another method might be:</p>

<pre><code>m_speed += val;
if (m_speed == numeric_limits&lt;float&gt;::infinity())
    m_speed = 0;
</code></pre>

<p>But do keep in mind when an overflow actually occurs, the result is undefined behavior. So while this probably works on most machines, it isn't guaranteed. You're better of catching it before it happens.</p>

<hr>

<p>Because this isn't trivial to read at first, I'd wrap it into a function:</p>

<pre><code>template &lt;typename T&gt;
bool will_overflow(const T&amp; pX, const T&amp; pValue, 
                    const T&amp; pMax = std::numeric_limits&lt;T&gt;::max())
{
    return pMax - pValue &lt; pX;
}

template &lt;typename T&gt;
bool will_underflow(const T&amp; pX, const T&amp; pValue, 
                    const T&amp; pMin = std::numeric_limits&lt;T&gt;::min())
{
    return pMin + pValue &gt; pX;
}

m_speed = will_overflow(m_speed, val) ? 0 : m_speed + val;
</code></pre>
"
"<p>I know I can set a custom allocator for vectors using the syntax <code>vector&lt;T, Alloc&gt;</code>. Is there a way I can do the same for strings?</p>
","87234","","<p>Yes. All string classes come from the class template <code>basic_string</code>, declared as such:</p>

<pre><code>template &lt;class charT, class traits = char_traits&lt;charT&gt;,
            class Allocator = allocator&lt;charT&gt; &gt;
class basic_string;
</code></pre>

<p>For example, <code>std::string</code> is just <code>typedef basic_string&lt;char&gt; string;</code>.</p>

<p>The third template parameter is the allocator, so you can do something like:</p>

<pre><code>typedef basic_string&lt;char, char_traits&lt;char&gt;, my_allocator&lt;char&gt; &gt; my_string;
</code></pre>
"
"<p>If so, why?  Why doesn't it use the copy constructor of the value type?</p>

<p>I get the following error:</p>

<pre><code>/usr/lib/gcc/i686-pc-cygwin/3.4.4/include/c++/bits/vector.tcc: In member functio
n `ClassWithoutAss&amp; ClassWithoutAss::operator=(const ClassWithoutAss&amp;)':
/usr/lib/gcc/i686-pc-cygwin/3.4.4/include/c++/bits/vector.tcc:238:   instantiate
d from `void std::vector&lt;_Tp, _Alloc&gt;::_M_insert_aux(__gnu_cxx::__normal_iterato
r&lt;typename _Alloc::pointer, std::vector&lt;_Tp, _Alloc&gt; &gt;, const _Tp&amp;) [with _Tp =
ClassWithoutAss, _Alloc = std::allocator&lt;ClassWithoutAss&gt;]'
/usr/lib/gcc/i686-pc-cygwin/3.4.4/include/c++/bits/stl_vector.h:564:   instantia
ted from `void std::vector&lt;_Tp, _Alloc&gt;::push_back(const _Tp&amp;) [with _Tp = Class
WithoutAss, _Alloc = std::allocator&lt;ClassWithoutAss&gt;]'
main.cpp:13:   instantiated from here
/usr/lib/gcc/i686-pc-cygwin/3.4.4/include/c++/bits/vector.tcc:238: error: non-st
atic const member `const int ClassWithoutAss::mem', can't use default assignment
 operator
</code></pre>

<p>running g++ main.cpp on the following code:</p>

<pre><code>/*
 * ClassWithoutAss.h
 *
 */

#ifndef CLASSWITHOUTASS_H_
#define CLASSWITHOUTASS_H_

class ClassWithoutAss
{

public:
    const int mem;
    ClassWithoutAss(int mem):mem(mem){}
    ClassWithoutAss(const ClassWithoutAss&amp; tobeCopied):mem(tobeCopied.mem){}
    ~ClassWithoutAss(){}

};

#endif /* CLASSWITHOUTASS_H_ */

/*
 * main.cpp
 *
 */

#include ""ClassWithoutAss.h""
#include &lt;vector&gt;

int main()
{
    std::vector&lt;ClassWithoutAss&gt; vec;
    ClassWithoutAss classWithoutAss(1);
    (vec.push_back)(classWithoutAss);

    return 0;
}
</code></pre>
","87234","","<p>The C++03 standard says elements must be copy-constructible and copy-assignable to be used in a standard container. So an implementation is free to use whichever it wants.</p>

<p>In C++0x, these requirements are put on a per-operation basis. (In general, elements must be move-constructible and move-assignable.) </p>

<p>To get what you want, you should use a smart pointer like <code>shared_ptr</code> (from either Boost, TR1, or C++0x), and completely disable copy-ability:</p>

<pre><code>class ClassWithoutAss
{
public:
    const int mem;

    ClassWithoutAss(int mem):mem(mem){}
    // don't explicitly declare empty destructors

private:
    ClassWithoutAss(const ClassWithoutAss&amp;); // not defined
    ClassWithoutAss&amp; operator=(const ClassWithoutAss&amp;); // not defined
};

typedef shared_ptr&lt;ClassWithoutAss&gt; ptr_type;

std::vector&lt;ptr_type&gt; vec;
vec.push_back(ptr_type(new ClassWithoutAss(1)));
</code></pre>

<p>Pointers can be copied just fine, and the smart pointer ensures you don't leak. In C++0x you can do this best with a <code>std::unique_ptr</code>, taking advantage of move-semantics. (You don't actually need shared semantics, but in C++03 it's easiest as it stands.)</p>
"
"<p>please can anybody explain <a href=""http://www.cplusplus.com/reference/std/memory/auto_ptr/reset/"" rel=""nofollow"">this code from C++ Reference site</a>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;

int main () {
  auto_ptr&lt;int&gt; p;

  p.reset (new int);
  *p=5;
  cout &lt;&lt; *p &lt;&lt; endl;

  p.reset (new int);
  *p=10;
  cout &lt;&lt; *p &lt;&lt; endl;

  return 0;
}
</code></pre>
","87234","","<p><code>auto_ptr</code> manages a pointer. <code>reset</code> will delete the pointer it has, and point to something else.</p>

<p>So you start with <code>auto_ptr p</code>, pointing to nothing. When you <code>reset</code> with <code>new int</code>, it deletes nothing and then points to a dynamically allocated <code>int</code>. You then assign 5 to that <code>int</code>.</p>

<p>Then you <code>reset</code> again, deleting that previously allocated <code>int</code> and then point to a newly allocated <code>int</code>. You then assign 10 to the new <code>int</code>.</p>

<p>When the function returns, <code>auto_ptr</code> goes out of scope and has its destructor called, which deletes the last allocated <code>int</code> and the program ends.</p>
"
"<p>In C++, when you make a new variable on the heap like this:</p>

<pre><code>int* a = new int;
</code></pre>

<p>you can tell C++ to reclaim the memory by using delete like this:</p>

<pre><code>delete a;
</code></pre>

<p>However, when your program closes, does it automatically free the memory that was allocated with new?</p>
","87234","","<p>Don't let people tell you yes. C++ has no concept of an OS, so to say ""yes the OS will clean it up"" is no longer talking about C++ but about C++ running on some environment, which may not be yours.</p>

<p>That is, if you dynamically allocate something but never free it you've leaked. It can only end its lifetime once you call <code>delete</code>/<code>delete[]</code> on it. On <em>some</em> OS's (and almost all desktop OS's), memory will be reclaimed (so other programs may use it.) But memory is <em>not</em> the same as resource! The OS can free all the memory it wants, if you have some socket connection to close, some file to finish writing to, etc, the OS might not do it. It's important not to let resources leak. I've heard of some embedded platforms that won't even reclaim the memory you've not freed, resulting in a leak until the platform is reset.</p>

<p>Instead of dynamically allocating things raw (meaning you're the one that has to explicitly delete it), wrap them into automatically allocated (stack allocated) containers; not doing so is considered bad practice, and makes your code extremely messy.</p>

<p>So don't use <code>new T[N]</code>, use <code>std::vector&lt;T&gt; v(N);</code>. The latter won't let a resource leak occur. Don't use <code>new T;</code>, use <code>smart_ptr p(new T);</code>. The smart pointer will track the object and delete it when it's know longer used. This is called Scope-bound Resource Management (SBRM, also known as the dumber name Resource-Acquisition is Initialization, or RAII.)</p>

<p>Note there is no single ""<code>smart_ptr</code>"". You have to pick which one is best. The current standard includes <code>std::auto_ptr</code>, but it's quite unwieldy. (It cannot be used in standard containers.) Your best bet is to use the smart pointers part of Boost, or TR1 if your compiler supports it. Then you get <code>shared_ptr</code>, arguably the most useful smart pointer, but there are many others.</p>

<p>If every pointer to dynamically allocated memory is in an object that will destruct (i.e., not another object that is dynamically allocated), and that object knows to free the memory, that pointer is guaranteed to be freed. This question shouldn't even be a problem, since you should never be in a position to leak.</p>
"
"<p>I'd like clarification on the C++ standard, specifically where it says (my interpretation)  in section 20.1.3 that ""for class T and an instance of class T called x, T(x) must be equivalent to x"" for the class to work with standard containers.</p>

<p>I couldn't find a definition of 'equivalent'. Does this mean that I have to define <code>operator==</code> as a member of my class, so that <code>T(x) == x</code> returns true?</p>
","87234","","<p>Equivalent is purposefully vague. (To avoid things like implying <code>operator==</code> <em>must</em> be defined; it doesn't in a general case.)</p>

<p>However, conceptually two things are equivalent if their data represents the same object. If a class has data that might be different when ""copied"", then you do need to make an <code>operator==</code> (and possibly <code>operator&lt;</code> along with <code>rel_ops</code>) to make sure that ""equivalent"" is implemented with respect to that. (Effectively, make sure that the mutable data isn't 'part of the class', so to speak.)</p>

<p>It's usually better not to go such a route, because you end up having to patch lots of things up to make sure it works properly. If something is to be copied, let if be fully copied. This makes much more sense.</p>
"
"<p>I want to know the exact difference between Header file and namespace in consideration in programming languages ??</p>
","87234","","<p>A header file is a file that is intended to be included by source files. They typically contain declarations of certain classes and functions.</p>

<p>A namespace enables code to categorize identifiers. That is, classes, functions, etc. can be placed inside a namespace, keeping those separate from other classes that are unrelated. For example, in C++ everything from the standard library is in the <code>std</code> namespace.</p>
"
"<p>What is this idiom and when should it be used? Which problems does it solve? Does the idiom change when C++11 is used?</p>

<p>Although it's been mentioned in many places, we didn't have any singular ""what is it"" question and answer, so here it is. Here is a partial list of places where it was previously mentioned:</p>

<ul>
<li><a href=""http://stackoverflow.com/questions/276173/what-are-your-favorite-c-coding-style-idioms/2034447#2034447"">What are your favorite C++ Coding Style idioms:  Copy-swap</a></li>
<li><a href=""http://stackoverflow.com/questions/1734628/copy-constructor-and-operator-overload-in-c-is-a-common-function-possible/1734640#1734640"">Copy constructor and = operator overload in C++: is a common function possible?</a></li>
<li><a href=""http://stackoverflow.com/questions/2143787/what-is-copy-elision-and-how-it-optimizes-copy-and-swap-idiom"">What is copy elision and how it optimizes copy-and-swap idiom</a></li>
<li><a href=""http://stackoverflow.com/questions/255612/c-dynamically-allocating-an-array-of-objects/255744#255744"">C++: dynamically allocating an array of objects?</a></li>
</ul>
","87234","","<h2>Overview</h2>

<h3>Why do we need the copy-and-swap idiom?</h3>

<p>Any class that manages a resource (a <em>wrapper</em>, like a smart pointer) needs to implement <a href=""http://stackoverflow.com/questions/4172722/what-is-the-rule-of-three"">The Big Three</a>. While the goals and implementation of the copy-constructor and destructor are straightforward, the copy-assignment operator is arguably the most nuanced and difficult. How should it be done? What pitfalls need to be avoided?</p>

<p>The <em>copy-and-swap idiom</em> is the solution, and elegantly assists the assignment operator in achieving two things: avoiding <a href=""http://en.wikipedia.org/wiki/Don%27t_repeat_yourself"">code duplication</a>, and providing a <a href=""http://en.wikipedia.org/wiki/Exception_guarantees"">strong exception guarantee</a>.</p>

<h3>How does it work?</h3>

<p><a href=""http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279616#3279616"">Conceptually</a>, it works by using the copy-constructor's functionality to create a local copy of the data, then takes the copied data with a <code>swap</code> function, swapping the old data with the new data. The temporary copy then destructs, taking the old data with it. We are left with a copy of the new data.</p>

<p>In order to use the copy-and-swap idiom, we need three things: a working copy-constructor, a working destructor (both are the basis of any wrapper, so should be complete anyway), and a <code>swap</code> function.</p>

<p>A swap function is a <em>non-throwing</em> function that swaps two objects of a class, member for member. We might be tempted to use <code>std::swap</code> instead of providing our own, but this would be impossible; <code>std::swap</code> uses the copy-constructor and copy-assignment operator within its implementation, and we'd ultimately be trying to define the assignment operator in terms of itself! </p>

<p>(Not only that, but unqualified calls to <code>swap</code> will use our custom swap operator, skipping over the unnecessary construction and destruction of our class that <code>std::swap</code> would entail.)</p>

<hr>

<h2>An in-depth explanation</h2>

<h3>The goal</h3>

<p>Let's consider a concrete case. We want to manage, in an otherwise useless class, a dynamic array. We start with a working constructor, copy-constructor, and destructor:</p>

<pre><code>#include &lt;algorithm&gt; // std::copy
#include &lt;cstddef&gt; // std::size_t

class dumb_array
{
public:
    // (default) constructor
    dumb_array(std::size_t size = 0)
        : mSize(size),
          mArray(mSize ? new int[mSize]() : 0)
    {
    }

    // copy-constructor
    dumb_array(const dumb_array&amp; other) 
        : mSize(other.mSize),
          mArray(mSize ? new int[mSize] : 0),
    {
        // note that this is non-throwing, because of the data
        // types being used; more attention to detail with regards
        // to exceptions must be given in a more general case, however
        std::copy(other.mArray, other.mArray + mSize, mArray);
    }

    // destructor
    ~dumb_array()
    {
        delete [] mArray;
    }

private:
    std::size_t mSize;
    int* mArray;
};
</code></pre>

<p>This class almost manages the array successfully, but it needs <code>operator=</code> to work correctly.</p>

<h3>A failed solution</h3>

<p>Here's how a naive implementation might look:</p>

<pre><code>// the hard part
dumb_array&amp; operator=(const dumb_array&amp; other)
{
    if (this != &amp;other) // (1)
    {
        // get rid of the old data...
        delete [] mArray; // (2)
        mArray = 0; // (2) *(see footnote for rationale)

        // ...and put in the new
        mSize = other.mSize; // (3)
        mArray = mSize ? new int[mSize] : 0; // (3)
        std::copy(other.mArray, other.mArray + mSize, mArray); // (3)
    }

    return *this;
} 
</code></pre>

<p>And we say we're finished; this now manages an array, without leaks. However, it suffers from three problems, marked sequentially in the code as <code>(n)</code>.</p>

<p>The first  is the self-assignment test. This check serves two purposes: it's an easy way to prevent us from running needless code on self-assignment, and it protects us from subtle bugs (such as deleting the array only to try and copy it). But in all other cases it merely serves to slow the program down, and act as noise in the code; self-assignment rarely occurs, so most of the time this check is a waste. It would be better if the operator could work properly without it.</p>

<p>The second is that it only provides a basic exception guarantee. If <code>new int[mSize]</code> fails, <code>*this</code> will have been modified. (Namely, the size is wrong and the data is gone!) For a strong exception guarantee, it would need to be something akin to:</p>

<pre><code>dumb_array&amp; operator=(const dumb_array&amp; other)
{
    if (this != &amp;other) // (1)
    {
        // get the new data ready before we replace the old
        std::size_t newSize = other.mSize;
        int* newArray = newSize ? new int[newSize]() : 0; // (3)
        std::copy(other.mArray, other.mArray + newSize, newArray); // (3)

        // replace the old data (all are non-throwing)
        delete [] mArray;
        mSize = newSize;
        mArray = newArray;
    }

    return *this;
} 
</code></pre>

<p>The code has expanded! Which leads us to the third problem: code duplication. Our assignment operator effectively duplicates all the code we've already written elsewhere, and that's a terrible thing.</p>

<p>In our case, the core of it is only two lines (the allocation and the copy), but with more complex resources this code bloat can be quite a hassle. We should strive to never repeat ourselves.</p>

<p>(One might wonder: if this much code is needed to manage one resource correctly, what if my class manages more than one? While this may seem to be a valid concern, and indeed it requires non-trivial <code>try</code>/<code>catch</code> clauses, this is a non-issue. That's because a class should manage <a href=""http://en.wikipedia.org/wiki/Single_responsibility_principle""><em>one resource only</em></a>!)</p>

<h3>A successful solution</h3>

<p>As mentioned, the copy-and-swap idiom will fix all these issues. But right now, we have all the requirements except one: a <code>swap</code> function. While The Rule of Three successfully entails the existence of our copy-constructor, assignment operator, and destructor, it should really be called ""The Big Three and A Half"": any time your class manages a resource it also makes sense to provide a <code>swap</code> function.</p>

<p>We need to add swap functionality to our class, and we do that as follows†:</p>

<pre><code>class dumb_array
{
public:
    // ...

    friend void swap(dumb_array&amp; first, dumb_array&amp; second) // nothrow
    {
        // enable ADL (not necessary in our case, but good practice)
        using std::swap; 

        // by swapping the members of two classes,
        // the two classes are effectively swapped
        swap(first.mSize, second.mSize); 
        swap(first.mArray, second.mArray);
    }

    // ...
};
</code></pre>

<p>Now not only can we swap our <code>dumb_array</code>'s, but swaps in general can be more efficient; it merely swaps pointers and sizes, rather than allocating and copying entire arrays. Aside from this bonus in functionality and efficiency, we are now ready to implement the copy-and-swap idiom.</p>

<p>Without further ado, our assignment operator is:</p>

<pre><code>dumb_array&amp; operator=(dumb_array other) // (1)
{
    swap(*this, other); // (2)

    return *this;
} 
</code></pre>

<p>And that's it! With one fell swoop, all three problems are elegantly tackled at once. </p>

<h3>Why does it work?</h3>

<p>We first notice an important choice: the parameter argument is taken <em>by-value</em>. While one could just as easily do the following (and indeed, many naive implementations of the idiom do):</p>

<pre><code>dumb_array&amp; operator=(const dumb_array&amp; other)
{
    dumb_array temp(other);
    swap(*this, temp);

    return *this;
}
</code></pre>

<p>We lose an <a href=""https://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/"">important optimization opportunity</a>. Not only that, but this choice is critical in C++11, which is discussed later. (On a general note, a remarkably useful guideline is as follows: if you're going to make a copy of something in a function, let the compiler do it in the parameter list.‡)</p>

<p>Either way, this method of obtaining our resource is the key to eliminating code duplication: we get to use the code from the copy-constructor to make the copy, and never need to repeat any bit of it. Now that the copy is made, we are ready to swap.</p>

<p>Observe that upon entering the function that all the new data is already allocated, copied, and ready to be used. This is what gives us a strong exception guarantee for free: we won't even enter the function if construction of the copy fails, and it's therefore not possible to alter the state of <code>*this</code>. (What we did manually before for a strong exception guarantee, the compiler is doing for us now; how kind.)</p>

<p>At this point we are home-free, because <code>swap</code> is non-throwing. We swap our current data with the copied data, safely altering our state, and the old data gets put into the temporary. The old data is then released when the function returns. (Where upon the parameter's scope ends and its destructor is called.)</p>

<p>Because the idiom repeats no code, we cannot introduce bugs within the operator. Note that this means we are rid of the need for a self-assignment check, allowing a single uniform implementation of <code>operator=</code>. (Additionally, we no longer have a performance penalty on non-self-assignments.)</p>

<p>And that is the copy-and-swap idiom.</p>

<h2>What about C++11?</h2>

<p>The next version of C++, C++11, makes one very important change to how we manage resources: the Rule of Three is now <strong>The Rule of Four</strong> (and a half). Why? Because not only do we need to be able to copy-construct our resource, <a href=""http://stackoverflow.com/questions/3106110/can-someone-please-explain-move-semantics-to-me"">we need to move-construct it as well</a>.</p>

<p>Luckily for us, this is easy:</p>

<pre><code>class dumb_array
{
public:
    // ...

    // move constructor
    dumb_array(dumb_array&amp;&amp; other)
        : dumb_array() // initialize via default constructor, C++11 only
    {
        swap(*this, other);
    }

    // ...
};
</code></pre>

<p>What's going on here? Recall the goal of move-construction: to take the resources from another instance of the class, leaving it in a state guaranteed to be assignable and destructible.</p>

<p>So what we've done is simple: initialize via the default constructor (a C++11 feature), then swap with <code>other</code>; we know a default constructed instance of our class can safely be assigned and destructed, so we know <code>other</code> will be able to do the same, after swapping.</p>

<p>(Note that some compilers do not support constructor delegation; in this case, we have to manually default construct the class. This is an unfortunate but luckily trivial task.)</p>

<h3>Why does that work?</h3>

<p>That is the only change we need to make to our class, so why does it work? Remember the ever-important decision we made to make the parameter a value and not a reference:</p>

<pre><code>dumb_array&amp; operator=(dumb_array other); // (1)
</code></pre>

<p>Now, if <code>other</code> is being initialized with an rvalue, <em>it will be move-constructed</em>. Perfect. In the same way C++03 let us re-use our copy-constructor functionality by taking the argument by-value, C++11 will <em>automatically</em> pick the move-constructor when appropriate as well. (And, of course, as mentioned in previously linked article, the copying/moving of the value may simply be elided altogether.)</p>

<p>And so concludes the copy-and-swap idiom.</p>

<hr>

<h3>Footnotes</h3>

<p>*Why do we set <code>mArray</code> to null? Because if any further code in the operator throws, the destructor of <code>dumb_array</code> might be called; and if that happens without setting it to null, we attempt to delete memory that's already been deleted! We avoid this by setting it to null, as deleting null is a no-operation.</p>

<p>†There are other claims that we should specialize <code>std::swap</code> for our type, provide an in-class <code>swap</code> along-side a free-function <code>swap</code>, etc. But this is all unnecessary: any proper use of <code>swap</code> will be through an unqualified call, and our function will be found through <a href=""http://en.wikipedia.org/wiki/Argument-dependent_name_lookup"">ADL</a>. One function will do.</p>

<p>‡The reason is simple: once you have the resource to yourself, you may swap and/or move it (C++11) anywhere it needs to be. And by making the copy in the parameter list, you maximize optimization.</p>
"
"<p>I'm trying to write the contents of buf pointer to the file created by ofstream.</p>

<p>For some reason the file is empty, however the contents of buf is never empty...  What am I doing wrong?</p>

<pre><code>void DLog::Log(const char *fmt, ...)
{
    va_list varptr;

    va_start(varptr, fmt);

    int n = ::_vscprintf(fmt, varptr);
    char *buf = new char[n + 1];
    ::vsprintf(buf, fmt, varptr);

    va_end(varptr);

    if (!m_filename.empty())
    {

        std::ofstream ofstr(m_filename.c_str(), ios::out);

        ofstr &lt;&lt; *buf; // contents of *buf are NEVER empty, however nothing is in file??

        ofstr.close();
    }


    delete [] buf;
}
</code></pre>
","87234","","<p>Many problems can be solved by getting rid of the hairy stuff, like manual allocation management. </p>

<p>Never use <code>new T[N]</code> in your code: instead use <code>std::vector&lt;T&gt; v(N);</code>. Simply this alone might solve your problem, because the pointer stuff isn't in the way:</p>

<pre><code>void DLog::Log(const char *fmt, ...)
{
    va_list varptr;
    va_start(varptr, fmt);

    int n = ::_vscprintf(fmt, varptr);
    std::vector&lt;char&gt; buf(n + 1);

    ::vsprintf(&amp;buf[0], fmt, varptr);

    va_end(varptr);

    if (!m_filename.empty())
    {
        std::ofstream ofstr(m_filename.c_str(), ios::out);
        if (!ofstr) 
        {
            // didn't open, do some error reporting here
        }

        // copy each character to the stream
        std::copy(buf.begin(), buf.end(), std::ostream_iterator&lt;char&gt;(ofstr));

        // no need to close, it's done automatically
    }

    // no need to remember to delete
}
</code></pre>

<p>Much easier to read and maintain. Note even better would be a <code>std::string buf(n + 1);</code>, then you could just do <code>ofstr &lt;&lt; buf;</code>. Sadly, <code>std::string</code> isn't currently required to store its elements contiguously, like <code>std::vector</code>. This means the line with <code>&amp;buf[0]</code> isn't guaranteed to work. That said, I doubt you'll find an implementation where it wouldn't work. Still, it's arguably better to maintain guaranteed behavior.</p>

<p>I do <a href=""http://stackoverflow.com/questions/3279733/ofstream-doesnt-write-buffer-to-file/3279778#3279778"">suspect</a> the <a href=""http://stackoverflow.com/questions/3279733/ofstream-doesnt-write-buffer-to-file/3279814#3279814"">issue</a> was you dereferencing the pointer, though.</p>
"
"<p>I'm playing a little with memory dynamic allocation, but I don't get a point. When allocating some memory with the <code>new</code> statement, I'm supposed to be able to destroy the memory the pointer points to using <code>delete</code>.</p>

<p>But when I try, this <code>delete</code> command doesn't seem to work since the space the pointer is pointing at doesn't seem to have been emptied.</p>

<p>Let's take this truly basic piece of code as an example:</p>

<pre><code>#include &lt;iostream&gt;  

using namespace std;

int main()  
{  
    //I create a pointer-to-integer pTest, make it point to some new space,  
    // and fulfill this free space with a number;  
    int* pTest;  
    pTest = new int;  
    *(pTest) = 3;  
    cout &lt;&lt; *(pTest) &lt;&lt; endl; 

    // things are working well so far. Let's destroy this
    // dynamically allocated space!
    delete pTest;

    //OK, now I guess the data pTest pointed to has been destroyed 
    cout &lt;&lt; *(pTest) &lt;&lt; endl; // Oh... Well, I was mistaking.  

    return 0;  
}  
</code></pre>

<p>I guess this a very very noob question. Any clue ?</p>
","87234","","<p>It's time to learn what undefined behavior is. :)</p>

<p>In C++, when you do something illegal/nonsensical/bad/etc. the standard often says that ""it leads to undefined behavior."" This means that from that point forward, the state of your program is completely non-guaranteed, and anything could happen.</p>

<p>At the point where you do your last <code>*(pTest)</code>, you get undefined behavior. This is because <code>pTest</code> does not point to a valid object, and dereferencing such a pointer is undefined. So what you're seeing is totally allowed: undefined output.</p>

<p>All you've done is said ""I'm finished with this allocation."" Once you've said that, you shouldn't (and indeed, cannot) inspect or care about that memory any longer. It doesn't even make conceptual sense to deallocate something then try to use it; you've said you were done!</p>

<p>Your output is somewhat predictable though: likely, your OS simply says ""okay, thanks for the memory"" and that's it. It has no reason to actually ""reset"" the memory, or do anything special. That would indeed be a waste of time, when nobody (including your own program) is not using it.</p>

<p>But remember, this output is completely undefined. Don't try to use objects that don't exist. Perhaps a better test would have been:</p>

<pre><code>#include &lt;iostream&gt;

struct foo
{
    ~foo(void)
    {
        std::cout &lt;&lt; ""foo is gone :("" &lt;&lt; std::endl;
    }
};

int main(void)
{
    foo* f = new foo();
    delete f; // you'll see that the object is destroyed.
}
</code></pre>

<p>Although it seems you were looking to see what happens with the memory itself. Just remember that it makes no sense to get rid of memory then try to use it, so the answer is: who knows. It's up to your specific platform, which C++ doesn't care about.</p>
"
"<p>I'm using the vector container to store an array of doubles. Is there any quick 
way of multiplying each element in my vector by some scalar without using a loop. </p>

<p>For example: </p>

<pre><code>  vector&lt;double&gt; Array(10,1);
</code></pre>

<p>will initialise an array of 10 doubles with initial value 1. To multiply this
array by 0.5 I would write: </p>

<pre><code>  for(unsigned int i=0; i&lt;Array.size(); i++) 
     Array[i] = 0.5*Array[i]; 
</code></pre>

<p>Is there there another way? I have used valarray which overloads the '*' operator 
so that: </p>

<pre><code>     Array = 0.5 * Array; 
</code></pre>

<p>is valid but I'd rather not use valarray as it seems the vector container is a more
standard approach for manipulating arrays. </p>

<p>Thanks!   </p>
","87234","","<p>You could do this:</p>

<pre><code>std::transform(Array.begin(), Array.end(), Array.begin(),
                std::bind2nd(std::multiplies&lt;double&gt;(), 0.5));
</code></pre>

<p>In response to getting the sum of elements:</p>

<pre><code>double sum = std::accumulate(Array.begin(), Array.end(), 0.0);
</code></pre>

<p>And in response to getting <code>sqrt</code>'ing each element:</p>

<pre><code>std::transform(Array.begin(), Array.end(), Array.begin(),
                static_cast&lt;double (*)(double)&gt;(std::sqrt));
</code></pre>

<p>That cast is to select the correct overload.</p>
"
"<p>The Wikipedia article about <a href=""http://en.wikipedia.org/wiki/Special_member_functions"" rel=""nofollow"">special member functions</a> doesn't contain any reference to move constructors and move assignment operators.</p>

<p>I would like to update the entry but I'm not sure what the 0x standard says.</p>

<p>What are the rules regarding these two functions? Are they automatically generated by the compiler and if so when?</p>

<hr>

<p><strong>Edit:</strong> I've updated the Wikipedia page, if anyone feels like it please help the community by editing it into shape (if needed).</p>
","87234","","<p>Keeping in mind C++0x isn't quite standard yet, this is subject to change. From the <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf"" rel=""nofollow"">FCD</a> (PDF link), move constructors and move assignment operators can indeed be explicitly defaulted, and even implicitly defaulted.<strong>*</strong></p>

<hr>

<p>I'm just going to quote (heavily abridged) a bunch of stuff that might be useful to glance at:</p>

<p>On explicitly-defaulted functions, §8.4.2/1-2:</p>

<blockquote>
  <p>A function that is explicitly defaulted shall</p>
  
  <ul>
  <li>be a special member function,  </li>
  <li>have the same declared function type as if it had been implicitly declared,  </li>
  <li>not have default arguments, and  </li>
  <li>not have an exception-specification.  </li>
  </ul>
  
  <p>If it is explicitly defaulted on its first declaration,</p>
  
  <ul>
  <li>it shall be public,  </li>
  <li>it shall not be explicit,  </li>
  <li>it shall not be virtual,  </li>
  <li>it is implicitly considered to have the same exception-specification as if it had been implicitly declared (15.4), and  </li>
  <li>in the case of a copy constructor, move constructor, copy assignment operator, or move assignment operator, it shall have the same parameter type as if it had been implicitly declared.</li>
  </ul>
</blockquote>

<p>On special member functions, §12/1:</p>

<blockquote>
  <p>The default constructor (12.1), copy constructor and copy assignment operator (12.8), move constructor and move assignment operator (12.8), and destructor (12.4) are special member functions. [ Note: The implementation will implicitly declare these member functions for some class types when the program does not explicitly declare them. The implementation will implicitly define them if they are used. See 12.1, 12.4
  and 12.8. —end note ]</p>
</blockquote>

<p>About implicitly declared functions, §12.8/8-11:</p>

<blockquote>
  <p>If the class definition does not explicitly declare a copy constructor and there is no user-declared move constructor, a copy constructor is implicitly declared as defaulted (8.4).  </p>
  
  <p>The implicitly-declared copy constructor for a class X will have the form <code>X::X(const X&amp;)</code> if  </p>
  
  <ul>
  <li>each direct or virtual base class B of X has a copy constructor whose first parameter is of type <code>const B&amp;</code> or <code>const volatile B&amp;</code>, and  </li>
  <li>for all the non-static data members of X that are of a class type M (or array thereof), each such class type has a copy constructor whose first parameter is of type <code>const M&amp;</code> or <code>const volatile M&amp;</code>.  </li>
  </ul>
  
  <p>Otherwise, the implicitly-declared copy constructor will have the form <code>X::X(X&amp;)</code>.</p>
  
  <p>If the class definition does not explicitly declare a move constructor, one will be implicitly declared as defaulted if and only if</p>
  
  <ul>
  <li>X does not have a user-declared copy constructor and  </li>
  <li>the move constructor would not be implicitly defined as deleted.  </li>
  </ul>
  
  <p>[ Note: When the move constructor is not implicitly declared or explicitly supplied, expressions that otherwise would have invoked the move constructor may instead invoke a copy constructor. —end note ]</p>
  
  <p>The implicitly-declared move constructor for class X will have the form <code>X::X(X&amp;&amp;)</code>.</p>
</blockquote>

<p>On implicitly deleted default functions, §12.8/12:</p>

<blockquote>
  <p>An implicitly-declared copy/move constructor is an inline public member of its class. A defaulted copy-/move constructor for a class X is defined as deleted (8.4.3) if X has:</p>
  
  <ul>
  <li>a variant member with a non-trivial corresponding constructor and X is a union-like class,  </li>
  <li>a non-static data member of class type M (or array thereof) that cannot be copied/moved because overload resolution (13.3), as applied to M’s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor, or  </li>
  <li>a direct or virtual base class B that cannot be copied/moved because overload resolution (13.3), as applied to B’s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor, or  </li>
  <li>for the move constructor, a non-static data member or direct or virtual base class with a type that does not have a move constructor and is not trivially copyable.</li>
  </ul>
</blockquote>

<p>§12.8/13-18 defines how the functions should work when they are implicitly generated.</p>

<p>§12.8/19 then does the same thing as §12.8/8 did, except with the copy-assignment and move-assignment operators. They are similar enough not to warrant quoting here.</p>

<p>For a more complete picture, you'll want to read those sections in their entirety, but that's the general idea. I'm glad we get implicit move semantics.</p>

<hr>

<p>*But like defaulted copy-functions, they might not always have the correct behavior! The Big Three should become The Big Five. (For example, The Big Three are implemented whenever we need to deep-copy something. We also need to make sure we do a ""deep-move"", where the source's data is nulled/reset. This is <em>not</em> done implicitly.)</p>
"
"<p>I was looking at the implementation of the <code>is_class</code> template in Boost, and ran into some syntax I can't easily decipher.</p>

<pre><code>    template &lt;class U&gt; static ::boost::type_traits::yes_type is_class_tester(void(U::*)(void));
    template &lt;class U&gt; static ::boost::type_traits::no_type is_class_tester(...);
</code></pre>

<p>How do I interpret <code>void(U::*)(void)</code> above?  I'm familiar with C, so it appears somewhat analogous to <code>void(*)(void)</code>, but I don't understand how <code>U::</code> modifies the pointer.  Can anyone help?</p>

<p>Thanks</p>
","87234","","<p>You're right, it is analogous to a function pointer. Rather, this is a pointer to member function, where the member is of the class <code>U</code>.</p>

<p>The difference in type is necessitated because member functions have an implicit <code>this</code> pointer, as they cannot be called without an instance. Getting rid of the template might make it a bit easier:</p>

<pre><code>struct foo
{
    void bar(void);
};
</code></pre>

<p><code>void(*)(void)</code> won't do, as this has no way to communicate an instance of the class. Rather, we need:</p>

<pre><code>void (foo::*)(void)
</code></pre>

<p>Indicating that this function pointer requires an instance of <code>foo</code>. </p>

<hr>

<p>For what it's worth, you use them like this:</p>

<pre><code>typedef void (foo::*func_ptr)(void);

foo f;
foo* fp = &amp;f;
func_ptr func = &amp;foo::bar;

(f.*func)();
(fp-&gt;*func)();
</code></pre>
"
"<p>I want to specialize operator&lt;&lt; but this code is not compiling;</p>

<pre><code>template&lt;&gt;

std::ostream&amp; operator&lt;&lt; &lt; my_type &gt;( std::ostream&amp; strm, my_type obj);
</code></pre>
","87234","","<p>Why not just overload?</p>

<pre><code>// no template &lt;&gt;
std::ostream&amp; operator&lt;&lt;( std::ostream&amp; strm, my_type obj);
</code></pre>

<p>You only specialize when there exists a template <em>to</em> specialize.</p>

<p><sub>Your parameter should probably be <code>const my_type&amp;</code>, to avoid a needless copy.</sub></p>
"
"<p>I'm making a very dumb mistake just wrapping a pointer to some new'ed memory in a simple class.</p>

<pre><code>class Matrix
{
  public:
    Matrix(int w,int h) : width(w),height(h)
    {           
        data = new unsigned char[width*height];
    }

    ~Matrix() { delete data;    }

    Matrix&amp; Matrix::operator=(const Matrix&amp;p)
    {  
            width = p.width;
            height = p.height;
            data= p.data;
            return *this;
    }
    int width,height;
    unsigned char *data;
}

.........
// main code
std::vector&lt;Matrix&gt; some_data;

for (int i=0;i&lt;N;i++) {
   some_data.push_back(Matrix(100,100)); // all Matrix.data pointers are the same
}
</code></pre>

<p>When I fill the vector with instances of the class, the internal data pointers all end up pointing to the same memory ?</p>
","87234","","<p>Whenever you write one of a copy-constructor, copy-assignment operator, or destructor, you should do all three. These are The Big Three, and the previous rule is The Rule of Three.</p>

<p>Right now, your copy-constructor doesn't do a deep copy. I also recommend you use the <a href=""http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom"">copy-and-swap idiom</a> whenever you implement The Big Three.* As it stands, your <code>operator=</code> is incorrect.</p>

<hr>

<p>Perhaps it's a learning exercise, but you should always give classes a single responsibly. Right now, yours has two: managing a memory resource, and being a <code>Matrix</code>. You should separate these so that you have one class that handles the resource, and another that uses said class to use the resource.</p>

<p>That utility class will need to implement The Big Three, but the user class will actually need not implement any of them, because the implicitly generated ones will be handled properly thanks to the utility class.</p>

<p>Of course, such a class already exists as <code>std::vector</code>.</p>
"
"<p>I've got a loop that looks like this:
<pre><code>
while (elapsedTime &lt; refreshRate) 
{
    timer.stopTimer();
    elapsedTime=timer.getElapsedTime();
}
</pre></code>
I read something similar to this elsewhere (<a href=""http://stackoverflow.com/questions/1222574/c-main-loop-without-100-cpu"">http://stackoverflow.com/questions/1222574/c-main-loop-without-100-cpu</a>), but this loop is running a high resolution timer that must be accurate. So how am I supposed to not take up 100% CPU while still keeping it high resolution?</p>
","87234","","<p>Typically, you yield to the OS in some fashion. This allows the OS to take a break from your program and do something else.</p>

<p>Obviously this is OS dependent, but:</p>

<pre><code>#ifdef _WIN32
    #include &lt;windows.h&gt;
#else
    #include &lt;unistd.h&gt;
#endif

void yield(void)
{
    #ifdef _WIN32
        Sleep(0);
    #else
        usleep(1);
    #endif
}
</code></pre>

<p>Insert a call to yield before you stop the timer. The OS will report less time usage by your program.</p>

<p>Keep in mind, of course, this makes your timer ""less accurate"", because it might not update as frequently as possible. But you really shouldn't depend on extreme-accuracy, it's far too difficult. Approximations are okay.</p>
"
"<p>Any idea why I get ""Maya is not Maya"" as a result for this code?</p>

<pre><code>if (""Maya"" == ""Maya"") 
   printf(""Maya is Maya \n"");
else
   printf(""Maya is not Maya \n"");
</code></pre>
","87234","","<p>The output of your program is implementation-defined.</p>

<p>A string literal has the type <code>const char[N]</code> (that is, it's an array). Whether or not each string literal in your program is represented by a unique array is <em>implementation-defined</em>. (§2.13.4/2)</p>

<p>When you do the comparison, the arrays decay into pointers (to the first element), and you do a pointer comparison. If the compiler decides to store both string literals as the same array, the pointers compare true; if they each have their own storage, they compare false. </p>

<p>To compare string's, use <code>std::strcmp()</code>, like this:</p>

<pre><code>if (std::strcmp(""Maya"", ""Maya"") == 0) // same
</code></pre>

<p>Typically you'd use the standard string class, <code>std::string</code>. It defines <code>operator==</code>. You'd need to make one of your literals a <code>std::string</code> to use that operator:</p>

<pre><code>if (std::string(""Maya"") == ""Maya"") // same
</code></pre>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/36906/what-is-the-fastest-way-to-swap-values-in-c"">What is the fastest way to swap values in C?</a>  </p>
</blockquote>



<p>How can I swap the values of two variables without using 3rd variable?</p>

<p>I want to swap (interchange) the values of two variables <code>a</code> and <code>b</code>.</p>
","87234","","<p>Typically, you don't. There's no reason not to use a third variable, just call <code>std::swap(a, b)</code> and move on with your life.</p>

<p>With integer types, you can do:</p>

<pre><code>void swap(int&amp; a, int&amp; b)
{
    if (a != b)
    {
        a ^= b;
        b ^= a;
        a ^= b;
    }
}
</code></pre>

<p>But this typically gives worse performance than just using a third variable. </p>
"
"<p>I'm writing a program to count blanks, tabs, and newlines. I remember what the escape sequence for tabs and newlines are, but what about blanks? \b? Or is that backspace?</p>
","87234","","<p>You mean ""blanks"" like in <code>""a b""</code>? That's a space: <code>' '</code>.</p>

<p>Here's a <a href=""http://www.lix.polytechnique.fr/~liberti/public/computing/prog/c/C/FUNCTIONS/escape.html"" rel=""nofollow"">list of escape sequences</a> for reference.</p>
"
"<p>Is there some books that teach the game structure:</p>

<ul>
<li>How to create a UI, menus, game flow (for example: What happens when you proceed to the next phase of the game? What are the changes to the main loop?)</li>
</ul>

<p>And also I would like to find books that really show a working, complete game code/structure with explanation, because most of the books I've found contain just practical examples for each field (such as how to use this function from the graphics engine... How to get the object displayed). I can't find ones that actually have the whole thing. </p>

<p>Any graphics engine is preferable. </p>
","87234","","<p>I think this is very important: Learn C++ <em>first</em>, then game programming strictly after!</p>

<p><a href=""http://stackoverflow.com/questions/2656168/gametutorials-com-questions-and-reviews-directx-tutorials/2656377#2656377"">I've expressed this sentiment before.</a> I tihnk the worse thing you can do is try to learn both at the same time. <a href=""http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">Get a good beginner C++ book</a>, then a good intermediate book, then start on a game programming book.</p>

<p>Here's the thing: Many ""experts"" in the field like LaMothe aren't very good C++ programmers. (In fact, many game programmers aren't very good C++ programmers.) While they certainly know the overall design of a game, if you try to learn C++ while reading their books you're going to end up with down-right terrible C++ code without any bit of modern style to it. Old C++ code with respect to game programming is often C-with-classes. That's no way to go.</p>

<p>You're much better off learning proper C++ and good, modern style. <em>Once you understand C++</em>, game programming is just the application of that knowledge in a specific field. Then nearly any book will do. (Because you'll not be stumbling over understanding the code, but rather be learning what it does.)</p>

<p>I can't recommend any start-to-end books since I haven't picked up any modern books (haven't had the need.) I do have old books from the type of author I mentioned, and I can't say I recommend it. I do have ""Game Programming All In One"", and I recommend you <em>don't</em> get this. He spends a portion of the book making a <code>CString</code> class; this is the stuff I'm talking about, just use <code>std::string</code> and move on with your life.</p>

<p>I can recommend ""Introduction to Game Development"" as a good start on game structure. It's not code rich and is a bit enthusiastic about design patterns (I hate design patterns, if code was some pattern we just had to apply we wouldn't be here.), but it's a good start.</p>

<p>Once you have gotten to an intermediate level, do start simple. Ignore the idea of getting a game loop on your first game: you should make a text adventure. Then something simple like Pong, then try making your own 2D engine and remake Pong with that.* Then make more 2D games. And after that, use someone else's engine to make 3D Pong (Pong from a perspective). Then make another simple 3D game. Then make your own engine and remake 3D Pong or some other simple game.* Then use someone else's engine to make a more complex 3D game, then improve your engine and port that game, and so on. That's how you learn game programming: trying to jump into a 3D will just dismay you.</p>

<p>But indeed, learn C++ first! </p>

<p><sub>*The purpose of remaking a game in your own engine is to separate game programming from game engine programming. Never try to do both at the same time, until you're very experienced. In the same way you should separate your learning of C++ from game programming, separate your learning of game programming from game engine programming.</sub></p>
"
"<p>I have structure for storing callback function like this:</p>

<pre><code>template&lt;class T&gt;
struct CommandGlobal : CommandBase
{
    typedef boost::function&lt;T ()&gt; Command;
    Command comm;

    virtual T Execute() const
    {
        if(comm)
            return comm();
        return NULL;
    }
};
</code></pre>

<p>Seems like it should work fine except when T is void because the Execute function wants to return a value..</p>

<p>What is the best solution to this problem?</p>

<p>Thanks!</p>
","87234","","<p>This answer is based off <a href=""http://stackoverflow.com/questions/75538/hidden-features-of-c/2176229#2176229"">this fun-fact</a>: In a function returning <code>void</code>, you can return any expression of which the type is void.</p>

<p>So the simple solution is:</p>

<pre><code>virtual T Execute() const
{
    if (comm) // boolean logic change, typo in OP?
        return comm();
    else
        return static_cast&lt;T&gt;(NULL);
}
</code></pre>

<p>When <code>T = void</code>, the last return statement is equivalent to <code>return;</code>.</p>

<hr>

<p>However, I feel this is bad design. Is <code>NULL</code> meaningful for <em>every</em> <code>T</code>? I don't think so. I would throw an exception:</p>

<pre><code>virtual T Execute() const
{
    if (comm)
        return comm();
    else
        throw std::runtime_error(""No function!"")
}
</code></pre>

<p>However, this is done <a href=""http://www.boost.org/doc/libs/1_43_0/doc/html/boost/bad_function_call.html"">automatically by Boost</a>, so your code becomes the much cleaner:</p>

<pre><code>virtual T Execute() const
{
    return comm();
}
</code></pre>

<p>You could then add additional functionality, such as:</p>

<pre><code>bool empty(void) const
{
    return !comm; // or return comm.empty() if you're the explicit type
}
</code></pre>

<p>So the user can check if it can be called prior to calling it. Of course at this point, unless your class has additional functionality you've left out for the sake of the question, I see no reason not to just use <code>boost::function</code> in the first place.</p>
"
"<h2>Situation</h2>

<p>I want to implement the Composite pattern:</p>

<pre><code>class Animal
{
public:
    virtual void Run() = 0;
    virtual void Eat(const std::string &amp; food) = 0;
    virtual ~Animal(){}
};

class Human : public Animal
{
public:
    void Run(){ std::cout &lt;&lt; ""Hey Guys I'm Running!"" &lt;&lt; std::endl; }
    void Eat(const std::string &amp; food)
    {
        std::cout &lt;&lt; ""I am eating "" &lt;&lt; food &lt;&lt; ""; Yummy!"" &lt;&lt; std::endl;
    }
};

class Horse : public Animal
{
public:
    void Run(){ std::cout &lt;&lt; ""I am running real fast!"" &lt;&lt; std::endl; }
    void Eat(const std::string &amp; food)
    {
        std::cout &lt;&lt; ""Meah!! "" &lt;&lt; food &lt;&lt; "", Meah!!"" &lt;&lt; std::endl;
    }
};

class CompositeAnimal : public Animal
{
public:
    void Run()
    {
        for(std::vector&lt;Animal *&gt;::iterator i = animals.begin();
            i != animals.end(); ++i)
        {
            (*i)-&gt;Run();
        }
    }

    // It's not DRY. yuck!
    void Eat(const std::string &amp; food)
    {
        for(std::vector&lt;Animal *&gt;::iterator i = animals.begin();
            i != animals.end(); ++i)
        {
            (*i)-&gt;Eat(food);
        }
    }

    void Add(Animal * animal)
    {
        animals.push_back(animal);
    }

private:
    std::vector&lt;Animal *&gt; animals;
};
</code></pre>

<h2>The Problem</h2>

<p>You see, for my simple requirement of the composite pattern, I end up writing a lot of the same repeating code iterating over the same array.</p>

<h2>Possible solution with macros</h2>

<pre><code>#define COMPOSITE_ANIMAL_DELEGATE(_methodName, _paramArgs, _callArgs)\
    void _methodName _paramArgs                                      \
    {                                                                \
        for(std::vector&lt;Animal *&gt;::iterator i = animals.begin();     \
            i != animals.end(); ++i)                                 \
        {                                                            \
            (*i)-&gt;_methodName _callArgs;                             \
        }                                                            \
    }
</code></pre>

<p>Now I can use it like this:</p>

<pre><code>class CompositeAnimal : public Animal
{
public:
    // It ""seems"" DRY. Cool

    COMPOSITE_ANIMAL_DELEGATE(Run, (), ())
    COMPOSITE_ANIMAL_DELEGATE(Eat, (const std::string &amp; food), (food))

    void Add(Animal * animal)
    {
        animals.push_back(animal);
    }

private:
    std::vector&lt;Animal *&gt; animals
};
</code></pre>

<h2>The question</h2>

<p>Is there a way to do it ""cleaner"" with C++ meta-programming?</p>

<h2>The harder question</h2>

<p><code>std::for_each</code> has been suggested as a solution. I think our problem here is a specific case of the more general question, let's consider our new macro:</p>

<pre><code>#define LOGGED_COMPOSITE_ANIMAL_DELEGATE(_methodName, _paramArgs, _callArgs)\
    void _methodName _paramArgs                                      \
    {                                                                \
        log &lt;&lt; ""Iterating over "" &lt;&lt; animals.size() &lt;&lt; "" animals"";    \
        for(std::vector&lt;Animal *&gt;::iterator i = animals.begin();     \
            i != animals.end(); ++i)                                 \
        {                                                            \
            (*i)-&gt;_methodName _callArgs;                             \
        }                                                            \
        log &lt;&lt; ""Done""                                                \
    }
</code></pre>

<p>Looks like this can't be replaced by <code>for_each</code></p>

<h2>Aftermath</h2>

<p>Looking at GMan's excellent answer, this part of C++ is definitely non-trivial. Personally, if we just want to reduce the amount of boilerplate code, I think macros probably is the right tool for the job for this particular situation.</p>

<p>GMan suggested <code>std::mem_fun</code> and <code>std::bind2nd</code> to return functors. Unfortunately, this API doesn't support 3 parameters (I can't believe something like this got released into the STL).</p>

<p>For illustrative purpose, here're the delegate functions using <code>boost::bind</code> instead:</p>

<pre><code>void Run()
{
    for_each(boost::bind(&amp;Animal::Run, _1));
}

void Eat(const std::string &amp; food)
{
    for_each(boost::bind(&amp;Animal::Eat, _1, food));
}
</code></pre>
","87234","","<p>I'm not sure I really see the problem, per se. Why not something like:</p>

<pre><code>void Run()
{
    std::for_each(animals.begin(), animals.end(),
                    std::mem_fun(&amp;Animal::Run));
}

void Eat(const std::string &amp; food)
{
    std::for_each(animals.begin(), animals.end(),
                    std::bind2nd(std::mem_fun(&amp;Animal::Eat), food));
}
</code></pre>

<p>Not too bad.</p>

<hr>

<p>If you really wanted to get rid of the (small) boilerplate code, add:</p>

<pre><code>template &lt;typename Func&gt;
void for_each(Func func)
{
    std::for_each(animals.begin(), animals.end(), func);
}
</code></pre>

<p>As a private utility member, then use that:</p>

<pre><code>void Run()
{
    for_each(std::mem_fun(&amp;Animal::Run));
}

void Eat(const std::string &amp; food)
{
    for_each(std::bind2nd(std::mem_fun(&amp;Animal::Eat), food));
}
</code></pre>

<p>A bit more concise. No need for meta-programming.</p>

<p>In fact, meta-programming will ultimately fail. You're trying to generate functions, which are defined textually. Meta-programming cannot generate text, so you'll inevitably use a macro somewhere to generate text.</p>

<p>At the next level, you'd write the function then try to take out the boilerplate code. <code>std::for_each</code> does this quite well. And of course as has been demonstrated, if you find <em>that</em> to be too much repetition, just factor that out as well.</p>

<hr>

<p>In response to the <code>LoggedCompositeAnimal</code> example in the comment, your best bet is to make something akin to:</p>

<pre><code>class log_action
{
public:
    // could also take the stream to output to
    log_action(const std::string&amp; pMessage) :
    mMessage(pMessage),
    mTime(std::clock())
    {
        std::cout &lt;&lt; ""Ready to call "" &lt;&lt; pMessage &lt;&lt; std::endl;
    }

    ~log_action(void)
    {
        const std::clock_t endTime = std::clock();

        std::cout &lt;&lt; ""Done calling "" &lt;&lt; pMessage &lt;&lt; std::endl;
        std::cout &lt;&lt; ""Spent time: "" &lt;&lt; ((endTime - mTime) / CLOCKS_PER_SEC)
                    &lt;&lt; "" seconds."" &lt;&lt; std::endl;
    }

private:
    std::string mMessage;
    std::clock_t mTime;
};
</code></pre>

<p>Which just mostly automatically logs actions. Then:</p>

<pre><code>class LoggedCompositeAnimal : public CompositeAnimal
{
public:
    void Run()
    {
        log_action log(compose_message(""Run""));
        CompositeAnimal::Run();
    }

    void Eat(const std::string &amp; food)
    {
        log_action log(compose_message(""Eat""));
        CompositeAnimal::Eat(food);
    }

private:
    const std::string compose_message(const std::string&amp; pAction)
    {
        return pAction + "" on "" +
                    lexical_cast&lt;std::string&gt;(animals.size()) + "" animals."";
    }
};
</code></pre>

<p>Like that. <sub>Information on <a href=""http://stackoverflow.com/questions/1243428/convert-string-to-int-with-bool-fail-in-c/1243435#1243435"">lexical_cast</a>.</sub></p>
"
"<p>Does Visual Studio C++ 2008/2010 support <code>_mm_malloc</code> officially? It is defined in <code>malloc.h</code> but I can't find its description in the MSDN library.</p>
","87234","","<p>Doesn't answer your question directly, but I think you're suppose to use <a href=""http://msdn.microsoft.com/en-us/library/8z34s9c6%28VS.80%29.aspx"" rel=""nofollow""><code>_aligned_malloc</code></a>. If my understanding is correct, <code>_mm_malloc</code> is for Intel compilers.</p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/1717773/which-sorting-algorithm-is-used-by-stls-listsort"">Which sorting algorithm is used by STL&rsquo;s list::sort()?</a>  </p>
</blockquote>



<p>Which sorting algorithm can be used for sorting std::list ?</p>
","87234","","<p>It's implementation defined. However, it must follow these restrictions (§23.2.​2.4):</p>

<blockquote>
  <p>Stable: the relative order of the equivalent elements is preserved.<br>
  Complexity: Approximately NlogN comparisons, where N == size().</p>
</blockquote>

<p>So it's a stable sort with <code>O(nlog n)</code>.</p>
"
"<p>I guess I'm not understanding something about C++:</p>

<p>I have this code:</p>

<pre><code>#include ""window.h""

int main(int argc, char* argv[]) {
    Gtk::Main kit(argc, argv);
    window win();
    Gtk::Main::run(win);

    return EXIT_SUCCESS;
}
</code></pre>

<p>'window' is a class that inherits from Gtk::Window with an empty constructor.  When I try to compile this code, I get this error:</p>

<pre><code>no matching function for call to ‘Gtk::Main::run(window (&amp;)())
</code></pre>

<p>However, if I change the line:</p>

<pre><code>window win();
</code></pre>

<p>to</p>

<pre><code>window win;
</code></pre>

<p>then the code compiles.  How do the presence/absence of the parentheses change things?  I've run into this before and never understood what was going on.  What's happening?</p>
","87234","","<p>Because <code>window win();</code> is the declaration of a function taking no parameters and returning a <code>window</code>. (Hence the error saying no matching call for <code>window (&amp;)()</code>, which is that type.)</p>

<p>This is known as the ""Most Vexing Parse.""</p>
"
"<p>Let's say that I have a list of data: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} where n = 10 elements</p>

<p>I'd like to randomly choose k elements of this set to form a sublist, say k = 5.</p>

<p>In that case, I could end up with a sublist that looks like {9, 3, 5, 2, 7}</p>

<p>I could accomplish this by:<ul>
<li>Randomly determining an offset within the list, between 0 and the current size of the list minus 1</li><li>Appending that element to my sublist</li><li>Erasing that element from the original list</li><li>Repeat until the desired size is found</li></ul></p>

<p>The problem with this is that as the original list grows the offset and deletion time grows as well, and for any significantly large list (say over 1,000,000 elements), it takes quite a long time to perform this algorithm.</p>

<p>Is there a faster way to generate a random sequence from a list of given data? The implementation of the random number generator should be set aside for this problem, instead, focusing on how the RNG result is used in a proposed algorithm.</p>

<p>Any thoughts?</p>

<p>Right now I'm using the C++ STL list</p>
","87234","","<p>I would use <a href=""http://www.cplusplus.com/reference/algorithm/random_shuffle/"" rel=""nofollow""><code>random_shuffle</code></a>. You can change the generator by supplying a third parameter.</p>

<p>It requires random access iterators, so you can either switch to a <code>std::vector</code> (which is generally far superior and preferred over <code>std::list</code>, arguably the worse container), or just operate on some array. I'll demonstrate both:</p>

<pre><code>int data[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
std::random_shuffle(data, data + 10); 

// or

std::vector data; // populate it
std::random_shuffle(data.begin(), data.end());
</code></pre>

<p>Now everything is in random order, just treat the fist <code>k</code> elements as your subset:</p>

<pre><code>// now treat data[0] through data[k] as your random subset, or:
std::vector subset(data, data + k);

// or
data.resize(k); // shrink vector
</code></pre>

<hr>

<p>Note that in another question, Jerry <a href=""http://stackoverflow.com/questions/2394246/algorithm-to-select-a-single-random-combination-of-values/2394292#2394292"">shares an excellent way</a> of doing what you want.</p>
"
"<p>A student of mine submitted some C++ code similar to the following one. The code compiles and runs, but the <code>throw</code> statement produces the following message:</p>

<blockquote>
  <p>terminate called after throwing an instance of 'int'</p>
</blockquote>

<p>If I make the function <code>void</code> the compiler complains</p>

<blockquote>
  <p>invalid use of ‘void’</p>
</blockquote>

<p>on the line that contains the <code>throw</code> statement (expectedly).</p>

<pre><code>class TestClass
{
public:
    int MyException()
    {
        return 0;
    }

    void testFunc()
    {
        throw MyException();
    }
};


int main(int argc, char** argv)
{
    TestClass tc;
    tc.testFunc();

    return 0;
}
</code></pre>

<p><em>So, how does C++ interpret <code>MyException</code> since the code is ""correct"" ?</em></p>
","87234","","<p>It calls the function: <code>MyException()</code>, then throws the returned <code>int</code>. A more complete example:</p>

<pre><code>struct foo
{
    int bar(void) const
    {
        return 123456789;
    }

    void baz(void) const
    {
        throw bar();
    }
};

int main(void)
{
    try
    {
        foo f;
        f.baz(); // throws exception of type int, caught below
    }
    catch (int i)
    {
        // i is 123456789
    }
}
</code></pre>

<p>Without the try-catch block, the exception propagates out of main, where <code>terminate()</code> is called.</p>

<p>Note that throwing things that don't derive from <code>std::exception</code> is frowned upon. It's expected that you be able to catch meaningful exceptions by <code>catch (const std::exception&amp;)</code>.</p>
"
"<p>Is the following valid?:</p>

<pre><code>template&lt;typename T&gt; class C { C1&lt;C2&lt;T&gt;&gt; someMember; };
</code></pre>
","87234","","<p>Well, you'd need to do something with the type, either make it a typedef or member, but yes:</p>

<pre><code>template &lt;typename T&gt;
struct C1 {};

template &lt;typename T&gt;
struct C2 {};

template &lt;typename T&gt;
struct C
{
    typedef C1&lt;C2T&gt; &gt; type; // note the space!
};
</code></pre>

<p><code>&gt;&gt;</code> is actually the right shift operator, so you need a space in there for it to work correctly. In C++0x, however, you can just type <code>&gt;&gt;</code>; it is parsed just fine.*</p>

<p><sub>*Some lenient compilers will currently accept it.</sub></p>
"
"<p>Let's say you have a c++0x std::array member of a template class and you want to initialize it by means of a constructor that takes a couple of iterators:</p>

<pre><code>template &lt;typename Tp, size_t N&gt;
class Test 
{
public:
    template &lt;typename Iterator&gt;
    Test(Iterator first, Iterator last)
    {
        if (std::distance(first,last) &gt; N )
            throw std::runtime_error(""bad range"");
        std::copy(first, last, _M_storage.begin());
    }

private:
    std::array&lt;Tp, N&gt; _M_storage;

};
</code></pre>

<p>Assuming that you are providing a range congruent with the size of your storage, is it possible to initialize the std::array in the constructor initializer, avoiding the superflous default constructors of Tps in the storage? Is it possible to exploit the std::initializer_list&lt;> in this case?</p>
","87234","","<p>No.</p>

<p><code>std::array</code> is an aggregate, so you get no special functionality like constructors taking iterators. (This actually surprises me, with the introduction of <code>std::initializer_list</code> I see no harm in making other useful constructors. Perhaps a question is in store.)</p>

<p>This means the only way to use iterators to copy data inside the array is to iterate, and to do that the <code>array</code> must be already constructed and ready to use.</p>
"
"<p>Consider the following source code. I have two classes CBar and CFoo. CFoo inherits from CBar. The output of this source code is </p>

<pre><code>Bar 
Foo 
Bar 
</code></pre>

<p>I was expecting </p>

<pre><code>Bar 
Foo 
Foo
</code></pre>

<p>Where did I go wrong?
What I was thinking was that since the CFoo object has a Speak function that overrides the CBar speak function. When I call The Speak() function from a CBar function on an object that is CFoo the CFoo Speak function would be executed.  But that assumption appears to be wrong. </p>

<pre><code>class CBar
{
    public:
        void Speak() { 
            printf("" Bar \n""); 
        }

        void DoStuff() {
            this-&gt;Speak(); 
        }
};


class Cfoo : public CBar 
{
    public:
        void Speak() { 
            printf("" Foo \n""); 
        }

        void DoStuff() {
            CBar::DoStuff(); 
        }
};



int _tmain(int argc, _TCHAR* argv[])
{
    CBar b;
    b.Speak(); 

    Cfoo f;
    f.Speak();

    f.DoStuff(); 
    return 0;
}
</code></pre>
","87234","","<p><code>Speak</code> is not a polymorphic function.</p>

<p>That is, because it isn't marked <code>virtual</code> any calls to it are determined statically. So within <code>CBar</code>, <code>this-&gt;Speak();</code> will always refer to <code>CBar::Speak</code>.</p>

<p>If you make the function virtual, a call to the function will be chosen based off the dynamic type, not the static type, and the call you expect will be made.</p>
"
"<p>I have a structure Defined in the Header file for a class i am working in, and i am trying to use the Struct in one of the methods of the class. It looks basically like this:</p>

<pre><code>struct example
{
     double a;
     int b;
     ...
};
</code></pre>

<p>in the header above my class definition, and then in the cpp file, i have:</p>

<pre><code>void exampleclass::test(){

    struct example *teststruct;
    teststruct-&gt;a = 0; //This line causes a access violation

}
</code></pre>

<p>why do i get an error here? Im sure im doing something clompletly wrong here, and i must say im a huge structure rookie. </p>
","87234","","<p><code>struct example *teststruct;</code> is a pointer to an instance of the struct <code>example</code>. (By the way, C++ does not require the <code>struct</code> prefix, leave it off.)</p>

<p>So, what <code>example</code> are you pointing at? (Hint: none, you haven't initialized the variable.) You could dynamically allocate one: <code>example *teststruct = new example();</code>, and later delete it: <code>delete teststruct;</code>.*</p>

<p>Of course, you should prefer automatic (stack) allocation over dynamic allocation, and just do:</p>

<pre><code>example teststruct;
teststruct.a = 0;
</code></pre>

<p><sub>*And you should never actually handle raw allocations like this. Put them in a smart pointer. At the very least, <code>std::auto_ptr</code>.</sub></p>
"
"<p>I have a templatized container class in C++ which is similar to a std::map (it's basically a thread-safe wrapper around the std::map).  I'd like to write a member function which dumps information about the entries in the map.  Obviously, however, I don't know the type of the objects in the map or their keys.  The goal is to be able to handle the basic types (integers, strings) and also some specific class types that I am particularly interested in.  For any other class, I'd like to at least compile, and preferably do something somewhat intelligent, such as print the address of the object.  My approach so far is similar to the following (please note, I didn't actually compile this or anything...):</p>

<pre><code>template&lt;typename Index, typename Entry&gt;
class ThreadSafeMap
{
    std::map&lt;Index, Entry&gt; storageMap;
    ...
    dumpKeys()
    {
        for(std::map&lt;Index, Entry&gt;::iterator it = storageMap.begin();
            it != storageMap.end();
            ++it)
        {
            std::cout &lt;&lt; it-&gt;first &lt;&lt; "" =&gt; "" &lt;&lt; it-&gt;second &lt;&lt; endl;
        }
    }
    ...
}
</code></pre>

<p>This works for basic types.  I can also write custom stream insertion functions to handle specific classes I'm interested in.  However, I can't figure out a good way to handle the default case where <code>Index</code> and/or <code>Entry</code> is an unhandled arbitrary class type.  Any suggestions?</p>
","87234","","<p>I originally had just a more canonical way of using <a href=""http://stackoverflow.com/questions/3312486/c-how-to-print-an-object-of-uknown-type/3312735#3312735"">Staffan's answer</a>. However, jpalecek correctly pointed out a large flaw with the approach.</p>

<p>As it stood, if no <em>explicit</em> insertion operator is found, the templated insertion operator kicks in and defines a perfect match; this destroys any possibility for existing implicit conversions.</p>

<p>What must be done is make that template insertion operator a conversion (while maintain it's generality), so other conversions can be considered. Once no others are found, <em>then</em> it will be converted to the generic insertion operator.</p>

<p>The utility code is as such:</p>

<pre><code>#include &lt;iosfwd&gt;
#include &lt;memory&gt;

namespace outputter_any_detail
{
    // your generic output function
    template &lt;typename T&gt;
    std::ostream&amp; output_generic(std::ostream&amp; pStream, const T&amp; pX)
    {
        // note: safe from recursion. if you accidentally try 
        // to output pX again, you'll get a compile error
        return pStream &lt;&lt; ""unknown type at address: "" &lt;&lt; &amp;pX;
    }

    // any type can be converted to this type,
    // but all other conversions will be 
    // preferred before this one
    class any
    {
    public:
        // stores a type for later output
        template &lt;typename T&gt;
        any(const T&amp; pX) :
        mPtr(new any_holder&lt;T&gt;(pX))
        {}

        // output the stored type generically
        std::ostream&amp; output(std::ostream&amp; pStream) const
        {
            return mPtr-&gt;output(pStream);
        }

    private:
        // hold any type
        class any_holder_base
        {
        public:
            virtual std::ostream&amp; output(std::ostream&amp; pStream) const = 0;
            virtual ~any_holder_base(void) {}
        };

        template &lt;typename T&gt;
        class any_holder : public any_holder_base
        {
        public:
            any_holder(const T&amp; pX) :
            mX(pX)
            {}

            std::ostream&amp; output(std::ostream&amp; pStream) const
            {
                return output_generic(pStream, mX);
            }

        private:
            const T&amp; mX;
            any_holder&amp; operator=(const any_holder&amp;);
        };

        std::auto_ptr&lt;any_holder_base&gt; mPtr;
        any&amp; operator=(const any&amp;);
    };

    // hidden so the generic output function
    // cannot accidentally call this fall-back
    // function (leading to infinite recursion)
    namespace detail
    {
        // output a type converted to any. this being a conversion allows
        // other conversions to partake in overload resolution
        std::ostream&amp; operator&lt;&lt;(std::ostream&amp; pStream, const any&amp; pAny)
        {
            return pAny.output(pStream);
        }
    }

    // a transfer class, to allow
    // a unique insertion operator
    template &lt;typename T&gt;
    class outputter_any
    {
    public:
        outputter_any(const T&amp; pX) :
          mX(pX)
          {}

          const T&amp; get(void) const
          {
              return mX;
          }

    private:
        const T&amp; mX;
        outputter_any&amp; operator=(const outputter_any&amp;);
    };

    // this is how outputter_any's get outputted,
    // found outside the detail namespace by ADL
    template &lt;typename T&gt;
    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; pStream, const outputter_any&lt;T&gt;&amp; pX)
    {
        // bring in the fall-back insertion operator
        using namespace detail;

        // either a specifically defined operator,
        // or the generic one via a conversion to any
        return pStream &lt;&lt; pX.get();
    }
}

// construct an outputter_any
template &lt;typename T&gt;
outputter_any_detail::outputter_any&lt;T&gt; output_any(const T&amp; pX)
{
    return outputter_any_detail::outputter_any&lt;T&gt;(pX);
}
</code></pre>

<p>Stick it in some header like <code>""output_any.hpp""</code>. And you use it as such:</p>

<pre><code>#include &lt;iostream&gt;
#include ""output_any.hpp""    

struct foo {}; 
struct A {}; 
struct B : A {};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const A&amp;)
{
    return o &lt;&lt; ""A"";
}

int main(void)
{
    foo f;
    int i = 5;
    B b;

    /*

    Expected output:
    unknown type at address: [address]
    5
    [address] 
    A
    */                                       // output via...  
    std::cout &lt;&lt; output_any(f) &lt;&lt; std::endl; // generic
    std::cout &lt;&lt; output_any(i) &lt;&lt; std::endl; // int
    std::cout &lt;&lt; output_any(&amp;i) &lt;&lt; std::endl;// void*
    std::cout &lt;&lt; output_any(b) &lt;&lt; std::endl; // const A&amp;
}
</code></pre>

<p>Let me know if something doesn't make sense. </p>
"
"<p>I was reading Google C++ Style Guide, and got confused in the <a href=""http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Exceptions#Exceptions"">Exceptions</a> part. One of the cons of using it, according to the guide is:</p>

<blockquote>
  <p>Exception safety requires both RAII
  and different coding practices. Lots
  of supporting machinery is needed to
  make writing correct exception-safe
  code easy. Further, to avoid requiring
  readers to understand the entire call
  graph, exception-safe code must
  isolate logic that writes to
  persistent state into a ""commit""
  phase. This will have both benefits
  and costs (perhaps where you're forced
  to obfuscate code to isolate the
  commit). Allowing exceptions would
  force us to always pay those costs
  even when they're not worth</p>
</blockquote>

<p>Specifically, the statement that I didn't understand is this:</p>

<blockquote>
  <p>(...) exception-safe code must isolate
  logic that writes to persistent state
  into a ""commit"" phase.</p>
</blockquote>

<p>and this:</p>

<blockquote>
  <p>(...) perhaps where you're forced to
  obfuscate code to isolate the commit (...).</p>
</blockquote>

<p>I think I'm not used to the terms ""persistent state"", ""commit phase"", ""obfuscate code to isolate the commit"". It'd be nice some small explanations, examples or references about these terms and possibly why this is true.</p>
","87234","","<p>Basically, modern C++ uses Scope-Bound Resource Management (SBRM, or RAII). That is, an object cleans up a resource in its destructor, which is guaranteed to be called.</p>

<p>This is all fine and dandy, unless your code isn't modern. For example:</p>

<pre><code>int *i = new int();
do_something(i);
delete i;
</code></pre>

<p>If <code>do_something</code> throws an exception, you've leaked. The correct solution is to not have the resource out in the wild like that, i.e.:</p>

<pre><code>std::auto_ptr&lt;int&gt; i(new int());
do_something(i.get());
</code></pre>

<p>Now it can never leak (and the code is cleaner!).</p>

<p>I think what the guide is trying to say is that we already have all this old code, and using a modern style would take too much effort. So let's not use exceptions. (Rather than fix all the code...I dislike the Google Style Guide very much.)</p>
"
"<p>I have seen this in some book/ tutorial.</p>

<p>When you pass in the head pointer (of linked list) into a function, you need to pass it as a double pointer.</p>

<p>For eg:
// This is to reverse a linked list where head points to first node.</p>

<pre><code>void nReverse(digit **head)
{
    digit *prev=NULL;
    digit *curr=*head;
    digit *next;

    while(curr!=NULL)
    {
        next=curr-&gt;next;
        curr-&gt;next=prev;
        prev=curr;
        curr=next;
    }
    *head=prev;
    return;
}
</code></pre>

<p>This works fine.</p>

<p>It also works when I use single pointer like, </p>

<pre><code>void nReverse(digit *head)
{
    digit *prev=NULL;
    digit *curr=head;
    digit *next;

    while(curr!=NULL)
    {
        next=curr-&gt;next;
        curr-&gt;next=prev;
        prev=curr;
        curr=next;
    }
    head=prev;
    return;
}
</code></pre>

<p>I tried printing the list by using the head pointer. Both the functions work fine.</p>

<p>Am I missing something ? </p>

<p>Thanks,</p>
","87234","","<p>This is very C-like code, not C++.</p>

<p>Basically, when something is passed by-value the function operates on a copy of the data:</p>

<pre><code>void foo(int i)
{
    i = 5; // copy is set to 5
}

int x = 7;
foo(x);
// x is still 7
</code></pre>

<p>In C, you instead pass a pointer to the variable, and can change it that way:</p>

<pre><code>void foo(int* i)
{
    *i = 5; // whatever i points to is set to 5
}

int x = 7;
foo(&amp;x);
// x is 5
</code></pre>

<p>For you, instead of an <code>int</code> it's a <code>digit*</code>. (Resulting in a pointer to pointer.)</p>

<hr>

<p>In C++, references were introduced. A reference is an alias to another object. So you'd do something like this:</p>

<pre><code>void foo(int&amp; i) // i is an alias to another value
{
    i = 5; // x is set to 5
}

int x = 7;
foo(x); // pass x as alias, not address of x.
// x is 5
</code></pre>

<p>A reference is generally preferred, since it enforces that you actually refer to an object, and simplifies both calling and operating code.</p>

<p>Of course in C++ you wouldn't implement a list yourself, you'd use <code>std::list</code>.</p>
"
"<p>Just trying to mess around with Qt and SQLite to get familiar with how things work- I haven't really done DB programming since my vb6 days, so please be easy ;]</p>

<p>I'm just trying to get the result of a query and I'm trying to follow some examples I found online (namely <a href=""http://wiki.forum.nokia.com/index.php/CS001507_-_Searching_for_data_in_a_database_in_Qt"" rel=""nofollow"">this</a> one). The process seems simple enough: create the QSqlQuery object, have it execute a query, check that something came back, and just get the value. When doing this, I'm getting an error. Code follows:</p>

<pre><code>bool DatabaseManager::structureDB(){
    QSqlQuery query;
    query.exec(""CREATE TABLE mytable""
                      "" (id integer primary key,""
                      "" firstname varchar(20),""
                      "" lastname varchar(20),""
                      "" age integer)"");

    QSqlQuery query2;
    query2.exec(""pragma table_info(mytable)"");

    if(query2.first()){
        QString test = query2.value(0).toString(); // Error line
        qDebug()&lt;&lt;test;
        return true;
    }
    return false;
}
</code></pre>

<p>The error I am getting is:  </p>

<pre><code>error: invalid use of incomplete type 'struct QVariant'
</code></pre>

<p>On the line commented above. I'm not sure what this error means or what I'm doing wrong, can someone please help? Thanks so much!</p>
","87234","","<p>Basically, the type is declared but not defined, like this:</p>

<pre><code>struct QVariant;
</code></pre>

<p>Once you try to use it, it needs to be defined, like this:</p>

<pre><code>struct QVariant
{
    // stuff goes here
};
</code></pre>

<p>The error is telling you it's <em>incomplete</em> (declared but not defined), and therefore not usable. You should include the header <code>&lt;QVariant&gt;</code> to get the definition of <code>QVariant</code>, to make it <em>complete</em> and therefore usable.</p>
"
"<p>If a window is closed (like with sending <code>WM_CLOSE</code>), are the destructors of objects called?</p>

<p>I followed my source code with a break point in that situation, but the compiler doesn't seem to pass through my destructor.</p>

<p>Is the program closed without calling any destructors?</p>
","87234","","<p>I'm not too sure I understand, but let's say you've got a window setup with a typical <code>WndProc</code> and you're pumping messages with something akin to:</p>

<pre><code>while (GetMessage(&amp;msg, hwnd, 0, 0) &gt; 0)
{ 
    TranslateMessage(&amp;msg); 
    DispatchMessage(&amp;msg); 
}
</code></pre>

<p>When the window finishes (processes <code>WM_DESTROY</code>, after <code>WM_CLOSE</code> posts is handled and called <code>DestroyWindow</code>), this loop will end, and you'll continue normal execution.</p>

<p>In other words, the window isn't anything too special, but while it's up you're pretty much stuck in this loop. You get the same cleanup as always. </p>
"
"<p>I have a typedef, a class with a member vector using that type and then a method using std::&lt;vector&gt;::erase().</p>

<pre><code>#typedef DWORD WordNo_t;

class CWordList : public CObject
{
public:
WordNo_t* begin() { return m_Words.begin(); }
WordNo_t* end()   { return m_Words.end(); }
void truncate (WordNo_t *Ptr)
{
  if (Ptr == end())
    return;
  ASSERT (Ptr &gt;= begin() &amp;&amp; Ptr &lt; end());
  // following line generates C2664
  m_Words.erase (Ptr, end());
}

private:
  std:vector&lt;WordNo_t&gt; m_Words;
}
</code></pre>

<p>The detailed error is:<br>
error C2664: 'std::_Vector_iterator&lt;_Myvec> std::vector&lt;_Ty>::erase(std::_Vector_const_iterator&lt;_Myvec>,std::_Vector_const_iterator&lt;_Myvec>)' : cannot convert parameter 1 from 'const WordNo_t' to 'std::_Vector_const_iterator&lt;_Myvec>'</p>

<p>Pretty new to STL... Any help would be appreciated.</p>
","87234","","<p>I'm surprised <code>begin</code> and <code>end</code> are even compiling, they shouldn't. <code>std::vector</code> (and friends) use iterators, not pointers. (Though they are intended to act similarly.)</p>

<p>In any case, <code>erase</code> takes an iterator, not a pointer. Because vectors are contiguous, you can make utility functions as such, though:</p>

<pre><code>template &lt;typename T, typename A&gt;
typename std::vector&lt;T, A&gt;::iterator
to_iterator(T* pPtr, std::vector&lt;T, A&gt;&amp; pVec)
{
    ASSERT(pPtr &gt;= &amp;pVec.front() &amp;&amp; pPtr &lt;= &amp;pVec.back());

    return pVec.begin() + (pPtr- &amp;pVec[0]);
}

template &lt;typename T, typename A&gt;
typename std::vector&lt;T, A&gt;::const_iterator
to_iterator(const T* pPtr, const std::vector&lt;T, A&gt;&amp; pVec)
{
    ASSERT(pPtr &gt;= &amp;pVec.front() &amp;&amp; pPtr &lt;= &amp;pVec.back());

    return pVec.begin() + (pPtr - &amp;pVec[0]);
}
</code></pre>

<p>Basically, find out how many elements <code>pPtr</code> is from <code>&amp;pVec[0]</code> (the first element), then add that to <code>pVec.begin()</code>. (Transform the offset from a pointer and the pointer to start into the offset from the start.) This operation is O(1). And then:</p>

<pre><code>void truncate (WordNo_t *Ptr)
{
    // note the == end() bit will be in here anyway:
    m_Words.erase(to_iterator(Ptr, m_Words), end());
}
</code></pre>
"
"<p>In C++, when you have a function that takes a reference to an object, how can you pass an object pointer to it?</p>

<p>As so:</p>

<pre><code>Myobject * obj = new Myobject();

somefunc(obj);  //-&gt; Does not work?? Illegal cast??

somefunc(Myobject&amp; b)
{
 // Do something
}
</code></pre>
","87234","","<p>Just dereference the pointer, resulting in the lvalue:</p>

<pre><code>somefun(*obj);
</code></pre>
"
"<p>Can anybody explain the difference between </p>

<pre><code>#define int* char
</code></pre>

<p>and </p>

<pre><code>typedef int* char;
</code></pre>
","87234","","<p>There's no difference because both are illegal.</p>

<p><code>int*</code> isn't a valid identifier for a macro, and even if you put a space in, neither is <code>int</code>, because it's a keyword and reserved. Even if you switched it to your likely intended <code>#define char int*</code>, it fails for the same reason.</p>

<p>And you cannot redefine the type <code>char</code>, so the <code>typedef</code> is a bust.</p>

<hr>

<p>The difference, had you given examples that were legal, is that <code>#define</code> is a preprocessing directive. It only does textual replacement, before the compiling stage. Contrarily <code>typedef</code> defines a new type, and that new type identifier respects ""the rules"" just like any other type.</p>
"
"<p>I have a function named <code>_push</code> which can handle different parameters, including tuples, and is supposed to return the number of pushed elements.</p>

<p>For example, <code>_push(5)</code> should push '5' on the stack (the <a href=""http://www.lua.org/manual/5.1/manual.html#lua_pushinteger"" rel=""nofollow"">stack of lua</a>) and return 1 (because one value was pushed), while <code>_push(std::make_tuple(5, ""hello""))</code> should push '5' and 'hello' and return 2.</p>

<p>I can't simply replace it by <code>_push(5, ""hello"")</code> because I sometimes use <code>_push(foo())</code> and I want to allow <code>foo()</code> to return a tuple.</p>

<p>Anyway I can't manage to make it work with tuples:</p>

<pre><code>template&lt;typename... Args, int N = sizeof...(Args)&gt;
int _push(const std::tuple&lt;Args...&gt;&amp; t, typename std::enable_if&lt;(N &gt;= 1)&gt;::type* = nullptr) {
 return _push&lt;Args...,N-1&gt;(t) + _push(std::get&lt;N-1&gt;(t));
}

template&lt;typename... Args, int N = sizeof...(Args)&gt;
int _push(const std::tuple&lt;Args...&gt;&amp; t, typename std::enable_if&lt;(N == 0)&gt;::type* = nullptr) {
 return 0;
}
</code></pre>

<p>Let's say you want to push a <code>tuple&lt;int,bool&gt;</code>. This is how I expect it to work:</p>

<ul>
<li><code>_push&lt;{int,bool}, 2&gt;</code> is called (first definition)</li>
<li><code>_push&lt;{int,bool}, 1&gt;</code> is called (first definition)</li>
<li><code>_push&lt;{int,bool}, 0&gt;</code> is called (second definition)</li>
</ul>

<p>However with g++ 4.5 (the only compiler I have which supports variadic templates), I get an error concerning <code>_push&lt;Args...,N-1&gt;(t)</code> (line 3) saying that it couldn't find a matching function to call (without any further detail). I tried without the ""..."" but I get another error saying that the parameters pack is not expanded.</p>

<p>How can I fix this?</p>

<p><em>PS: I know that you can do this using a template struct (this is in fact what I was doing before), but I'd like to know how to do it with a function</em></p>

<p><em>PS 2: PS2 is solved, thanks GMan</em></p>
","87234","","<p>I don't have a compiler to test any of this, so you'll have to report any issues.</p>

<p>The following should allow you to iterate across a tuple calling a function. It's based off your logic, with a few minor changes. (<code>N</code> is a <code>std::size_t</code>, it's the first parameter to allow <code>Args</code> (and <code>Func</code>) to be deduced on further calls, it just calls some function instead of performing a specific task). Nothing too drastic:</p>

<pre><code>namespace detail
{
    // just to keep things concise and readable
    #define ENABLE_IF(x) typename std::enable_if&lt;(x)&gt;::type

    // recursive case
    template &lt;std::size_t N, typename... Args, typename Func&gt;
    ENABLE_IF(N &gt;= 1) iterate(const std::tuple&lt;Args...&gt;&amp; pTuple, Func&amp; pFunc)
    {
        pFunc(std::get&lt;N - 1&gt;(pTuple));

        iterate&lt;N - 1&gt;(pTuple, pFunc);
    }

    // base case
    template &lt;std::size_t N, typename... Args, typename Func&gt;
    ENABLE_IF(N == 0) iterate(const std::tuple&lt;Args...&gt;&amp;, Func&amp;)
    {
        // done
    }
}

// iterate tuple
template &lt;typename... Args, typename Func&gt;
Func iterate(const std::tuple&lt;Args...&gt;&amp; pTuple, Func pFunc)
{
    detail::iterate&lt;sizeof...(Args)&gt;(pTuple, pFunc);

    return pFunc;
}
</code></pre>

<p>Assuming that all works, you then just have:</p>

<pre><code>struct push_lua_stack
{
    // constructor taking reference to stack to push onto
    // initialize count to 0, etc....

    template &lt;typename T&gt;
    void operator()(const T&amp; pX)
    {
        // push pX onto lua stack
        ++count;
    }

    std::size_t count;
};
</code></pre>

<p>And lastly:</p>

<pre><code>std::size_t pushCount = iterate(someTuple, push_lua_stack()).count;
</code></pre>

<p>Let me know if that all makes sense.</p>

<hr>

<p>Since you seem to really be seriously against structs for some reason, just make a function like this:</p>

<pre><code>template &lt;typename T&gt;
void push_lua(const T&amp; pX)
{
    // push pX onto lua stack
}
</code></pre>

<p>And change everything to specifically call that function:</p>

<pre><code>namespace detail
{
    // just to keep things concise and readable
    #define ENABLE_IF(x) std::enable_if&lt;(x)&gt;::type* = nullptr

    // recursive case
    template &lt;std::size_t N, typename... Args&gt;
    typename ENABLE_IF(N &gt;= 1) iterate(const std::tuple&lt;Args...&gt;&amp; pTuple)
    {
        // specific function instead of generic function
        push_lua(std::get&lt;N - 1&gt;(pTuple));

        iterate&lt;N - 1&gt;(pTuple);
    }

    // base case
    template &lt;std::size_t N, typename... Args, typename Func&gt;
    typename ENABLE_IF(N == 0) iterate(const std::tuple&lt;Args...&gt;&amp;, Func&amp;)
    {
        // done
    }
}

// iterate tuple
template &lt;typename... Args&gt;
void _push(const std::tuple&lt;Args...&gt;&amp; pTuple)
{
    detail::iterate&lt;sizeof...(Args)&gt;(pTuple);
}
</code></pre>

<p>No idea why you'd avoid generic functionality though, or be so against structs.</p>

<hr>

<p>Oh how nice polymorphic lambda's would be. Ditch the utility <code>push_lua_stack</code> class and just write:</p>

<pre><code>std::size_t count = 0;

iterate(someTuple, [&amp;](auto pX)
                    {
                        // push onto lua stack
                        ++count;
                    });
</code></pre>

<p>Oh well.</p>
"
"<p>I have the following class:</p>

<pre><code>class Stack {
  struct Link {
    void* data;
    Link* next;
    void initialize(void* dat, Link* nxt);
  }* head;
public:
  void initialize();
  void push(void* dat);
  void* peek();
  void* pop();
  void cleanup();
};
</code></pre>

<p>The <code>pop</code> method is:</p>

<pre><code>void* Stack::pop() {
  if(head == 0) return 0;
  void* result = head-&gt;data;
  Link* oldHead = head;
  head = head-&gt;next;
  delete oldHead;
  return result;
}
</code></pre>

<p><code>oldHead</code> is a pointer to a <code>struct Link</code>, which has a void pointer as member. So by deleting <code>oldHead</code> I'm implicitly deleting that void pointer, right? </p>

<p>I'm reading Thinking in C++ by Bruce Eckel, and it says that deleting void pointers doesn't clean things up properly because <code>delete</code> needs to know the type of the pointer. </p>

<p>This code is implicitly deleting the void pointer <code>data</code>, so: Can someone explain why is this (implicit) way of deleting a void pointer different from deleting with <code>delete &lt;void pointer&gt;</code>?</p>
","87234","","<p>Your terminology is causing ambiguity, but let me explain. Let's say you have:</p>

<pre><code>struct foo
{
    void* bar;
};
</code></pre>

<p>Whenever a <code>foo</code> ends its lifetime, <code>bar</code> simply stops existing too. So if you have:</p>

<pre><code>{
    foo f = { new int; }
}
</code></pre>

<p>You've leaked, as <code>new int</code> is never deleted. Likewise, when you do:</p>

<pre><code>{
    foo* f = new foo;
    f-&gt;bar = new int;
    delete f;
}
</code></pre>

<p>You've still leaked, since when <code>delete f</code> is run, you simply end the lifetime of what <code>f</code> is pointing to (just like what happened automatically above), ergo <code>bar</code> simply ceases to exist and the <code>new int</code> is not deleted.</p>

<p>To summarize, when an object's lifetimes ends, <code>delete</code> is <em>not</em> called on the members that are a pointer.</p>

<p>So when you call delete on a <code>Link</code>, it's the same situation as <code>bar</code> in <code>foo</code> above: you're deleteing the memory for a <code>Link</code> causing <code>data</code> to stop existing, but not actually deleting what it's pointing at.</p>
"
"<p>I have a system of 6 equations that I need to solve over and over again in a program (with many different inputs of course). I am currently using the Cramer's rule method of solving the system and it works quite well (it seems that my processor really likes add and multiply operations, it gets solutions in 1 microsecond despite the explicit equations being over 2 pages in length). However the number of times i need to solve is huge and I'm looking for an even faster method. </p>

<p>The question is, is there an even faster or more efficient method for solving these equations or would something like CUDA be beneficial here?</p>
","87234","","<p>You might check out <a href=""http://www.boost.org/doc/libs/1_43_0/libs/numeric/ublas/doc/index.htm"" rel=""nofollow"">Boost's uBLAS</a>.</p>

<p>The method is not as straightforward, however; you'll want to look into <a href=""http://en.wikipedia.org/wiki/LU_decomposition"" rel=""nofollow"">LU decomposition</a>.</p>
"
"<p>i know this sounds totally ridiculous at the moment but trust me, i want something like ""$variable"" in php or ""def"" in groovy, by means of my approach is an automatic variable ""data type"" identification to <strong>IMPLEMENT</strong> into c language.</p>

<p>for example:</p>

<p>""def"" is a replacement for a type name. In variable definitions it is used to indicate that you don't care about the type. In variable definitions it is mandatory to either provide a type name explicitly or to use ""def"" in replacement. This is needed to the make variable definitions detectable for the Groovy parser.</p>

<pre><code>def dynamic  =  1
dynamic = ""I am a String stored in a variable of dynamic type""
</code></pre>

<p>OR</p>

<p>Let's try creating a variable containing a string, and a variable containing a number:</p>

<pre><code>&lt;?php
$txt=""Hello World!"";
$x=16;
?&gt;
</code></pre>

<p>PHP is a Loosely Typed Language
In PHP, <strong>a variable does not need to be declared before adding a value to it.</strong>
*<em>In the example above, you see that you do not have to tell PHP which data type the variable is.</em>*
<strong>PHP automatically converts the variable to the correct data type, depending on its value.</strong>
*<em>In a strongly typed programming language, you have to declare (define) the type and name of the variable before using it.</em>*</p>
","87234","","<p>There is no way of doing what you want in C. You need to know the type of a variable before you declare it, and you need to declare a variable before you use it.</p>
"
"<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstdlib&gt;

using namespace std;

const int FILENAME_MAX=20;

int main() {

    ifstream input;
    char name[FILENAME_MAX + 1];
    int value;

    do {

        cout &lt;&lt; ""Enter the filename (maximum of "" &lt;&lt; (FILENAME_MAX+1) 
        &lt;&lt; "" characters: "";
        cin &gt;&gt; name;
        input.open(name);

    } while(input.fail() );

    while(input &gt;&gt; value) {
    int count=1;

    cout &lt;&lt; ""value #"" &lt;&lt; count &lt;&lt; ""\t"" &lt;&lt; value &lt;&lt; endl;

    count++;
    }

return 0;
}
</code></pre>

<hr>

<p>This is a very simple piece of code for reading some numbers from a file.
Unfortunately I can't get it to compile. There is an error after/on the line 
""const int FILENAME_MAX=20;"" 
The error says ""expected unqualified-id before numeric constant.""</p>

<p>Could someone please tell me what I am doing wrong?</p>

<hr>

<p>I am compiling on Mac OS 10.5.8 with Xcode 3.0 </p>
","87234","","<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdio/FILENAME_MAX/"" rel=""nofollow""><code>FILENAME_MAX</code></a> is a macro that is defined by the standard library*, and so it is already taken for use as an identifier. When you try to use it as an identifier, it's actually being replaced during preprocessing to some number. A number is not a valid identifier, so you get an error. (Which is why it's saying ""I was expecting an identifier, not a numeric constant."")</p>

<p>Rename it to something else. (Or use <code>std::string</code>, though it seems you aren't quite there yet.)</p>

<p><sub>*It is defined by <code>&lt;cstdio&gt;</code>. While you don't include it directly, other standard library headers are free to include any other standard headers as they see fit.</sub></p>
"
"<p>Would there be a better way to do this using alogrithm functions like std::find()?</p>

<pre><code>std::string s = ""012X012Y012"";

//After erasing the numbers from beginning and end; the end result should be X012Y

size_t index = s.find_first_not_of(""0123456789"");
string::iterator iter_end = s.begin();
advance(iter_end, index);
s.erase(s.begin(), iter_end);

//Now std::string should be X012Y012

size_t index = s.find_last_not_of(""0123456789"")+1;
string::iterator iter_start = s.begin();
advance(iter_start, index);
s.erase(iter_start, s.end());

//Finally, std::string should be X012Y
</code></pre>
","87234","","<p>Seems fine enough. I'd factor out your constant:</p>

<pre><code>const std::string Numbers = ""0123456789"";
</code></pre>

<p>And re-use that. <code>erase</code> does allow you to use indices instead of iterators, so you can trim all that iterator stuff from your code. You should also check the results of your search, otherwise you'll do weird things to your string:</p>

<pre><code>std::size_t start = s.find_first_not_of(Numbers);
if (start != std::string::npos)
    s.erase(0, start);

size_t end = s.find_last_not_of(Numbers);
if (end != std::string::npos)
    s.erase(end + 1, std::string::npos);
</code></pre>

<p>Lastly, I think you should trim the right before the left. If you trim the left first, during <code>erase</code> the remainder of the string needs to be copied and moved down. By trimming the right first, you eliminate some things to copy. Nothing major, I suspect, but might as well.</p>

<p>(This is true of most sequence containers: erasing from some point to the end simply means getting rid of objects, while erasing from the start to some point requires moving the remaining items into their new spot.)</p>

<hr>

<p>Of course, you can generalize this and re-use it:</p>

<pre><code>// typically you trim whitespace, so for the sake of
// a generic utility, default to that
const std::string whitespace = "" \f\n\r\t\v"";

void trim_left(std::string&amp; pStr, const std::string&amp; pExcess = whitespace)
{
    std::size_t start = s.find_first_not_of(pExcess);
    if (start != std::string::npos)
        s.erase(0, start);
}

void trim_right(std::string&amp; pStr, const std::string&amp; pExcess = whitespace)
{
    size_t end = s.find_last_not_of(pExcess);
    if (end != std::string::npos)
        s.erase(end + 1, std::string::npos);
}

void trim(std::string&amp; pStr, const std::string&amp; pExcess = whitespace)
{
    // right then left, for reasons said above
    trim_right(pStr, pExcess);
    trim_left(pStr, pExcess);
}
</code></pre>
"
"<p>Apparently <a href=""http://stackoverflow.com/questions/3220009/is-this-key-oriented-access-protection-pattern-a-known-idiom"">this key-oriented access-protection pattern</a>:</p>

<pre><code>class SomeKey { 
    friend class Foo;
    SomeKey() {} 
    // possibly non-copyable too
};

class Bar {
public:
    void protectedMethod(SomeKey); // only friends of SomeKey have access
};
</code></pre>

<p>... doesn't have a known name yet, thus i'd like to find a good one for it so we can refer to it without breaking our tongues. Suggestions?</p>

<p>It should be:</p>

<ul>
<li>succinct </li>
<li>convey the intent of access-protection</li>
<li>ideally imply that no proxying is required (?)</li>
</ul>
","87234","","<p>I like, in decreasing preference:</p>

<ul>
<li>passkey friend idiom</li>
<li>passkey-door friend idiom</li>
<li>pass-door friend idiom</li>
<li>key-door friend idiom</li>
<li>partial-friend idiom</li>
<li>restricted-friend idiom</li>
</ul>

<p><sub>I moved away from the key-lock/key-keyhole naming scheme to the pass naming scheme, which grew on me.</sub></p>
"
"<p>Can we increase the re-usability for <a href=""http://stackoverflow.com/questions/3220009/is-this-key-oriented-access-protection-pattern-a-known-idiom"">this key-oriented access-protection pattern</a>:</p>

<pre><code>class SomeKey { 
    friend class Foo;
    // more friends... ?
    SomeKey() {} 
    // possibly non-copyable too
};

class Bar {
public:
    void protectedMethod(SomeKey); // only friends of SomeKey have access
};
</code></pre>

<p>To avoid continued misunderstandings, this pattern is different from the <a href=""http://www.drdobbs.com/184402053"">Attorney-Client</a> idiom:</p>

<ul>
<li>It can be more concise than Attorney-Client (as it doesn't involve proxying through a third class)</li>
<li>It can allow delegation of access rights</li>
<li>... but its also more intrusive on the original class (one dummy parameter per method) </li>
</ul>

<p><em>(A side-discussion developed in <a href=""http://stackoverflow.com/questions/3324248/how-to-name-this-key-oriented-access-protection-pattern/3324741"">this question</a>, thus i'm opening this question.)</em></p>
","87234","","<p>I like this idiom, and it has the potential to become much cleaner and more expressive.</p>

<p>In standard C++03, I think the following way is the easiest to use and most generic. (Not too much of an improvement, though. Mostly saves on repeating yourself.) Because <a href=""http://stackoverflow.com/questions/702650/making-a-template-parameter-a-friend"">template parameters cannot be friends</a>, we have to use a macro to define passkey's:</p>

<pre><code>// define passkey groups
#define EXPAND(pX) pX

#define PASSKEY_1(pKeyname, pFriend1)                             \
        class EXPAND(pKeyname)                                    \
        {                                                         \
        private:                                                  \
            friend EXPAND(pFriend1);                              \
            EXPAND(pKeyname)() {}                                 \
                                                                  \
            EXPAND(pKeyname)(const EXPAND(pKeyname)&amp;);            \
            EXPAND(pKeyname)&amp; operator=(const EXPAND(pKeyname)&amp;); \
        }

#define PASSKEY_2(pKeyname, pFriend1, pFriend2)                   \
        class EXPAND(pKeyname)                                    \
        {                                                         \
        private:                                                  \
            friend EXPAND(pFriend1);                              \
            friend EXPAND(pFriend2);                              \
            EXPAND(pKeyname)() {}                                 \
                                                                  \
            EXPAND(pKeyname)(const EXPAND(pKeyname)&amp;);            \
            EXPAND(pKeyname)&amp; operator=(const EXPAND(pKeyname)&amp;); \
        }
// and so on to some N

//////////////////////////////////////////////////////////
// test!
//////////////////////////////////////////////////////////
struct bar;
struct baz;
struct qux;
void quux(int, double);

struct foo
{
    PASSKEY_1(restricted1_key, struct bar);
    PASSKEY_2(restricted2_key, struct bar, struct baz);
    PASSKEY_1(restricted3_key, void quux(int, double));

    void restricted1(restricted1_key) {}
    void restricted2(restricted2_key) {}
    void restricted3(restricted3_key) {}
} f;

struct bar
{
    void run(void)
    {
        // passkey works
        f.restricted1(foo::restricted1_key());
        f.restricted2(foo::restricted2_key());
    }
};

struct baz
{
    void run(void)
    {
        // cannot create passkey
        /* f.restricted1(foo::restricted1_key()); */

        // passkey works
        f.restricted2(foo::restricted2_key());
    }
};

struct qux
{
    void run(void)
    {
        // cannot create any required passkeys
        /* f.restricted1(foo::restricted1_key()); */
        /* f.restricted2(foo::restricted2_key()); */
    }
};

void quux(int, double)
{
    // passkey words
    f.restricted3(foo::restricted3_key());
}

void corge(void)
{
    // cannot use quux's passkey
    /* f.restricted3(foo::restricted3_key()); */
}

int main(){}
</code></pre>

<p>This method has two drawbacks: 1) the caller has to know the specific passkey it needs to create. While a simple naming scheme (<code>function_key</code>) basically eliminates it, it could still be one abstraction cleaner (and easier). 2) While it's not very difficult to use the macro can be seen as a bit ugly, requiring a block of passkey-definitions. However, improvements to these drawbacks cannot be made in C++03.</p>

<hr>

<p>In C++0x, the idiom can reach its simplest and most expressive form. This is due to both variadic templates and allowing template parameters to be friends. (Note that MSVC pre-2010 allows template friend specifiers as an extension; therefore one can simulate this solution):</p>

<pre><code>// each class has its own unique key only it can create
// (it will try to get friendship by ""showing"" its passkey)
template &lt;typename T&gt;
class passkey
{
private:
    friend T; // C++0x, MSVC allows as extension
    passkey() {}

    // noncopyable
    passkey(const passkey&amp;) = delete;
    passkey&amp; operator=(const passkey&amp;) = delete;
};

// functions still require a macro. this
// is because a friend function requires
// the entire declaration, which is not
// just a type, but a name as well. we do 
// this by creating a tag and specializing 
// the passkey for it, friending the function
#define EXPAND(pX) pX

// we use variadic macro parameters to allow
// functions with commas, it all gets pasted
// back together again when we friend it
#define PASSKEY_FUNCTION(pTag, pFunc, ...)               \
        struct EXPAND(pTag);                             \
                                                         \
        template &lt;&gt;                                      \
        class passkey&lt;EXPAND(pTag)&gt;                      \
        {                                                \
        private:                                         \
            friend pFunc __VA_ARGS__;                    \
            passkey() {}                                 \
                                                         \
            passkey(const passkey&amp;) = delete;            \
            passkey&amp; operator=(const passkey&amp;) = delete; \
        }

// meta function determines if a type 
// is contained in a parameter pack
template&lt;typename T, typename... List&gt;
struct is_contained : std::false_type {};

template&lt;typename T, typename... List&gt;
struct is_contained&lt;T, T, List...&gt; : std::true_type {};

template&lt;typename T, typename Head, typename... List&gt;
struct is_contained&lt;T, Head, List...&gt; : is_contained&lt;T, List...&gt; {};

// this class can only be created with allowed passkeys
template &lt;typename... Keys&gt;
class allow
{
public:
    // check if passkey is allowed
    template &lt;typename Key&gt;
    allow(const passkey&lt;Key&gt;&amp;)
    {
        static_assert(is_contained&lt;Key, Keys&gt;::value, 
                        ""Passkey is not allowed."");
    }

private:
    // noncopyable
    allow(const allow&amp;) = delete;
    allow&amp; operator=(const allow&amp;) = delete;
};

//////////////////////////////////////////////////////////
// test!
//////////////////////////////////////////////////////////
struct bar;
struct baz;
struct qux;
void quux(int, double);

// make a passkey for quux function
PASSKEY_FUNCTION(quux_tag, void quux(int, double));

struct foo
{    
    void restricted1(allow&lt;bar&gt;) {}
    void restricted2(allow&lt;bar, baz&gt;) {}
    void restricted3(allow&lt;quux_tag&gt;) {}
} f;

struct bar
{
    void run(void)
    {
        // passkey works
        f.restricted1(passkey&lt;bar&gt;());
        f.restricted2(passkey&lt;bar&gt;());
    }
};

struct baz
{
    void run(void)
    {
        // passkey does not work
        /* f.restricted1(passkey&lt;baz&gt;()); */

        // passkey works
        f.restricted2(passkey&lt;baz&gt;());
    }
};

struct qux
{
    void run(void)
    {
        // own passkey does not work,
        // cannot create any required passkeys
        /* f.restricted1(passkey&lt;qux&gt;()); */
        /* f.restricted2(passkey&lt;qux&gt;()); */
        /* f.restricted1(passkey&lt;bar&gt;()); */
        /* f.restricted2(passkey&lt;baz&gt;()); */
    }
};

void quux(int, double)
{
    // passkey words
    f.restricted3(passkey&lt;quux_tag&gt;());
}

void corge(void)
{
    // cannot use quux's passkey
    /* f.restricted3(passkey&lt;quux_tag&gt;()); */
}

int main(){}
</code></pre>

<p>Note with just the boilerplate code, in most cases (<em>all</em> non-function cases!) nothing more ever needs to be specially defined. This code generically and simply implements the idiom for any combination of classes and functions.</p>

<p>The caller doesn't need to try to create or remember a passkey specific to the function. Rather, each class now has its own unique passkey and the function simply chooses which passkey's it will allow in the template parameters of the passkey parameter (no extra definitions required); this eliminates both drawbacks. The caller just creates its own passkey and calls with that, and doesn't need to worry about anything else.</p>
"
"<p>Say I have 2 containers storing pointers to the same objects...</p>

<pre><code>std::list&lt;Foo*&gt; fooList;
std::vector&lt;Foo*&gt; fooVec;
</code></pre>

<p>Lets say I remove an object from one of these containers via one if its methods, for example...</p>

<pre><code>std::vector&lt;Foo*&gt;::iterator itr = 
  std::find( fooVec.begin(), fooVec.end(), pToObj );
fooVec.erase( itr );
</code></pre>

<p>CppReference says that this calls the object's destructor. Does this mean that the pointer to the object in fooList is a dangling pointer?</p>

<p>I'd prefer not to use reference counted pointers. How can this problem be handled?</p>
","87234","","<p>No.</p>

<p>When you remove a pointer from a container, all you've done is take that pointer value from the container, nothing is deleted. (i.e.: pointers have no destructor.)</p>

<p>However, it's dangerous to have pointers of things in containers. Consider:</p>

<pre><code>std::vector&lt;int*&gt; v;
v.push_back(new int());
v.push_back(new int());
v.push_back(new int());
</code></pre>

<p>If you never go through the container and delete each one, you've leaked. Worse is it's not exception safe. You should use a <a href=""http://www.boost.org/doc/libs/1_43_0/libs/ptr_container/doc/ptr_container.html"">pointer container</a>, which will delete things it points to when they are erased. (And all get erased when the container destructs.)</p>

<p>In your case, though, since you are sharing a pointer in different places, I can't see an argument against <a href=""http://www.boost.org/doc/libs/1_43_0/libs/smart_ptr/shared_ptr.htm""><code>shared_ptr</code></a>; that's exactly what it was made for.</p>
"
"<p>I would like to implement something like this because my application is divided into scenes and this gets sort of messy:</p>

<pre><code>glEngine.scene[glEngine.current.currentScene].layer[glEngine.scene[glEngine.current.currentScene].currentLayer].Shapes.push_back(CGlShape());
</code></pre>

<p>instead I'd want to be able to do something like this:</p>

<pre><code>glEngine.Scene().layer[glEngine.Scene().currentLayer].Shapes.push_back(CGlShape());
</code></pre>

<p>How could I make a function like this?</p>

<p>Thanks</p>
","87234","","<p>We have no idea what your classes are, but just make a function:</p>

<pre><code>struct glEngine
{
    // ...

    scene_type&amp; Scene()
    {
        return scene[current.currentScene];
    }
};
</code></pre>

<p>You can also do this for <code>Scene</code>, returning the current layer:</p>

<pre><code>struct scene_type
{
    // ...

    layer_type&amp; Layer()
    {
        return layer[current.currentScene];
    }
};
</code></pre>

<p>Giving:</p>

<pre><code>glEngine.Scene().Layer().Shapes.push_back(CGlShape());
</code></pre>

<p>You might also consider splitting the line up merely for the sake of readability:</p>

<pre><code>scene_type&amp; scene = glEngine.Scene();
layer_type&amp; layer = scene.Layer();

layer.Shapes.push_back(CGlShape());
</code></pre>

<p>Lastly, the naming convention seems a bit weird, maybe rename the <code>Scene</code> and <code>Layer</code> functions to <code>current_scene</code> and <code>current_layer</code>.</p>
"
"<p>this is my first question here.</p>

<p>Writing some code, i receive this error from g++: ""Entity was not declared in this scope"", in this context:</p>

<pre><code>#ifndef Psyco2D_GameManager_
#define Psyco2D_GameManager_

#include &lt;vector&gt;
#include ""Entity.h""

namespace Psyco2D{
    class GameManager{J
    private:
        std::vector&lt;Entity&gt; entities;
    };
}

#endif
</code></pre>

<p>This is the content of Entity.h:</p>

<pre><code>#ifndef Psyco2D_Entity_
#define Psyco2D_Entity_

#include &lt;string&gt;
#include ""GameManager.h""
#include ""EntityComponent.h""


namespace Psyco2D{

    class Entity{
        friend class GameManager;

    private:
        /* Identificatore */
        std::string _name;

        /* Components list */
        std::map&lt;const std::string, EntityComponent*&gt; components;

    protected:
        Entity(const std::string name);

    public:
        inline const std::string getName() const{
            return this-&gt;_name;
        }

        void addComponent(EntityComponent* component, const std::string name);

        EntityComponent* lookupComponent(const std::string name) const;

        void deleteComponent(const std::string name);

    };

}

#endif
</code></pre>

<p>If i use <code>std::vector&lt;class Entity&gt;</code> instead of <code>std::vector&lt;Entity&gt;</code> it works.</p>

<p>Why?</p>

<p>Thanks to all =)</p>
","87234","","<p>The problem is you have a cyclic dependency. Take out <code>#include ""GameManager.h""</code> in <code>Entity.h</code>, since you don't actually need it in that header. (Up-vote <a href=""http://stackoverflow.com/questions/3326717/another-x-was-not-declared-in-this-scope/3327088#3327088"">this answer</a>, which first pointed it out.)</p>

<p>Note the guards are actually the problem; but don't take them out! You just need to minimize the includes you have, and declare (and not define) types when possible. Consider what happens when you include <code>Entity.h</code>: As some point it includes <code>GameManager.h</code>, which in turn includes <code>Entity.h</code>. At this point, <code>Entity.h</code> already has its header guard defined, so it skips the contents. Then the parsing of <code>GameManager.h</code> continues, where upon it runs into <code>Entity</code>, and rightfully complains it is not defined. (Indeed, this is still the process of including <code>GameManager.h</code> in the first inclusion of <code>Entity.h</code>, far before <code>Entity</code> is defined!)</p>

<p>Note your numerous edits demonstrate why it's important to post real code, not re-synthesized code. You need real details to get real answers.</p>

<hr>

<p><sub>Old:</sub></p>

<p><code>Entity</code> is in the <code>Psyco2D</code> namespace. You need to specify that:</p>

<pre><code>class GameManager{
private:
    std::vector&lt;Psyco2D::Entity&gt; entities;
};
</code></pre>
"
"<p>Probably everyone ran into this problem at least once during development:</p>

<pre><code>while(/*some condition here that somehow never will be false*/)
{
    ...
    yourvector.push_back(new SomeType());
    ...
}
</code></pre>

<p>As you see the program starts to drain all system memory, your program hangs and your system starts to swap like crazy. If you don't recognize the problem fast enough and kill the process you probably get an unresponsive system in seconds where your mouse pointer don't even moving. You can either wait your program crash with ""out of memory"" error (which may take several long minutes) or hit the reset on your computer.</p>

<p>If you can't track down the bug immediately then you will need several tests and resets to find out which is very annoying...</p>

<p>I'm looking for a possibly cross-platform way to prevent this somehow. The best would be a debug mode code that exits the program if it allocated too much memory, but how can I keep track how much memory is allocated?
Overriding the global new and delete operators won't help, because the free function I would invoke in the delete won't give any idea how many bytes are freed.</p>

<p>Any ideas appreciated.</p>
","87234","","<blockquote>
  <p>Overriding the global new and delete operators won't help, because the free function I would invoke in the delete won't give any idea how many bytes are freed.</p>
</blockquote>

<p>But you can make it so. Here's a full framework for overloading the global memory operators (throw it in some <code>global_memory.cpp</code> file):</p>

<pre><code>namespace
{   
    // utility
    std::new_handler get_new_handler(void)
    {
        std::new_handler handler = std::set_new_handler(0);
        std::set_new_handler(handler);

        return handler;
    }

    // custom allocation scheme goes here!
    void* allocate(std::size_t pAmount)
    {

    }

    void deallocate(void* pMemory)
    {

    }

    // allocate with throw, properly
    void* allocate_throw(std::size_t pAmount)
    {
        void* result = allocate(pAmount);

        while (!result)
        {
            // call failure handler
            std::new_handler handler = get_new_handler();
            if (!handler)
            {
                throw std::bad_alloc();
            }

            handler();

            // try again
            result = allocate(pAmount);
        }

        return result;
    }
}

void* operator new(std::size_t pAmount) throw(std::bad_alloc)
{
    return allocate_throw(pAmount);
}

void *operator new[](std::size_t pAmount) throw(std::bad_alloc)
{
    return allocate_throw(pAmount);
}

void *operator new(std::size_t pAmount, const std::nothrow_t&amp;) throw()
{
    return allocate(pAmount);
}

void *operator new[](std::size_t pAmount, const std::nothrow_t&amp;) throw()
{
    return allocate(pAmount);
}

void operator delete(void* pMemory) throw()
{
    deallocate(pMemory);
}

void operator delete[](void* pMemory) throw()
{
    deallocate(pMemory);
}

void operator delete(void* pMemory, const std::nothrow_t&amp;) throw()
{
    deallocate(pMemory);
}

void operator delete[](void* pMemory, const std::nothrow_t&amp;) throw()
{
    deallocate(pMemory);
}
</code></pre>

<p>Then you can do something like:</p>

<pre><code>    // custom allocation scheme goes here!
    const std::size_t allocation_limit = 1073741824; // 1G
    std::size_t totalAllocation = 0;

    void* allocate(std::size_t pAmount)
    {
        // make sure we're within bounds
        assert(totalAllocation + pAmount &lt; allocation_limit);

        // over allocate to store size
        void* mem = std::malloc(pAmount + sizeof(std::size_t));
        if (!mem)
            return 0;

        // track amount, return remainder
        totalAllocation += pAmount;
        *static_cast&lt;std::size_t*&gt;(mem) = pAmount;

        return static_cast&lt;char*&gt;(mem) + sizeof(std::size_t);
    }

    void deallocate(void* pMemory)
    {
        // get original block
        void* mem = static_cast&lt;char*&gt;(pMemory) - sizeof(std::size_t);

        // track amount
        std::size_t amount = *static_cast&lt;std::size_t*&gt;(mem);
        totalAllocation -= pAmount;

        // free
        std::free(mem);
    }
</code></pre>
"
"<p>In my CPP file I have a call that is:</p>

<pre><code>pt.x = mDownPoint.x + FSign(pt.x-mDownPoint.x) *
        FMax( FAbs(pt.x-mDownPoint.x), FAbs(pt.y-mDownPoint.y) );
</code></pre>

<p>I get compiler errors for <code>FSign</code>, <code>FMax</code>, <code>FAbs</code>, but I include the header file where they are at.</p>

<p>So I don't see why it would not find it, unless I have done something wrong in the creation of this header file.</p>

<p>Can I get some pointers on what I am doing wrong?</p>

<p>Header: </p>

<pre><code>class FxMathFunctions
{
struct FxPoint2d;

public:
    FxMathFunctions();
    ~FxMathFunctions();

    static FxInt32 IMin(FxInt32 i1,FxInt32 i2);
    static FxInt32 IMax(FxInt32 i1,FxInt32 i2);
    static FxInt32 ILimit(FxInt32 val, FxInt32 i1, FxInt32 i2);
    static FxDouble FMin(FxDouble i1,FxDouble i2);
    static FxDouble FMax(FxDouble i1,FxDouble i2);
    static FxFloat FMax(FxFloat i1,FxFloat i2);
    static FxFloat FLimit(FxFloat val, FxFloat i1, FxFloat i2);
    static FxDouble FrInverseContrast(FxDouble opacity,FxDouble antialias);
    static FxInt32 ISign(FxInt32 l);
    static FxFloat FSign(FxFloat v);
    static FxInt32 IAbs(FxInt32 l);
    static FxFloat FAbs(FxFloat v);
    static FxInt32 INonzero(FxInt32 l);
    static double DAbs(double v);
    static FxInt32 Sqr(FxByte v);
    static FxInt32 Sqr(FxInt32 v);
    static FxFloat Sqr(FxFloat v);
    static FxDouble Sqr(FxDouble v);
    static FxInt32 FrCubed(FxByte v);
    static FxInt32 FrCubed(FxInt32 v);
    static FxFloat FrCubed(FxFloat v);
    static FxDouble FrCubed(FxDouble v);
    static FxDouble FrFourthPower(FxDouble v);
    static FxFloat FrFourthPower(FxFloat v);
    static FxBool FNearEqual(FxFloat val, FxFloat nearTo, FxFloat closeness = 0.00001f);
    static FxBool FNearGreaterEqual(FxFloat val, FxFloat nearTo, FxFloat closeness = 0.00001f);
    static FxBool FNearLessEqual(FxFloat val, FxFloat nearTo, FxFloat closeness = 0.00001f);
};
</code></pre>

<p>.CPP to Header where applicable for one function that is failing:</p>

<pre><code>FxFloat FAbs(FxFloat v)
{
    if (v &lt; 0.0f) v = -v;
    return v;
}
</code></pre>

<p>EDIT:</p>

<p>Fixed call:</p>

<pre><code>pt.x = mDownPoint.x + FxMathFunctions::FSign(pt.x-mDownPoint.x) * 
                FxMathFunctions::FMax( FxMathFunctions::FAbs(pt.x-mDownPoint.x),
                FxMathFunctions::FAbs(pt.y-mDownPoint.y) );
</code></pre>

<p>Failing with:</p>

<blockquote>
  <p>error: cannot call member function 'FxFloat FxMathFunctions::FAbs(FxFloat)'</p>
</blockquote>
","87234","","<p>All the function are within <code>FxMathFunctions</code>, so it should be:</p>

<pre><code>pt.x = mDownPoint.x + FxMathFunctions::FSign(pt.x-mDownPoint.x) *
        FxMathFunctions::FMax( FxMathFunctions::FAbs(pt.x-mDownPoint.x), 
        FxMathFunctions::FAbs(pt.y-mDownPoint.y) );
</code></pre>

<p>But this is what namespaces are for, I don't think you actually want a class. If it's a namespace, you can even do <code>using namespace FxMathFunctions;</code> at the top of the function your code is in and leave the code you have in the question.</p>

<hr>

<p>Secondly, a lot of those functions don't need to be written, unless you've gotten some hand-written implementation of them. (Just use <code>cmath</code> and <code>utility</code>, for things like <code>std::fabs</code> and <code>std::min</code>.) Lastly, why not overload <code>FAbs</code> and <code>DAbs</code> to just <code>Abs</code>, like you do for <code>Sqr</code>? It would make the interface simpler.</p>
"
"<pre><code>class A{
private:
    int a;
public:
    A() {a = 4;}
    const int&amp; random1() const {return a; }
    //int&amp;     random2() const {return a; }
    const int* random3() const {return &amp;a;}
    //int*     random4() const {return &amp;a;}
};

int main(){
    A objA;
    cout&lt;&lt;objA.random1()&lt;&lt;""\n"";
    cout&lt;&lt;*objA.random3()&lt;&lt;""\n"";
}
</code></pre>

<p><code>random2()</code> and <code>random4()</code> are not permitted as defined above. I somehow knew this all along but never came across it while writing my own code, until today.</p>

<p>What all except these two cases is not permitted in const member functions?</p>

<p>Any reference to C++ standard text will also be helpful. Thanks!</p>
","87234","","<p>First understand that <code>const T*</code> is a pointer to some <code>T</code> that cannot be changed. The second thing to remember is all members are actually accessed via <code>this-&gt;</code>.</p>

<p>So (§9.3.1):</p>

<blockquote>
  <p>A nonstatic member function may be declared const, volatile, or const volatile. These cvqualifiers affect the type of the this pointer (9.3.2).</p>
</blockquote>

<p>And what it does (§9.3.2):</p>

<blockquote>
  <p>In the body of a nonstatic (9.3) member function, the keyword this is a non-lvalue expression whose value is the address of the object for which the function is called. The type of this in a member function of a class X is X*. If the member function is declared const, the type of this is const X*, if the member function is declared volatile, the type of this is volatile X*, and if the member function is declared const volatile, the type of this is const volatile X*.</p>
</blockquote>

<p>A <code>const</code> on a function makes the <code>this</code> pointer <code>const T*</code>.</p>

<p>This is why those examples fail: In the <code>int&amp;</code> variant, <code>a</code> is accessed as <code>this-&gt;a</code>, <code>this</code> is <code>const T*</code>, so <code>a</code> is a <code>const int</code>. And <code>const int</code> cannot be implicitly converted to <code>int&amp;</code>. Same with the other function.</p>

<p>In other words, when a function is <code>const</code> it smacks a <code>const</code> on everything in the class, and you can't implicitly cast the <code>const</code> away. </p>
"
"<p>I'm using list class in c++ and i don't know what does allocator mean here</p>

<pre><code>template &lt; class T, class Allocator = allocator&lt;T&gt; &gt; class list;
</code></pre>

<p>if i have <code>list &lt;int&gt; mylist</code> would it mean allocate integer type of memory using the allocator when an element is added to list? and when do you want a custom allocator?</p>
","87234","","<p>Yes. An <code>allocator</code> is a way of factoring the allocation of memory from the use of memory. If a container needs some memory, instead of: </p>

<pre><code>// too rigid, cannot allow custom allocation schemes
void* mem = ::operator new(someAmount);
</code></pre>

<p>You get:</p>

<pre><code>// flexible, allows custom allocation schemes
void* mem = myallocator.allocate(someAmount);
</code></pre>

<p>There is a standard allocator, <code>std::allocator</code>, which uses global <code>operator new</code> and <code>operator delete</code>.</p>

<p>You want to use your own allocator anytime you need to allocate in a special way. These cases may be: get memory from some freelist, allocate from the stack, etc. (Generally for optimization purposes, though you could also record statistics with a custom allocator) Most of the time, the standard allocator works perfectly.</p>
"
"<p>I would like to put use a string* as a key in an unordered_list. I do not want the hash the pointer itself but the string it points to.</p>

<p>I understand I need to create a struct like this:</p>

<pre><code>struct myhash{
    size_t operator()(const string * str){
        return hash(*str);
    }
}
</code></pre>

<p>and send it as a a hasher to the map template, but i am not sure how.</p>
","87234","","<p>That's basically it. You then provide it as the third template parameter to the <code>unordered_map</code> type (Which I will assume to be the C++0x one). I would generalize it so it's usable in any situation, rather than just <code>string</code>:</p>

<pre><code>struct dereference_hash
{
    template &lt;typename T&gt;
    std::size_t operator()(const T* pX)
    {
        return std::hash&lt;T&gt;()(*pX);
    }
};

typedef std::unordered_map&lt;std::string*, int, dereference_hash&gt; map_type;
</code></pre>
"
"<p>I know C pretty well, however I'm confused of how temporary storage works.</p>

<p>Like when a function returns, all the allocation happened inside that function is freed (from the stack or however the implementation decides to do this).</p>

<p>For example:</p>

<pre><code>void f() {
    int a = 5;
} // a's value doesn't exist anymore 
</code></pre>

<p>However we can use the <code>return</code> keyword to transfer some data to the outside world:</p>

<pre><code>int f() {
    int a = 5;
    return a;
} // a's value exists because it's transfered to the outside world
</code></pre>

<p>Please stop me if any of this is wrong.</p>

<p>Now here's the weird thing, when you do this with <code>arrays</code>, it doesn't work.</p>

<pre><code>int []f() {
    int a[1] = {5};
    return a;
} // a's value doesn't exist. WHY?
</code></pre>

<p>I know arrays are only accessible by pointers, and you can't pass arrays around like another data structure without using pointers. Is this the reason you can't return arrays and use them in the outside world? Because they're only accessible by pointers?</p>

<p>I know I could be using dynamic allocation to keep the data to the outside world, but my question is about temporary allocation.</p>

<p>Thanks!</p>
","87234","","<p>When you return something, its value is copied. <code>a</code> does <em>not</em> exist outside the function in your second example; it's value does. (It exists as an rvalue.)</p>

<p>In your last example, you implicitly convert the array <code>a</code> to an <code>int*</code>, and that copy is returned. <code>a</code>'s lifetime ends, and you're pointing at garbage.</p>

<p>No variable lives outside its scope, ever.</p>
"
"<p>I am not able to get this to work:</p>

<pre><code>template&lt;class Input, class Output, class Index&gt;
size_t pack(void (*copy)(Input, Input, Output),
            size_t N, Input input, Output output,
            const Index &amp;index);

size_t K = pack(&amp;std::copy&lt;const double*,double*&gt;,
                M, C.data().begin(), C_.data().begin(),
                index.host);
</code></pre>

<p>compiler message I get tells me that copy is not resolved, instead I get
<code>unresolved overloaded function type&gt;</code>.</p>

<p>what am I doing wrong?
thank you</p>
","87234","","<p>You could make a design change. One might be make the return type a separate template parameter:</p>

<pre><code>template&lt;class R, class Input, class Output, class Index&gt;
size_t pack(R (*copy)(Input, Input, Output),
            size_t N, Input input, Output output,
            const Index &amp;index);
</code></pre>

<p>The return type is deduced (and subsequently ignored by your code.) The other option, which I would recommend, would be to accept any generic function type:</p>

<pre><code>template&lt;class CopyFunc, class Input, class Output, class Index&gt;
size_t pack(CopyFunc func,
            size_t N, Input input, Output output,
            const Index &amp;index);
</code></pre>

<p>This doesn't enforce any specific signature, and provides the most flexibility.</p>
"
"<p>I have changed title slightly because I thought this is more appropriate question.</p>

<p>Would you refactor it (seems like legitimate use of goto) ?
If, how would you refactor the following code to remove go to statement?  </p>

<pre><code>if (data.device) {
    try {
        ...
    }
    catch(const std::exception&amp;) { goto done; }
    ... // more things which should not be caught
done: ;
}
</code></pre>

<p>complete statement</p>

<pre><code>#ifdef HAVE_GPU
            // attempt to use GPU device
            if (data.device) {
                try {
                    Integral::Gpu eri(S, R, Q, block.shell());
                    eri(basis.centers(), quartets, data.device);
                }
                // if GPU fails, propagate to cpu
                catch(std::exception) { goto done; }
                data.device += size;
                host_index.extend(block_index);
                block_index.data.clear();
            done: ;
            }
#endif
</code></pre>

<p>thank you</p>

<p>after have seen preference of most, I decided to go with flag, but with Mr. York comment.</p>

<p>Thank you everybody</p>
","87234","","<p>I think a variant of this might work for you. </p>

<pre><code>// attempt to use GPU device
if (data.device)
{
    try
    {
        Integral::Gpu eri(S, R, Q, block.shell());
        eri(basis.centers(), quartets, data.device);

        data.device += size;
        host_index.extend(block_index);
        block_index.data.clear();
    }
    catch (const std::bad_alloc&amp;)
    {
        // this failure was not because 
        // of the GPU, let it propagate
        throw;
    }
    catch(...)
    {
        // handle any other exceptions by
        // knowing it was the GPU and we 
        // can fall back onto the CPU.
    }
}

// do CPU
</code></pre>

<p>If you could edit the GPU library and give all GPU exceptions some base like <code>gpu_exception</code>, the code becomes much simpler:</p>

<pre><code>// attempt to use GPU device
if (data.device)
{
    try
    {
        Integral::Gpu eri(S, R, Q, block.shell());
        eri(basis.centers(), quartets, data.device);

        data.device += size;
        host_index.extend(block_index);
        block_index.data.clear();
    }
    catch (const gpu_exception&amp;)
    {
        // handle GPU exceptions by
        // doing nothing and falling
        // back onto the CPU.
    }

    // all other exceptions, not being 
    // GPU caused, may propagate normally
}

// do CPU
</code></pre>

<p>If nether of these work, I think the next best thing is <a href=""http://stackoverflow.com/questions/3345994/c-is-this-goto-statement-warranted/3346232#3346232"">Steve's answer</a>.</p>
"
"<p>Variables of type int are allegedly ""one machine-type word in length""
but in embedded systems, C compilers for 8 bit micro use to have int of 16 bits!, (8 bits for unsigned char) then for more bits, int behave normally:
in 16 bit micros int is 16 bits too, and in 32 bit micros int is 32 bits, etc..</p>

<p>So, is there a standar way to test it, something as BITSIZEOF( int ) ?</p>

<p>like ""sizeof"" is for bytes but for bits. </p>

<p>this was my first idea    </p>

<pre><code>    register c=1;                
    int bitwidth=0;
    do
    {

        bitwidth++;

    }while(c&lt;&lt;=1);

    printf(""Register bit width is : %d"",bitwidth);
</code></pre>

<p>But it takes c as int, and it's common in 8 bit compilers to use int as 16 bit, so it gives me 16 as result, It seems there is no standar for use ""int"" as ""register width"", (or it's not respected)</p>

<p>Why I want to detect it? suppose I need many variables that need less than 256 values, so they can be 8, 16, 32 bits, but using the right size (same as memory and registers) will speed up things and save memory, and if this can't be decided in code, I have to re-write the function for every architecture</p>

<p><strong>EDIT</strong>
After read the answers I found this good article</p>

<p><a href=""http://embeddedgurus.com/stack-overflow/category/efficient-cc/page/4/"" rel=""nofollow"">http://embeddedgurus.com/stack-overflow/category/efficient-cc/page/4/</a></p>

<p>I will quote the conclusion (added bold)</p>

<blockquote>
  <p>Thus
  the bottom line is this. If you want
  to start writing efficient, portable
  embedded code, the first step you
  should take is start using the C99
  data types ‘least’ and ‘fast’. If your
  compiler isn’t C99 compliant then
  <strong>complain until it is – or change
  vendors.</strong> If you make this change I
  think you’ll be pleasantly surprised
  at the improvements in code size and
  speed that you’ll achieve.</p>
</blockquote>
","87234","","<blockquote>
  <p>I have to re-write the function for every architecture  </p>
</blockquote>

<p>No you don't. Use C99's <code>stdint.h</code>, which has types like <code>uint_fast8_t</code>, which will be a type capable of holding 256 values, and quickly.</p>

<p>Then, no matter the platform, the types will change accordingly and you don't change anything in your code. If your platform has no set of these defined, you can add your own. </p>

<p>Far better than rewriting every function.</p>
"
"<p>I have this ""interesting"" problem. I have this legacy code that looks like</p>

<pre><code>int main()
{
  while(true) {
    doSomething();
 }
}
</code></pre>

<p>I would like to duplicate that doSomething() in many threads, so that now main() would look like</p>

<pre><code>int main() {
  runManyThreads(threadEntry)
}

void threadEntry() {
   while(true) {
    doSomething();
  }
}
</code></pre>

<p>The problem is that doSomething() access many global and static variables, and I cannot alter its code. Is there a trick to duplicate those static variables, so each thread has its own set ? (somekind of thread local storage, but without affecting doSomething())..
I use VisualC++</p>
","87234","","<p>Untested, but I think you can do something like:</p>

<pre><code>#define threadlocal __declspec(thread)
</code></pre>

<p>And then put <code>threadlocal</code> before all the variables that should be local to the thread. Might not work though, it's generally not a good idea to just throw functions into threads when they weren't written to be multi-threaded.</p>
"
"<p>I've some code that produces a set of tr1::array of different sizes, but same type, like</p>

<pre><code>array&lt;int, 2&gt;
array&lt;int, 4&gt;
array&lt;int, 6&gt;
</code></pre>

<p>The <strong>number</strong> of these arrays, and their sizes, are given in compile time, so I know exactly how many of them there will be and how's big each one (but they may be different).</p>

<p>Problem: I would like to put them in a collection (using array&lt;> would be great), but type must be equal for all the members and this is not the case.</p>

<p>I thought about using boost::variant, but how can specify a variant with a compile-time determined list of types (I'm thinking about an heavy usage of the preprocessor...)?
What about using boost::any? Other methods? (Wild pointers?)</p>

<p>TIA
~Aki</p>

<p>Correction: preprocessor is not usable in this case.</p>
","87234","","<p>I would use Boost's MPL and Fusion libraries. There are two ways of ending up with the type list: generate them, or explicitly define them. The former is bit more flexible, but it's hard to say which is right for you since we don't know how you get the values you have.</p>

<p>In any case, generating:</p>

<pre><code>#include &lt;boost/mpl/for_each.hpp&gt;
#include &lt;boost/mpl/range_c.hpp&gt;
#include &lt;boost/mpl/transform.hpp&gt;
#include &lt;boost/mpl/vector.hpp&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;

namespace bmpl = boost::mpl;

// turns an index into an array
template &lt;typename T&gt;
struct make_array
{
    // or whatever scheme you have
    static const std::size_t size = T::value * 2;

    // define generated type
    typedef std::array&lt;int, size&gt; type;
};

// list of values to convert
typedef bmpl::range_c&lt;size_t, 1, 10&gt; array_range;

// transform that list into arrays, into a vector
typedef bmpl::transform&lt;array_range, make_array&lt;bmpl::_1&gt;,
                            bmpl::back_inserter&lt;bmpl::vector&lt;&gt;&gt;
                                &gt;::type array_collection;
</code></pre>

<p>Or explicitly stating:</p>

<pre><code>#include &lt;boost/mpl/vector.hpp&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;

namespace bmpl = boost::mpl;

// list all array types
typedef bmpl::vector&lt;
            std::array&lt;int, 2&gt;,
            std::array&lt;int, 4&gt;,
            std::array&lt;int, 6&gt;,
            std::array&lt;int, 8&gt;,
            std::array&lt;int, 10&gt;,
            std::array&lt;int, 12&gt;,
            std::array&lt;int, 14&gt;,
            std::array&lt;int, 16&gt;,
            std::array&lt;int, 18&gt;
                &gt; array_collection;
</code></pre>

<p>Either way, you can then use it like this:</p>

<pre><code>#include &lt;boost/fusion/algorithm.hpp&gt;
#include &lt;boost/fusion/container/vector.hpp&gt;
#include &lt;boost/fusion/mpl.hpp&gt;
#include &lt;boost/fusion/sequence.hpp&gt;
#include &lt;boost/mpl/for_each.hpp&gt;
#include &lt;typeinfo&gt;

// fusion ""fuses"" the bridge between MPL and runtime
namespace bf = boost::fusion;

struct print_type
{
    template &lt;typename T&gt;
    void operator()(const T&amp;) const
    {
        std::cout &lt;&lt; typeid(T).name() &lt;&lt; ""\n"";
    }
};

struct print_values
{
    template &lt;typename T&gt;
    void operator()(const T&amp; pArray) const
    {
        std::cout &lt;&lt; ""Printing array with size ""
                    &lt;&lt; pArray.size() &lt;&lt; "":\n"";
        std::for_each(pArray.begin(), pArray.end(),
                [](int pX)
                {
                    std::cout &lt;&lt; pX &lt;&lt;  "" "";
                });
        std::cout &lt;&lt; std::endl;
    }
};

int main(void)
{
    // print all the types you have
    bmpl::for_each&lt;array_collection&gt;(print_type());
    std::cout.flush();

    // make a usable type out of the typelist
    typedef bf::result_of::as_vector&lt;array_collection&gt;::type array_fusion;
    array_fusion arrays; // now have an array of different arrays,
                         // compile-time generated but run-time usable

    // access like this:
    bf::at_c&lt;0&gt;(arrays)[1] = 5; 
    bf::at_c&lt;1&gt;(arrays)[2] = 7; 
    bf::at_c&lt;2&gt;(arrays)[0] = 135; 

    // for_each:
    bf::for_each(arrays, print_values());
}
</code></pre>
"
"<p>I know the title sounds familiar as there are many similar questions, but I'm asking for a different aspect of the problem (I know the difference between having things on the stack and putting them on the heap).</p>

<p>In Java I can always return references to ""local"" objects</p>

<pre><code>public Thing calculateThing() {
    Thing thing = new Thing();
    // do calculations and modify thing
    return thing;
}
</code></pre>

<p>In C++, to do something similar I have 2 options</p>

<p>(1) I can use references whenever I need to ""return"" an object</p>

<pre><code>void calculateThing(Thing&amp; thing) {
    // do calculations and modify thing
}
</code></pre>

<p>Then use it like this</p>

<pre><code>Thing thing;
calculateThing(thing);
</code></pre>

<p>(2) Or I can return a pointer to a dynamically allocated object</p>

<pre><code>Thing* calculateThing() {
    Thing* thing(new Thing());
    // do calculations and modify thing
    return thing;
}
</code></pre>

<p>Then use it like this</p>

<pre><code>Thing* thing = calculateThing();
delete thing;
</code></pre>

<p>Using the first approach I won't have to free memory manually, but to me it makes the code difficult to read. The problem with the second approach is, I'll have to remember to <code>delete thing;</code>, which doesn't look quite nice. I don't want to return a copied value because it's inefficient (I think), so here come the questions</p>

<ul>
<li>Is there a third solution (that doesn't require copying the value)?</li>
<li>Is there any problem if I stick to the first solution?</li>
<li>When and why should I use the second solution?</li>
</ul>
","87234","","<blockquote>
  <p>I don't want to return a copied value because it's inefficient</p>
</blockquote>

<p>Prove it.</p>

<p>Look up RVO and NRVO, and in C++0x move-semantics. In most cases in C++03, an out parameter is just a good way to make your code ugly, and in C++0x you'd actually be hurting yourself by using an out parameter.</p>

<p>Just write clean code, return by value. If performance is a problem, profile it (stop guessing), and find what you can do to fix it. It likely won't be returning things from functions.</p>

<hr>

<p>That said, if you're dead set on writing like that, you'd probably want to do the out parameter. It avoids dynamic memory allocation, which is safer and generally faster. It does require you have some way to construct the object prior to calling the function, which doesn't always make sense for all objects.</p>

<p>If you want to use dynamic allocation, the least that can be done is put it in a smart pointer. (This should be done all the time anyway) Then you don't worry about deleting anything, things are exception-safe, etc. The only problem is it's likely slower than returning by value anyway!</p>
"
"<p>I am trying to use a lambda to pass in place of a function pointer but VS2010 can't seem to convert it.  I have tried using std::function like this and it crashes and I have no idea if I am doing this right!</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;conio.h&gt;

#include &lt;functional&gt;
#include &lt;iostream&gt;

#include &lt;concrt.h&gt;


void main()
{
    std::function&lt;void(void*)&gt; f = [](void*) -&gt; void
    {
        std::cout &lt;&lt; ""Hello\n"";
    };


    Concurrency::CurrentScheduler::ScheduleTask(f.target&lt;void(void*)&gt;(), 0);

    getch();
}
</code></pre>

<p>It seems strange to me that the compiler can't convert such a lambda to a simple function pointer as it captures no variables - also in the case that it did I wonder what can be done.</p>

<p>Is the type of each lambda unique? So I could hack around with a template function using the lambdas' type as a template argument to generate a unique static function that could be called instead and hopefully optimised out?</p>

<p><strong>UPDATED</strong></p>

<p>The below seems to work but is it safe?</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;conio.h&gt;

#include &lt;iostream&gt;

#include &lt;concrt.h&gt;


template&lt;typename Signature&gt;
struct Bind
{
    static Signature method;

    static void Call(void* parameter)
    {
        method(parameter);
    }
};


template&lt;typename Signature&gt;
Signature Bind&lt;Signature&gt;::method;


template&lt;typename Signature&gt;
void ScheduleTask(Signature method)
{
    Bind&lt;Signature&gt;::method = method;
    Concurrency::CurrentScheduler::ScheduleTask(&amp;Bind&lt;Signature&gt;::Call,0);
}


void main()
{
    ScheduleTask
    (   
        [](void*)
        {
            std::cout &lt;&lt; ""Hello"";
        }
    );


    ScheduleTask
    (   
        [](void*)
        {
            std::cout &lt;&lt; "" there!\n"";
        }
    );


    getch();
}
</code></pre>

<p><strong>UPDATED AGAIN</strong></p>

<p>So with the help given I have come up with the shorter:</p>

<pre><code>template&lt;typename Signature&gt;
void (*LambdaBind(Signature))(void*)
{
    struct Detail
    {
        static void Bind(void* parameter)
        {
            Signature method;

            method(parameter);
        }
    };


    return &amp;Detail::Bind;
}
</code></pre>

<p>This can be used to wrap a lambda with no closure of <code>void(*)(void*)</code> into the equivalent function pointer.  It appears that this will become unnecessary in a later version of VS2010.</p>

<p>So how to get this to work for a lambda with closures?</p>

<p><strong>UPDATED AGAIN!</strong></p>

<p>Works for closures in VS2010 - no idea if it's 'safe' though...</p>

<pre><code>template&lt;typename Signature&gt;
struct Detail2
{
    static std::function&lt;void(void*)&gt; method;


    static void Bind(void* parameter)
    {
        method(parameter);
    }
};


template&lt;typename Signature&gt;
std::function&lt;void(void*)&gt; Detail2&lt;Signature&gt;::method;


template&lt;typename Signature&gt;
void (*LambdaBind2(Signature method))(void*)
{
    Detail2&lt;Signature&gt;::method = method;
    return &amp;Detail2&lt;Signature&gt;::Bind;
}
</code></pre>
","87234","","<p><a href=""http://stackoverflow.com/questions/3321283/c0x-lambda-how-can-i-pass-as-a-parameter"">This feature of lambda's was added after VS2010 implemented them, so they don't exist in it yet.</a></p>

<p>Here's a possible generic work-around, very untested:</p>

<pre><code>#include &lt;functional&gt;
#include &lt;iostream&gt;

namespace detail
{
    // helper specializations,
    // define forwarding methods
    template &lt;typename Lambda, typename Func&gt;
    struct lambda_wrapper;

    #define DEFINE_OPERATOR \
            typedef decltype(&amp;call) function_type; \
            operator function_type(void) const \
            { \
                return &amp;call; \
            }

    template &lt;typename Lambda, typename C, typename R&gt;
    struct lambda_wrapper&lt;Lambda, R (C::*)(void) const&gt;
    {
        static R call(void)
        {
            Lambda x;
            return x();
        }

        DEFINE_OPERATOR
    };

    template &lt;typename Lambda, typename C, typename R,
                typename A0&gt;
    struct lambda_wrapper&lt;Lambda, R (C::*)(A0) const&gt;
    {
        static R call(A0&amp;&amp; p0)
        {
            Lambda x;
            return x(std::forward&lt;A0&gt;(p0));
        }

        DEFINE_OPERATOR
    };

    // and so on
    #undef DEFINE_OPERATOR
}

// wraps a lambda and provides 
// a way to call it statically
template &lt;typename Lambda&gt;
struct lambda_wrapper :
        detail::lambda_wrapper&lt;Lambda, decltype(&amp;Lambda::operator())&gt;
{};

template &lt;typename Lambda&gt;
lambda_wrapper&lt;Lambda&gt; wrap_lambda(const Lambda&amp;)
{
    return lambda_wrapper&lt;Lambda&gt;();
}

int main(void)
{
    auto l = [](){ std::cout &lt;&lt; ""im broked :("" &lt;&lt; std::endl; };
    std::function&lt;void(void)&gt; f = wrap_lambda(l);

    f();
}
</code></pre>

<p>Let me know if any part is confusing.</p>
"
"<p>Most of my C++ programming experience has been projects for school. In that way, our usage of external libraries (ie boost) has been either prohibited or discouraged. Therefore we could not use smart pointers unless we wanted to write our own, which was usually beyond the scope of the projects. I'm just wondering in real world projects, how much memory management is actually done manually?</p>

<p>I guess this is sort of a vague question. I'm just wondering how memory management is usually done in real world projects.</p>
","87234","","<p>Depends what you mean by ""memory management"".</p>

<p>Obviously, a strict definition means ""all the time"", since automatic variables (stack allocated) is a memory thing. You probably didn't intend that.</p>

<p>On the other side, there is raw <code>new</code> and <code>delete</code> usage. This <em>should</em> never happen, but probably happens in ""common"" C++ anyway. It's bad practice, sloppy, and easily solvable with containers. One can literally copy and paste a smart pointer implementation from somewhere and be done, no excuse.</p>

<p>In the middle, ideally all ""management"" is done automatically, with containers. The only management that might need to be done is breaking cyclic dependencies or making your own container classes. </p>

<p>In my own projects, I only ever use <code>new</code> and <code>delete</code> when I'm making a utility class so I never have to <code>new</code> and <code>delete</code> again. After that, I only use <code>new</code> when it goes directly into some container.</p>
"
"<p>I'm using Microsoft Visual Studio 2010. When I add files to my project, they have a <code>.cpp</code> extension. To work with C, I have to manually rename the files to <code>.c</code>.</p>

<p>Is there any way to directly add C files, without renaming anything?</p>
","87234","","<p>If I'm understanding correctly, you want to directly add a C file to the project. Unfortunately, I don't think VS provides any means to do so; you'll just have to rename newly added files.</p>

<hr>

<p>You can rename a file from within the IDE. Right click the file and hit rename (or click on the file and push F2).</p>

<p><img src=""http://blackninjagames.com/images/rename_file.PNG"" alt=""Click file, push F2.""></p>
"
"<blockquote>
  <p><strong>Possible Duplicates:</strong><br>
  <a href=""http://stackoverflow.com/questions/437150/can-someone-explain-this-template-code-that-gives-me-the-size-of-an-array"">Can someone explain this template code that gives me the size of an array?</a><br>
  <a href=""http://stackoverflow.com/questions/2384107/magic-arguments-in-function-templates"">Magic arguments in function templates&hellip;</a>  </p>
</blockquote>



<p>Can someone explain how this code works? I know that the purpose of this code is to get the length of an array, but I don't know how this code works:</p>

<pre><code>template&lt;typename T, int size&gt;
int GetArrLength(T(&amp;)[size]){return size;}
</code></pre>

<p>Thanks.</p>
","87234","","<p>First let's dissect the parameter, <code>T(&amp;)[size]</code>. Read declarations from inside out, right to left, parenthesis group first: It's an unnamed parameter that is a reference to an array of size <code>size</code> of type <code>T</code>.</p>

<p>That is, it accepts a reference to any array, where the type and size of the array are template parameters.</p>

<p>If we call it as such:</p>

<pre><code>int a[10];
GetArrLength(a);
</code></pre>

<p>The compiler will try to deduce the template parameters. For the parameter type to match what you're passing, <code>T</code> must be <code>int</code> and <code>size</code> must be 10 (making the parameter a reference to an array of 10 <code>int</code>'s).</p>

<p>You then return that size, giving you the number of elements in an array.</p>

<hr>

<p>There are two ""problems"" with this code. Firstly, sizes cannot be negative, so it doesn't make sense to use a signed type as the template parameter and return type. Rather, an unsigned type should be used; best would be <code>std::size_t</code>:</p>

<pre><code>template&lt;typename T, std::size_t Size&gt;
std::size_t GetArrLength(T(&amp;)[Size]) { return size; }
</code></pre>

<p>The second is that the result of this function is not a constant-expression, even though an arrays size is. While that's fine in most situations, it would be better if we could get a constant-expression from it. That's where you end up with this solution:</p>

<pre><code>template &lt;std::size_t N&gt;
struct type_of_size
{
    typedef char type[N];
};

template &lt;typename T, std::size_t Size&gt;
typename type_of_size&lt;Size&gt;::type&amp; sizeof_array_helper(T(&amp;)[Size]);

#define sizeof_array(pArray) sizeof(sizeof_array_helper(pArray))
</code></pre>

<p>This is used as such:</p>

<pre><code>int a[10];
const std::size_t n = sizeof_array(a); // constant-expression!
</code></pre>

<p>It works by three things: the first is the same idea as above, that template parameters will be filled out giving you the array's size.</p>

<p>The second part is using that information to make a type with a specific size, hence the <code>type_of_size</code> helper. That part isn't strictly necessary, but I think it makes the code easier to read. A <code>char[N]</code> has a size equal to <code>N</code>, always, hence we can abuse that to ""store"" the size of the array...in the size of a type itself!</p>

<p>The third part is getting that size with <code>sizeof</code>. It doesn't actually evaluate anything, so we don't need a definition for the function. It simply says ""If you were to do this...the size would be..."". And the size is our ""stored"" size, in the <code>char</code> array.</p>
"
"<p>Free function <strong>allocate_shared</strong> can be used with any standard compliant allocator. But what about shared_ptr's constructor and reset method.</p>

<pre><code>template&lt;class Y, class D, class A&gt; shared_ptr(Y * p, D d, A a);
template&lt;class Y, class D, class A&gt; void reset(Y * p, D d, A a);
</code></pre>

<p>The manual says that <strong>D</strong> should provide a call operator which will be used to delete the pointer and <strong>A</strong> must be a standard compliant allocator. If so, why <strong>D</strong> is needed? Can't <strong>A</strong> do both allocation and delocation? <strong>Don't you think that the requirement to provide a deleter for every custom allocator makes the above methods pretty much useless?</strong> When I use custom allocators, I go for <strong>allocate_shared</strong>. How do I know what is the proper way to free memory allocated by a custom allocator?</p>

<p><strong>EDIT:</strong> After some experimentation with a verbatim allocator and a deleter I figured out that the allocator passed to the constructor of <strong>shared_ptr</strong> and to the factory function <strong>allocate_shared</strong> is used to allocate the internal structure of <strong>shared_ptr</strong> only. <strong>allocate_shared</strong> never uses the passed allocator to allocate the shared object. I think that the boost manual could have explained how the allocator is used more explicitly.</p>
","87234","","<p>The allocator is intended to be used to allocate and deallocate <em>internal <code>shared_ptr</code> details</em>, not the object.</p>

<p>That is, while the deleter gives us full control over our shared object (because we control how it's acquired and released), the allocator parameter gives us control over the internal details of our object's shared nature.</p>

<p>If you look at <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2351.htm"">N2351</a>, at the end of the allocator proposal they note that Boost has implemented the feature, and link to an example that was made to demonstrate its use. </p>

<p>Here is that example, verbatim:</p>

<pre><code>#include &lt;boost/config.hpp&gt;

//  shared_ptr_alloc2_test.cpp
//
//  Copyright (c) 2005 Peter Dimov
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)


#include &lt;boost/detail/lightweight_test.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;
#include &lt;memory&gt;
#include &lt;cstddef&gt;

// test_allocator

struct test_allocator_base
{
    int id_;

    static int last_global_id_;
    static int count_;

    explicit test_allocator_base( int id ): id_( id )
    {
    }
};

int test_allocator_base::last_global_id_ = 0;
int test_allocator_base::count_ = 0;

template&lt;class T&gt; class test_allocator: public test_allocator_base
{
public:

    typedef T * pointer;
    typedef T const * const_pointer;
    typedef T &amp; reference;
    typedef T const &amp; const_reference;
    typedef T value_type;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;

private:

    static T * last_pointer_;
    static std::size_t last_n_;
    static int last_id_;

public:

    template&lt;class U&gt; struct rebind
    {
        typedef test_allocator&lt;U&gt; other;
    };

    pointer address( reference r ) const
    {
        return &amp;r;
    }

    const_pointer address( const_reference s ) const
    {
        return &amp;s;
    }

    explicit test_allocator( int id = 0 ): test_allocator_base( id )
    {
    }

    template&lt;class U&gt; test_allocator( test_allocator&lt;U&gt; const &amp; r ): test_allocator_base( r )
    {
    }

    template&lt;class U&gt; test_allocator &amp; operator=( test_allocator&lt;U&gt; const &amp; r )
    {
        test_allocator_base::operator=( r );
        return *this;
    }

    void deallocate( pointer p, size_type n )
    {
        BOOST_TEST( p == last_pointer_ );
        BOOST_TEST( n == last_n_ );
        BOOST_TEST( id_ == last_id_ );

        --count_;

        ::operator delete( p );
    }

    pointer allocate( size_type n, void const * )
    {
        T * p = static_cast&lt; T* &gt;( ::operator new( n * sizeof( T ) ) );

        last_pointer_ = p;
        last_n_ = n;
        last_id_ = id_;

        last_global_id_ = id_;
        ++count_;

        return p;
    }

    void construct( pointer p, T const &amp; t )
    {
        new( p ) T( t );
    }

    void destroy( pointer p )
    {
        p-&gt;~T();
    }

    size_type max_size() const
    {
        return size_type( -1 ) / sizeof( T );
    }
};

template&lt;class T&gt; T * test_allocator&lt;T&gt;::last_pointer_ = 0;
template&lt;class T&gt; std::size_t test_allocator&lt;T&gt;::last_n_ = 0;
template&lt;class T&gt; int test_allocator&lt;T&gt;::last_id_ = 0;

template&lt;class T, class U&gt; inline bool operator==( test_allocator&lt;T&gt; const &amp; a1, test_allocator&lt;U&gt; const &amp; a2 )
{
    return a1.id_ == a2.id_;
}

template&lt;class T, class U&gt; inline bool operator!=( test_allocator&lt;T&gt; const &amp; a1, test_allocator&lt;U&gt; const &amp; a2 )
{
    return a1.id_ != a2.id_;
}

template&lt;&gt; class test_allocator&lt;void&gt;: public test_allocator_base
{
public:

    typedef void * pointer;
    typedef void const * const_pointer;
    typedef void value_type;

    template&lt;class U&gt; struct rebind
    {
        typedef test_allocator&lt;U&gt; other;
    };

    explicit test_allocator( int id = 0 ): test_allocator_base( id )
    {
    }

    template&lt;class U&gt; test_allocator( test_allocator&lt;U&gt; const &amp; r ): test_allocator_base( r )
    {
    }

    template&lt;class U&gt; test_allocator &amp; operator=( test_allocator&lt;U&gt; const &amp; r )
    {
        test_allocator_base::operator=( r );
        return *this;
    }
};

//

struct X
{
    static int instances;

    X()
    {
        ++instances;
    }

    ~X()
    {
        --instances;
    }

private:

    X( X const &amp; );
    X &amp; operator=( X const &amp; );
};

int X::instances = 0;

int main()
{
    BOOST_TEST( X::instances == 0 );

    boost::shared_ptr&lt;void&gt; pv( new X, boost::checked_deleter&lt;X&gt;(), std::allocator&lt;X&gt;() );

    BOOST_TEST( X::instances == 1 );

    pv.reset( new X, boost::checked_deleter&lt;X&gt;(), test_allocator&lt;float&gt;( 42 ) );

    BOOST_TEST( X::instances == 1 );

    BOOST_TEST( test_allocator_base::last_global_id_ == 42 );
    BOOST_TEST( test_allocator_base::count_ &gt; 0 );

    pv.reset();

    BOOST_TEST( X::instances == 0 );
    BOOST_TEST( test_allocator_base::count_ == 0 );

    pv.reset( new X, boost::checked_deleter&lt;X&gt;(), test_allocator&lt;void&gt;( 43 ) );

    BOOST_TEST( X::instances == 1 );
    BOOST_TEST( test_allocator_base::last_global_id_ == 43 );

    pv.reset( new X, boost::checked_deleter&lt;X&gt;(), std::allocator&lt;void&gt;() );

    BOOST_TEST( X::instances == 1 );

    pv.reset();

    BOOST_TEST( X::instances == 0 );

    return boost::report_errors();
}
</code></pre>
"
"<p>The code states:</p>

<pre><code>void (* log_msg)(char *msg)
    =printf;

void change_and_log(int *buffer, int offset, int value){
    buffer[offset] = value;
    log_msg(""changed"");
}
</code></pre>

<p>I'm most concerned with the first part:</p>

<p>Firstly, what does the signature <code>void (* log_msg)(char *msg)</code> mean?  Is this code simply mapping the function <code>log_msg</code> to <code>printf</code>?  In that case, why is the function name <code>(* log_msg)</code> and not simply <code>log_msg</code>?</p>
","87234","","<p>It's a <a href=""http://www.newty.de/fpt/index.html"" rel=""nofollow"">function pointer</a>.</p>

<p>The type of a function pointer is <code>R (*)(Args...)</code>, where <code>R</code> and <code>Args...</code> are replaced with the return type and arguments, if any. It is read as ""a pointer to a function that takes arguments <code>Args...</code> and returns <code>R</code>.""</p>

<p>Your code would read easier as:</p>

<pre><code>// print_function is a type that is a function pointer
typedef void (*print_function)(char *msg); 

// log_msg is a variable of the type print_function: it points to a function
print_function log_msg = printf; // point to printf
</code></pre>

<p>And later, it's just calling that function via a function pointer.</p>
"
"<p>i am using visual c++  2010  and want to check if it supports  boost library    and if not how download it?can i do  it?</p>
","87234","","<p>Yes, I use VS2010 and Boost. (You may find bumps here or there, since VS2010 is relatively new, but generally it all works the same.)</p>

<p>Do keep in mind there isn't a ""Boost library"", per se. Boost is a collection of libraries, and you can download it and include what you want, or just strip out the libraries you want.</p>
"
"<p>I just asked <a href=""http://stackoverflow.com/questions/3434534/how-do-i-code-and-pass-a-reference-to-a-stdvector"">this</a> question and the good answers mentioned using an initialization list. So I looked it up in many various places. It was often said that one can use an initialization list to select which constructor to use.</p>

<pre><code>class First
   {private: 
         int a, b, c;
  public:
First(int x);
First(int x, int y);
}

First::First(int x, int y, int z = 0)
{ /* this is a constructor that will take two or three int arguements. */ }

First::First(int x, int y = 0, int z = 0)
{ /* and this will be called if one arguement is given */ }
</code></pre>

<p>I thought all assignments should be avoided, so how would I write the initializer lists for these two constructors?</p>
","87234","","<p>I'm not quite sure I follow. As it stands, by providing an argument to <code>x</code> and <code>y</code> (and therefore <code>z</code>), <em>both</em> constructors will be available to call, resulting in ambiguity.</p>

<p>I think what you're looking for is:</p>

<pre><code>class First
{
public:
  First(int x);
  First(int x, int y, int z = 0);
};    

// invoked as First f(1);
First::First(int x) :
a(x), b(0), c(0)
{}

// invoked as First f(1, 2); or First f(1, 2, 3);
First::First(int x, int y, int z) :
a(x), b(y), c(z)
{}
</code></pre>
"
"<p>I'm using the following code in some cases:</p>

<pre><code>#define array_key_exists(find_key, arr) (arr.find(find_key) != arr.end())
</code></pre>

<p>But i also use simply this method:</p>

<pre><code>if(SomeMap[""something""]){
    // key exists
}
</code></pre>

<p>I am using String to int map.</p>

<p>Are they both as fast...? Or is there a possibility for errors with the second case, assuming i am not using zero value in the map values at all? So far the second case seems to work just fine.</p>
","87234","","<p>The second if-statement will always be entered, because if the key doesn't exist it will be created. (After which, subsequent calls will just return the existing element.)</p>

<p>If you want to find a value and use it if it exists, you typically do this:</p>

<pre><code>std::map&lt;T&gt;::iterator iter = theMap.find(theKey);
if (iter != theMap.end())
{
    // use iter
}
else
{
    // value doesn't exist
}
</code></pre>

<p>If you simply want to know if it's in there, without using it, do:</p>

<pre><code>if (theMap.count(theKey)) // in map, count will return either 0 or 1
{
    // it exists
}
else
{
    // it doesn't exist
}
</code></pre>

<hr>

<p>At the very least, don't use a macro! There's no reason to in C++:</p>

<pre><code>template &lt;typename Map, typename Key&gt;
bool contains(const Map&amp; pMap, const Key&amp; pKey)
{
    return pMap.find(pKey) != pMap.end();
}
</code></pre>

<p>But there's no use for this, just use <code>count</code>.</p>
"
"<p>Following an example in <em>Accelerated C++</em>, I created a custom STL container, which is a simplified version of <code>std::vector</code>, called <code>Vec</code>. Everything worked fine, until, emboldened by success, I tried to add a <code>Vec::clear()</code> that will clear the vector. </p>

<p>Here's the latest class definition (only the relevant parts to this question):</p>

<pre><code>template &lt;class T&gt;
class Vec {
public:
    Vec() { create(); }

    size_type size() const { return avail - data; }
    size_type capacity() const { return limit - data; }
    void clear();

    // operators that return iterators
    iterator begin() { return data; }
    const_iterator begin() const { return data; }
    iterator end() { return avail; }
    const_iterator end() const { return avail; }

    void push_back( const T&amp; val ) {
        if ( avail == limit ) grow();
        unchecked_append( val );
    }       
private:
    iterator data;  // points to beginning of data 
    iterator avail; // points to end of initialized data
    iterator limit; // points to end of data

    std::allocator&lt;T&gt; alloc;    // object to handle data allocation

    void create();
    // functions to support push_back()
    void grow();
    void unchecked_append( const T&amp; );
};

// Creates an empty vector.
template &lt;class T&gt; 
void Vec&lt;T&gt;::create() { data = avail = limit = 0; }

// All the elements of the vector are dropped: their destructors are called, 
// and then they are removed from the vector container, 
// leaving the container with a size  of 0. 
// The capacity remains the same, however.
template &lt;class T&gt;
void Vec&lt;T&gt;::clear()
{
    std::cout &lt;&lt; ""capacity before clear: "" &lt;&lt; capacity() &lt;&lt; std::endl;
    std::cout &lt;&lt; ""data = "" &lt;&lt; data &lt;&lt; "" limit = "" &lt;&lt; limit &lt;&lt; std::endl;
    if (data) {
        iterator it = avail;
        // destroy objects in reverse order
        while ( it != data ) {
            alloc.destroy(--it);
        }
    }
    data = avail = 0;
    std::cout &lt;&lt; ""capacity after clear: "" &lt;&lt; capacity() &lt;&lt; std::endl;
    std::cout &lt;&lt; ""data = "" &lt;&lt; data &lt;&lt; "" limit = "" &lt;&lt; limit &lt;&lt; std::endl;
}

// Controls how the vector should grow if it needs more space.
template &lt;class T&gt;
void Vec&lt;T&gt;::grow()
{
    // Allocate twice as much storage as is currently used.
    // If matrix is empty, allocate one element.
    size_type new_size = std::max( 2*(limit-data), ptrdiff_t(1) );

    // Allocate new space and copy existing elements
    iterator new_data = alloc.allocate( new_size );
    iterator new_avail = std::uninitialized_copy( data, avail, new_data );

    // Deallocate old space
    uncreate();

    // Reset pointers to new values
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

// Create space for one element at the end and put given value there.
template &lt;class T&gt;
void Vec&lt;T&gt;::unchecked_append( const T&amp; val )
{
    alloc.construct( avail, val );
    avail++;
}
</code></pre>

<p>I test this using </p>

<pre><code>Vec&lt;int&gt; v;

for ( int i = 0; i &lt; 100; i++ ) {
    v.push_back(i);
}
std::cout &lt;&lt; ""size="" &lt;&lt; v.size() &lt;&lt; "" capacity="" &lt;&lt; v.capacity() &lt;&lt; std::endl;
v.clear();
std::cout &lt;&lt; ""size="" &lt;&lt; v.size() &lt;&lt; "" capacity="" &lt;&lt; v.capacity() &lt;&lt; std::endl;
</code></pre>

<p>I get the following output:</p>

<pre><code>size=100 capacity=128
capacity before clear: 128
data = 0x100100280 limit = 0x100100480
capacity after clear: 1074004256
data = 0 limit = 0x100100480
size=0 capacity=1074004256
</code></pre>

<p>For some reason, <code>clear()</code> clobbers the <code>limit</code> pointer. How can this be when it doesn't even modify it. Code looks so simple, yet I cannot see what I'm missing.</p>

<p>Thanks!</p>
","87234","","<p>You're losing (and therefore leaking) <code>data</code> by setting it to 0. When you clear, you're only taking away the available (allocated) elements, the buffer (<code>data</code>) stays.</p>

<p>You should replace <code>data = avail = 0;</code> with <code>avail = data;</code>.</p>
"
"<pre><code>//Using g++ and ubuntu.
#include &lt;vector&gt;
using namespace std;
</code></pre>

<p>Define a class:</p>

<pre><code>class foo(){
(...)
foo(int arg1, double arg2);
}
</code></pre>

<p>Constructor:</p>

<pre><code>foo::foo(int arg1, double arg2){ 
(...) //arrays whose length depend upon arg1 and arg2
} 
</code></pre>

<p>I would like to do something like this:</p>

<pre><code>vector&lt;foo&gt; bar(10); //error: no matching function for call to 'foo::foo()'
bar[0] = new foo(123, 4.56);
(...)
</code></pre>

<p>An alternative method (which I like less) is to use push_back:</p>

<pre><code>vector&lt;foo&gt; bar; //works
bar.push_back(new foo(123, 4.56)); //throws similar error.
//Omitting the ""new"" compiles but throws a ""double free or corruption (fasttop)"" on runtime.
</code></pre>

<p>I want different elements of the vector to be constructed differently, so I don't want to use the ""Repetitive sequence constructor"".
What should be done?</p>
","87234","","<p>Why are you using <code>new</code> when no dynamic memory needs to be created? Of course using <code>new</code> will fail, it results in a <code>foo*</code> when <code>push_back</code> accepts a <code>foo</code>. (That's what you have a vector of, after all.)</p>

<p>What's wrong with <code>push_back</code>? If you want to reserve memory up front, use <code>reserve()</code>; providing a number in the constructor of <code>vector</code> makes that many copies of the second parameter (which is implicitly <code>foo()</code>, which won't work hence your errors), which isn't the same as simply reserving memory.</p>

<p>If doing things correctly (no <code>new</code>) crashes, the fault is in your code and not vector. You probably haven't written a proper class that manages resources.* (Remember <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29"" rel=""nofollow"">The Big Three</a>, use the <a href=""http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom"">copy-and-swap idiom</a>.)</p>

<p><sub>*I say this because you say ""<code>//arrays whose length depend upon arg1 and arg2
</code>"", which I suspect means you have <code>new[]</code> in your class somewhere. Without the Big Three, your resource management will fail.</p>

<p>You shouldn't be managing resources anyway, classes have one responsibility. That means it should either be a dynamic array, or use a dynamic array, but not both manage and use a dynamic array. So factor out the resources into their own class, and then make another class (yours) which uses them. A dynamic array is a <code>std::vector</code>, so you are already done with that. <em>Any</em> time you need a dynamic array, use a <code>vector</code>; there is never a reason not to.</sub></p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/3337126/in-c-why-cant-i-write-a-for-loop-like-this-for-int-i-1-double-i2-0"">In C++ why can&rsquo;t I write a for() loop like this: for( int i = 1, double i2 = 0; &hellip;</a>  </p>
</blockquote>



<p>A C developer would write this:</p>

<pre><code>int myIndex;
for (myIndex=0;myIndex&lt;10;++myIndex) ...
</code></pre>

<p>A C++ developer would write this to prevent the loop variable from leaking outside the loop:</p>

<pre><code>for (int myIndex=0;myIndex&lt;10;++myIndex) ...
</code></pre>

<p>However, if you have 2 loop variables, you cannot do this anymore.  The following doesn't compile:</p>

<pre><code>for (int myIndex=0,MyElement *ptr=Pool-&gt;First;ptr;++myIndex,ptr=ptr-&gt;next) ...
</code></pre>

<p>The comma operator does not allow two variables to be defined this way, so we have to write it like this:</p>

<pre><code>int myIndex;
MyElement *ptr;
for (myIndex=0,ptr=Pool-&gt;First;ptr;++myIndex,ptr=ptr-&gt;next) ...
</code></pre>

<p>Which defeats the advantage of having real loop-local variables.</p>

<p>A solution could be to put the whole construction between braces, like this:</p>

<pre><code>{
int myIndex;
MyElement *ptr;
for (myIndex=0,ptr=Pool-&gt;First;ptr;++myIndex,ptr=ptr-&gt;next) ...
}
</code></pre>

<p>But this is hardly more elegant.</p>

<p>Isn't there a better way of doing this in C++ (or C++0x)?</p>
","87234","","<p>You just have to understand the first statement is a declaration (and that comma is <em>not</em> the comma operator). It's not any harder to do:</p>

<pre><code>for (int i, double d; ...)
</code></pre>

<p>Than it is:</p>

<pre><code>int i, double d;
</code></pre>

<p>Because <code>for (init cond; expr) statement</code> gets expanded to:</p>

<pre><code>{
    init
    while (cond)
    {
        statement
        expr;
    }
}
</code></pre>

<p>A trick is to make that <code>init</code> statement a struct definition and instance, like:</p>

<pre><code>for (struct { int myIndex; MyElement* ptr;} data = {0, Pool-&gt;First};
    data.ptr;
    ++data.myIndex, data.ptr = data.ptr-&gt;next)
    {
        // blah...
    }
</code></pre>

<p>Which becomes the same as:</p>

<pre><code>{
    struct
    {
        int myIndex;
        MyElement* ptr;
    } data = {0, Pool-&gt;First};

    while (data.ptr)
    {
        {
            // blah...
        }
        ++data.myIndex, data.ptr = data.ptr-&gt;next;
    }
}
</code></pre>

<p>But I find that pretty ugly. In practice, I'd just split it up like you have. If scope is <em>really</em> a problem, which it probably isn't, throw the extra braces around there.</p>

<p>I don't think there's much to improve here without a bit of boilerplate code.</p>
"
"<p>I am preparing some code:</p>

<pre><code>for(int a = 1; a &lt;= 100; a++)    //loop a (main loop)
{
    for(int b = 1000; b &lt;= 2000; b++)    //loop b
    {
       if(b == 1555)
          break;
    }

    for(int c = 2001; c &lt;= 3000; c++)    //loop c
    {
       .
       .
       .
    }
}
</code></pre>

<p>I want to break the main loop (loop variable <code>int a</code>) by using a <code>break;</code> statement in the b loop (loop variable <code>int b</code>).</p>

<p>How can I do it?</p>
","87234","","<p>Either do one of four things: use <code>goto</code>, use <code>throw</code>, use a flag, or refactor.</p>

<p>Many will disagree with <a href=""http://stackoverflow.com/questions/3442423/c-break-the-main-loop/3442441#3442441"">using <code>goto</code></a>, but <a href=""http://stackoverflow.com/questions/3442423/c-break-the-main-loop/3442442#3442442"">sometimes</a> it's a clean solution. (Most times, it isn't, but it exists for a reason.) However, I find the use of <code>goto</code> warrants a refactor.</p>

<p>The second solution is <a href=""http://stackoverflow.com/questions/3442423/c-break-the-main-loop/3442443#3442443"">to throw</a> some special exception and then catch it just outside the main loop. This is an abuse of the exception system and basically a worse <code>goto</code>; use a <code>goto</code> instead of this.</p>

<p>The third solution would be to use <a href=""http://stackoverflow.com/questions/3442423/c-break-the-main-loop/3442444#3442444"">a flag</a> of <a href=""http://stackoverflow.com/questions/3442423/c-break-the-main-loop/3442445#3442445"">some sort</a>. This is basically a ""safer"" <code>goto</code>, but some might argue it's a bit uglier. (Especially with multiple-levels. Though in such a case your concern is how ugly your code is.)</p>

<p>The solution I would recommend is <strong>refactor</strong>. Whatever you're doing, it's too much. You should move the inner loops into a function, and call that function. Returning to the main loop is simply a return from that function. (In other words ""My work is done."")</p>
"
"<p>I have stringstream object ss1</p>

<p>now I would like to create another copy from this one.</p>

<p>I try this </p>

<pre><code>std::stringstream ss2 = ss1;
</code></pre>

<p>or </p>

<pre><code>std::stringstream ss2(ss1)
</code></pre>

<p>neither works</p>

<p>The error message is like this</p>

<p>std::ios::basic_ios(const std::ios &amp;) is not accessible from bsl::basic_stringstream, bsl::allocator>::basic_stringstream(const bsl::basic_stringstream, bsl::allocator>&amp;).</p>
","87234","","<p>Indeed, streams are non-copyable (though they are movable).</p>

<p>Depending on your usage, the following works quite well:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;

int main()
{
    std::stringstream ss1;
    ss1 &lt;&lt; ""some "" &lt;&lt; 123 &lt;&lt; "" stuff"" &lt;&lt; std::flush;

    std::stringstream ss2;
    ss2 &lt;&lt; ss1.rdbuf(); // copy everything inside ss1's buffer to ss2's buffer

    std::cout &lt;&lt; ss1.str() &lt;&lt; std::endl;
    std::cout &lt;&lt; ss2.str() &lt;&lt; std::endl;
}
</code></pre>

<p>Output:</p>

<blockquote>
  <p>some 123 stuff<br>
  some 123 stuff  </p>
</blockquote>
"
"<p>In another community, i have people suggesting that you should 'NEVER' have attributes in your base class. Instead it should have only pure virtual functions and let the derived class take responsibility to provide definition for all these methods.</p>

<p>My take on it is that 'It is not a rule of thumb'. I gave following trivial example:</p>

<pre><code>class Shape
{
    protected:
        double Area;
        double Perimeter ;
    public:
        Shape():Area(0.0), Perimeter(0.0){}
        double getArea(){return Area;}
        double getPerimeter (){return Perimeter;}
        virtual void setArea () = 0 ;
        virtual void setPerimeter () = 0 ;
};

class Rectangle : public Shape
{
    private :
        double length ;
        double breadth ;
    public:
        Rectangle ():length(0.0),breadth(0.0){}
        Rectangle (int _length, int _breadth):length(_length),breadth(_breadth){}
        void setArea ()
        {
            Area = length * breadth ;
        }
        void setPerimeter ()
        {
            Perimeter = 2 * (length + breadth) ;
        }
} ; 
</code></pre>

<p>With the example given above, i feel that any shape has following attributes <strong>'Area'</strong> and <strong>'Perimeter'</strong> and hence if we do not provide these attributes in the class, the <strong>Shape class</strong> would not be a appropriate representation of <strong>'Real world shape'</strong></p>

<p>Please let me know your opinion on this.</p>

<p><strong>EDIT:</strong></p>

<p>The first thing which i would say is indeed my code is a naive one and doesn't make much sense w.r.t. the design. I thought earlier that i would add a line saying that this was just an example and the whole point of this post is to know if 'Base class should <strong>NEVER</strong> have attributes'. But then i thought that i'll get some good design suggestions too and i indeed have got many :)</p>

<p>Coming to the question, with all the posts below, i understand that its not a rule of thumb and it is design choice (which is exactly i wanted to emphasize). Having said that i also acknowledge that it would be desirable to NOT have attributes in the base class if these attributes can be calculated (or derived) as Area = Length * Breadth. 
Thanks a lot for all your answers (i wish i had option to accept more than one answer).</p>
","87234","","<p>You need to separate interface from implementation. Yes, a shape has both area and perimeter, and yes you should provide a way to query those values, but <em>that's it</em>. You should not tell a shape <em>how</em> to to do this.</p>

<p>Note in your example you've broken invariants; a rectangle of a certain length and width can have its area publically changed from under its feet. (Because it has not yet been recalculated) A mess! Only define the interface to the attributes:</p>

<pre><code>class shape
{
    public:
        ~shape(){}

        virtual double area(void) const = 0;
        virtual double perimeter(void) const = 0;
};
</code></pre>

<p>And let the shapes return that information in their own way:</p>

<pre><code>class square : public shape
{
public:
    square(double pSide) : mSide
    {}

    double area(void) const
    {
        return mSide * mSide;
    }

    double perimeter(void) const
    {
        return 4 * mSide;
    }

private:
    double mSide;
};
</code></pre>

<p>However, let's say those things were indeed expensive to calculate, and you wanted to cache those attributes after a shape-specific property changed. You might introduce a <em>mixin</em>, which is just a helper base class. This particular once uses the CRTP:</p>

<pre><code>template &lt;typename Shape&gt;
class shape_attribute_cache : public shape
{
public:
    // provide shape interface
    double area(void) const
    {
        return cached_area();
    }

    double perimeter(void) const
    {
        return cached_perimeter();
    }

protected:
    shape_attribute_cache() : mArea(0), mPerim(0), mChanged(false) {} 
    ~shape_attribute_cache(){} // not to be used publically 

    double cached_area(void) const { update_area(); return mArea; }
    void cached_area(double pArea) { mArea = pArea; }

    double cached_perimeter(void) const { update_perimeter(); return mPerim; }
    void cached_perimeter(double pPerim) { mPerim = pPerim; }

    void changed(void) { mAreaChanged = true; mPerimChanged = true; }

private:
    void update_area(void)
    {
        if (!mAreaChanged) return;

        // delegate to derived shapes update method
        static_cast&lt;Shape*&gt;(this)-&gt;update_area();
        mAreaChanged = false;
    }

   void update_perimeter(void)
    {
        if (!mPerimChanged) return;

        // delegate to derived shapes update method
        static_cast&lt;Shape*&gt;(this)-&gt;update_perimeter();
        mPerimChanged = false;
    }

    double mArea;
    double mPerim;
    bool mAreaChanged;
    bool mPerimChanged;
};

// use helper implementation
class expensive_shape : public shape_attribute_cache&lt;expensive_shape&gt;
{
public:
    // ...

    void some_attribute(double pX)
    {
        mX = pX;
        changed(); // flag cache is bad, no longer callers responsibility
    }

private:
    // ...

    void update_area(void)
    {
        double newArea = /* complicated formula */;
        cached_area(newArea);
    }

    void update_perimeter(void)
    {
        double newPerim = /* complicated formula */;
        cached_perimeter(newPerim);
    }
}; 
</code></pre>

<p>A shape remains purely an interface, but you've provided a helper shape interface which <em>may</em> be used but you are not forcing this implementation upon other shapes.</p>

<p>This is all in this instance, perhaps it was just a poor example. You should do what you need to get a clean design, and if that means introducing variables into the base class, then do so. (Standard library streams do this, and then derived classes change virtual functions without changing the ""real"" functions; I do this in some of my code.)</p>
"
"<p>I just came across a piece of code written by my ex-colleague few years ago. Honestly, I'm not an C++ expert, so I am seeking help. </p>

<p>The code looks like this:</p>

<pre><code>std::vector&lt;OBJ&gt; objects;

void initobjs()
{
    for (int i=0; i&lt;10; i++)
    {
        OBJ obj;
        obj.type=i;
        obj.len=16;

        objects.push_back(obj);
    }
}
</code></pre>

<p>My question is: after function <code>initobjs()</code> returns, aren't all <code>obj</code> instances already out of scope and automatically freed by the C++ runtime system? If they are, will any reference to contents of any of the objects added to the vector cause memory fault or unexpected result?</p>
","87234","","<p>Your concern can be made even more local: <code>obj</code> ends at the bottom of the for-loop.</p>

<p>That said, a container makes a <em>copy</em> of its argument*, and does not store any reference or pointer to the ""original"" value.</p>

<p><sub>*Hence all containers require their elements be copy-constructible and copy-assignable.</sub></p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/1301380/g-is-not-a-type-error"">g++ &ldquo;is not a type&rdquo; error </a>  </p>
</blockquote>



<p>The following does not compile:</p>

<pre><code>1    template&lt;typename T&gt;
2    void foo(std::vector&lt;T&gt;::iterator &amp; i)
3    {  
4    }
</code></pre>

<p>On Visual Studio, I get the following errors:</p>

<pre><code>&gt;(2) error C2065: 'i' : undeclared identifier
&gt;(4) warning C4346: 'std::vector&lt;_Tp&gt;::iterator' : dependent name is not a type
     prefix with 'typename' to indicate a type
&gt;(4) error C2182: 'foo' : illegal use of type 'void'
&gt;(4) error C2998: 'int foo' : cannot be a template definition
</code></pre>
","87234","","<p><code>std::vector&lt;T&gt;::iterator</code> is a type that is <em>dependent</em> on a template parameter, namely <code>T</code>. Therefore, you should prefix with it <code>typename</code>:</p>

<pre><code>template&lt;typename T&gt;
void foo(typename std::vector&lt;T&gt;::iterator &amp; i)
{  
}
</code></pre>

<p><a href=""http://pages.cs.wisc.edu/~driscoll/typename.html"">Here's an explanation.</a></p>
"
"<p>Let's say I have an array of ints and I want to call a function to remove the smallest and largest values. By remove I mean that if my initial array was 7 elements in length, the new array has 5 elements. The order of the remaining elements does not matter. I've come up with some ways to do it, but I'm not sure which one is the C++ ""way"" of doing it, if that makes sense.</p>

<p>What I have now is that I use std::sort to sort my array and then I use a for loop to copy the results starting from the second element and stopping at the second-to last element into a new array with the appropriate size. How should I return the array though?</p>

<p>I can't return the newly created array because it's a local variable to the function. I could pass the new array as an argument to the function, but isn't that more of an older, C-style way of doing this? I could also use std::vector, but then I'd have to wrap the array in a vector and then unwrap it (the numbers need to remain in an array of ints). Seems like overkill, doesn't it?</p>

<p>I'm coming from a Python background and I just want to know what's the more appropriate way to do this in C++.</p>
","87234","","<p>There are two operations you need to perform: find the min and max, and then remove the min and max. By recognizing these steps and remember the single-responsibility principle, you maintain clean code.</p>

<p>The first operation is <em>missing</em> in C++03. As it stands, without making your own function the only way is to go through the range <em>twice</em>, one with <code>min_element</code> and <code>max_element</code>. This is algorithmically unnecessary.</p>

<p>C++0x recognizes this defect and adds <code>minmax_element</code> (and <code>minmax</code>). If you have a compiler that supports C++0x, just use <code>std::minmax_element</code> defined in <code>&lt;algorithm&gt;</code>. If not, <a href=""http://www.boost.org/doc/libs/1_43_0/boost/algorithm/minmax_element.hpp"" rel=""nofollow"">use Boost's</a> or steal Boost's/write your own.</p>

<p>We can now complete the first operation:</p>

<pre><code>int array[] = {4, 7, 6, 5, 9, 4, 3, 1, 11};

// see footnote for begin and end
std::pair&lt;int*, int*&gt; mm = minmax_element(begin(array), end(array));
</code></pre>

<p>With pointers (or iterators) to the elements, we now remove them. With a statically-sized array, the typically solution is to move them to the end, ala:</p>

<pre><code>// and take care your array has enough elements!
std::swap(*mm.first, end(array) - 2);
std::swap(*mm.second, end(array) - 1);
</code></pre>

<p>Then you just treat the array two elements shorter; this is O(1). Another solution, which maintains order, is to copy/shift all the elements down by one; this is O(N).</p>

<p>And that's it. You can wrap the above into some form of <code>erase_minmax</code> function.</p>

<p><sub>
*<code>begin</code> and <code>end</code> just make things a bit easier, they are:</p>

<pre><code>template &lt;typename T, size_t N&gt;
T* begin(T (&amp;pArray)[N])
{
    return pArray;
}

template &lt;typename T, size_t N&gt;
T* end(T (&amp;pArray)[N])
{
    return pArray + N;
}
</code></pre>

<p></sub></p>
"
"<p>in qemu source code, I have the following macro named <code>offsetof</code>. Can anybody tell me what it does? </p>

<pre><code>#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *) 0)-&gt;MEMBER)
</code></pre>

<p>It's used in this manner :</p>

<pre><code>offsetof(CPUState, icount_decr.u32)
</code></pre>

<p>where CPUState is a struct.</p>

<p>I think it gives the offset of the member inside a struct, but I'm not sure.</p>

<p>EDIT:Yeah, I found out what was happening. The definition of CPUState had a macro inside, which I missed, which included the variable icount_decr.</p>
","87234","","<p>It's defined in §7.17/3:</p>

<blockquote>
  <p><code>offsetof(type, member-designator)</code><br>
  which expands to an integer constant expression that has type <code>size_t</code>, the value of
  which is the offset in bytes, to the structure member (designated by <em>member-designator</em>),
  from the beginning of its structure (designated by <em>type</em>). The type and member designator
  shall be such that given<br>
  <code>static type t;</code><br>
  then the expression <code>&amp;(t.member-designator)</code> evaluates to an address constant. (If the
  specified member is a bit-field, the behavior is undefined.)</p>
</blockquote>

<p>Because the library doesn't have to necessarily follow language rules, an implementation is free to get the result however it pleases.</p>

<p>So the result of this particular implementation is <em>not</em> undefined behavior, because you aren't suppose to care how it's implemented. (In other words, your implementation makes the guarantee that taking the address of an indirection through a null pointer is well-defined. You of course can't assume this in your own programs.)</p>

<p>If that some library has (re)defined <code>offsetof</code>, they've made your program behavior undefined and should be using the standard library instead. (The dummies.)</p>
"
"<p>Is it somehow possible to use boost::object_pool&lt;>::construct with non const references?</p>

<p>The following snippet doesn't compile (VS2010):</p>

<pre><code>foo::foo(bar &amp; b)
{
}

static boost::shared_ptr&lt;foo&gt; foo::create(bar &amp; b)
{
  return boost::shared_ptr&lt;foo&gt;(foo_pool.construct(b),
    boost::bind(&amp; boost::object_pool&lt;foo&gt;::destroy, &amp; foo_pool, _1));
}
</code></pre>

<p>VS2010 complains about not being able to convert bar &amp; to const bar &amp;. Looking at boost::object_pool&lt;>::construct the reason ist clear:</p>

<pre><code>element_type * construct(const T0 &amp; a0)
</code></pre>

<p>I can't make the ctor parameter const though. Is there a trick to make boost::object_pool&lt;> work with my foo class?</p>
","87234","","<p>Use <a href=""http://www.boost.org/doc/libs/1_43_0/doc/html/ref.html""><code>boost::ref</code></a>:</p>

<pre><code>static boost::shared_ptr&lt;foo&gt; foo::create(bar &amp; b)
{
  return boost::shared_ptr&lt;foo&gt;(foo_pool.construct(boost::ref(b)),
    boost::bind(&amp; boost::object_pool&lt;foo&gt;::destroy, &amp; foo_pool, _1));
}
</code></pre>

<p><code>boost::ref</code> makes a <code>reference_wrapper</code>. Because that uses a pointer, it can be copied around however you wish, and implicitly dereferenced into a reference to the original value.</p>
"
"<p>A few simple questions.</p>

<pre><code>const int gFirst;
const int gSecond;

struct Data
{
    static int First;
    static int Second;

    int first;
    int second;
};

Data data;
</code></pre>

<p>Is it guaranteed that the following statements are true?</p>

<p>1) <code>&amp;gFirst &lt; &amp;gSecond</code><br>
2) <code>&amp;Data::First &lt; &amp;Data::Second</code><br>
3) <code>&amp;data.first &lt; &amp;data.second</code></p>
","87234","","<p>1) This result is unspecified.<br>
2) This result is unspecified.*<br>
3) Yes.  </p>

<p>The relevant section in the standard is §5.9/2. Relational comparisons between the pointers <code>p</code> and <code>q</code> are only specified when:</p>

<ul>
<li><code>p</code> and <code>q</code> point to the same object or function, point to one past the end of the same array, or both are null. In this case, <code>p &lt;= q</code> and <code>p &gt;= q</code> are true, and <code>p &lt; q</code> and <code>p &gt; q</code> are false.</li>
<li><code>p</code> and <code>q</code> point to nonstatic data members of the same object, the pointer to the later declared member compares greater. (Note, this comparison cannot be between access specifiers.)</li>
<li><code>p</code> and <code>q</code> point to elements within the same array or one past the end of the array, the pointer to the element with the higher subscript or to one past the end of the array compares greater.</li>
<li><code>p</code> and <code>q</code> point to data members of the same union object, in which case they compare equal. </li>
</ul>

<p>In all other cases, the result is not specified.</p>

<p><sub>*Because they are static, they (obviously) do not get the ""nonstatic member"" rules. They will be defined in some translation unit, and therefore are just like any other pointer. (Unspecified.)
</sub></p>

<hr>

<p><strong>Note!</strong> There is a way to get total ordering, and that is via <code>std::less&lt;void*&gt;</code> (and all the other comparative function objects.)</p>

<p>This is in §20.3.3/8:</p>

<blockquote>
  <p>For templates <code>greater</code>, <code>less</code>, <code>greater_equal</code>, and <code>less_equal</code>, the specializations for any
  pointer type yield a total order, even if the built-in operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> do not.</p>
</blockquote>

<p>So while you don't know if <code>std::less&lt;void*&gt;(&amp;gFirst, &amp;gSecond)</code> is <code>true</code> or <code>false</code>, you are guaranteed:</p>

<pre><code>std::less&lt;void*&gt;(&amp;gFirst, &amp;gSecond) ==
    std::greater&lt;void*&gt;(&amp;gSecond, &amp;gFirst);
std::less&lt;void*&gt;(&amp;Data::First, &amp;Data::Second) ==
    std::greater&lt;void*&gt;(&amp;Data::Second, &amp;Data::First);
</code></pre>

<p>Which can prove useful.</p>
"
"<p>I would like to use boost::shared_ptr&lt;> to encapsulate the lifetime management of a handle. My handle and it's creation/destruction functions are declared like this:</p>

<pre><code>typedef const struct MYHANDLE__ FAR* MYHANDLE;

void CloseMyHandle( MYHANDLE );
MYHANDLE CreateMyHandle();
</code></pre>

<p>Ideally, I would like to use the <code>boost::shared_ptr&lt;&gt;</code> like this to manage the handle:</p>

<pre><code>boost::shared_ptr&lt; void &gt; my_handle( CreateMyHandle(), &amp;CloseMyHandle );
</code></pre>

<p>Unfortunately, because the handle is declared as a <code>const struct *</code> instead of the usual <code>void *</code>, I get errors like this:</p>

<pre><code>boost/smart_ptr/shared_ptr.hpp(199) : error C2440: 'initializing' : cannot convert from 'const MYHANDLE__ *' to 'void *'
</code></pre>

<p>I can use a functor to cast the <code>void *</code> to a <code>MYHANDLE</code> like this:</p>

<pre><code>struct DeallocateMyHandle
{ 
    void operator()( void* handle )
    {
        CloseMyHandle( ( MYHANDLE )handle ); 
    };
};

boost::shared_ptr&lt; void &gt; my_handle( ( void* )CreateMyHandle(), DeallocateMyHandle() );
</code></pre>

<p>But, I'd rather have a method that doesn't involve the separate functor. Is there a way to do this just within the <code>boost::shared_ptr&lt;&gt;</code> constructor that I'm not seeing? Or, am I stuck with the functor?</p>

<p>Thanks,
PaulH</p>
","87234","","<p>Your <code>shared_ptr</code> type needs to be this:</p>

<pre><code>boost::shared_ptr&lt; const MYHANDLE__ FAR&gt;
</code></pre>

<p>That way when <code>shared_ptr</code> makes a pointer out of it, it becomes:</p>

<pre><code>const MYHANDLE__ FAR*
</code></pre>

<p>Which matches your <code>MYHANDLE</code> type exactly:</p>

<pre><code>#include &lt;boost/shared_ptr.hpp&gt;

struct MYHANDLE__ {};
typedef const MYHANDLE__* MYHANDLE;

void CloseMyHandle(MYHANDLE) {}
MYHANDLE CreateMyHandle(void) { return 0; }

int main()
{
    typedef boost::shared_ptr&lt;const MYHANDLE__&gt; ptr_type;
    ptr_type my_handle( CreateMyHandle(), &amp;CloseMyHandle );
}
</code></pre>

<hr>

<p>Note, I <em>really</em> doubt you need <code>FAR</code>, that's from the 16-bit ages. It expands to either <code>far</code> or nothing, depending on if you're compiling for 16-bit (hint: you aren't compiling to 16-bit. :) ). <code>far</code> isn't even an extension anymore, as far as I know.</p>

<p>Also, like Martin said don't use double-underscores anywhere.</p>
"
"<p>If I have a pointer to the start of a memory region, and I need to read the value packed in bits 30, 31, and 32 of that region, how can I read that value?</p>
","87234","","<p>I'd probably <a href=""http://stackoverflow.com/questions/3461482/reading-bits-in-a-memory/3461505#3461505"">generalize this answer</a> to something like this:</p>

<pre><code>template &lt;typename T&gt;
bool get_bit(const T&amp; pX, size_t pBit)
{
    if (pBit &gt; sizeof(pX) * CHAR_BIT)
        throw std::invalid_argument(""bit does not exist"");

    size_t byteOffset = pBit / CHAR_BIT;
    size_t bitOffset = pBit % CHAR_BIT;

    char byte = (&amp;reinterpret_cast&lt;const char&amp;&gt;(pX))[byteOffset];
    unsigned mask = 1U &lt;&lt; bitOffset;

    return (byte &amp; mask) == 1;
}
</code></pre>

<p>Bit easier to use:</p>

<pre><code>int i = 12345;
bool abit = get_bit(i, 4);
</code></pre>
"
"<p>Given Polygon P which I have its verticies in order. and I have a rectangle  R with 4 verticies how could I do this:</p>

<p>If any edge of P (line between adjacent vertexes) intersects an edge of R, then return TRUE, otherwise return FALSE.</p>

<p>Thanks</p>

<pre><code> *             *


*              *
</code></pre>
","87234","","<p>What you want is a quick way to determine if a line-segment intersects an axis-aligned rectangle. Then just check each line segment in the edge list against the rectangle. You can do the following:</p>

<p>1) Project the line onto the X-axis, resulting in an interval L<sub>x</sub>.<br>
2) Project the rectangle onto the X-axis, resulting in an interval R<sub>x</sub>.<br>
3) If L<sub>x</sub> and R<sub>x</sub> do not intersect, the line and rectangle do not intersect. </p>

<p>[Repeat for the Y-axis]:   </p>

<p>4) Project the line onto the Y-axis, resulting in an interval L<sub>y</sub>.<br>
5) Project the rectangle onto the Y-axis, resulting in an interval R<sub>y</sub>.<br>
6) If L<sub>y</sub> and R<sub>y</sub> do not intersect, the line and rectangle do not intersect.  </p>

<p>7) ...<br>
8) They intersect.</p>

<p>Note if we reach step 7, the shapes cannot be separated by an axis-aligned line. The thing to determine now is if the line is fully outside the rectangle. We can determine this by checking that all the corner points on the rectangle are on the same side of the line. If they are, the line and rectangle are not intersecting.</p>

<p>The idea behind 1-3 and 4-6 comes from the <a href=""http://en.wikipedia.org/wiki/Separating_axis_theorem"" rel=""nofollow"">separating axis theorem</a>; if we cannot find a separating axis, they must be intersecting. <em>All</em> these cases must be tested before we can conclude they are intersecting.</p>

<p>Here's the matching code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

typedef double number; // number type

struct point
{
    number x;
    number y;
};

point make_point(number pX, number pY)
{
    point r = {pX, pY};
    return r;
}

typedef std::pair&lt;number, number&gt; interval; // start, end
typedef std::pair&lt;point, point&gt; segment; // start, end
typedef std::pair&lt;point, point&gt; rectangle; // top-left, bottom-right

namespace classification
{
    enum type
    {
        positive = 1,
        same = 0,
        negative = -1
    };
}

classification::type classify_point(const point&amp; pPoint,
                                    const segment&amp; pSegment)
{
    // implicit line equation
    number x = (pSegment.first.y - pSegment.second.y) * pPoint.x +
                (pSegment.second.x - pSegment.first.x) * pPoint.y +
                (pSegment.first.x * pSegment.second.y -
                 pSegment.second.x * pSegment.first.y);

    // careful with floating point types, should use approximation
    if (x == 0)
    {
        return classification::same;
    }
    else
    {
        return (x &gt; 0) ? classification::positive :classification::negative;
    }
}

bool number_interval(number pX, const interval&amp; pInterval)
{
    if (pInterval.first &lt; pInterval.second)
    {
        return pX &gt; pInterval.first &amp;&amp; pX &lt; pInterval.second;
    }
    else
    {
        return pX &gt; pInterval.second &amp;&amp; pX &lt; pInterval.first;
    }
}

bool inteveral_interval(const interval&amp; pFirst, const interval&amp; pSecond)
{
    return number_interval(pFirst.first, pSecond) ||
            number_interval(pFirst.second, pSecond) ||
            number_interval(pSecond.first, pFirst) ||
            number_interval(pSecond.second, pFirst);
}

bool segment_rectangle(const segment&amp; pSegment, const rectangle&amp; pRectangle)
{
    // project onto x (discard y values)
    interval segmentX =
                std::make_pair(pSegment.first.x, pSegment.second.x);
    interval rectangleX =
                std::make_pair(pRectangle.first.x, pRectangle.second.x);

    if (!inteveral_interval(segmentX, rectangleX))
        return false;

    // project onto y (discard x values)
    interval segmentY =
                std::make_pair(pSegment.first.y, pSegment.second.y);
    interval rectangleY =
                std::make_pair(pRectangle.first.y, pRectangle.second.y);

    if (!inteveral_interval(segmentY, rectangleY))
        return false;

    // test rectangle location
    point p0 = make_point(pRectangle.first.x, pRectangle.first.y);
    point p1 = make_point(pRectangle.second.x, pRectangle.first.y);
    point p2 = make_point(pRectangle.second.x, pRectangle.second.y);
    point p3 = make_point(pRectangle.first.x, pRectangle.second.y);

    classification::type c0 = classify_point(p0, pSegment);
    classification::type c1 = classify_point(p1, pSegment);
    classification::type c2 = classify_point(p2, pSegment);
    classification::type c3 = classify_point(p3, pSegment);

    // test they all classify the same
    return !((c0 == c1) &amp;&amp; (c1 == c2) &amp;&amp; (c2 == c3));
}

int main(void)
{
    rectangle r = std::make_pair(make_point(1, 1), make_point(5, 5));
    segment s0 = std::make_pair(make_point(0, 3), make_point(2, -3));
    segment s1 = std::make_pair(make_point(0, 0), make_point(3, 0));
    segment s2 = std::make_pair(make_point(3, 0), make_point(3, 6));
    segment s3 = std::make_pair(make_point(2, 3), make_point(9, 8));

    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; segment_rectangle(s0, r) &lt;&lt; std::endl;
    std::cout &lt;&lt; segment_rectangle(s1, r) &lt;&lt; std::endl;
    std::cout &lt;&lt; segment_rectangle(s2, r) &lt;&lt; std::endl;
    std::cout &lt;&lt; segment_rectangle(s3, r) &lt;&lt; std::endl;
}
</code></pre>

<p>Hope that makes sense.</p>
"
"<p>Sometimes, I felt method overloading may create confusion.</p>

<pre><code>class a {
public:
    void copy(float f);
    void copy(double d);
};
</code></pre>

<hr>

<pre><code>a me;
me.copy(1.2); // Not obvious at the first sight on which version we are calling.
</code></pre>

<hr>

<p>A workaround on this is.</p>

<pre><code>class a {
public:
    void copyFloat(float f);
    void copyDouble(double d);
};
</code></pre>

<hr>

<p>However, having method with different name, to perform same functionality doesn't seem a good idea as well. May I know, what do you consider, to choose among <strong>method overloading</strong>, or <strong>method with different naming</strong>?</p>
","87234","","<p>Overloading for sure.</p>

<p>Okay, so it's not ""obvious"" which function gets called (arguable)...so what? You don't care that it can take different types of parameters, it just needs to do its thing. If you have different behavior based on different overloads, you've abused overloads, not pointed out a flaw in them.</p>

<p>An example of abusing overloads:</p>

<pre><code>// good:
struct has_properties
{
    void property1(float); // set property1, which happens to be a float
    void property2(int); // set property2, which happens to be an int
};

// bad:
struct has_properties
{
    void property(float); // set property1, abusing that it's a float
    void property(int); // set property2, abusing that it's an int
};
</code></pre>

<p>Hopefully you see the problem here. If two functions have the same name, they should do the same thing.</p>

<p>Even better, if you're merely trying to allow the possibility for operating on different types, just use a template. (This arguably is a form of overloading.)</p>
"
"<p>I want to create an immutable data structure which, say, can be initialized from a file.</p>

<pre><code>class Image {
public:
   const int width,height;
   Image(const char *filename) {
     MetaData md((readDataFromFile(filename)));
     width = md.width();   // Error! width  is const
     height = md.height(); // Error! height is const
   }
};
</code></pre>

<p>What I could do to fix the problem is</p>

<pre><code>class Image {
   MetaData md;
public:
   const int width,height;
   Image(const char *filename):
     md(readDataFromFile(filename)),
     width(md.width()),height(md.height()) {}
};
</code></pre>

<p>However </p>

<ol>
<li>It forces me to save MetaData as a field in my object. Which I don't always want.</li>
<li>Sometimes the logic in the constructor is much more complex than a single read (say, error handling can take a few lines)</li>
</ol>

<p>So the only solution I thought of is along the lines of</p>

<pre><code>class A {
  int stub;
  int init(){/* constructor logic goes here */}
  A():stub(init)/*now initialize all the const fields you wish
  after the constructor ran */{}
};
</code></pre>

<p>Is there a better idea? (In <code>Java</code>, you're allowed initializing <code>final</code>s in the constructor).</p>
","87234","","<p>First, you should understand the constructor body is just for running code to <em>complete</em> initializing your object as a whole; the members must be completely initialized before the body is entered.</p>

<p>Ergo, <em>all</em> members are initialized in an (implicit unless made explicit) initialization list. Clearly, <code>const</code> variables must be initialized in the list because once you enter the body, they are already suppose to be initialized; you'd simply be trying to assign them.</p>

<p>Generally, you don't have <code>const</code> members. If you want those members to be immutable, just don't give any public access to them that could change them. (Also, having <code>const</code> members make your class non-assignable; typically unnecessarily.) Going this route easily fixes your problem, as you'd just assign them values in the body of the constructor like you wish.</p>

<p>A method to do what you want while maintaining <code>const</code> could be:</p>

<pre><code>class ImageBase
{
public:
    const int width, height;

protected:
    ImageBase(const MetaData&amp; md) :
    width(md.width()),
    height(md.height())
    {}

    // not meant to be public to users of Image
    ~ImageBase(void) {} 
};

class Image : public ImageBase
{
public:
    Image(const char* filename) : // v temporary!
    ImageBase(MetaData(readDataFromFile(filename)))
    {}
};
</code></pre>

<p>I don't think this route is worth it.</p>
"
"<p>What is the right way to typedef a type and the same type's pointer? Here is what I mean. Should I do this:</p>

<pre><code>typedef unsigned int delay;
typedef unsigned int * delayp;
</code></pre>

<p>Or should I do this:</p>

<pre><code>typedef unsigned int delay;
typedef delay * delayp;
</code></pre>

<p>Or perhaps I should not typedef pointer at all and just use <code>delay *</code> instead of <code>delayp</code> everywhere I find necessary?</p>

<p>Thanks, Boda Cydo.</p>
","87234","","<p>Generally, you do the second block because you're re-using the type. For example, if <code>delay</code> needed to become an <code>unsigned long</code>, the definition of <code>delayp</code> wouldn't need to be modified.</p>

<p>That said, hiding pointers behind <code>typedef</code>'s is usually a very bad idea. It's more acceptable for things that <em>act</em> like pointers, like iterators or smart pointers:</p>

<pre><code>typedef std::vector&lt;int&gt; my_container;
typedef my_container::iterator my_iterator;

typedef some_type&lt;blah&gt; my_type;
typedef shared_ptr&lt;my_type&gt; my_shared_ptr;
</code></pre>
"
"<p>I have the following C++ map example code:</p>

<pre><code>map&lt;string,string&gt; &amp;weight2price  
....  
weight = ...  
price = ...  
if(weight2price.find(weight) == weight2price.end())  
    weight2price[weight] = price;
</code></pre>

<p>could anyone tell me what it means by</p>

<pre><code>if(weight2price.find(weight) == weight2price.end())
</code></pre>
","87234","","<p>If the key passed to <code>find()</code> does not exist, <code>find()</code> returns <code>end()</code>. So it's saying ""If it wasn't found..."".</p>

<p>The code could be written better as:</p>

<pre><code>weight2price.insert(std::make_pair(weight, price));
</code></pre>

<p>So look-up isn't done twice. (If the key already exists, <code>insert</code> won't do anything.)</p>
"
"<p>I have an SFINAE test for checking if an class has a function.  The test works correctly, but I get compiler errors when I try to use it in an if statement.</p>

<pre><code>//SFINAE test for setInstanceKey()
template &lt;typename K&gt;
class HasSetInstanceKey
{
    template &lt;typename C&gt;
    static char test( typeof(&amp;C::setInstanceKey) );

    template &lt;typename C&gt;
    static long test(...);

public:
    enum { value = 1 == sizeof(test&lt;K&gt;(0)) };
};
</code></pre>

<p>I get ""error: ‘class Node’ has no member named ‘setInstanceKey’"" on the second line even though the else clause should be executing.</p>

<pre><code>if ( 0 != HasSetInstanceKey&lt;T&gt;::value)
    instance-&gt;setInstanceKey(instanceKey);
else
    ...
</code></pre>

<p>Is there a way to make this work?</p>

<p>Thanks.</p>
","87234","","<p>Just because the if-branch is never entered doesn't mean the code within the branch can be invalid. (Another way to think about it: you aren't guaranteed anything about optimizations, yet your code would only be valid with a dead-branch optimization.)</p>

<p>What you do is shift the branch to a function. Typically you have a framework like this:</p>

<pre><code>// holds some integral constant
template &lt;typename T, T V&gt;
struct integral_constant
{
    static const T value = V;
};

// holds a boolean constant
template &lt;bool V&gt;
struct bool_type : integral_constant&lt;bool, V&gt;
{};

typedef bool_type&lt;true&gt; true_type; // a true boolean constant
typedef bool_type&lt;false&gt; false_type; // a false boolean constant

typedef const true_type&amp; true_tag; // tag a function as the true variant
typedef const false_type&amp; false_tag; // tag a function as the false variant
</code></pre>

<p>Then something like this:</p>

<pre><code>namespace detail
{
    template &lt;typename T, typename KeyType&gt;
    void foo(T* instance, const KeyType&amp; instanceKey, true_tag)
    {
        // we are in the true variant, so our meta-function's value was true
        // therefore, instance has the ability to do setInstanceKey
        instance-&gt;setInstanceKey(instanceKey);
    }

    template &lt;typename T, typename KeyType&gt;
    void foo(T*, const KeyType&amp;, false_tag)
    {
        // we are in the false variant, so our meta-function's value was false
        // therefore, instance does not have the right capabilities, 
        // so do nothing
    }
}

// interface, forwards to correct implementation function
template &lt;typename T, typename KeyType&gt;
void foo(T* instance, const KeyType&amp; instanceKey)
{
    // pass instance, but to the overloaded foo 
    // that accepts the right boolean result
    detail::foo(instance, instanceKey, // plug the value into a bool_type, 
                bool_type&lt;HasSetInstanceKey&lt;T&gt;::value&gt;()); // and instantiate it
                // will either go into the true_tag or false_tag
}
</code></pre>

<p>It's good practice to have to meta-functions inherit from the correct <code>bool_type</code>, to ease use:</p>

<pre><code>namespace detail
{
    // implementation
    template &lt;typename K&gt;
    class HasSetInstanceKey
    {
        // note, using char and long doesn't necessarily guarantee
        // they each have a unique size. do this instead:
        typedef char yes[1];
        typedef char no[2]; // these must have different sizes

        template &lt;typename C&gt;
        static yes&amp; test( typeof(&amp;C::setInstanceKey) );

        template &lt;typename C&gt;
        static no&amp; test(...);

    public:
        // check against size of yes result
        static const bool value = sizeof(test&lt;K&gt;(0)) == sizeof(yes);
    };
}

template &lt;typename K&gt;
struct HasSetInstanceKey : // delegate to implementation, take result and
    bool_type&lt;detail::HasSetInstanceKey&lt;K&gt;::value&gt; // inherit from the 
                                                   // appropriate bool_type
{};
</code></pre>

<p>So it just becomes:</p>

<pre><code>template &lt;typename T, typename KeyType&gt;
void foo(T* instance, const KeyType&amp; instanceKey)
{
    // because it inherits from bool_type, it can be implicitly
    // converted into either true_tag or false_tag
    detail::foo(instance, instanceKey, HasSetInstanceKey&lt;T&gt;());
}
</code></pre>
"
"<p>I got a simple C++ struct as follows:</p>

<pre><code>// Functor for peak to decreasing intensity sorting
struct cmp_decr_int2
{
    bool operator() (peak2 a, peak2 b) 
    { 
        return a.int2 &gt; b.int2;
    }   
};
</code></pre>

<p>is there an overload of the operator in this sample?</p>
","87234","","<p>Yes. <code>operator()</code> is called the ""function call"" operator, and allows an object to be usable as if it were a function. Such a class is called a ""functor"".</p>

<p>A common pattern is to make functors that compare two things for equality or relations, for use in anything requiring a comparison predicate. (This one could be usable in an <code>std::map</code>, for example. It would have a member like<code>cmp_decr_int2 compare;</code> and then it could compare the relation between two things with: <code>if (compare(x, y)) /* x is less than y, by some metric */</code>)</p>

<p>This particular struct orders two <code>peak2</code>'s by comparing their <code>int2</code> members. It could be better written as:</p>

<pre><code>struct cmp_decr_int2
{
    //                     note const! vvvvv
    bool operator() (peak2 a, peak2 b) const
    { 
        return a.int2 &gt; b.int2;
    }   
};
</code></pre>

<p>The function should be <code>const</code> because it does not need to change any members (there are none to change.) <a href=""http://www.parashift.com/c++-faq-lite/const-correctness.html"" rel=""nofollow""><code>const</code>-correctness</a> is important.*</p>

<p>In many cases these functors are used in contexts where the arguments themselves are <code>const</code>, so you should either take the arguments by value as in the example or by constant reference.</p>

<p>You should prefer to pass types by const-reference over by-value, except when that type is fundamental (float, unsigned int, double, etc.) or smaller than a <code>void*</code>. In most cases, then, you will pass by const-reference:</p>

<pre><code>struct cmp_decr_int2
{
    // note const&amp;:  vvvvv       v    vvvvv       v    vvvvv
    bool operator() (const peak2 &amp; a, const peak2 &amp; b) const
    { 
        return a.int2 &gt; b.int2;
    }   
};
</code></pre>

<p><sub>
*If this were used as a predicate in a <code>std::map</code>, for example, without <code>const</code> the map wouldn't be able to compare two things while within a <code>const</code> function.
</sub></p>
"
"<p>I have some data that is stored in a sorted vector. This vector is sorted by some key. I know the STL has an algorithm for checking if an element is in this sorted list. This means I can write something like this:</p>

<pre><code>struct MyData { int key; OtherData data; };
struct MyComparator
{
  bool operator()( const MyData &amp; d1, const MyData &amp; d2 ) const
  {
    return d1.key &lt; d2.key;
  }
};

bool isKeyInVector( int key, const std::vector&lt;MyData&gt; &amp;v )
{
   MyData thingToSearchFor;
   thingToSearchFor.key = key;
   return std::binary_search( v.begin(), v.end(), thingToSearchFor, MyComparator() );
}
</code></pre>

<p>However I find the construction of the ""thingToSearchFor"" object inelegant. Is there a better way? Something similar to this?</p>

<pre><code>struct MyComparator2
{
  bool operator()( const MyData &amp; d1, const MyData &amp; d2 ) const
  {
    return d1.key &lt; d2.key;
  }
};

bool isKeyInVector2( int key, const std::vector&lt;MyData&gt; &amp;v )
{
   return std::binary_search( v.begin(), v.end(), key, MyComparator2() );
}
</code></pre>
","87234","","<p>Do:</p>

<pre><code>struct MyComparator
{
    bool operator()(int d1, const MyData &amp; d2) const
    {
        return d1 &lt; d2.key;
    }

    bool operator()(const MyData &amp; d1, int d2) const
    {
        return d1.key &lt; d2;
    }
};
</code></pre>

<p>The predicate is called like <code>pred(value, ...)</code> or <code>pred(..., value)</code>, so just take in the value directly. </p>
"
"<p>I've a class and there is an array set as private. How do I make the <code>get_array()</code> function? I mean, how do I return that array knowing that I will have to return a pointer of arr[0] as we know , but isn't this breaking the private rule? Is there another way of returning this array?</p>

<p>I actually thought of having array2 in the main, then edit that array using the class function. I think it will be a plan B if the above doesn't work.</p>
","87234","","<p>You can do a few things.</p>

<p>The simplest is to return a pointer to the first element that is const: <code>const int* get_array(void) const;</code> You might want to make a function to query the size as well.</p>

<p>A better option might be to return a const-reference to the array. Use a <code>typedef</code> to make it simple:</p>

<pre><code>typedef int array_type[10];
const array_type&amp; get_array(void) const;
</code></pre>

<p>Another option is to <a href=""http://stackoverflow.com/questions/3478377/c-return-private-array/3478397#3478397"">wrap the array up</a>, like <code>boost::array</code>. You can copy and paste Boost's header if you want, into your own <code>array.hpp</code>:</p>

<pre><code>typedef boost::array&lt;int, 10&gt; array_type;
const array_type&amp; get_array(void) const;
</code></pre>
"
"<p>A template template specification is like this:</p>

<pre><code>template &lt; template &lt; class &gt; class T &gt;
struct MyTemplate
{
};
</code></pre>

<p>How am I supposed to create a total (or partial) specialization for this template? 
Is this possible?</p>
","87234","","<p>Like this:</p>

<pre><code>#include &lt;iostream&gt;

template &lt;typename T&gt;
struct foo{};

template &lt;typename T&gt;
struct bar{};

template &lt; template &lt; class &gt; class T &gt;
struct MyTemplate
{
    static const bool value = false;
};

template &lt;&gt;
struct MyTemplate&lt;bar&gt;
{
    static const bool value = true;
};


int main(void)
{
    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; MyTemplate&lt;foo&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; MyTemplate&lt;bar&gt;::value &lt;&lt; std::endl;
}
</code></pre>
"
"<p>The following pattern has arisen in a program I'm writing.  I hope it's not too contrived, but it manages to mutate a <code>Foo</code> object in the const method <code>Foo::Questionable() const</code>, without use of any const_cast or similar.  Basically, <code>Foo</code> stores a reference to <code>FooOwner</code> and vice versa, and in <code>Questionable()</code>, <code>Foo</code> manages to modify itself in a const method by calling <code>mutate_foo()</code> on its owner.  Questions follow the code.</p>

<pre><code>#include ""stdafx.h""
#include &lt;iostream&gt;
using namespace std;

class FooOwner;

class Foo {
    FooOwner&amp; owner;
    int data;

public:
    Foo(FooOwner&amp; owner_, int data_)
        : owner(owner_),
          data(data_)
    {
    }

    void SetData(int data_)
    {
        data = data_;
    }

    int Questionable() const;       // defined after FooOwner
};

class FooOwner {
    Foo* pFoo;

public:
    FooOwner()
        : pFoo(NULL)
    {}

    void own(Foo&amp; foo)
    {
        pFoo = &amp;foo;
    }

    void mutate_foo()
    {
        if (pFoo != NULL)
            pFoo-&gt;SetData(0);
    }
};

int Foo::Questionable() const
{
    owner.mutate_foo();     // point of interest
    return data;
}

int main()
{
    FooOwner foo_owner;
    Foo foo(foo_owner, 0);      // foo keeps reference to foo_owner
    foo_owner.own(foo);         // foo_owner keeps pointer to foo

    cout &lt;&lt; foo.Questionable() &lt;&lt; endl;  // correct?

    return 0;
}
</code></pre>

<p>Is this defined behavior?  Should <code>Foo::data</code> be declared mutable?  Or is this a sign I'm doing things fatally wrong?  I'm trying to implement a kind of lazy-initialised 'data' which is only set when requested, and the following code compiles fine with no warnings, so I'm a little nervous I'm in UB land.</p>

<p>Edit: the <code>const</code> on Questionable() only makes immediate members const, and not the objects pointed to or referenced by the object.  Does this make the code legal?  I'm confused between the fact that in <code>Questionable()</code>, <code>this</code> has the type <code>const Foo*</code>, and further down the call stack, <code>FooOwner</code> legitimately has a non-const pointer it uses to modify <code>Foo</code>.  Does this mean the <code>Foo</code> object can be modified or not?</p>

<p>Edit 2: perhaps an even simpler example:</p>

<pre><code>class X {
    X* nonconst_this;   // Only turns in to X* const in a const method!
    int data;

public:
    X()
        : nonconst_this(this),
          data(0)
    {
    }

    int GetData() const
    {
        nonconst_this-&gt;data = 5;    // legal??
        return data;
    }
};
</code></pre>
","87234","","<p>Consider the following:</p>

<pre><code>int i = 3;
</code></pre>

<p><code>i</code> is an object, and it has the type <code>int</code>. It is not cv-qualified (is not <code>const</code> or <code>volatile</code>, or both.)</p>

<p>Now we add:</p>

<pre><code>const int&amp; j = i;
const int* k = &amp;i;
</code></pre>

<p><code>j</code> is a reference which refers to <code>i</code>, and <code>k</code> is a pointer which points to <code>i</code>. (From now on, we simply combine ""refer to"" and ""points to"" to just ""points to"".)</p>

<p>At this point, we have two cv-qualified variables, <code>j</code> and <code>k</code>, that point to a non-cv-qualified object. This is mentioned in §7.1.​5.1/3:</p>

<blockquote>
  <p>A pointer or reference to a cv-qualified type need not actually point or refer to a cv-qualified object, but it is treated as if it does; a const-qualified access path cannot be used to modify an object even if the object referenced is a non-const object and can be modified through some other access path. [Note: cv-qualifiers are supported by the type system so that they cannot be subverted without casting (5.2.11). ]</p>
</blockquote>

<p>What this means is that a compiler must respect that <code>j</code> and <code>k</code> are cv-qualified, even though they point to a non-cv-qualified object. (So <code>j = 5</code> and <code>*k = 5</code> are illegal, even though <code>i = 5</code> is legal.)</p>

<p>We now consider removing the <code>const</code> from those:</p>

<pre><code>const_cast&lt;int&amp;&gt;(j) = 5;
*const_cast&lt;int*&gt;(k) = 5;
</code></pre>

<p>This is legal (§refer to 5.2.11), but is it undefined behavior? <strong>No.</strong> See §7.1.​5.1/4:</p>

<blockquote>
  <p>Except that any class member declared mutable (7.1.1) can be modified, <strong>any attempt to modify a const object during its lifetime (3.8) results in undefined behavior</strong>.
  <sup>Emphasis mine.</sup></p>
</blockquote>

<p>Remember that <code>i</code> is <em>not</em> <code>const</code> and that <code>j</code> and <code>k</code> both point to <code>i</code>. All we've done is tell the type system to remove the const-qualifier from the type so we can modify the pointed to object, and then modified <code>i</code> through those variables.</p>

<p>This is exactly the same as doing:</p>

<pre><code>int&amp; j = i; // removed const with const_cast...
int* k = &amp;i; // ..trivially legal code

j = 5;
*k = 5;
</code></pre>

<p>And this is trivially legal. We now consider that <code>i</code> was this instead:</p>

<pre><code>const int i = 3;
</code></pre>

<p>What of our code now?</p>

<pre><code>const_cast&lt;int&amp;&gt;(j) = 5;
*const_cast&lt;int*&gt;(k) = 5;
</code></pre>

<p>It now leads to <em>undefined behavior</em>, because <code>i</code> is a const-qualified object. We told the type system to remove <code>const</code> so we can modify the pointed to object, <em>and then modified a const-qualified object</em>. This is undefined, as quoted above.</p>

<p>Again, more apparent as:</p>

<pre><code>int&amp; j = i; // removed const with const_cast...
int* k = &amp;i; // ...but this is not legal!

j = 5;
*k = 5;
</code></pre>

<p>Note that simply doing this:</p>

<pre><code>const_cast&lt;int&amp;&gt;(j);
*const_cast&lt;int*&gt;(k);
</code></pre>

<p>Is perfectly legal and defined, as no const-qualified objects are being modified; we're just messing with the type-system.</p>

<hr>

<p>Now consider:</p>

<pre><code>struct foo
{
    foo() :
    me(this), self(*this), i(3)
    {}

    void bar() const
    {
        me-&gt;i = 5;
        self.i = 5;
    }

    foo* me;
    foo&amp; self;
    int i;
};
</code></pre>

<p>What does <code>const</code> on <code>bar</code> do to the members? It makes access to them go through something called a <em>cv-qualified access path</em>. (It does this by changing the type of <code>this</code> from <code>T* const</code> to <code>cv T const*</code>, where <code>cv</code> is the cv-qualifiers on the function.)</p>

<p>So what are the members types during the execution of <code>bar</code>? They are:</p>

<pre><code>// const-pointer-to-non-const, where the pointer points cannot be changed
foo* const me;

// foo&amp; const is ill-formed, cv-qualifiers do nothing to reference types
foo&amp; self; 

// same as const int
int const i; 
</code></pre>

<p>Of course, the types are irrelevant, as the important thing is the const-qualification of the <em>pointed to</em> objects, not the pointers. (Had <code>k</code> above been <code>const int* const</code>, the latter <code>const</code> is irrelevant.) We now consider:</p>

<pre><code>int main()
{
    foo f;
    f.bar(); // UB?
}
</code></pre>

<p>Within <code>bar</code>, both <code>me</code> and <code>self</code> point to a non-const <code>foo</code>, so just like with <code>int i</code> above we have well-defined behavior. Had we had:</p>

<pre><code>const foo f;
f.bar(); // UB!
</code></pre>

<p>We would have had UB, just like with <code>const int</code>, because we would be modifying a const-qualified object.</p>

<p>In your question, you have no const-qualified objects, so you have no undefined behavior.</p>

<hr>

<p>And just to add an appeal to authority, consider the <code>const_cast</code> trick by Scott Meyers, used to recycle a const-qualified function in a non-const function:</p>

<pre><code>struct foo
{
    const int&amp; bar() const
    {
        int* result = /* complicated process to get the resulting int */
        return *result; 
    }

    int&amp; bar()
    {
        // we wouldn't like to copy-paste a complicated process, what can we do?
    }

};
</code></pre>

<p>He suggests:</p>

<pre><code>int&amp; bar(void)
{
    const foo&amp; self = *this; // add const
    const int&amp; result = self.bar(); // call const version
    return const_cast&lt;int&amp;&gt;(result); // take off const
}
</code></pre>

<p>Or how it's usually written:</p>

<pre><code>int&amp; bar(void)
{
    return const_cast&lt;int&amp;&gt;( // (3) remove const from result
            static_cast&lt;const foo&amp;&gt;(*this) // (1) add const to this
            .bar() // (2) call const version
            ); 
}
</code></pre>

<p>Note this is, again, perfectly legal and well-defined. Specifically, because this function must be called on a non-const-qualified <code>foo</code>, we are perfectly safe in stripping the const-qualification from the return type of <code>int&amp; boo() const</code>.</p>

<p>(Unless someone shoots themselves with a <code>const_cast</code> + call in the first place.)</p>

<hr>

<p>To summarize:</p>

<pre><code>struct foo
{
    foo(void) :
    i(),
    self(*this), me(this),
    self_2(*this), me_2(this)
    {}

    const int&amp; bar() const
    {
        return i; // always well-formed, always defined
    }

    int&amp; bar() const
    {
        // always well-formed, always well-defined
        return const_cast&lt;int&amp;&gt;(
                static_cast&lt;const foo&amp;&gt;(*this).
                bar()
                );
    }

    void baz() const
    {
        // always ill-formed, i is a const int in baz
        i = 5; 

        // always ill-formed, me is a foo* const in baz
        me = 0;

        // always ill-formed, me_2 is a const foo* const in baz
        me_2 = 0; 

        // always well-formed, defined if the foo pointed to is non-const
        self.i = 5;
        me-&gt;i = 5; 

        // always ill-formed, type points to a const (though the object it 
        // points to may or may not necessarily be const-qualified)
        self_2.i = 5; 
        me_2-&gt;i = 5; 

        // always well-formed, always defined, nothing being modified
        // (note: if the result/member was not an int and was a user-defined 
        // type, if it had its copy-constructor and/or operator= parameter 
        // as T&amp; instead of const T&amp;, like auto_ptr for example, this would 
        // be defined if the foo self_2/me_2 points to was non-const
        int r = const_cast&lt;foo&amp;&gt;(self_2).i;
        r = const_cast&lt;foo* const&gt;(me_2)-&gt;i;

        // always well-formed, always defined, nothing being modified.
        // (same idea behind the non-const bar, only const qualifications
        // are being changed, not any objects.)
        const_cast&lt;foo&amp;&gt;(self_2);
        const_cast&lt;foo* const&gt;(me_2);

        // always well-formed, defined if the foo pointed to is non-const
        // (note, equivalent to using self and me)
        const_cast&lt;foo&amp;&gt;(self_2).i = 5;
        const_cast&lt;foo* const&gt;(me_2)-&gt;i = 5;

        // always well-formed, defined if the foo pointed to is non-const
        const_cast&lt;foo&amp;&gt;(*this).i = 5;
        const_cast&lt;foo* const&gt;(this)-&gt;i = 5;
    }

    int i;

    foo&amp; self;
    foo* me;
    const foo&amp; self_2;
    const foo* me_2;
};

int main()
{
    int i = 0;
    {
        // always well-formed, always defined
        int&amp; x = i;
        int* y = &amp;i;
        const int&amp; z = i;
        const int* w = &amp;i;

        // always well-formed, always defined
        // (note, same as using x and y)
        const_cast&lt;int&amp;&gt;(z) = 5;
        const_cast&lt;int*&gt;(w) = 5;
    }

    const int j = 0;
    {
        // never well-formed, strips cv-qualifications without a cast
        int&amp; x = j;
        int* y = &amp;j;

        // always well-formed, always defined
        const int&amp; z = i;
        const int* w = &amp;i;

        // always well-formed, never defined
        // (note, same as using x and y, but those were ill-formed)
        const_cast&lt;int&amp;&gt;(z) = 5;
        const_cast&lt;int*&gt;(w) = 5;
    }

    foo x;
    x.bar(); // calls non-const, well-formed, always defined
    x.bar() = 5; // calls non-const, which calls const, removes const from
                 // result, and modifies which is defined because the object
                 // pointed to by the returned reference is non-const,
                 // because x is non-const.

    x.baz(); // well-formed, always defined

    const foo y;
    y.bar(); // calls const, well-formed, always defined
    const_cast&lt;foo&amp;&gt;(y).bar(); // calls non-const, well-formed, 
                               // always defined (nothing being modified)
    const_cast&lt;foo&amp;&gt;(y).bar() = 5; // calls non-const, which calls const,
                                   // removes const from result, and
                                   // modifies which is undefined because 
                                   // the object pointed to by the returned
                                   // reference is const, because y is const.

    y.baz(); // well-formed, always undefined
}
</code></pre>

<p><sub>I refer to the ISO C++03 standard.</sub></p>
"
"<p>In a program to simulate logic gates I switched from using arrays </p>

<pre><code>node N[1000];
</code></pre>

<p>to vectors </p>

<pre><code>vector&lt;node&gt; N;
</code></pre>

<p>And my program did work perfectly before using vectors but now it prints wrong results, so I tried debugging and I found out that the bug happens here:</p>

<pre><code>node* Simulator::FindNode(string h)
{
    int i;
    for(i = 0; i &lt; NNodes; i++)
    {
        if (N[i].getname() == h)
        {
            return &amp;N[i];
        }
    }

    node n ;
    N.push_back(n);
    N[NNodes].setname(h);
    NNodes++;
    return &amp;N[NNodes-1]; //why?because of NNodes++  
}

// ...

node* inp1;
node* inp2;
node* out;
string NodeName;

inp_file &gt;&gt; NodeName;
inp1 = FindNode(NodeName);
s1 = inp1;

inp_file &gt;&gt; NodeName;
inp2 = FindNode(NodeName); //inp1 is destroyed here 

inp_file &gt;&gt; NodeName;
out = FindNode(NodeName); //inp2 and inp1 are destroyed here 
</code></pre>

<p>When calling <code>FindNode</code> for the 1st time, the 1st pointer inp1 points to the right place which is <code>&amp;N[0]</code>.  </p>

<p>When calling <code>FindNode</code> for the second time the 1st pointer inp1 points to rubbish and the second pointer inp2 points to the right place <code>&amp;N[1]</code>. </p>

<p>When calling <code>FindNode</code> for the 3rd time the both the 1st and 2nd pointers (<code>inp1</code>, <code>inp2</code>) point to rubbish! And 3rd pointer out points to the right place. </p>

<p><em>Why would that happen?</em><br>
<em>How does vector work when I insert items to them and which kind of pointers should I use to point to vectors items?</em></p>
","87234","","<p>A few things.</p>

<p>First, as far as I can tell <code>NNodes</code> is just tracking the size. But you have <code>std::vector::size()</code> for that. You then use it to get the last inserted element, but you can just use <code>std::vector::back()</code> for that: <code>return &amp;N.back();</code>.</p>

<p>Also your parameter is being passed by value, when it should probably be passed by const-reference: <code>const string&amp; h</code>. This avoids unnecessary copies, and in general* you should pass things by const-reference instead of by-value.</p>

<p>And this is bad:</p>

<pre><code>node n;
N.push_back(n);
N[NNodes].setname(h);
</code></pre>

<p><code>node</code> should probably have a constructor that takes a <code>const string&amp;</code> and sets the name during initialization. That way you can never have a node without a name, as in:</p>

<pre><code>node n(h);
N.push_back(n);
</code></pre>

<p>Or more terse:</p>

<pre><code>N.push_back(node(h));
</code></pre>

<p>Much better.</p>

<p>Second, yes, <code>vector</code> can invalidate pointers to elements; namely, whenever the capacity of the vector needs to be increased. If you can, <code>reserve()</code> the capacity up front to avoid re-allocations. In your case you cannot, so you can go two different routes.</p>

<p>The first route is <a href=""http://stackoverflow.com/questions/3488571/does-insertion-of-elements-in-a-vector-damages-a-pointer-to-the-vector/3488573#3488573"">a level of indirection</a>. Instead of pointing directly at things, get their index into the array. Note that while their address may change, their location within the vector will not. You would have <code>Simulator::FindNode</code> return a <code>size_t</code>, and return <code>N.size() - 1</code>. Add a member like <code>node&amp; GetNode(size_t index)</code>, which just does <code>return N[index];</code> (will error checking if you wish). Now whenever you need a member, hand the index to that member to <code>GetNode</code> and you'll get a reference to that node back.</p>

<p>The other route is to change your container. You can use a <code>deque</code>, for example. This does not have contiguous storage, but it's much like <code>vector</code>. <code>push_back</code> and <code>pop_back</code> are still O(1), and it still has good cache-coherence. (And by the way, <code>deque</code> trades contiguous storage for the ability to <code>push_front</code> and <code>pop_front</code> in O(1) time as well)</p>

<p>The important thing is that <code>deque</code> will <em>not</em> invalidate pointers during a push or pop operation from either end. It works by a sort of vector-list hybrid, where you get chunks of storage for elements linked together. Change your underlying storage to <code>deque</code> (and don't take or put anything in the middle), and you can point to things just fine.</p>

<p>However, from what I can tell you have a terribly inefficient map. You're mapping names to nodes. You should probably just use <code>std::map</code>, which has the exact interface you're trying to recreate. You can even point to any element in a map, which never invalidates things.</p>

<p><sub>
*The rule is, pass by const-reference unless the type is primitive (built-in like <code>int</code>, <code>double</code>, etc.), if the types size is less than <code>sizeof(void*)</code>, or if you are going to need a copy of it anyway.</p>

<p>That is, don't do this:</p>

<pre><code>void foo(const std::string&amp; s)
{
    std::string ss(s); // make a copy, use copy
}
</code></pre>

<p>But do this:</p>

<pre><code>void foo(std::string s) // make a copy, use copy
{
}
</code></pre>

<p></sub></p>
"
"<p>Do I need virtual destructor when I am using boost::ublas matrix ? </p>

<p>By the way, my class is a template class.</p>
","87234","","<p>Do you mean you have this?</p>

<pre><code>template &lt;typename Whatever&gt;
struct my_class
{
    // ...

    boost::ublas::matrix m;
};
</code></pre>

<p>There's nothing here that dictates you have a virtual destructor.</p>

<hr>

<p>You want a virtual destructor when you intend on having users publically derive from your class. So that question should be ""Users will publically derive from my class, do I need a virtual destructor?"". Yes, you do.</p>

<p>The reason is that doing this leads to undefined behavior:</p>

<pre><code>struct base {}; // no virtual destructor
struct derived : base {};

base* b = new derived;

// undefined behavior, dynamic type does not match static type,
// and the base class does not have a virtual destructor
delete b; 
</code></pre>

<p>This does not:</p>

<pre><code>struct base { virtual ~base(){} }; // virtual destructor
struct derived : base {};

base* b = new derived;

// well-defined behavior, dynamic type does not match static type,
// but the base class has a virtual destructor
delete b; 
</code></pre>

<p>Note that it has <em>nothing</em> to do with what members there are in the base class. You <em>always</em> need a virtual destructor if users will be deleting derived classes through a pointer to a base class.</p>

<hr>

<p><sub>
I would recommend you <a href=""http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">get a book</a> so you know what it does, because it sounds like you just throw things around and hope it works, which isn't a very good approach.
</sub></p>
"
"<p>Couldn't figure out how to word the question accurately, so here's an example:</p>

<p>Given this function prototype:</p>

<pre><code>void Foo(myClass* bar);
</code></pre>

<p>I want to prevent this usage:</p>

<pre><code>Foo(new myClass());
</code></pre>

<p>and instead require a previously created object:</p>

<pre><code>myClass* bar = NULL;
bar = new myClass();
Foo(bar);
</code></pre>

<p>or</p>

<pre><code>myClass bar;
Foo(&amp;bar);
</code></pre>

<p>Thanks.</p>

<hr>

<h2>EDIT</h2>

<p>Here's a clarified example:</p>

<pre><code>
void Mouse::SetImage(BITMAP* image, int focusX, int focusY) {
    if(_image) {
        set_mouse_sprite(NULL);
        set_mouse_sprite_focus(0, 0);
        show_mouse(NULL);
        destroy_bitmap(_image);
        _image = NULL;
    }
    if(image) {
        _image = create_bitmap(image->w, image->h);
        clear_bitmap(_image);
        blit(image, _image, 0, 0, 0, 0, image->w, image->h);
    }
    if(image == NULL) {
        focusX = 0;
        focusY = 0;
    }
    _focusX = focusX;
    _focusY = focusY;
    _dirtyImage = true;
}
</code></pre>

<p>Whatever image the user passes in gets copied to the object's image.</p>

<p>If I deallocate the passed in image after copying it and the image is used elsewhere in the program it will crash the program with an access violation.</p>

<p>If they allocate the storage in-line and I don't deallocated it, a memory leak occurs. The problem is compounded if they call the SetImage method multiple times over the course of the running program.</p>

<p>Comments about using alternative libraries or on the Allegro Library itself will be ignored, I already know it's horrible. I don't have a choice.</p>
","87234","","<p>Your design needs to make a choice. Either take ownership and delete it, or don't take ownership. <em>Either way, it's up to the user to know how to use your function.</em> They either need to know that your function will destroy the image (and maybe pass their own copy as needed), or they need to be smart enough to manage their own resources.</p>

<p>Typically, you don't want to steal ownership away just to delete it. So I would <em>not</em> delete anything. If someone is silly enough to lose the ability to delete the image they pass, that's not this functions problem. In other words, you should try to protect against Murphy, but forget about protecting against Machiavelli.</p>

<p>That said, raw pointer use is bad! Poor C++ code is marked by manual resource management and resource issues. You should have a wrapper around an image, that will delete the image in the destructor. That way you can <em>never</em> leak, even if an exception is thrown. Provide it with a <code>reset()</code> method which discards it's old image resource and gets a new one.</p>

<p>It sounds like you want shared ownership, so you'll want a reference counted resource wrapper. The issue is then solved: if someone does an ""inline"" allocation, it'll be put into the shared pointer and then deleted automatically when it's done. (And even better is to have an <code>explicit</code> constructor so someone has to know they'll be sharing the resource.)</p>

<p>This is done in a smart pointer called <code>shared_ptr</code>. <a href=""http://www.boost.org/doc/libs/1_43_0/libs/smart_ptr/shared_ptr.htm?sess=8153b05b34d890e02d48730db1ff7ddc"">Boost</a> has one, TR1 has one, and C++0x has one. Just give it a custom deleted (one that frees the image), and you never worry about resource management again. </p>

<p>This should be done with <em>all</em> resources. The concept here is <a href=""http://stackoverflow.com/questions/3119197/whats-the-right-approach-for-error-handling-in-c/3119202#3119202"">Scoped-bound Resource Management</a> (SBRM); that a resource is managed automatically by taking advantage of the lifetime rules of automatic (stack) variables. It's known alos as it's original but uglier name <a href=""http://stackoverflow.com/questions/395123/raii-and-smart-pointers-in-c/395158#395158"">Resource-Acquisition Is Initialization</a> (RAII). Do some research into this area and you'll find your code is easier and cleaner.</p>

<hr>

<p>It cannot be done without changing the type of the parameter. You could change it to:</p>

<pre><code>void Foo(myClass*&amp; bar);
</code></pre>

<p>Because a non-const reference can only be bound to an lvalue:</p>

<pre><code>void foo(int*&amp;);

int main(void)
{
    int *i = 0;
    int j;

    foo(i); // well-formed
    foo(&amp;j); // ill-formed
    foo(new int); // ill-formed
}
</code></pre>

<p>However, this disallows taking the address of an lvalue. You can of course do the simple:</p>

<pre><code>int main(void)
{
    int j;
    int* pj = &amp;j;
    foo(pj); // well-formed
}
</code></pre>

<p>And it works. But I don't know why you'd want to do any of this.</p>

<hr>

<p>The above solution would allow you to modify the argument (because it's a reference). If you wanted to enforce const within the function, you could make a utility like this:</p>

<pre><code>template &lt;typename T&gt;
class require_lvalue
{
public:
    require_lvalue(T&amp; pX) :
    mX(pX)
    {}

    const T&amp; get(void) const
    {
        return mX;
    }

    operator const T&amp;(void) const
    {
        return get();
    }

private:
    // non-copy-assignable
    require_lvalue&amp; operator=(const require_lvalue&amp;);

    const T&amp; mX;
};

void foo(require_lvalue&lt;int*&gt;);
</code></pre>

<p>Same result, except you have a const-reference within the function.</p>

<hr>

<p>Note that MSVC has a bug, and accepts this:</p>

<pre><code>foo(new int);
</code></pre>

<p>in both cases, even though it shouldn't. (It does not accept <code>new int()</code>, however.)</p>
"
"<p>I found in some legacy code I'm dealing with this function (in C++)</p>

<pre><code>Vec3d Minimum()
{
    if(this-&gt;valid)
    {
        return minBB;
    }
    else
    {
        return NULL;
    }
}
</code></pre>

<p>where Vec3d is a object that is basically a struct with x,y,z and some operators overloaded (code below).</p>

<p>AFAIK, you can't return a 0 for a user defined object... or is there some automatic cast to zero that I didn't know about? This is just out of curiosity :p</p>

<p>Thanks</p>

<pre><code>class Vec3d
{
public:
    double x,y,z;

    /// \brief Default constructor initializes x and y to 0
    Vec3d();

    /** \brief Constructor initializies vector to input parameters x and y and z
     *
     *  \param x Double value that initializes x value of vector
     *  \param y Double value that initializes y value of vector
     *  \param z Double value that initializes z value of vector
     */
    Vec3d(double x, double y, double z);

    /** \brief Copy constructor
     *
     *  \param v Pointer to another vec3i with which to initialize current vec3i
     */
    Vec3d(Vec3d* v);

    /**\brief Sets a vector (already instantiated) to the input parameters (x,y,z)
     *
     *  \param x Double value that initializes x value of vector
     *  \param y Double value that initializes y value of vector
     *  \param z Double value that initializes z value of vector
     *
     *  This method is just so you can change the value of an already instantiated vector
     */
    void set(double xi, double yi, double zi);

    const Vec3d operator -(const Vec3d &amp;other) const;
    const Vec3d operator +(const Vec3d &amp;other) const;
    const Vec3d operator *(const double num) const;
    const double operator *(const Vec3d &amp;other) const;
    const Vec3d operator /(const double num) const;
    double magnitude();
};
</code></pre>
","87234","","<p>0 can be used in the context of pointers to be the null pointer constant. That is, it's going into here:</p>

<pre><code>Vec3d(Vec3d* v); 
</code></pre>

<p>Note the comment is incorrect, as that is <em>not</em> a copy-constructor.</p>

<p>The code is a bit shoddy. There doesn't need to be a <code>set</code> function, and typically non-mutating operators should be free-functions. And not least of all, having a constructor like it has is a waste and confusing. If you have a pointer to a vector, you should do:</p>

<pre><code>Vec3d v = *other;
</code></pre>

<p>Not provide an implicit conversion from a pointer.</p>
"
"<p>For code,</p>

<pre><code>while(1)
{
   /* ..... */
}
</code></pre>

<p>MSVC generates the following warning. </p>

<pre><code>warning C4127: conditional expression is constant
</code></pre>

<p><a href=""http://msdn.microsoft.com/en-us/library/6t66728h%28VS.80%29.aspx"" rel=""nofollow"">MSDN</a> page for the warning suggests to use <code>for(;;)</code> instead of <code>while(1)</code>. I am wondering what advantage <code>for(;;)</code> is giving and why it warns for the constant usage in <code>while</code>? </p>

<p>What flag to use on GCC to get the same warning?</p>
","87234","","<p><code>for(;;)</code> and <code>while (true)</code> are different in that the former is a special case <em>defined</em> to be an infinite loop, while the latter is sort of an abuse saying ""true, always.""</p>

<p>The warning comes up because infinite loops when <a href=""http://stackoverflow.com/questions/3490823/why-msvc-generates-warning-c4127-whan-constant-is-used-in-while-c/3490834#3490834"">you don't want them</a> are pretty bad, so it's warning you that you might have one at the first sign. But by using <code>for(;;)</code>, you've pretty much explicitly said ""loop this forever"", and there's nothing to warn about.</p>

<p>I don't think GCC has an equivalent warning.</p>
"
"<p>I'm currently using boost::thread, because it very conveniently allows me to pass an arbitrary number of arguments to the thread and copies them along the way, so I don't have to worry about them being deleted before the thread launches. Is there any other library that allows this, or a way to simulate it using pthreads? I'd like to wean myself off of boost, but I've never seen any other library do this.</p>
","87234","","<p>I don't remember the details of Boost.Thread, but the general idea is something like this:</p>

<pre><code>class thread_function_base
{
public:
    virtual ~thread_function_base(void) {}
    virtual void run(void) = 0;
};

template &lt;typename Func&gt;
class thread_function_0 : public thread_function_base
{
public:
    thread_function_0(const Func&amp; pFunc) :
    mFunc(pFunc)
    {}

    void run(void)
    {
        mFunc();
    }

private:
    Func mFunc;
};

template &lt;typename Func, typename A0&gt;
class thread_function_1 : public thread_function_base
{
public:
    thread_function_1(const Func&amp; pFunc, const A0&amp; pA0) :
    mFunc(pFunc),
    mA0(pA0)
    {}

    void run(void)
    {
        mFunc(mA0);
    }

private:
    Func mFunc;
    A0 mA0;
};

// and so on to some limit, either
// generated either by hand (yuck), by
// Boost.PP (phew), or by C++0x's
// variadic templates (yay, no limit either)

class thread
{
public:
    template &lt;typename Func&gt;
    thread(const Func&amp; pFunc)
    {
        std::auto_ptr&lt;thread_function_base&gt;
            threadFunc(new thread_function_0&lt;Func&gt;(pFunc));

        create_thread(threadFunc);
    }

    template &lt;typename Func, typename A0&gt;
    thread(const Func&amp; pFunc, const A0&amp; pA0)
    {
        std::auto_ptr&lt;thread_function_base&gt;
            threadFunc(new thread_function_1&lt;Func, A0&gt;(pFunc, pA0));

        create_thread(threadFunc);
    }

    // again, needs to be generated somehow

private:
    // noncopyable
    thread(const thread&amp;);
    thread&amp; operator=(const thread&amp;);

    // signature needs to match implementations expectations:
    static void thread_function(void* pUserData)
    {
        std::auto_ptr&lt;thread_function_base&gt;
            pFunc(static_cast&lt;thread_function_base*&gt;(pUserData));

        // (A)

        pFunc-&gt;run();
    }

    void create_thread(std::auto_ptr&lt;thread_function_base&gt;&amp; pThreadFunc)
    {
        // again, implementation specific function:
        if (create_thread(&amp;thread_function, pThreadFunc.get(), ...))
        {
            // failed, do something (and return), 
            // auto_ptr in constructor will free resources
            return;
        }    

        // thread was created, so it now owns that resource
        pThreadFunc.release();

        // (B)
    }
};
</code></pre>

<p>Basically, everything needed to invoke the thread is copied into some dynamically allocated container, a pointer to that dynamic container is passed into the thread function (trivial), then ownership is transferred from outside the thread to inside.</p>

<p>You can make things safer by packing not only the <code>thread_function_base</code> into the user data, but also a (implementation-specific) signal handle. The threading function will block at <code>(A)</code> until the signal is raised at <code>(B)</code>, indicated the main thread has given the worker thread full ownership of the resources. (And from there it's <code>auto_ptr</code> will eventually delete it.)</p>

<p>And so on, making it more sophisticated.</p>
"
"<p>Suppose I have a <code>std::vector&lt;Obj *&gt; objs</code> (for performance reasons I have pointers not actual <code>Obj</code>s).</p>

<p>I populate it with <code>obj.push_back(new Obj(...));</code> repeatedly.</p>

<p>After I am done, I have to <code>delete</code> the pushed-back elements. One way is to do this:</p>

<pre><code>for (std::vector&lt;Obj *&gt;::iterator it = objs.begin(); it != objs.end(); ++it) {
    delete *it;
}
</code></pre>

<p>However, I am interested if I can use <code>for_each</code> algorithm to do the same:</p>

<pre><code>#include &lt;algorithm&gt;
...
for_each(objs.begin(), objs.end(), delete);
</code></pre>

<p>What do you think?</p>

<p>Thanks, Boda Cydo.</p>
","87234","","<p>Yes, but you need a functor:</p>

<pre><code>struct delete_ptr
{
    template &lt;typename T&gt;
    void operator()(T* pPtr)
    {
        delete pPtr;
    }
};

std::for_each(objs.begin(), objs.end(), delete_ptr());
</code></pre>

<p>In C++0x, lambda's help you make functors in-place:</p>

<pre><code>std::for_each(objs.begin(), objs.end(), [](Obj* pPtr){ delete pPtr; });
</code></pre>

<hr>

<p>However, this is dangerous, in the face of exceptions. <a href=""http://stackoverflow.com/questions/3505343/can-i-call-delete-on-a-vector-of-pointers-in-c-via-for-each-algorithm/3505412#3505412"">sbi has shown a solution.</a></p>
"
"<p>Given a 3D line in CGAL, how do I compute a point on that line that is some known distance from an endpoint?</p>
","87234","","<p>If you have two points P<sub>0</sub> and P<sub>1</sub>, you can make a vector V = P<sub>1</sub> - P<sub>0</sub>.</p>

<p>Given distance D from P<sub>0</sub>, you can get the resulting point R = P<sub>0</sub> + (D ÷ ||V||) ⋅ V.</p>

<p>(Linearly interpolate between the lines, changing D into a percentage by dividing by the full length of the line.)</p>

<hr>

<p>I don't know CGAL (and the documentation kind of sucks), but I assume it'd be something like this:</p>

<pre><code>Line_3&lt;K&gt; l = /* ... */;
Vector_3&lt;K&gt; v = l.to_vector();
Point_3&lt;K&gt; r = l.p + (d * d / v.squared_length()) * v;
</code></pre>

<p>Note I can't even find a way to get the starting point of a line, so that one is up to you. (The <code>l.p</code> part is made up.)</p>
"
"<p>This code compiles and works as expected (it throws at runtime, but never mind):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;boost/property_tree/ptree.hpp&gt;

void foo(boost::property_tree::ptree &amp;pt) 
{
    std::cout &lt;&lt; pt.get&lt;std::string&gt;(""path""); // &lt;---
}

int main()
{
    boost::property_tree::ptree pt;
    foo(pt);
    return 0;
}
</code></pre>

<p>But as soon as I add templates and change the <code>foo</code> prototype into</p>

<pre><code>template&lt;class ptree&gt;
void foo(ptree &amp;pt)
</code></pre>

<p>I get an error in GCC:</p>

<pre><code>test_ptree.cpp: In function ‘void foo(ptree&amp;)’:
test_ptree.cpp:7: error: expected primary-expression before ‘&gt;’ token
</code></pre>

<p>but no errors with MSVC++! The error is in the marked line <code>&lt;---</code>. And again, if I change the problem line into</p>

<pre><code>--- std::cout &lt;&lt; pt.get&lt;std::string&gt;(""path""); // &lt;---
+++ std::cout &lt;&lt; pt.get(""path"", ""default value"");
</code></pre>

<p>the error disappears (the problem is in explicit <code>&lt;std::string&gt;</code>).</p>

<p><a href=""http://www.boost.org/doc/libs/1_44_0/doc/html/property_tree.html"">Boost.PropertyTree</a> requires Boost >= 1.41. Please help me to understand and fix this error.</p>

<hr>

<p><strong>See <a href=""http://stackoverflow.com/questions/1682844/templates-template-function-not-playing-well-with-classs-template-member-functi"">Templates: template function not playing well with class’s template member function</a></strong> — a similar popular question containing other good answers and explanations.</p>
","87234","","<p>You need to do:</p>

<pre><code>std::cout &lt;&lt; pt.template get&lt;std::string&gt;(""path"");
</code></pre>

<p>Use <code>template</code> in the same situation as <code>typename</code>, except for template members instead of types.</p>

<p>(That is, since <code>pt::get</code> is a template member <em>dependent</em> on a template parameter, you need to tell the compiler it's a template.)</p>
"
"<p>i basically want to use a dif function to extract a different element of a class (ac). </p>

<p>the code is similar to this:</p>

<p>.h:</p>

<pre><code>class MyClass
{
  public:
    double f1(AnotherClass &amp;);
    void MyClass::f0(AnotherClass &amp; ac, double(MyClass::*f1)(AnotherClass &amp;));
};
</code></pre>

<p>.cc:</p>

<pre><code>double MyClass::f1(AnotherClass &amp; ac)
{
  return ac.value;
}

void MyClass::f0(AnotherClass &amp; ac, double(MyClass::*f1)(AnotherClass &amp;))
{
  std::cout &lt;&lt; f1(ac);
}
</code></pre>

<p>didn't work, it gives error#547 ""nonstandard form for taking the address of a member function""</p>

<p>EDIT:</p>

<p>I call it from:</p>

<pre><code>void MyClass(AnotherClass &amp; ac)
{
  return f0(ac,&amp;f1);  // original and incorrect
  return f0(ac,&amp;Myclass::f1); //solved the problem
}
</code></pre>

<p>However, I have another error:</p>

<pre><code>std::cout &lt;&lt; f1(ac); 
             ^ error: expression must have (pointer-to-) function type
</code></pre>
","87234","","<p>Look at where the error points. I bet it's not on the function declaration line, but on how you call it.</p>

<p>Observe:</p>

<pre><code>struct foo
{
    void bar(void (foo::*func)(void));
    void baz(void)
    {
        bar(&amp;foo::baz); // note how the address is taken
        bar(&amp;baz); // this is wrong
    }
};
</code></pre>

<hr>

<p>You're getting your error because you're calling the function incorrectly. Given my <code>foo</code> above, we know this won't work:</p>

<pre><code>baz(); // where did the foo:: go?
</code></pre>

<p>Because <code>baz</code> requires an instance to be called on. You need to give it one (I'll assume <code>this</code>):</p>

<pre><code>std::cout &lt;&lt; (this-&gt;*f1)(ac);
</code></pre>

<p>The syntax is a bit weird, but this operator <code>-&gt;*</code> says: ""take the member function pointer on the right, and call it with the instance on the left."" (There is also a <code>.*</code> operator.)</p>
"
"<p>HI All,</p>

<p>I was trying to overload new and delete to fix a memory leak problem in my project. But got stuck with some compilation error.</p>

<p>Currently this code is bit shabby</p>

<p>Here is my hdr file</p>

<pre><code>#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
using namespace std;
typedef unsigned int  DWORD;
void AddTrack(DWORD addr,  DWORD asize,  const char *fname, DWORD lnum);
char *OutputDebugString (const char *fmt, ...);
void RemoveTrack(DWORD addr);
void DumpUnfreed();

#ifdef _DEBUG
#define DEBUG_NEW new(__FILE__, __LINE__)
#define new DEBUG_NEW


   void *  operator new (unsigned int size, const char *file, int line)
  {
          void *ptr = (void *)malloc(size);
          AddTrack((DWORD)ptr, size, file, line);
          return(ptr);
  }
  /*inline void * operator new(unsigned int size)
  {
          void *ptr = (void *)malloc(size);
          AddTrack((DWORD)ptr, size, _FILE_,_LINE_);
          return(ptr);
  }*/
  void  operator delete(void *p)
  {
          RemoveTrack((DWORD)p);
          free(p);
  }

#endif


char *OutputDebugString (const char *fmt, ...)
{

char *p = NULL;
 size_t size = 1024;
 int n = 0;
 va_list ap;

 if((p = (char*) malloc(size)) == NULL)
 return NULL;

 while(1) {
  va_start(ap, fmt);
  n = vsnprintf(p, size, fmt, ap);
  va_end(ap);

 if(n &gt; -1 &amp;&amp; n &lt; size)
return p;

/* failed: have to try again, alloc more mem. */
if(n &gt; -1)      /* glibc 2.1 */
size = n + 1;
else            /* glibc 2.0 */
size *= 2;     /* twice the old size */

if((p = (char *)realloc (p, size)) == NULL)
return NULL;
}
}

typedef struct information {
DWORD   address;
DWORD   size;
char    file[64];
DWORD   line;
} ALLOC_INFO;

typedef list &lt; ALLOC_INFO* &gt; AllocList;
AllocList *allocList;




  void AddTrack(DWORD addr,  DWORD asize,  const char *fname, DWORD lnum)
  {
          ALLOC_INFO *info;

          if(!allocList) {
          //allocList = new AllocList;
            allocList = (AllocList*)malloc (sizeof (AllocList));
          }

          //info = new(ALLOC_INFO);
          info = (ALLOC_INFO*) malloc (sizeof (ALLOC_INFO));
          info-&gt;address = addr;
          strncpy(info-&gt;file, fname, 63);
          info-&gt;line = lnum;
          info-&gt;size = asize;
          allocList-&gt;insert(allocList-&gt;begin(), info);
  }

  void RemoveTrack(DWORD addr)
  {
          AllocList::iterator i;

          if(!allocList)
          if(!allocList)
                  return;
          for(i = allocList-&gt;begin(); i != allocList-&gt;end(); i++)
          {
                  if((*i)-&gt;address == addr)
                  {
                          allocList-&gt;remove((*i));
                          break;
                  }
          }
  }





void DumpUnfreed()
  {
          AllocList::iterator i;
          DWORD totalSize = 0;
          char buf[1024];

          if(!allocList)
                  return;

          for(i = allocList-&gt;begin(); i != allocList-&gt;end(); i++) {
                  sprintf(buf, ""%-50s:\t\tLINE %d,\t\tADDRESS %d\t%d unfreed\n"",
                          (*i)-&gt;file, (*i)-&gt;line, (*i)-&gt;address, (*i)-&gt;size);
                  OutputDebugString(""%s"",buf);
                  totalSize += (*i)-&gt;size;
          }
          sprintf(buf, ""-----------------------------------------------------------\n"");
          OutputDebugString(""%s"",buf);
          sprintf(buf, ""Total Unfreed: %d bytes\n"", totalSize);
          OutputDebugString(""%s"",buf);
  }
</code></pre>

<p>And my main.cpp is</p>

<pre><code>#include ""mynew.h""
int main()
{

char *ptr = new char;
DumpUnfreed();

return 0;
}
</code></pre>

<p>When i try to compile i get the following error</p>

<pre><code>[root@dhcppc0 new]# !g
g++ main.cpp -D_DEBUG
mynew.h:25: error: declaration of ‘operator new’ as non-function
main.cpp: In function ‘int main()’:
main.cpp:9: error: no matching function for call to ‘operator new(unsigned int, const     char [9], int)’
/usr/lib/gcc/i386-redhat-linux/4.1.1/../../../../include/c++/4.1.1/new:84: note:   candidates are: void* operator new(size_t)
/usr/lib/gcc/i386-redhat-linux/4.1.1/../../../../include/c++/4.1.1/new:88: note:                     void* operator new(size_t, const std::nothrow_t&amp;)
/usr/lib/gcc/i386-redhat-linux/4.1.1/../../../../include/c++/4.1.1/new:94: note:                    void* operator new(size_t, void*)
</code></pre>

<p>I know there is some thing wrong with my #defines, but I am not sure what is wrong.</p>

<p>Can any one please bale me out of this </p>
","87234","","<p>You've defined your <code>new</code> macro before your functions. Your code ends up looking like:</p>

<pre><code>void *
  operator new(__FILE__, __LINE__)(unsigned int size, const char *file, int line)
</code></pre>

<p>Which is obviously wrong. Your should move the macro definitions underneath the functions (or better is to keep those functions in a .cpp file you link with.) For what it's worth, <code>new</code> is a keyword and cannot be an identifier, so your program is, strictly speaking, ill-formed.</p>

<p>I recently posted my <a href=""http://stackoverflow.com/questions/3326742/how-to-avoid-the-swapping-of-death-during-development/3326799#3326799"">global memory operators framework</a>. It might help you a bit.</p>
"
"<pre><code>class A;

class B {
public:
    B(A&amp; a) : a(a) {}
private:
    A&amp; a;
};

/* Method 1 */
/* warning C4355: 'this' : used in base member initializer list */
/*
class A {
public:
    A() : b(*this) {}

private:
    B b;
};
*/

/* Method 2 */
/* But I need to manually perform memory dellocation. */
class A {
public:
    A() { b = new B(*this); }
    ~A() { delete b; }

private:
    B* b;
};

int main() {
}
</code></pre>

<p>Currently, when I try to initialize the reference in B, I am using Method 1. However, Method 1 will flag me warning which is understandable.</p>

<p>Hence, I have to fall back using Method 2, by using dynamic memory allocation.</p>

<p>Is there any better way I can use, without the need of manual memory allocation/ dellocation (OK. I know smart pointer)?</p>

<p>I prefer Method 1, just that I am not comfortable with the warning.</p>
","87234","","<p>Depending on what you're doing, a method might be to factor out the parts of <code>A</code> that <code>B</code> needs, than have <code>A</code> inherit from the part.</p>

<pre><code>struct bar_base; // interface foo wants

struct foo
{
    foo(bar_base&amp; pX) :
    mX(pX)
    {}

    bar_base&amp; mX;
};

struct bar_base
{
    /* whatever else */ 
protected:
    bar_base&amp; get_base(void)
    {
        // getting `this` went here; safe because bar_base is initialized
        return *this; 
    }
};

struct bar : bar_base
{
    bar(void) :
    // bar_base is already initialized, so:
    mX(get_base())
    {}

    foo mX;
};
</code></pre>

<p>Obviously, this depends on what you're doing. This makes sure you never get undefined behavior.</p>

<p>But really, it's just warning. If you promise to never use <code>this</code> in B's constructor, you're fine, and can silence the warning this way:</p>

<pre><code>struct bar;

struct foo
{
    foo(bar&amp; pX) :
    mX(pX)
    {}

    bar&amp; mX;
};

struct bar
{
    bar(void) :
    mX(self())
    {}

    foo mX;

private:
    bar&amp; self(void)
    {
        // fools the warning
        return *this;
    }
};
</code></pre>

<p>Make sure you know what you're doing, though. (Perhaps it could be re-designed?)</p>
"
"<pre><code>char *cp = (char *) malloc(1);
strcpy(cp, ""123456789"");
puts(cp);
</code></pre>

<p>output is ""123456789"" on both gcc (Linux) and Visual C++ Express, does that mean when there is free memory, I can actually use more than what I've allocated with <code>malloc()</code>?</p>

<p>and why <code>malloc(0)</code> doesn't cause runtime error?</p>

<p>Thanks.</p>
","87234","","<p>No. You get <em>undefined behavior</em>. That means anything can happen, from it crashing (yay) to it ""working"" (boo), to it reformatting your hard drive and filling it with text files that say ""UB, UB, UB..."" (wat).</p>

<p>There's no point in wondering what happens after that, because it depends on your compiler, platform, environment, time of day, favorite soda, etc., all of which can do whatever they want as (in)consistently as they want.</p>

<p>More specifically, using any memory you have not allocated is undefined behavior. You get <em>one byte</em> from <code>malloc(1)</code>, that's it. </p>
"
"<p>Take a simple class with the ""big 3"" (constructor, copy constructor, destructor):</p>

<pre><code>#include &lt;vector&gt;
using namespace std; //actually goes in the C file that links to this header file
...
class planets(){ //stores mass and radii data for planets in a solar system.
   public:
      vector &lt;double&gt; mass;
      vector &lt;double&gt; radius;

   //constructor
   planets( int numObj ){
     for(int i=0; i&lt;numObj; i++){
         mass.push_back(8.0); //some default values.
         radius.push_back(2.0);
     }
   }
   //copy constructor
   planets(const planets &amp;p){
      vector &lt;double&gt; mass(p.mass); //copy vectors into new class.
      vector &lt;double&gt; radius(p.radius);
   }
  //destructor
  ~planets(){
     delete mass; //ERROR: (...) argument given to ‘delete’, expected pointer
     ~radius(); //also causes error: no match for call to(...) 
   }
}
</code></pre>

<p>I plan on making a vector of planets, thus the need for the ""big 3"":</p>

<pre><code>vector &lt;planets&gt; stars;
stars.push_back(planets(5)); //5 hypothetical planets of alpha centauri
stars.push_back(planets(8)); //our solar system. Used to be nine.
///etc.
</code></pre>

<p>How do I delete the mass and radius vectors properly, to avoid memory leaks (do I even have to)? </p>
","87234","","<p>No, you don't need to do anything because you aren't managing any resources. You only write the Big Three when you're managing a resource, but <code>vector</code> is doing that. <em>It's</em> the one with the Big Three properly written, you just use it.</p>

<p>This is why the single responsibility principle is key in resource management: once you have some class that properly manages a resource, you can simply use it without ever worrying about that resource again. <em>Always</em> split resource management from resource use.</p>

<p>The reason you need the Big Three written in a managing class is because the default special members typically do the wrong thing (they copy, assign, destruct values instead of what the values manage/point at.) But once you're resource is wrapped up (like in a <code>std::vector</code>), everything is just fine. The defaults will copy vector, <em>but</em> that copying is correctly written.</p>

<p>By the way, the Big Three is in the context of <em>managing</em> resources (copying and destroying resources), not created them. So it would be copy-constructor, copy-assignment, and destructor, not default constructor.</p>

<hr>

<p>For your information, here's how you would do it:</p>

<pre><code>class planets
{
public:
    // ...

    //copy constructor
    planets(const planets &amp;p) : // use an initialization list to initialize
    mass(p.mass), // copy-construct mass with p.mass
    radius(p.radius) // copy-construct radius with p.radius
    {
        // what you had before just made a local variable, copy-constructed
        // it with p.xxx, then got released (nothing happened to your members)
    }

    //destructor
    ~planets()
    {
        // nothing to do, really, since vector destructs everything 
        // right for you, but you yes, you would delete any resources
        // you managed here
    }
};
</code></pre>

<p>But don't forget the copy-assignment operator. I recommend the <a href=""http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom"">copy-and-swap idiom</a>, and leave that as an exercise for you.</p>

<p>(Remember you don't actually need these, though.)</p>
"
"<p>I have an stl iterator resulting from a std::find() and wish to test whether it is the last element.  One way to write this is as follows:</p>

<pre><code>mine *match = someValue;
vector&lt;mine *&gt; Mine(someContent);
vector&lt;mine *&gt;::iterator itr = std::find(Mine.begin(), Mine.end(), match);

if (itr == --Mine.end()) {
  doSomething;
}
</code></pre>

<p>But it seems to me that decrementing the end() iterator is asking for trouble, such as if the vector has no elements, then it would be undefined.  Even if I know it will never be empty, it still seems ugly. I'm thinking that maybe rbegin() is the way to go, but am not certain as to best way to compare the forward iterator with a reverse iterator.</p>
","87234","","<p>Do this:</p>

<pre><code>// defined in boost/utility.hpp, by the way
template &lt;typename Iter&gt;
Iter next(Iter iter)
{
    return ++iter;
}

// first check we aren't going to kill ourselves
// then check if the iterator after itr is the end
if ((itr != Mine.end()) &amp;&amp; (next(itr) == Mine.end()))
{
    // points at the last element
}
</code></pre>

<p>That is all. Never gives you undefined behavior, works on all iterators, good day.</p>

<p>Wrap it up for fun:</p>

<pre><code>template &lt;typename Iter, typename Cont&gt;
bool is_last(Iter iter, const Cont&amp; cont)
{
    return (iter != cont.end()) &amp;&amp; (next(iter) == cont.end())
}
</code></pre>

<p>Giving:</p>

<pre><code>if (is_last(itr, Mine))
</code></pre>

<hr>

<p>If you're allergic to utility functions/nice looking code, do:</p>

<pre><code>if ((itr != Mine.end()) &amp;&amp; (itr + 1 == Mine.end()))
</code></pre>

<p>But you can't do it on non-random-access iterators. This one works with bidirectional iterators:</p>

<pre><code>if ((itr != Mine.end()) &amp;&amp; (itr == --Mine.end()))
</code></pre>

<p>And is safe since <code>end() &gt; itr</code> by the first check.</p>
"
"<p>I have a VectorN class, and a Vector3 class inherited from VectorN (which can handle cross products for example). I have trouble determining the return types of the different operators. Example:</p>

<pre><code>class VectorN
{
public:
   VectorN(){};
   virtual VectorN operator*(const double&amp; d) {.....};
   std::vector&lt;double&gt; coords;
};

class Vector3 : public VectorN
{
public:
  Vector3(){};
  virtual Vector3 operator*(const double&amp; d) {....};
};
</code></pre>

<p>This particular example produces a C2555 error :
'Vector3::operator *': overriding virtual function return type differs and is not covariant from 'VectorN::operator *', see declaration of 'VectorN::operator *'.</p>

<p>The problem is that I don't return a reference to a Vector3, and that the Vector3 class is not fully defined at the declaration of the operator*. However, I want my operator* to be virtual, and I want to return a Vector3 when I multiply a Vector3 with a constant (otherwise, if I do (Vector3*double).crossProduct(Vector3), it would return an error).</p>

<p>What can I do ?</p>

<p>Thanks!!</p>
","87234","","<p>You need a re-design. First, prefer free-functions over member-functions. The only member functions you should have are the ones that need access to privates.</p>

<p>Start with this combo:</p>

<pre><code>class VectorN
{
public:
   virtual VectorN&amp; operator*=(double d)
    {
        /* ... */

        return *this;
    };
};


class Vector3 : public VectorN
{
public:
    virtual Vector3&amp; operator*=(double d)
    {
        return static_cast&lt;Vector3&amp;&gt;(VectorN::operator*=(d));
    };
};
</code></pre>

<p>Here covariance works fine because the type is a reference or pointer, and you re-use code. (<code>static_cast</code> is free, performance-wise, and safe since you know the derived type.)</p>

<p>Then you implement your free-functions:</p>

<pre><code>// optimization: if you're going to make a copy, do it in the parameter list;
// compilers can elide a copy when working with temporaries
VectorN operator*(VectorN v, double d)
{
    // reuse code
    return v *= d;
}

VectorN operator*(double d, VectorN v)
{
    // reuse code
    return v *= d;
}
</code></pre>

<p>Do the same with <code>Vector3</code>. </p>

<p>What's been done is you get an <em>easy</em> way to write these operators because you get to use the core of the operator, and the return type matches, thanks to covariance.</p>

<hr>

<p>Do heed warnings though, you probably don't need any of it. And extensions you want to make can be made via free-functions operating on a <code>vector</code> or <code>valarray</code>.</p>
"
"<p>Consider I have 2 header files.</p>

<pre><code>// HEADER 1
/**
 * Doc  for Foo here?
 */
namespace Foo {
  class This {...};
}
</code></pre>

<p>&amp;&amp;</p>

<pre><code>// HEADER 2
/**
 * Doc for Foo here?
 */
namespace Foo {
  class That {...};
}
</code></pre>

<p>How should I handle this when documenting with Doxygen?</p>
","87234","","<p>Maybe neither.</p>

<p>For example, imagine you have <code>""&lt;root&gt;/utility/header1.hpp""</code> which has its contents in <code>namespace utility</code> and <code>""&lt;root&gt;/utility/header2.hpp""</code> which does also.</p>

<p>You could add a file: <code>""&lt;root&gt;/utility.hpp""</code> which documents the utility namespace. You could put this at the top <code>#error Documentation only.</code> to make sure it's not accidentally included.</p>

<p>But I would recommend at least making some out-of-the-way file to keep it in a sane place (and not mixed in randomly with some class.)</p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/1092331/overloading-in-c"">Overloading += in c++</a>  </p>
</blockquote>



<p>Do I need to overload the += operator if I overload + or will the compiler know what to do?</p>

<p>Thanks.</p>
","87234","","<p>You need to overload both.</p>

<p>However, if you reverse the order you can reuse your code:</p>

<pre><code>struct foo
{
    // this is the ""core"" operation, because it's mutating (changes this)
    foo&amp; operator+=(const foo&amp;)
    {
        // ...
        return *this;
    }

};

foo operator+(const foo&amp; lhs, const foo&amp; rhs)
{
    foo ret = lhs;
    ret += rhs;        
    return ret;
}
</code></pre>

<p>You make a copy, operate on that copy, and return it.</p>
"
"<p>Okay, not sure what I'm doing here, other than it's not right. Trying to overload the '==' method of a class, and it's just... not working. At least, I get a false back from my <code>main</code>, and the <code>cout</code> in the implementation of '==' doesnt output.</p>

<p>These are my three files:</p>

<pre><code>// TestClass.h

#ifndef TESTCLASS_H
#define TESTCLASS_H

class TestClass {
public:
    TestClass(int contents);
    TestClass(const TestClass&amp; orig);
    virtual ~TestClass();
    bool operator==(const TestClass&amp; other);
private:
    int contents;
};

#endif  /* TESTCLASS_H */



// TestClass.cpp

#include &lt;iostream&gt;

#include ""TestClass.h""

TestClass::TestClass(int contents) {
    this-&gt;contents = contents;
}

TestClass::TestClass(const TestClass&amp; orig) {
    this-&gt;contents = orig.contents;
}

TestClass::~TestClass() {
}

bool TestClass::operator ==(const TestClass&amp; other) {
    std::cout &lt;&lt; ""COMPARING"" &lt;&lt; std::endl;
    return (contents == other.contents);
}


// Main.cpp

#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

#include ""TestClass.h""

using namespace std;

/*
 * 
 */
int main(int argc, char** argv) {

    TestClass* tc = new TestClass(1);
    TestClass* tc1 = new TestClass(1);

    cout &lt;&lt; (tc == tc1) &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>So the question is - what have I done wrong? I apologise for what is probably a very silly mistake somewhere, but I just can't spot it. </p>
","87234","","<p><code>tc == tc1</code> compares pointer values. It ""should"" be <code>*tc == *tc1</code>, but I don't get why you'd dynamically allocate in the first place.</p>

<p>Automatic (stack) allocation is highly preferred, only dynamically allocate when you need the object to be independent of scope. (And then keep track of it with automatically allocated smart pointers, which will delete the pointer when it's appropriate.)</p>

<hr>

<p>Also, the operator should be <code>const</code>, because it doesn't modify <code>this</code>:</p>

<pre><code>//                                      vvvvv
bool operator==(const TestClass&amp; other) const;
</code></pre>

<p>Even better, though, is a free function:</p>

<pre><code>bool operator==(const TestClass&amp; lhs, const TestClass&amp; rhs);
</code></pre>

<p>Which would possibly be a friend. (Free-functions are always preferred, plus this allows <code>5 == tc</code> to work.)</p>
"
"<p>Couldn't <code>find_if</code> just be an overload of <code>find</code>? That's how <code>std::binary_search</code> and friends do it...</p>
","87234","","<p>A predicate is a valid thing to find, so you could arrive at ambiguities.</p>

<hr>

<p>Consider <code>find_if</code> is renamed <code>find</code>, then you have:</p>

<pre><code>template &lt;typename InputIterator, typename T&gt;
InputIterator find(InputIterator first, InputIterator last, const T&amp; value);

template &lt;typename InputIterator, typename Predicate&gt;
InputIterator find(InputIterator first, InputIterator last, Predicate pred);
</code></pre>

<p>What shall be done, then, with:</p>

<pre><code>find(c.begin(), c.end(), x); // am I finding x, or using x to find?
</code></pre>

<p>Rather than try to come up with some convoluted solution to differentiate based on <code>x</code> (which can't always be done*), it's easier just to separate them.</p>

<p>*This would be ambiguous, no matter what your scheme is or how powerful it might be†:</p>

<pre><code>struct foo
{
    template &lt;typename T&gt;
    bool operator()(const T&amp;);
};

bool operator==(const foo&amp;, const foo&amp;);

std::vector&lt;foo&gt; v = /* ... */;
foo f = /* ... */; 

// f can be used both as a value and as a predicate
find(v.begin(), v.end(), f); 
</code></pre>

<p>†Save mind reading.</p>
"
"<p>I am trying to compile my first c++ file on windows with the g++ compiler...</p>

<p>My cpp file is the following -</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main ()
{
  cout &lt;&lt; ""Hello World!"";
  return 0;
}
</code></pre>

<p>I type in this on command prompt to get to the directory</p>

<pre><code>cd C:\Users\Mark
</code></pre>

<p>Then to compile my program I do</p>

<pre><code>g++ hello.cpp
</code></pre>

<p>It creates a file name a.exe (default) but when I click on it the command prompt quickly flashes open then it's gone.</p>

<p>What did I do wrong?  It should say Hello World! on the prompt and stay there, right?</p>
","87234","","<p>The prompt has nothing to do with your program or the language. It has to do with your OS.</p>

<p>Your program should be run from the command line, which will (obviously) leave the command window up when it's finished.</p>

<p>There are tricks to make it stay up if you <em>really</em> want, but these are just tricks, and not necessarily good practice. One would be:</p>

<pre><code>int main()
{
    std::cin.get(); // waits for enter
}
</code></pre>
"
"<p>I want to suspend a void() function that sets a stack variable to true. How can I do this?</p>

<pre><code>bool flag = false;
boost::function&lt;void()&gt; f = ...;
f();
assert(flag);
</code></pre>

<p>This is, obviously, toy code that demonstrates the problem. My attempt at this, using <code>bind</code>, was <code>bind&lt;void&gt;(_1 = constant(true), flag);</code>, but this yields a compilation error.</p>
","87234","","<p>To use <code>boost::bind</code>, you'd need to make a function that sets a boolean to true, so you can bind to it:</p>

<pre><code>#include &lt;boost/bind.hpp&gt;
#include &lt;boost/function.hpp&gt;
#include &lt;boost/ref.hpp&gt;

void make_true(bool&amp; b)
{
    b = true;
}

int main()
{
    using namespace boost;

    bool flag = false;

    // without ref, calls with value of flag at the time of binding
    // (and therefore would call make_true with a copy of flag, not flag)
    function&lt;void()&gt; f = bind(make_true, ref(flag)); 

    f();
    assert(flag);
}
</code></pre>

<p>However, lambda's will help here. Lambda's are like bind, except they make functions too, so keep your code localized (no need for some external function). You'd do something like this:</p>

<pre><code>#include &lt;boost/function.hpp&gt;
#include &lt;boost/lambda/lambda.hpp&gt;

int main()
{
    using namespace boost;
    using namespace boost::lambda;

    bool flag = false;

    function&lt;void()&gt; f = (var(flag) = true);

    f();
    assert(flag);
}
</code></pre>

<p>Same idea, except <code>bind</code> and <code>make_true</code> has been replaced with a lambda.</p>
"
"<p>I have some clean up in a terminate_handler and it is possible to throw an exception.  Do I need to worry about catching it to prevent recursive calls to the terminate_handler?  With gcc, it seems this can't happen and we just go into abort.  Is that true of the standard or is the behavior undefined?</p>
","87234","","<p>A terminate handler is <em>not</em> allowed to return (§18.6.​3.1/2); it must end the program (the default handler calls <code>abort()</code>). If it consisted of:</p>

<pre><code>void my_terminate()
{
    throw 5;
}
</code></pre>

<p>You'd get undefined behavior, because you would leave the function (because the exception propagates) without having terminated the program. So if you have code that could throw, make sure you catch all exceptions, like this:</p>

<pre><code>void my_terminate()
{
    try
    {
        // stuff
    }
    catch(...)
    {
        // too bad
    }

    abort();
}
</code></pre>

<p>However (to answer the title question), I don't see anything that restricts it from being entered again, so this should be technically be fine:</p>

<pre><code>void my_terminate()
{
    static int counter = 0;

    if (counter++ &lt; 5)
        terminate();

    abort();
}
</code></pre>
"
"<p>How to bound 2 variables in C++ one with other so when one changes changes another?</p>

<p>for example I created Int A and Int B bound one to another and than when I change A one using some function another one will automatically change to  new value of A.</p>

<p>I am intrested in version for C++ .net 4th version.</p>
","87234","","<p>You can't do it with vanilla values, there needs to be indirection somewhere.</p>

<p>You could refer to one:</p>

<pre><code>int a;
int&amp; b = a;

a = 5;
assert(b == 5);
</code></pre>

<p>Point to one:</p>

<pre><code>int a;
int* b = &amp;a; // b points to a

a = 5;
assert(*b == 5);
</code></pre>

<p>Or create some utility for essentially wrapping the above.</p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/645994/why-this-is-a-pointer-and-not-a-reference"">Why &lsquo;this&rsquo; is a pointer and not a reference?</a>  </p>
</blockquote>



<p>Hey guys,</p>

<p>Is there a good reason that <code>this</code> is a pointer instead of a reference in C++?</p>
","87234","","<p>The <code>this</code> concept was introduced before the reference concept was. At the time, <code>this</code> had to be a pointer.<sup><a href=""http://www2.research.att.com/~bs/bs_faq2.html#this"" rel=""nofollow"">Source</a></sup></p>
"
"<p>If I have a code like the following:</p>

<pre><code>try {
  doSomething();
} catch (...) {
  noteError();
}

void noteError() {
  try {
    throw;
  } catch (std::exception &amp;err) {
    std::cerr &lt;&lt; ""Note known error here: "" &lt;&lt; err.what();
  } catch (...) {
    std::cerr &lt;&lt; ""Note unknown error here."";
  }
  throw;
}
</code></pre>

<p>Will the original exceptions get thrown from both places inside the lower frame of noteError()?</p>
","87234","","<p>The wording in the standard (§15.1/2) is (emphasis mine):</p>

<blockquote>
  <p>When an exception is thrown, control is transferred to the <em>nearest handler with a matching type</em> (15.3); “nearest” means the handler for which the compound-statement, ctor-initializer, or function-body <em>following the try keyword was most recently entered by the thread of control and not yet exited.</em></p>
</blockquote>

<p>When has a try block ""exited""? According to the grammar (§15/1), try blocks end with a <em>sequence</em> of handlers, so the block ends when the last handler ends. In other words:</p>

<pre><code>try // &lt;- start of try block
{
}
catch (whatever) // &lt;- first handler
{
}
// ... more handlers
catch (whatever_again) // &lt;- last handler
{
} // &lt;- end of try block
</code></pre>

<p>So yes, your code is fine. When re-thrown, the nearest try block has a matching handler (namely <code>catch (...)</code>), so that handler is entered.</p>
"
"<p>Given the following template:</p>

<pre><code>template &lt;typename T&gt;
class wrapper : public T {};
</code></pre>

<p>What visible differences in interface or behaviour are there between an object of type <code>Foo</code> and an object of type <code>wrapper&lt;Foo&gt;</code>?</p>

<p>I'm already aware of one:</p>

<ul>
<li><code>wrapper&lt;Foo&gt;</code> only has a nullary constructor, copy constructor and assignment operator (and it only has those if those operations are valid on <code>Foo</code>). This difference may be mitigated by having a set of templated constructors in <code>wrapper&lt;T&gt;</code> that pass values through to the T constructor.</li>
</ul>

<p>But I'm not sure what other detectable differences there might be, or if there are ways of hiding them.</p>

<hr>

<h2>(Edit) Concrete Example</h2>

<p>Some people seem to be asking for some context for this question, so here's a (somewhat simplified) explanation of my situation.</p>

<p>I frequently write code which has values which can be tuned to adjust the precise performance and operation of the system. I would like to have an easy (low code overhead) way of exposing such values through a config file or the user interface.  I am currently writing a library to allow me to do this.  The intended design allows usage something like this:</p>

<pre><code>class ComplexDataProcessor {
    hotvar&lt;int&gt; epochs;
    hotvar&lt;double&gt; learning_rate;
public:
    ComplexDataProcessor():
        epochs(""Epochs"", 50),
        learning_rate(""LearningRate"", 0.01)
        {}

    void process_some_data(const Data&amp; data) {
        int n = *epochs;
        double alpha = *learning_rate;
        for (int i = 0; i &lt; n; ++i) {
            // learn some things from the data, with learning rate alpha
        }
    }
};

void two_learners(const DataSource&amp; source) {
    hotobject&lt;ComplexDataProcessor&gt; a(""FastLearner"");
    hotobject&lt;ComplexDataProcessor&gt; b(""SlowLearner"");
    while (source.has_data()) {
        a.process_some_data(source.row());
        b.process_some_data(source.row());
        source.next_row();
    }
}
</code></pre>

<p>When run, this would set up or read the following configuration values:</p>

<pre><code>FastLearner.Epochs
FastLearner.LearningRate
SlowLearner.Epochs
SlowLearner.LearningRate
</code></pre>

<p>This is made up code (as it happens my use case isn't even machine learning), but it shows a couple of important aspects of the design. Tweakable values are all named, and may be organised into a hierarchy. Values may be grouped by a couple of methods, but in the above example I just show one method: Wrapping an object in a <code>hotobject&lt;T&gt;</code> class. In practice, the <code>hotobject&lt;T&gt;</code> wrapper has a fairly simple job -- it has to push the object/group name onto a thread-local context stack, then allow the <code>T</code> object to be constructed (at which point the <code>hotvar&lt;T&gt;</code> values are constructed and check the context stack to see what group they should be in), then pop the context stack.</p>

<p>This is done as follows:</p>

<pre><code>struct hotobject_stack_helper {
    hotobject_stack_helper(const char* name) {
        // push onto the thread-local context stack
    }
};

template &lt;typename T&gt;
struct hotobject : private hotobject_stack_helper, public T {
    hotobject(const char* name):
        hotobject_stack_helper(name) {
        // pop from the context stack
    }
};
</code></pre>

<p>As far as I can tell, construction order in this scenario is quite well-defined:</p>

<ol>
<li><code>hotobject_stack_helper</code> is constructed (pushing the name onto the context stack)</li>
<li><code>T</code> is constructed -- including constructing each of <code>T</code>'s members (the hotvars)</li>
<li>The body of the <code>hotobject&lt;T&gt;</code> constructor is run, which pops the context stack.</li>
</ol>

<p>So, I have working code to do this. There is however a question remaining, which is: What problems might I cause for myself further down the line by using this structure. That question largely reduces to the question that I'm actually asking: How will hotobject behave differently from T itself?</p>
","87234","","<p>Strange question, since you should be asking questions about your specific usage (""what do I want to do, and how does this help me or hurt me""), but I guess in general:</p>

<p><code>wrapper&lt;T&gt;</code> is not a <code>T</code>, so:</p>

<ul>
<li>It can't be constructed like a <code>T</code>. (As you note.)</li>
<li>It can't be converted like a <code>T</code>.</li>
<li>It loses access to privates <code>T</code> has access to.</li>
</ul>

<p>And I'm sure there are more, but the first two cover quite a bit.</p>
"
"<p>I'm fully aware that the return value of <code>std::type_info::name()</code> is implementation-defined.</p>

<p>From the C++ standard (ISO/IEC 14882:2003 §18.5.1.7):</p>

<blockquote>
  <p><strong>Returns:</strong> an implementation-defined NTBS.</p>
</blockquote>

<p>My question is: why? Wouldn't this member function be much more useful if the standard dictated what the return value should be?</p>
","87234","","<p>Basically, if an implementation decides that they can't or doesn't want to support RTTI, they can just <code>return """";</code>. If the standard forced it to return something, they'd possibly kill any ability to have a compliant compiler for an environment where the resources for RTTI don't exist or want to be disabled (a microchip, for example.)</p>

<p>And let's not forget we don't want to force an ABI/name-mangling scheme on any compilers.</p>

<p>This follows the C++ philosophy ""You don't pay for things you don't need.""</p>
"
"<p>Sometimes you run into code that has extra brace brackets, that have nothing to do with scope, only are for readability and avoiding mistakes.</p>

<p>For example:</p>

<pre><code>GetMutexLock( handle ) ; 
{
  // brace brackets ""scope"" the lock,
  // must close block / remember
  // to release the handle.
  // similar to C#'s lock construct
}
ReleaseMutexLock( handle ) ;
</code></pre>

<p>Other places I have seen it are:</p>

<pre><code>glBegin( GL_TRIANGLES ) ;
{
  glVertex3d( .. ) ;
  glVertex3d( .. ) ;
  glVertex3d( .. ) ;
} // must remember to glEnd!
glEnd() ; 
</code></pre>

<p>This introduces a compiler error if the mutex isn't freed (assuming you remember both the } and the <code>Release()</code> call).</p>

<p>The question is:</p>

<ul>
<li>1  Is this a bad practice?  Why?</li>
<li>2  If it is not a bad practice, will it possibly change how the code is compiled?  Possibly make it slower?</li>
</ul>
","87234","","<p>The braces themselves are fine, all they do is limit scope and you won't slow anything down. It can be seen as cleaner. (Always prefer clean code over fast code, if it's cleaner, don't worry about the speed until you profile.)</p>

<hr>

<p>But with respect to resources it's bad practice because you've put yourself in a position to leak a resource. If anything in the block throws or returns, bang you're dead.</p>

<p>Use Scope-bound Resource Management (SBRM, also known as RAII), which limits a resource to a scope, by using the destructor:</p>

<pre><code>class mutex_lock
{
public:
    mutex_lock(HANDLE pHandle) :
    mHandle(pHandle)
    {
        //acquire resource
        GetMutexLock(mHandle);
    }

    ~mutex_lock()
    {
        // release resource, bound to scope
        ReleaseMutexLock(mHandle);
    }

private:
    // resource
    HANDLE mHandle;

    // noncopyable
    mutex_lock(const mutex_lock&amp;);
    mutex_lock&amp; operator=(const mutex_lock&amp;);
};
</code></pre>

<p>So you get:</p>

<pre><code>{
  mutex_lock m(handle);
  // brace brackets ""scope"" the lock,
  // AUTOMATICALLY
}
</code></pre>

<p>Do this will <em>all</em> resources, it's cleaner and safer. If you are in a position to say ""I need to release this resource"", you've done it wrong; they should be handled automatically.</p>
"
"<p>I am very new at this and apologise if my question is not clear.</p>

<p>I have created a thread safe logger in C++. This logger will be used in a large program &amp; will be called from multiple places. I am using a singleton so there is only one instance of the logger. This logger outputs to a file &amp; to the console. It behaves similar to cout; it takes in a string from another file, ( concatenates it if necessary), stores the peices in a buffer until the string is done then outputs using cout. The string is being stored as a const char*. Right now the mutexes are being locked in one function and unlocked in another function ( this is were my problem is) which overloads the endl operator.  </p>

<p>My problem is that this function (where the mutexes are unlocked )only works if the user writes endl in the other files where the logger is being called. I need this to be a versatile utility which will NOT rely on what the user writes since a user may not use endl or may use it too often. I now need some means for my logger to identify when the string ( from the other file) is done so that it can empty out the buffer. Currently endl is like a keyword &amp; i need some means to make it work without any key words. </p>

<p>I was initially thinking i could find some means to check for the ""\0"" terminating character in the string then using that check to know that the string is done and then emptying out the buffer. However, i get out of bounds errors when i do this. </p>

<p>Thank you for your time</p>
","87234","","<p>I'm not quite sure I get the situation, but it sounds like you want a proxy:</p>

<pre><code>class LogSingleton
{
public:
    LogSingleton&amp; instance() { /* ... */ }

    void lock(); // lock mutex
    void unlock(); // unlock mutex

    template &lt;typename T&gt;
    friend LogSingleton&amp; operator&lt;&lt;(LogSingleton&amp; pLog, const T&amp; pX)
    {
        // needs to be locked first
        assert(is_locked()); 

        /* output pX however */

        return pLog;
    }
};

class LogProxy
{
public:
    LogProxy()
    {
        // manage lock in proxy
        LogSingleton::instance().lock();            
    }

    ~LogProxy()
    {
        LogSingleton::instance().unlock();            
    }
};

// forward input into the proxy to the log, knowing it's locked
template &lt;typename T&gt;
LogProxy&amp; operator&lt;&lt;(LogProxy&amp; pProxy, const T&amp; pX)
{
    LogSingleton::instance() &lt;&lt; pX;

    return pProxy;
}

// now expose proxy
typedef LogProxy log;
</code></pre>

<p>And you'd do this:</p>

<pre><code>log() &lt;&lt; ""its locked now"" &lt;&lt; ""and the temporary will die"" &lt;&lt; ""here -&gt;"";
</code></pre>

<p>The locking is done in the constructor and destructor, and the destructor is called at the end.</p>

<hr>

<p>As Tony correctly points out, this holds the lock unnecessarily long. The lock is only needed for the ""final"" output to the <code>LogSingleton</code>. Imagine this:</p>

<pre><code>log() &lt;&lt; ""this next function takes 5 minutes""
        &lt;&lt; my_utterly_crappy_function() &lt;&lt; ""ouch"";
</code></pre>

<p>Nothings getting logged yet the mutex is locked for a long time. Better would be to buffer-up output then output it all at once:</p>

<pre><code>class LogProxy
{
public:
    ~LogProxy()
    {
        // manage lock in proxy
        LogSingleton::instance().lock();

        // no-throw, or wrap mutex use in a scoped-lock
        LogSingleton::instance() &lt;&lt; mBuffer.rdbuf();

        LogSingleton::instance().unlock();            
    }

    // buffer output
    template &lt;typename T&gt;
    friend LogProxy&amp; operator&lt;&lt;(LogProxy&amp; pProxy, const T&amp; pX)
    {
        mBuffer &lt;&lt; pX;

        return pProxy;
    }

private:
    std::ostringstream mBuffer;
};
</code></pre>

<p>Now no locks are acquired until the buffer is ready to be outputted.</p>
"
"<p>I have the following question whether there is the possibility in c++ to create header files using the following rules. Let's take the header </p>

<pre><code>#include ""sum.h""
</code></pre>

<p>where in sum.h i will declare    functions or procedures   and then use it in .cpp files?</p>
","87234","","<p>As far as I can tell, you want to declare functions in headers and then include the header somewhere and use it. This is normal use for headers. (You should <a href=""http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">get a book</a> that explains this, since scrapping for information online isn't going to get you a very good knowledge-base.)</p>

<p>You can go about it in two ways. Declare the functions in the header, then define them in some translation unit and link with that translation unit:</p>

<pre><code>// sum.h
int do_sum(int x, int y); // declare

// sum.cpp
#include ""sum.h"" // get declarations (strictly not needed)

int do_sum(int x, int y) // define
{
    return x + y;
}
</code></pre>

<p>The other way is to use <code>inline</code> to avoid the One-Definition Rule (ODR) and define the functions in the header:</p>

<pre><code>inline int do_sum(int x, int y) // define
{
    return x + y;
}
</code></pre>

<p>Without <code>inline</code>, you'd get an error for having multiple definitions of the function.</p>
"
"<p>I am maintaining a library that contains a Mutex class. I cannot decide if the lock() and unlock() functions exposed by this class should be const or not. I looked for similar code on the Web, and could find both implementations.</p>

<p>First implementation, lock() and unlock() are not const. It means someone who uses the Mutex class in a const function should put extra effort to call Mutex's functions:</p>

<pre><code>class Mutex
{
public:
   void lock();
   void unlock();
};

class Foo
{
public:
   void getBar(Bar& bar) const
   {
      m_mutex.lock();
      bar = m_bar;
      m_mutex.unlock();
   }

private:
   // Mutable, responsability of the user (or we could use a const_cast when needed)
   mutable Mutex m_mutex;
   Bar   m_bar;
};
</code></pre>

<p>Second implementation, lock() and unlock() are const, even if that does not sound very natural (as we modify the Mutex instance), but the user does not have to bother when calling those functions in one of his const functions:</p>

<pre><code>class Mutex
{
public:
   void lock() const;
   void unlock() const;
};

class Foo
{
public:
   void getBar(Bar& bar) const
   {
      m_mutex.lock();
      bar = m_bar;
      m_mutex.unlock();
   }

private:
   Mutex m_mutex;
   Bar   m_bar;
};
</code></pre>

<p>What solution do you prefer ? I hope your opinions will help me to take a decision.</p>
","87234","","<p><code>mutable</code> was made for this kind of stuff. Namely, <code>mutable</code> applies to things that don't take part in the <em>logical constness</em> of an object. (If one value is ""logically constant"", it means the 'primary' values are constant; the value of the object, from the outside, cannot change.)</p>

<p>The value of your object is <em>independent</em> from the state of the mutex (it's only an implementation detail to provide consistency, and it's state is not known outside the class), which is a good sign your mutex should be <code>mutable</code>.</p>

<hr>

<p>Note, you should not go the <code>const_cast</code> route. <a href=""http://stackoverflow.com/questions/3484233/const-method-that-modifies-this-without-const-cast/3485333#3485333"">This leads to undefined behavior</a> if you did:</p>

<pre><code>const Foo f;

Bar b;
f.getBar(b); // takes const off of mutex, modifies (bang you're dead)
</code></pre>
"
"<pre><code>#include&lt;iostream&gt;
using namespace std;

class temp
    {
      int value1; 
      public :
        void fun() const
        {
        ((temp*)this)-&gt;value1 = 10;
        }
        void print()
        {
            cout&lt;&lt;value1&lt;&lt;endl;
        }
     };
int main()
{
  temp t;
  t.fun();
  t.print();
}
</code></pre>
","87234","","<p>Because you're casting away <code>const</code>...</p>

<p>When you cast something, the responsibility is yours for making sure that it doesn't do something dumb.</p>

<hr>

<p>Note that if <code>temp t;</code> is changed to <code>const temp t;</code>, you get undefined behavior, for modifying a <code>const</code> value.</p>

<p>Coincidentally I literally just touched on this in <a href=""http://blackninjagames.com/?p=91"" rel=""nofollow"">my blog</a>. (Almost the same function, too.)</p>
"
"<p>In C++11, is there a way to template a lambda function? Or is it inherently too specific to be templated?</p>

<p>I understand that I can define a classic templated class/functor instead, but the question is more like: does the language allow templating lambda functions?</p>
","87234","","<p>At it stands, sadly no. Polymorphic lambdas would be excellent in terms of flexibility and power.</p>

<p>The original reason they ended up being monomorphic was because of concepts. Concepts made this code situation difficult:</p>

<pre><code>template &lt;Constraint T&gt;
void foo(T x)
{
    auto bar = [](auto x){}; // imaginary syntax
}
</code></pre>

<p>In a constrained template you can only call other constrained templates. (Otherwise the constraints couldn't be checked.) Can <code>foo</code> invoke <code>bar(x)</code>? What constraints does the lambda have (the parameter for it is just a template, after all)?</p>

<p>Concepts weren't ready to tackle this sort of thing; it'd require more stuff like <code>late_check</code> (where the concept wasn't checked until invoked) and stuff. Simpler was just to drop it all and stick to monomorphic lambdas.</p>

<p>However, with the removal of concepts from C++0x, polymorphic lambdas become a simple proposition again. However, I can't find any proposals for it. :(</p>
"
"<p>In perfect forwarding, <code>std::forward</code> is used to convert the named rvalue references <code>t1</code> and <code>t2</code> to unnamed rvalue references. What is the purpose of doing that? How would that affect the called function <code>inner</code> if we leave <code>t1</code> &amp; <code>t2</code> as lvalues?</p>

<pre><code>template &lt;typename T1, typename T2&gt;
void outer(T1&amp;&amp; t1, T2&amp;&amp; t2) 
{
    inner(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));
}
</code></pre>
","87234","","<p>You have to understand the forwarding problem. You can <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm"">read the entire problem in detail</a>, but I'll summarize.</p>

<p>Basically, given the expression <code>E(a, b, ... , c)</code>, we want the expression <code>f(a, b, ... , c)</code> to be equivalent. In C++03, this is impossible. There are many attempts, but they all fail in some regard.</p>

<hr>

<p>The simplest is to use an lvalue-reference:</p>

<pre><code>template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, B&amp; b, C&amp; c)
{
    E(a, b, c);
}
</code></pre>

<p>But this fails to handle temporary values: <code>f(1, 2, 3);</code>, as those cannot be bound to an lvalue-reference.</p>

<p>The next attempt might be:</p>

<pre><code>template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, const B&amp; b, const C&amp; c)
{
    E(a, b, c);
}
</code></pre>

<p>Which fixes the above problem, but flips flops. It now fails to allow <code>E</code> to have non-const arguments:</p>

<pre><code>int i = 1, j = 2, k = 3;
void E(int&amp;, int&amp;, int&amp;); f(i, j, k); // oops! E cannot modify these
</code></pre>

<p>The third attempt accepts const-references, but then <code>const_cast</code>'s the <code>const</code> away:</p>

<pre><code>template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, const B&amp; b, const C&amp; c)
{
    E(const_cast&lt;A&amp;&gt;(a), const_cast&lt;B&amp;&gt;(b), const_cast&lt;C&amp;&gt;(c));
}
</code></pre>

<p>This accepts all values, can pass on all values, but potentially leads to undefined behavior:</p>

<pre><code>const int i = 1, j = 2, k = 3;
E(int&amp;, int&amp;, int&amp;); f(i, j, k); // ouch! E can modify a const object!
</code></pre>

<p>A final solution handles everything correctly...at the cost of being impossible to maintain. You provide overloads of <code>f</code>, with <em>all</em> combinations of const and non-const:</p>

<pre><code>template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, B&amp; b, C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, B&amp; b, C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, const B&amp; b, C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, B&amp; b, const C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, const B&amp; b, C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, B&amp; b, const C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, const B&amp; b, const C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, const B&amp; b, const C&amp; c);
</code></pre>

<p>N arguments require 2<sup>N</sup> combinations, a nightmare. We'd like to do this automatically.</p>

<p>(This is effectively what we get the compiler to do for us in C++11.)</p>

<hr>

<p>In C++11, we get a chance to fix this. <a href=""http://stackoverflow.com/questions/3591832/perfect-forwarding-in-c03/3591909#3591909"">One solution modifies template deduction rules on existing types, but this potentially breaks a great deal of code.</a> So we have to find another way.</p>

<p>The solution is to instead use the newly added <strong>rvalue-references</strong>; we can introduce new rules when deducing rvalue-reference types and create any desired result. After all, we cannot possibly break code now.</p>

<p>If given a reference to a reference (note reference is an encompassing term meaning both <code>T&amp;</code> and <code>T&amp;&amp;</code>), we use the following rule to figure out the resulting type:</p>

<blockquote>
  <p>""[given] a type TR that is a reference to a type T, an attempt to create the type “lvalue reference to cv TR” creates the type “lvalue reference to T”, while an attempt to create the type “rvalue reference to cv TR” creates the type TR.""</p>
</blockquote>

<p>Or in tabular form:</p>

<pre><code>TR   R

T&amp;   &amp;  -&gt; T&amp;  // lvalue reference to cv TR -&gt; lvalue reference to T
T&amp;   &amp;&amp; -&gt; T&amp;  // rvalue reference to cv TR -&gt; TR (lvalue reference to T)
T&amp;&amp;  &amp;  -&gt; T&amp;  // lvalue reference to cv TR -&gt; lvalue reference to T
T&amp;&amp;  &amp;&amp; -&gt; T&amp;&amp; // rvalue reference to cv TR -&gt; TR (rvalue reference to T)
</code></pre>

<p>Next, with template argument deduction: if an argument is an lvalue A, we supply the template argument with an lvalue reference to A. Otherwise, we deduce normally. This gives so-called <strong>universal references</strong>.</p>

<p>Why is this useful? Because combined we maintain the ability to keep track of the value category of a type: if it was an lvalue, we have an lvalue-reference parameter, otherwise we have an rvalue-reference parameter.</p>

<p>In code:</p>

<pre><code>template &lt;typename T&gt;
void deduce(T&amp;&amp; x); 

int i;
deduce(i); // deduce&lt;int&amp;&gt;(int&amp; &amp;&amp;) -&gt; deduce&lt;int&amp;&gt;(int&amp;)
deduce(1); // deduce&lt;int&gt;(int&amp;&amp;)
</code></pre>

<p>The last thing is to ""forward"" the value category of the variable. Keep in mind, once inside the function the parameter could be passed as an lvalue to anything:</p>

<pre><code>void foo(int&amp;);

template &lt;typename T&gt;
void deduce(T&amp;&amp; x)
{
    foo(x); // fine, foo can refer to x
}

deduce(1); // okay, foo operates on x which has a value of 1
</code></pre>

<p>That's no good. E needs to get the same kind of value-category that we got! The solution is this:</p>

<pre><code>static_cast&lt;T&amp;&amp;&gt;(x);
</code></pre>

<p>What does this do? Consider we're inside the <code>deduce</code> function, and we've been passed an lvalue. This means <code>T</code> is a <code>A&amp;</code>, and so the target type for the static cast is <code>A&amp; &amp;&amp;</code>, or just <code>A&amp;</code>. Since <code>x</code> is already an <code>A&amp;</code>, we do nothing and are left with an lvalue reference.</p>

<p>When we've been passed an rvalue, <code>T</code> is <code>A</code>, so the target type for the static cast is <code>A&amp;&amp;</code>. The cast results in an rvalue expression, <em>which can no longer be passed to an lvalue reference</em>. We've maintained the value category of the parameter.</p>

<p>Putting these together gives us ""perfect forwarding"": </p>

<pre><code>template &lt;typename A&gt;
void f(A&amp;&amp; a)
{
    E(static_cast&lt;A&amp;&amp;&gt;(a)); 
}
</code></pre>

<p>When <code>f</code> receives an lvalue, <code>E</code> gets an lvalue. When <code>f</code> receives an rvalue, <code>E</code> gets an rvalue. Perfect.</p>

<hr>

<p>And of course, we want to get rid of the ugly. <code>static_cast&lt;T&amp;&amp;&gt;</code> is cryptic and weird to remember; let's instead make a utility function called <code>forward</code>, which does the same thing:</p>

<pre><code>std::forward&lt;A&gt;(a);
// is the same as
static_cast&lt;A&amp;&amp;&gt;(a);
</code></pre>
"
"<p>If you have this function</p>

<pre><code>template&lt;typename T&gt; f(T&amp;);
</code></pre>

<p>And then try to call it with, let's say an rvalue like</p>

<pre><code>f(1);
</code></pre>

<p>Why isn't T just be deduced to be const int, making the argument a const int&amp; and thus bindable to an rvalue?</p>
","87234","","<p>This is mentioned as a potential solution in <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm"">the document</a> I linked in the <a href=""http://stackoverflow.com/questions/3582001/advantages-of-using-forward"">recent C++0x forwarding question</a>.</p>

<p>It <em>would</em> work fairly well, but it breaks existing code. Consider (straight from the document):</p>

<pre><code>template&lt;class A1&gt; void f(A1 &amp; a1)
{
    std::cout &lt;&lt; 1 &lt;&lt; std::endl;
}

void f(long const &amp;)
{
    std::cout &lt;&lt; 2 &lt;&lt; std::endl;
}

int main()
{
    f(5);              // prints 2 under the current rules, 1 after the change
    int const n(5);
    f(n);              // 1 in both cases
}
</code></pre>

<p>Or</p>

<pre><code>// helper function in a header

template&lt;class T&gt; void something(T &amp; t) // #1
{
    t.something();
}

// source

#include &lt;vector&gt;

void something(bool) // #2
{
}

int main()
{
    std::vector&lt;bool&gt; v(5);

    // resolves to #2 under the current rules, #1 after the change
    something(v[0]);
}
</code></pre>

<p>This also fails to forward the value category (lvalue or rvalue), which isn't much of a problem in C++03. But since this fix could only be done during C++0x, we'd effectively shutting ourselves out from rvalue references when forwarding (a bad thing). We should strive for a better solution.</p>
"
"<h3>Code</h3>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    const int N = 22;
    int * pN = const_cast&lt;int*&gt;(&amp;N);
    *pN = 33;
    cout &lt;&lt; N &lt;&lt; '\t' &lt;&lt; &amp;N &lt;&lt; endl;
    cout &lt;&lt; *pN &lt;&lt; '\t' &lt;&lt; pN &lt;&lt; endl;
}
</code></pre>

<h3>Output</h3>

<blockquote>
  <p>22      0x22ff74</p>
  
  <p>33      0x22ff74</p>
</blockquote>

<p>Why are there two different values at the same address?</p>
","87234","","<p>You get undefined behavior on the line <code>*pN = 33;</code>, because you're modifying a const value. Anything can happen. Don't do it.</p>

<hr>

<p>Likely, though, your compiler simply optimized. In the line:</p>

<pre><code>cout &lt;&lt; N &lt;&lt; '\t' &lt;&lt; &amp;N &lt;&lt; endl;
</code></pre>

<p>It knows <code>N</code> is a constant expression with the value 22, so just changes the line to:</p>

<pre><code>cout &lt;&lt; 22 &lt;&lt; '\t' &lt;&lt; &amp;N &lt;&lt; endl;
</code></pre>

<p>And on your next line, you fetch the value at the address of <code>N</code>, which you ""set"" to 33. (But really, all you did was remove any guarantees about the state of your program.)</p>
"
"<blockquote>
  <p><strong>Possible Duplicates:</strong><br>
  <a href=""http://stackoverflow.com/questions/2273913/how-would-you-set-a-variable-to-the-largest-number-possible-in-c"">How would you set a variable to the largest number possible in C?</a><br>
  <a href=""http://stackoverflow.com/questions/1855459/maximum-value-of-int"">maximum value of int</a>  </p>
</blockquote>



<p>I need to use the maximum integer value in my my code, but I don't want to explicitly write 4294967295. Is it defined somewhere?</p>
","87234","","<p>Use <a href=""http://en.wikipedia.org/wiki/Limits.h"" rel=""nofollow""><code>limits.h</code></a>:</p>

<pre><code>#include &lt;limits.h&gt;

int maximum = INT_MAX;
</code></pre>
"
"<p>Where is <code>ptrdiff_t</code> defined in C? If non-trivial, how can I make this type visible from GCC on Linux?</p>
","87234","","<p>It's defined in <code>stddef.h</code>.</p>

<hr>

<p>That header defines the integral types <code>size_t</code>, <code>ptrdiff_t</code>, and <code>wchar_t</code>, the functional macro <code>offsetof</code>, and the constant macro <code>NULL</code>.</p>
"
"<p>Is there a way to detect whether there is anything left inside a boost archive after I read from it? I tried this piece of code:</p>

<pre><code>const string s1(""some text"");
std::stringstream stream;
boost::archive::polymorphic_text_oarchive oAr(stream);
oAr &lt;&lt; s1;

boost::archive::polymorphic_text_iarchive iAr(stream);
string s2;
iAr &gt;&gt; s2;

if (!stream.eof())
{
    // There is still something inside the archive
}
</code></pre>

<p>I expected stream object to be updated as if I read directly from it, but in the above code <code>stream.eof()</code> is always <code>false</code> although I read everything I had written. Changing string to int gave the same result.</p>

<p>The reason I wanted this ability is for situations when I read not the same types I write:</p>

<pre><code>const string s1(""some text"");
std::stringstream stream;
boost::archive::polymorphic_text_oarchive oAr(stream);
oAr &lt;&lt; s1;

boost::archive::polymorphic_text_iarchive iAr(stream);
int s2;
iAr &gt;&gt; s2; // string was written but int is read
</code></pre>

<p>I know that there isn't much I can do in this situation, but I hoped that at least checking that I read everything will give me some indication whether there was some inconsistency between reads and writes. Any ideas?</p>
","87234","","<p>A stream can't set any flags until it's tried some operation.</p>

<p>You can use <code>peek()</code> to peek at and return, but not remove, the next character in a stream. This is enough to set a flag, so do: <code>if (stream.peek(), !stream.eof()) /* peek was not eof */</code>.</p>
"
"<p>I was looking up the keyword <code>volatile</code> and what it's for, and the answer I got was pretty much:</p>

<blockquote>
  <p>It's used to prevent the compiler from optimizing away code.</p>
</blockquote>

<p>There were some examples, such as when polling memory-mapped hardware: without <code>volatile</code> the polling loop would be removed as the compiler might recognize that the condition value is never changed. But since there only were one example or maybe two, it got me thinking: Are there other situations where we need to use <code>volatile</code> in terms of avoiding unwanted optimization? Are condition variables the only place where <code>volatile</code> is needed?</p>

<p>I imagine that optimization is compiler-specific and therefore is not specified in the C++ specification. Does that mean we have to go by gut feeling, saying <i>Hm, I suspect my compiler will do away with this if I don't declare that variable as <code>volatile</code></i> or are there any clear rules to go by?</p>
","87234","","<p>The <em>observable behavior</em> of a C++ program is determined by read and writes to volatile variables, and any calls to input/output functions.</p>

<p>What this entails is that all reads and writes to volatile variables <em>must</em> happen in the order they appear in code, and they <em>must</em> happen. (If a compiler broke one of those rules, it would be breaking the as-if rule.)</p>

<p>That's all. It's used when you need to indicate that reading or writing a variable is to be seen as an observable effect. (Note, the <a href=""http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf"" rel=""nofollow"">""C++ and the Perils of Double-Checked Locking"" article</a> touches on this quite a bit.)</p>

<hr>

<p>So to answer the title question, it prevents any optimization that might re-order the evaluation of volatile variables <em>relative to other volatile variables</em>.</p>

<p>That means a compiler that changes:</p>

<pre><code>int x = 2;
volatile int y = 5;
x = 5;
y = 7;
</code></pre>

<p>To</p>

<pre><code>int x = 5;
volatile int y = 5;
y = 7;
</code></pre>

<p>Is fine, since the value of <code>x</code> is not part of the observable behavior (it's not volatile). What wouldn't be fine is changing the assignment from 5 to an assignment to 7, because that write of 5 is an observable effect.</p>
"
"<p>For a built in type integer array say</p>

<pre><code>int a[10];
int i = 2;
a[i] = 10;
</code></pre>

<p>alternatively</p>

<pre><code>i[a] = 10;
</code></pre>

<p>because </p>

<p><code>a[i]</code> is a postfix expression that is <code>*(a+i)</code> or <code>*(i+a)</code> because commutative property of addition.</p>

<p>I want to achieve that for a userdefined type say</p>

<pre><code>class Dummy
{
//
};
</code></pre>

<p>Is it possible?
If yes then how?
If no then why?</p>

<p>EDIT :-
I know it is ugly but following code compiles :-
g++ -dumpversion
4.3.3</p>

<pre><code>#include &lt;stdio.h&gt;
#include&lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;malloc.h&gt;
using namespace std;

int main()
{
    string ArrayS[10];
    2[ArrayS] = ""ADASD"" ;
    cout &lt;&lt;  2[ArrayS] &lt;&lt; endl;
    return 0;
}
</code></pre>
","87234","","<p>It is completely impossible to do. Potatoswatter <a href=""http://stackoverflow.com/questions/3612554/commutative-property-ai-ia/3612591#3612591"">correctly points out</a> you couldn't possibly define any operator such as <code>operator[](int, T)</code>, so overloading for an integer on the left is impossible.</p>

<p>But consider that this works:</p>

<pre><code>struct foo
{
    operator const foo*() const
    {
        return this;
    }
};

int main()
{
    foo f;
    5[f]; // UB
}
</code></pre>

<p>Is there a way to utilize this? No:</p>

<blockquote>
  <p>5.2.1 Subscripting<br>
  A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type “pointer to T” and the other shall have enumeration or integral type. The result is an lvalue of type “T.” The type “T” shall be a completely-defined object type.56) The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code>.</p>
</blockquote>

<p>With <code>E1</code> being an integral type, <code>E2</code> <em>must</em> be a pointer type. So we can't inject user-behavior there.</p>

<p>The only thing left is <code>+</code> and <code>*</code>. We can't change <code>operator+</code> for an integral type and a pointer, because that's defined by the language. The result of <code>E1 + E2</code> is going to be a pointer, and we can't define <code>operator*</code> for a pointer either.</p>

<p>Therefore, injecting user-defined behavior is impossible.</p>
"
"<p>I want to make a dynamic array of foo, with the number of items being x. Arguments y and z are to be passed to the constructor of the item foo. I was hoping to do something similar to:</p>

<pre><code>Foo* bar = new Foo(y, z)[x];
</code></pre>

<p>However that produced the following compiler error:</p>

<pre><code> error: expected `;' before '[' token
</code></pre>

<p>So after speaking with an experienced friend, he gave me this, which he admitted was a lazy way of doing it, but it works. I was wondering, is there a better/proper way?</p>

<pre><code>Foo* bar = (Foo*) new int[x];
for (int i = 0; i &lt; x; i++) {
    bar[i] = Foo(y, z);
}
</code></pre>
","87234","","<p>""I want to make a dynamic array"" So use a <code>std::vector</code>, it exists for a reason.</p>

<pre><code>std::vector&lt;foo&gt; bar(x, foo(y, z));
</code></pre>

<p>This creates a dynamic array with <code>x</code> elements initialized to <code>foo(y, z)</code>.</p>

<hr>

<p>The above makes <em>copies</em> of the second parameter, <code>x</code> times. If you want to <em>generate</em> values for the <code>vector</code>, use <code>generate_n</code>:</p>

<pre><code>std::vector&lt;double&gt; weights;
std::generate_n(std::back_inserter(weights), x, ...);
</code></pre>

<p>You replace <code>...</code> with a function or functor to call, that returns a value. Generally you make a functor:</p>

<pre><code>struct generate_weight
{
    double operator()() const
    {
        return random(1e-3);
    }
};
</code></pre>

<p>Giving:</p>

<pre><code>std::generate_n(std::back_inserter(weights), x, generate_weight());
</code></pre>

<p>If your compiler supports C++0x, you can take advantage of lambda's. These do the same thing, except they keep the code concise and localized:</p>

<pre><code>std::generate_n(std::back_inserter(weights), x,
                [](){ return random(1e-3); } );
</code></pre>
"
"<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    int i;
    for(i=0; i &lt;= 11; i+=3)
        cout &lt;&lt; i;
    cout &lt;&lt; endl &lt;&lt; i &lt;&lt; endl;
}
</code></pre>

<p>output is: 0 3 6 and 9 and then once it exits the loop its 12.
The addresses of i inside the loop and out appear the same</p>

<p>What I need to know is: Is the i inside the for loop the same as the i that was initialized outside the for loop because the variable i was first initialized before the for loops i was ever created?</p>
","87234","","<p>A <code>for-loop</code> of the form:</p>

<pre><code>for (init condition; expression) statement
</code></pre>

<p>Is exactly equivalent to:</p>

<pre><code>{
    init
    while (condition)
    {
        statement
        expression;
    }
}
</code></pre>

<p>So with your code:</p>

<pre><code>    int i;
    {
        i=0;
        while (i &lt;= 11)
        {
            cout &lt;&lt; i;
            i += 3;
        }
    }
    cout &lt;&lt; endl &lt;&lt; i &lt;&lt; endl;
}
</code></pre>

<p>Can you tell now? <a href=""http://stackoverflow.com/questions/3640337/c-scope-of-for-loop/3640465#3640465"">Andrey puts it best</a>: if you didn't define it, it doesn't exist.</p>
"
"<p>The title pretty much says it all. The precise error message that seems to be the root of it is:</p>

<blockquote>
  <p>util.h:4: error: expected declaration
  specifiers or ‘...’ before ‘size_t’</p>
</blockquote>

<p>The header in question is:</p>

<pre><code>#ifndef UTIL_H
#define UTIL_H

void print_array(void*, int, size_t, void (*)(void*));
extern void print_int(void*);
extern void print_float(void*);

#endif /* UTIL_H */
</code></pre>

<p>If I compile the following file with <code>gcc -Wall -c util.c</code> the compiler silently creates an object file.</p>

<pre><code>#include &lt;stdio.h&gt;
#include ""util.h""

void print_array(void* a, int length, size_t size, void (*print)(void*)) {
  unsigned int i;
  for (i = 0; i &lt; length; i++) {
    print(a + i*(unsigned int)size);
  }
  printf(""\n"");
}

void print_int(void* i) {
  int* a = (int*) i;
  printf("" %i "", *a); 
}

void print_float(void* f) {
  float* a = (float*) f;
  printf("" %f "", *a);
}
</code></pre>

<p>If I include it with any other file, I get the aforementioned error and a bunch of other ones. The one I've provided comes first. Everything I've googled about it says that it's the result of a syntax error on a previous line but it was happening when it was the <em>first line</em> in the file. I can see that if I get this error knocked out, then all the other ones will go away as they have to do with <code>print_array</code> being called with the wrong number or type of arguments (which it isn't).</p>
","87234","","<p><code>size_t</code> isn't defined until you include <code>stddef.h</code>. Your header should probably include that first to guarantee it's defined. (As it stands, you're just getting ""lucky"" and having other includes that will eventually define it included first, so it doesn't cause a problem.)</p>
"
"<p>For my offline coding needs, I've been using the <a href=""http://www.sgi.com/tech/stl/download.html"" rel=""nofollow"">downloadable STL documentation from SGI</a>. Unfortunately it was last edited in 1999, and doesn't cover any of the TR1. </p>

<p>It's easy enough to find online references for TR1, but can anybody recommend an easily downloadable TR1 reference for working offline? In HTML? </p>

<p>I've downloaded Boost's docs, but I'm not super-happy with this solution. It feels klunky to be jumping around the different sub-libraries of Boost that make up its TR1 implementation, such as boost/unordered/ for <code>&lt;unordered_set&gt;</code> and boost/shared_ptr/ for <code>&lt;memory&gt;</code>, etc. It also doesn't cover the plain old STL, whereas I'd prefer a single reference for both std:: and std::tr1.</p>

<p>I also tried looking at <a href=""http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.2/namespacestd_1_1tr1.html"" rel=""nofollow"">GNU's libstd++ docs</a>, but they didn't seem to be meant for human consumption.</p>

<p>This may end up effectively being a wget question, as in ""what flags do I feed to wget to download all of <a href=""http://msdn.microsoft.com/en-us/library/bb982198.aspx"" rel=""nofollow"">MSDN's online TR1 docs</a> (and nothing else)"". </p>
","87234","","<p>You can just read TR1 itself, <a href=""http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf"" rel=""nofollow"">here</a>. (PDF Link, 1.4 MB)</p>
"
"<p>I'm basically looping through all the entries to check whether some entries is to be erased, but seems in a wrong way:</p>

<pre><code>std::vector&lt;HANDLE&gt; myvector; 
for(unsigned int i = 0; i &lt; myvector.size(); i++)
{
    if(...)
         myvector.erase(myvector.begin()+i);
}
</code></pre>

<p>Anyone spot the problem in it? How to do it correctly?</p>
","87234","","<p>You can use <code>std::remove_if</code>. This will move all remaining elements to the front, and returns an iterator to the new back. You can then erase it:</p>

<pre><code>struct my_predicate
{
    bool operator()(HANDLE) const
    {
        return ...;
    }
};

typedef std::vector&lt;HANDLE&gt; vector_type;

vector_type::iterator newEnd =
    std::remove_if(myvector.begin(), myvector.end(), my_predicate());

myvector.erase(newEnd, myvector.end());
</code></pre>

<p>It's commonly done on one line. If your compiler supports lambda's (C++0x), you can do:</p>

<pre><code>vector_type::iterator newEnd =
    std::remove_if(myvector.begin(), myvector.end(), [](HANDLE){ return ... });

myvector.erase(newEnd, myvector.end());
</code></pre>

<p>To keep the predicate local.</p>

<hr>

<p>If you think this is ugly, just wrap it up:</p>

<pre><code>template &lt;typename Vec, typename Pred&gt;
Pred erase_if(Vec&amp; pVec, Pred pPred)
{
    pVec.erase(std::remove_if(pVec.begin(), pVec.end(),
                                pPred), pVec.end());

    return pPred;
}
</code></pre>

<p>Then:</p>

<pre><code>erase_if(myvector, mypredicate);
</code></pre>

<p>C++0x lambda's work the same, of course.</p>
"
"<p>I have a std::list in a C++ program, which contains objects of a Class A. 
Lets say I have 10 objects in it. I have a reference to the 6th object stored, in another data structure say ref_6. Lets say I need to remove the 8th element from my list. To do this, I would use pop_front 8 times and store 8 objects in a vector and use push_front 7 times to insert the first 7 elements back in the list so now my resulting list would have 9 elemnts. Now i when i try to access the object stored in ref_6 , which was the 6th element , I cant do it. There is some garbage value in this reference.
I am assuming that when i do a pop and a push, the memory location of the same object changes . How do I deal with this ? </p>
","87234","","<p>Why would you erase things in such a manner? D: It's not a stack. The entire point (and <em>only</em> point*) of a list is that you can remove any element in constant time. (Though finding it is linear.)</p>

<p>Just do this:</p>

<pre><code>typedef std::list&lt;T&gt; list_type;

list_type mylist; // populate it

list_type::iterator iter =  mylist.begin();
std::advance(iter, 8); // move to 8th item

mylist.erase(iter); // erase it
</code></pre>

<p>And no other iterators are invalidated. (Indeed, erasing an element invalidates any references to it.)</p>

<hr>

<p>*You probably shouldn't even be using a list. Lists are nice when it comes to learning data structures, but they're pretty awful. </p>
"
"<p>Given:</p>

<pre><code>template &lt;int N&gt;
struct val2size
{
    char placeholder[N];
};
</code></pre>

<p>Is there any guarantee that <code>sizeof(val2size&lt;N&gt;) == N</code>?</p>
","87234","","<p>No, <a href=""http://stackoverflow.com/questions/3647562/is-there-a-guarantee-as-to-the-size-of-a-class-that-contains-an-array/3647567#3647567"">James covers that</a>. But you can get what you want with:</p>

<pre><code>template &lt;std::size_t N&gt; // not an int, a negative value doesn't make sense
struct value_to_size
{
    typedef char type[N];
};
</code></pre>

<p><code>sizeof(value_to_size&lt;N&gt;::type)</code> is guaranteed to be <code>N</code>. (This trick can be used to make a <a href=""http://stackoverflow.com/questions/3368883/how-does-this-size-of-array-template-function-work/3368894#3368894"">compile-time size-of array utility</a>.)</p>
"
"<p>Why in this code (this is just working code and not fully exception safe) I'm getting an assertion error:<br>
HEAP_CORRUPTION_DETECTED ...  </p>

<pre><code>class Allocator
{

public:

    explicit Allocator()
    {
        std::cout &lt;&lt; ""Allocator()"" &lt;&lt; '\n';
    }

    virtual ~Allocator()
    {

        std::cout &lt;&lt; ""~Allocator()"" &lt;&lt; '\n';
    }

    template&lt;class T&gt;
    T* Allocate(const std::size_t count)
    {
        return static_cast&lt;T*&gt;(::operator new(count));
    }

    /*[nothrow]*/
    template&lt;class T&gt;
    void Construct(void* where_, const T&amp; what)
    {
        new (where_) T(what);
    }

    template&lt;class T&gt;
    void Destruct(T* where_)
    {
        where_-&gt;~T();
    }

    template&lt;class FwdIter&gt;
    void Destruct(FwdIter first, FwdIter last)
    {
        while (first != last)
        {
            this-&gt;Destruct(&amp;*first);
            ++first;
        }
    }

    template&lt;class T&gt;
    void Deallocate(T* where_)
    {
        ::operator delete(where_);
    }
};


template&lt;class T&gt;
class ToyImplementation
{
private:

public:
    typedef T value_type;
    T* data_;///move to private
    std::size_t size_;
    std::size_t capacity_;
    explicit ToyImplementation(Allocator&amp; alloc, const std::size_t count):data_(alloc.Allocate&lt;value_type&gt;(count)),size_(0),capacity_(count)
    {
        std::cout &lt;&lt; ""ToyImplementation()"" &lt;&lt; '\n';
        //throw std::exception();
    }
    ~ToyImplementation()
    {
        std::cout &lt;&lt; ""~ToyImplementation()"" &lt;&lt; '\n';
    }
};


template&lt;class T&gt;
class ToyA
{
private:
    ToyImplementation&lt;T&gt;* implementation_;
    typedef ToyImplementation&lt;T&gt; value_type;
    Allocator alloc_;
public:
    explicit ToyA(const std::size_t count = 0): implementation_(alloc_.Allocate&lt;value_type&gt;(sizeof(value_type)))
    {
        alloc_.Construct(implementation_, value_type(alloc_,count));
        alloc_.Deallocate(implementation_);//&lt;&lt;--------HERE ERROR IS TRIGGERED
        std::cout &lt;&lt; ""Toy()"" &lt;&lt; '\n';
    }
    ~ToyA()
    {
        std::cout &lt;&lt; ""~Toy()"" &lt;&lt; '\n';
    }
};

int _tmain(int argc, _TCHAR* argv[])
{
    ToyA&lt;int&gt; t(10);
    return 0;
}
</code></pre>

<p>Seven lines up is a line which causes an error. Line is marked &lt;&lt;--------HERE ERROR IS TRIGGERED<br>
Thank you.</p>
","87234","","<p>You corrupted your heap because your allocation is incorrect. Namely, consider this:</p>

<pre><code>template&lt;class T&gt;
T* Allocate(const std::size_t count)
{
    return static_cast&lt;T*&gt;(::operator new(count));
}
</code></pre>

<p>If <code>count</code> is one, you get one byte. (You then try to construct an object which has a size greater than one in that memory...boom.)</p>

<p>You probably want:</p>

<pre><code>template&lt;class T&gt;
T* Allocate(const std::size_t count)
{
    return static_cast&lt;T*&gt;(::operator new(sizeof(T) * count));
}
</code></pre>

<hr>

<p>Note your function design is a bit unorthodox. The allocation and deallocation functions should strictly allocate and deallocate (no casts!), like this:</p>

<pre><code>template&lt;class T&gt;
void* Allocate(const std::size_t count)
{
    return ::operator new(sizeof(T) * count);
}

void Deallocate(void* where_)
{
    ::operator delete(where_);
}
</code></pre>

<p>And your construction and destruction functions should be the ones that construct and return an object, and destruct an object:</p>

<pre><code>template&lt;class T&gt;
T* Construct(void* where_, const T&amp; what)
{
    return new (where_) T(what);
}
</code></pre>
"
"<p>While reviewing Visual C++ codebase I found a following strange thing. A run-time assert (which is <em>check the condition and throw an exception if the condition is violated</em>) was used in a case when the condition could be evaluated at compile time:</p>

<pre><code>assert( sizeof( SomeType ) == sizeof( SomeOtherType ) );
</code></pre>

<p>clearly the compiler will evaluate the condition and replace the code that will effectively be either</p>

<pre><code>assert( true );
</code></pre>

<p>which does nothing or</p>

<pre><code>assert( false );
</code></pre>

<p>which throws an exception every time control passes through that line.</p>

<p>IMO a compile-time assert should have be used instead for the following reasons:</p>

<ul>
<li>it would expose the condition violation earlier - at compile time - and</li>
<li>it would let cleaner (thus faster and smaller) machine code be emitted</li>
</ul>

<p>Looks like a compile-time assert is the only right thing. Is there any possible reason to prefer a run-time assert here?</p>
","87234","","<p>There's no reason to prefer a run-time assert here. You should prefer compile-time errors over run-time errors so there's never a reason, given the option between the two, to choose a run-time assert.</p>

<p>However, if a static assert isn't an option (doesn't know the concept of a static assert, doesn't know how to make one and doesn't have one available, or knows how to make one but doesn't have the time to), a run-time assert is the next best thing.</p>

<p>With C++0x, the built-in <code>static_assert</code> feature should end all reason to use a run-time assert where a compile-time assert would work. </p>
"
"<p>What I want to do is something like this:</p>

<pre><code>void dosth(bool&amp; a) {
  a[2] = false;
}

int main() {
  bool a[10];

  dosth(a);

  return 0;
}
</code></pre>

<p>I want to call by reference, with an array as argument. How to realize this?</p>

<p>Thx</p>
","87234","","<p>Like this:</p>

<pre><code>typedef bool array_type[10];

void dosth(array_type&amp; a)
{
    a[2] = false;
}

int main()
{
    array_type a;
    dosth(a);
}
</code></pre>

<p>Or without the typedef:</p>

<pre><code>void dosth(bool (&amp;a)[10])
{
    a[2] = false;
}

int main()
{
    bool a[10];
    dosth(a);
}
</code></pre>

<p>Or more generally:</p>

<pre><code>template &lt;size_t Size&gt;
void dosth(bool (&amp;a)[Size])
{
    /*static_*/assert(Size &gt; 2);

    a[2] = false;
}

int main()
{
    bool a[10];
    dosth(a);
}
</code></pre>

<hr>

<p>If you're not in C++0x, you can implement a (simple) <code>static_assert</code> like this:</p>

<pre><code>template &lt;bool&gt;
struct static_assert_type;

template &lt;&gt; // only true is defined
struct static_assert_type&lt;true&gt; {}

#define static_assert(x) { static_assert_type&lt;(x)&gt;(); }
</code></pre>

<p>Which allows you uncomment the <code>static_assert</code> and get a compile-time error if the array size is too small.</p>
"
"<p>**I've gotten a few suggestions to make my function pure generic, which would work, but I'd prefer limiting the function to only accept Base and its children.</p>

<p>Having trouble making a function that can accept arguments of a variadic template class base type, while the function will actually be called with classes that derive from Base.  I've tried a few things.  Here's the general idea.  Given:</p>

<pre><code>template&lt;typename... Args&gt; struct Base {
    std::tuple&lt;Args...&gt; data;
    ... //other stuff
};

struct DerivedA : Base&lt;string, int&gt; {
};

struct DerviedB : Base&lt;bool, string, int&gt; {
};
</code></pre>

<p>What's the correct way to create a function that does this:</p>

<pre><code>string moosh_together(Base A, Base B) { //I only need access to Base's members
    return get&lt;0&gt;(A.data) + get&lt;1&gt;(B.data);
}

main() {
    DerivedA aThing;
        get&lt;0&gt;(aThing.data) = ""foo"";
    DerivedB bThing;
        get&lt;1&gt;(bThing.data) = ""bar'd"";
    cout &lt;&lt; moosh_together(aThing, bThing) &lt;&lt; endl;
}
</code></pre>

<p>Output:</p>

<pre><code>foobar'd
</code></pre>

<p>I've tried a few variations of the moosh_together function, none of which work.  Leaving it as above generates a compiler error about missing template arguments.  I'm unsure how to pass through to the function the template arguments that define DerivedA and DerivedB.</p>

<p>Other things I've tried (shotgun method):</p>

<pre><code>string moosh_together(Base&lt;&gt; A, Base&lt;&gt; B) {}
//err: conversion from 'DerivedA' to non-scalar type 'Base&lt;&gt;' requested

template&lt;Base&lt;typename... Args&gt; T1, Base&lt;typename... Args&gt; T2&gt;
string moosh_together(T1 A, T2 B) {}
//err: expected paramter pack before '...'

template&lt;Base&lt;Args...&gt; T1, Base&lt;Args...&gt; T2&gt;
string moosh_together(T1 A, T2 B) {}
//err: 'Args' was not declared in this scope
</code></pre>
","87234","","<p>When you write: <code>string moosh_together(Base A, Base B)</code>, ask yourself what <code>Base</code> is. <code>Base</code> is a <em>class template</em>, not a class type.</p>

<p>In other words, given:</p>

<pre><code>template &lt;typename T&gt;
struct foo {};
</code></pre>

<p><code>foo&lt;int&gt;</code> and <code>foo&lt;float&gt;</code> are two totally different types, that just so happened to be made from the same class template. They have no common base class, and you cannot refer to them simply as <code>foo</code> anymore than you can refer to both <code>int</code> and <code>float</code> with a single type.</p>

<p>You could factor out the non-dependent parts of <code>Base</code>:</p>

<pre><code>struct Core
{
    string name;
};

template &lt;typename... Args&gt;
struct Base : Core
{
    // ...
};
</code></pre>

<p>And then refer to the <code>Core</code> portions:</p>

<pre><code>// pass by reference, to avoid unnecessary copying
string moosh_together(const Core&amp; a, const Core&amp; b);
</code></pre>

<p>Or just make the function totally generic:</p>

<pre><code>template &lt;typename BaseOne, typename BaseTwo&gt;
string moosh_together(const BaseOne&amp; a, const BaseTwo&amp; b);
</code></pre>

<p>And say ""if you have the necessary members, you can use this function"".</p>
"
"<pre><code>template&lt;typename T&gt;
struct type_of {
   typedef boost::mpl::if_&lt;boost::is_pointer&lt;T&gt;,
   typename boost::remove_pointer&lt;T&gt;::type,
   T
   &gt;::type type;
};

int main() {
   int* ip;
   type_of&lt;ip&gt;::type iv = 3; // error: 'ip' cannot appear in a constant-expression
}
</code></pre>

<p>Thanks!</p>
","87234","","<p>You cannot. Either use compiler-specific extensions or Boost's Typeof (which hides the compiler-specific behavior behind a consistent interface).</p>

<p>In C++0x, you may use <code>decltype</code>: <code>decltype(ip) iv = 3;</code> If your compiler supports this aspect of C++0x, you're in luck.</p>
"
"<p>C++ allows overloading <code>operator new</code> - both global and per-class - usual <code>operator new</code>, <code>operator new[]</code> used with <code>new[]</code> statement and placement <code>operator new</code> separately.</p>

<p>The former two of those three are usually overloaded for using customized allocators and adding tracing. But placement <code>operator new</code> seems pretty straightforward - it actually does nothing inside. For example, in Visual C++ the default implementation just returns the address passed into the call:</p>

<pre><code>//from new.h
inline void* operator new( size_t, void* where )
{
   return where;
}
</code></pre>

<p>What else could it do?  Why and how could I sensibly overload placement <code>operator new</code>?</p>
","87234","","<p>The correct answer is <strong>you cannot replace operator placement new</strong>.</p>

<blockquote>
  <p>§18.4.​1.3 Placement forms<br>
  These functions are reserved, a C++ program may not define functions that displace the versions in the Standard C++ library.</p>
</blockquote>

<p>The rationale: The only purpose of the allocation and deallocation operators is to allocate and deallocate memory, so when given memory nothing more should be done. (The standard specifically notes that these functions ""Intentionally perform no other action."")</p>
"
"<p>I'm trying to do a simple custom runtime_error. I define the class:</p>

<pre><code>#include &lt;string&gt;
#include &lt;stdexcept&gt;


namespace utils{

 class FileNotFoundException: public std::runtime_error{
  public:
   FileNotFoundException():runtime_error(""File not found""){}
   FileNotFoundException(std::string msg):runtime_error(msg.c_str()){}
 };

};
</code></pre>

<p>Then I throw the error:</p>

<pre><code>bool checkFileExistence( std::string fileName )
 {
  boost::filesystem::path full_path = boost::filesystem::system_complete(boost::filesystem::path(fileName));
  if (!boost::filesystem::exists(full_path))
  {
    char msg[500];
    _snprintf(msg,500,""File %s doesn't exist"",fileName.c_str());
    throw new FileNotFoundException(msg);
  }
 }
</code></pre>

<p>And I use a try/catch block</p>

<pre><code>    try{
          checkFileExistence(fileName);
     }
   catch(utils::FileNotFoundException&amp; fnfe)
        {
          std::cout &lt;&lt; fnfe.what() &lt;&lt; std::endl;
     }
</code></pre>

<p>Runtime error is correctly thrown as FileNotFoundException but the line with std::cout is never reached and no line is writed to the console.</p>

<p>All ideas are welcome.
Thanks!</p>
","87234","","<p>That's because you're throwing a pointer. Just do: <code>throw FileNotFoundException(msg);</code>.</p>

<p>Whenever you use a pointer, unless you're putting it into a container/wrapper you're probably not doing the right thing.</p>
"
"<p>I'm trying to create a Breakout clone using C++, and so have several objects (like ball, paddle, powerupicon, block, etc). I understand that it's bad practice to have them at global scope, so they're initialized inside main(). The problem comes in with needing to do stuff with those objects from inside other functions (like redraw(), or reset_game()). The only method I can think of to do this would be to pass references of the objects into each function, but I'm not sure if this is the best approach.</p>

<p>Basically, what's the best way to do stuff with these objects from within a function? Pass them by reference? Make them global but within a namespace? Or something completely different?</p>
","87234","","<p>A simple (not necessarily flexible or powerful) approach is to define a base <code>game_object</code> class that defines your interface with game objects, and store those. Your objects inherit from it.:</p>

<pre><code>class game_object
{
public:
    virtual ~game_object() {}

    virtual void update() = 0;
    virtual void draw() = 0;

    // get and set position
    virtual vector3 position() = 0;
    virtual void position(const vector3&amp;) = 0;

    // etc...
};

class ball : public game_object
{
public:
    void update() { /* update the ball */ }
    void draw() { /* draw the ball */ }

    // etc
};

// etc
</code></pre>

<p>Now you have a common way of using a game object. Next, you can store these in a map (preferably an <code>unordered_map</code> if you have Boost, TR1, or C++0x), and make that map globally available:</p>

<pre><code>// game_object_manager.h
typedef std::map&lt;std::string, game_object*&gt; game_object_manager;

extern game_object_manager manager;
</code></pre>

<p>You define this in a translation unit (either <code>main.cpp</code> or a <code>game_object_manager.cpp</code>) somewhere. Lastly, you use it by inserting things by name:</p>

<pre><code>// somewhere, add the ball
manager.insert(std::make_pair(""ball"", new ball()));
</code></pre>

<p>And use it:</p>

<pre><code>game_object* b = manager[""ball""];
if (!b) /* there is no ball object */

// use b as ball */
</code></pre>

<p>Again, this is a simple solution and isn't necessarily robust, a best practice, or flexible. But for a first game, it'll work fine. (To improve it, you want to look into exception safety, smart pointers, and other things (game books). I recommend you do this <em>before</em> you try to make games.)</p>
"
"<p>So I'm making a snake game with teleports and the usual mice. I had a loop running like this:</p>

<pre><code>while(snake.alive() &amp;&amp; miceEaten &lt; micePerLevel)
{
    displayInfo(lives, score, level, micePerLevel - miceEaten);
    //some code
    if(miceEaten())
    {
        //update score...
    }
    //more stuff...
}
</code></pre>

<p>The problem with the above code was that <code>displayInfo</code> gets called before the score gets updated, and so after eating a mouse, the user has to wait until the loop runs again to see his score updated. So I moved that one line of code to the bottom of the function:</p>

<pre><code>while(snake.alive() &amp;&amp; miceEaten &lt; micePerLevel)
{
    //some code
    if(miceEaten())
    {
        //update score...
    }
    //more stuff...
    displayInfo(lives, score, level, micePerLevel - miceEaten);
}
</code></pre>

<p>and teleports stop working! The program crashes whenever the snake reaches a teleport. And <code>displayInfo</code> uses the following code:</p>

<pre><code>stringstream s;
s &lt;&lt; ""LEVEL "" &lt;&lt; left &lt;&lt; setw(12) &lt;&lt; level &lt;&lt; ""LIVES: "" &lt;&lt; setw(12) &lt;&lt; lives &lt;&lt; ""MICE LEFT: "" &lt;&lt; setw(12) &lt;&lt; miceLeft
    &lt;&lt; ""SCORE: "" &lt;&lt; setw(13) &lt;&lt; score;
printLine(0, s.str(), WHITEONBLUE);
</code></pre>

<p>Where <code>printLine</code> only has a <code>color_set</code>, <code>mvprintw</code>, and <code>refresh()</code>. Nothing to do with Teleports. Weird.</p>

<p>So I went to the snake function where the snake gets its next location from a teleport:</p>

<pre><code>    body.push_back(teleports[overlap(next)]-&gt;teleportFrom(dir)); //next is a Location object
</code></pre>

<p>Where <code>teleports[overlap(next)]-&gt;teleportFrom(dir)</code> returns the location the snake is to be teleported to. In an attempt to see why it was crashing (perhaps <code>Teleport</code> was returning some location offscreen?), I added the following 3 lines before the above line:</p>

<pre><code>    Location l = teleports[overlap(next)]-&gt;teleportFrom(dir);
    mvprintw(1, 0, ""(%i, %i)"", l.x, l.y);
    refresh();
</code></pre>

<p>And the problem disappears!</p>

<p>Not only that, but I HAVE to have those three lines. If I comment out <code>mvprintw(1, 0, ""(%i, %i)"", l.x, l.y);</code>, or <code>refresh();</code>, or both, the program crashes as before upon reaching a teleport.</p>

<p>Any ideas on what might be causing this behavior?</p>

<p><strong>UPDATE:</strong> I tried removing all warnings (which were mostly warnings about comparisons of signed/unsigned numbers), but only 1 remains so far:</p>

<pre><code>warning: reference to local variable 'other' returned
</code></pre>

<p>And the code:</p>

<pre><code>Location&amp; Location::operator = (Location other)
{
    if(this == &amp;other)
        return other;
    x = other.x;
    y = other.y;
    return *this;
}
</code></pre>

<p>What do I do to fix this warning?</p>
","87234","","<pre><code>Location&amp; Location::operator = (Location other)
{
    if(this == &amp;other)
        return other;
    x = other.x;
    y = other.y;
    return *this;
}
</code></pre>

<p>This returns a reference. When the function returns, what happens to <code>other</code>? (It dies, and you're referring to nothing.) Since this is the class you're dealing with around the problem area, this is probably the cause. Re-arranging surrounding code leaves the stack in a certain condition where referring to the dead variable ""works"".</p>

<p>Change it to <code>return *this</code>, or just remove the check altogether. (Assigning two variables without a branch will probably always run faster than adding a branch, on a modern CPU.)</p>

<p>(You should also generally take the parameter by reference, instead of by-value.)</p>
"
"<p>Sorry if this is explicitly answered somewhere, but I'm a little confused by the boost documentation and articles I've read online.</p>

<p>I see that I can use the reset() function to release the memory within a shared_ptr (assuming the reference count goes to zero), e.g.,</p>

<pre><code>shared_ptr&lt;int&gt; x(new int(0));
x.reset(new int(1));
</code></pre>

<p>This, I believe would result in the creation of two integer objects, and by the end of these two lines the integer equaling zero would be deleted from memory.</p>

<p>But, what if I use the following block of code:</p>

<pre><code>shared_ptr&lt;int&gt; x(new int(0));
x = shared_ptr&lt;int&gt;(new int(1));
</code></pre>

<p>Obviously, now *x == 1 is true, but will the original integer object (equaling zero) be deleted from memory or have I leaked that memory?</p>

<p>It seems to me that this would be an issue of the assignment operator decreasing the shared_ptr's reference count, but a glance at the source code doesn't seem to clear the question up for me. Hopefully someone more experienced or knowledgeable can help me out. Thanks in advance.</p>
","87234","","<p>The documentation is fairly clear:</p>

<blockquote>
  <p><code>shared_ptr &amp; operator=(shared_ptr const &amp; r); // never throws</code>  </p>
  
  <p>Effects: Equivalent to <code>shared_ptr(r).swap(*this)</code>.</p>
</blockquote>

<p>So it just swaps ownership with the temporary object you create. The temporary then expires, decreasing the reference count. (And deallocating if zero.)</p>

<hr>

<p>The purpose of these containers is to not leak memory. So no, you don't need to worry about leaking things unless you're trying to mess things up on purpose. (In other words, you probably don't need to doubt Boost knows what they're doing.)</p>
"
"<p>Is there any portable way of doing branch prediction hints? Consider the following example:</p>

<pre><code>  if (unlikely_condition) {
    /* ..A.. */
  } else {
    /* ..B.. */
  }
</code></pre>

<p>Is this any different than doing:</p>

<pre><code>  if (!unlikely_condition) {
    /* ..B.. */
  } else {
    /* ..A.. */
  }
</code></pre>

<p>Or is the only way to use compiler specific hints? (e.g. __builtin_expect on GCC)</p>

<p>Will compilers treat the <code>if</code> conditions any differently based on the ordering of the conditions?</p>
","87234","","<p>Optimization is inherently a compiler thing, so you have to use compiler functionality to help it. The language itself doesn't care about (or mandate) optimizations.</p>

<p>So the best you can do <em>without</em> compiler-specific extensions is organize your code in such a way where your compilers will ""do the right thing"" without help. But if you want to be sure, tap in to compiler extensions. (You might try abstracting them behind the preprocessor, so your code remains portable.)</p>
"
"<p>I would like to overload swap function for std::vector of primitive types / objects. The reason is a slow sorting of vectors containing big objects using std::sort. Here is the simple but not working example.</p>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
class Point
{
private:
    double x, y;
public:
    Point(double xx, double yy) : x(xx), y(yy) {}

    bool operator &lt; ( const Point&amp; p ) const
    {
        return x &lt; p.x;
    }

    void swap(Point &amp;p)
    {
        std::swap(*this, p);
    }

};

namespace std
{
void swap( Point &amp;p1, Point &amp;p2)
{
    p1.swap(p2);
}
}

typedef  std::vector&lt;Point&gt; TPoints;
int main()
{
Point p1(0,0);
Point p2(7,100);

TPoints points;
points.push_back(p1);
points.push_back(p2);

    //Overloaded metod swap will not be called
std::sort(points.begin(), points.end());
}
</code></pre>

<p>Unfortunately during the std::sort overloaded method is not called. I suppose the vector containing objects will be similar situation... Thanks for yout help...</p>
","87234","","<p>The proper way to implement swap is:</p>

<pre><code>class foo
{
public:
    void swap(foo&amp; pOther)
    {
        using std::swap; // enable ADL
        swap(member1, pOther.member1); // for all members
    }
};

// allows swap to be found with ADL (place in same namespace as foo)
void swap(foo&amp; pFirst, foo&amp; pSecond)
{
    pFirst.swap(pSecond);
}

// allows swap to be found within std
namespace std
{
    // only specializations are allowed to
    // be injected into the namespace std
    template &lt;&gt;
    void swap(foo&amp; pFirst, foo&amp; pSecond)
    {
        pFirst.swap(pSecond);
    }
}
</code></pre>

<p>However, it only makes sense to do this when you need to write the Big Three (you're <a href=""http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom"">managing some resource</a>).</p>

<p>You aren't, so I don't see the point. (All your <code>swap</code> will do is copy around some doubles, just like the default <code>std::swap</code> would.)</p>
"
"<p>Is it possible for a buffer overflow to occur from a cast?</p>

<p>If so, please explain how.</p>

<p>thanks.</p>
","87234","","<p>Not really. A buffer overrun is caused by <em>writing</em> outside a buffer's boundary. So unless you do something stupid like this:</p>

<pre><code>struct overrun
{
    explicit overrun(size_t pX)
    {
        char buffer[1];
        for (size_t i = 0; i &lt; pX; ++i)
            buffer[i] = 5;
    }
};

int main()
{
    static_cast&lt;overrun&gt;(100); // oops
}
</code></pre>

<p>A cast isn't going to typically overrun a buffer. (And even here, one could argue it's not the cast that causes the overrun so much as its the construction). If you're having a real problem, ask.</p>
"
"<p>[[UPDATE]] -> If I #include ""Queue.cpp"" in my program.cpp, it works just fine. This shouldn't be necessary, right?</p>

<p>Hey all -- I'm using Visual Studio 2010 and having trouble linking a quick-and-dirty Queue implementation. I started with an <em>empty</em> Win32 Console Application, and all files are present in the project. For verbosity, here's the complete code to duplicate my error. I realize some of the code may, in fact, be wrong. I haven't had a chance to test it yet because I haven't yet been able to link it.</p>

<p>Queue.hpp</p>

<pre><code>#ifndef ERROR_CODE
#define ERROR_CODE
enum Error_Code
{
    Success,
    Underflow,
    Overflow
};
#endif // ERROR_CODE

#ifndef QUEUE
#define QUEUE
template&lt;class T&gt;
struct Queue_Node
{
    T data;
    Queue_Node *next;

    Queue_Node()
    {
        next = NULL;
    }
    Queue_Node(T pData)
    {
        data = pData;
        next = NULL;
    }
    Queue_Node(T pData, Queue_Node *pNext)
    {
        data = pData;
        next = pNext;
    }
};

template&lt;class T&gt;
class Queue
{
public:
    Queue();
    Error_Code Serve();
    Error_Code Append(T item);
    T Front();
    ~Queue();

private:
    void Rescursive_Destroy(Queue_Node&lt;T&gt; *entry);
    Queue_Node&lt;T&gt; *front, *rear;
};
#endif // QUEUE
</code></pre>

<p>Queue.cpp</p>

<pre><code>#include ""Queue.hpp""

template &lt;class T&gt;
Queue&lt;T&gt;::Queue()
{
    this-&gt;front = this-&gt;rear = NULL;
}

template&lt;class T&gt;
Error_Code Queue&lt;T&gt;::Serve()
{
    if(front == NULL)
        return Underflow;

    Queue_Node *temp = this-&gt;front;
    this-&gt;front = this-&gt;front-&gt;next;
    delete temp;
}

template&lt;class T&gt;
Error_Code Queue&lt;T&gt;::Append(T item)
{
    Queue_Node *temp = new Queue_Node(item);
    if(!temp)
        return Overflow;

    if(this-&gt;rear != NULL)
        this-&gt;rear-&gt;next = temp;
    this-&gt;rear = temp;

    return Success;
}

template&lt;class T&gt;
T Queue&lt;T&gt;::Front()
{
    if(this-&gt;front == NULL)
        return Underflow;
    return this-&gt;front-&gt;data;
}

template&lt;class T&gt;
Queue&lt;T&gt;::~Queue()
{
    this-&gt;Rescursive_Destroy(this-&gt;front);
}

template&lt;class T&gt;
void Queue&lt;T&gt;::Rescursive_Destroy(Queue_Node&lt;T&gt; *entry)
{
    if(entry != NULL)
    {
        this-&gt;Recursive_Destroy(entry-&gt;next);
        delete entry;
    }
}
</code></pre>

<p>program.cpp</p>

<pre><code>#include ""Queue.hpp""

int main()
{
    Queue&lt;int&gt; steve;
    return 0;
}
</code></pre>

<p>And the errors...</p>

<pre><code>Error   1   error LNK2019: unresolved external symbol ""public: __thiscall Queue&lt;int&gt;::~Queue&lt;int&gt;(void)"" (??1?$Queue@H@@QAE@XZ) referenced in function _main    C:\[omitted]\Project2_2\Project2_2\program.obj  Project2_2
Error   2   error LNK2019: unresolved external symbol ""public: __thiscall Queue&lt;int&gt;::Queue&lt;int&gt;(void)"" (??0?$Queue@H@@QAE@XZ) referenced in function _main C:\[omitted]\Project2_2\Project2_2\program.obj  Project2_2
</code></pre>
","87234","","<p>If you have:</p>

<pre><code>template &lt;typename T&gt;
void foo();
</code></pre>

<p>And you do:</p>

<pre><code>foo&lt;int&gt;();
</code></pre>

<p>The compiler needs to generate (instantiate) that function. But it can't do that unless the function definition is visible <em>at the point of instantiation</em>.</p>

<p>This means template definitions needs to be included, in some way, in the header. (You can include the <code>.cpp</code> at the end of the header, or just provide the definitions inline.) </p>
"
"<p>I come from a the Objective-C and Cocoa world where there are lots of conventions and many people will say it makes your code beautiful!
Now programming in C++ I cannot find a good document like this one for C++.</p>

<p><a href=""http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html"">http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html</a></p>

<p>Standard C++ probably does not have something like above but I hope I can stick to some other SDK or APIs (like Microsoft's(?),etc) conventions. </p>

<p>I hope you can provide me with some links.</p>
","87234","","<p>Do whatever you want as long as its minimal, consistent, and <a href=""http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier"">doesn't break any rules</a>.</p>

<p>Personally, I find the Boost style easiest; it matches the standard library (giving a uniform look to code) and is simple. I personally tack on <code>m</code> and <code>p</code> prefixes to members and parameters, respectively, giving:</p>

<pre><code>#ifndef NAMESPACE_NAMES_THEN_PRIMARY_CLASS_OR_FUNCTION_THEN_HPP
#define NAMESPACE_NAMES_THEN_PRIMARY_CLASS_OR_FUNCTION_THEN_HPP

#include &lt;boost/headers/go/first&gt;
#include &lt;boost/in_alphabetical/order&gt;
#include &lt;then_standard_headers&gt;
#include &lt;in_alphabetical_order&gt;

#include ""then/any/detail/headers""
#include ""in/alphabetical/order""
#include ""then/any/remaining/headers/in""
// (you'll never guess)
#include ""alphabetical/order/duh""

#define NAMESPACE_NAMES_THEN_MACRO_NAME(pMacroNames) ARE_ALL_CAPS

namespace lowercase_identifers
{
    class separated_by_underscores
    {
    public:
        void because_underscores_are() const
        {
            volatile int mostLikeSpaces = 0; // but local names are condensed

            while (!mostLikeSpaces)
                single_statements(); // don't need braces

            for (size_t i = 0; i &lt; 100; ++i)
            {
                but_multiple(i);
                statements_do();
            }             
        }

        const complex_type&amp; value() const
        {
            return mValue; // no conflict with value here
        }

        void value(const complex_type&amp; pValue)
        {
            mValue = pValue ; // or here
        }

    protected:
        // the more public it is, the more important it is,
        // so order: public on top, then protected then private

        template &lt;typename Template, typename Parameters&gt;
        void are_upper_camel_case()
        {
            // gman was here                
        }

    private:
        complex_type mValue;
    };
}

#endif
</code></pre>

<p>That.
(And like I've said in comments, do <em>not</em> adopt the Google Style Guide for your code, unless it's for something as inconsequential as naming convention.)</p>
"
"<p>I have the following code</p>

<pre><code>int main()
{
    cout &lt;&lt; ""Please enter your name..."" &lt;&lt; endl;
    cin &gt;&gt; name;
    cout &lt;&lt; ""Data type = "" &lt;&lt; typeid(name).name() &lt;&lt; endl;
    cin.get();
    return 0;
}
</code></pre>

<p>According to the various textbooks and pieces of documentation I've read about the typeid operator, I should expect to read</p>

<pre><code>""Data type = string""
</code></pre>

<p>as the output. Instead, I get the following</p>

<pre><code>class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;
</code></pre>

<p>Does anyone have any idea where I'm going wrong? FWIW, I'm using Visual Studio 2010 Professional.</p>
","87234","","<p>Nothing is wrong.</p>

<p>Those text books, first of all, should have told you the result of <code>name()</code> is implementation-defined, and could very well be <code>""""</code>. Secondly, that type <em>is</em> <code>std::string</code>. The <code>std::string</code> type is just a typedef of <code>std::basic_string</code> with <code>char</code> and friends.</p>
"
"<p>I am trying to compile the following code in my test application on windows in visual studio for C++:</p>

<pre><code>const wchar_t* chinese = ""好久不见"";
</code></pre>

<p>But I get the following error:</p>

<blockquote>
  <p>error C2440: 'initializing' : cannot convert from 'const char [5]' to 'const wchar_t *</p>
</blockquote>

<p>I am compiling with unicode, so I am confused about this. The error goes away if I cast the literal like this:</p>

<pre><code>const wchar_t* chinese = (wchar_t*)""好久不见"";
</code></pre>

<p>I am not sure that is safe nor do I really want to do that so how can I fix this.</p>

<p>Thank you!</p>
","87234","","<p>You want a wide string literal, so prefix the string literal with <code>L</code>:</p>

<pre><code>const wchar_t* chinese =  L""好久不见"";
</code></pre>
"
"<p>My question is w.r.t the following thread : <a href=""http://stackoverflow.com/questions/2009924/specialize-a-member-template-without-specializing-its-parent"">http://stackoverflow.com/questions/2009924/specialize-a-member-template-without-specializing-its-parent</a></p>

<p>I'm absolutely fine with the standard saying that it is illegal to do so. But i want to understand <strong>why is it illegal to do so</strong>? What would be impact had it been allowed?</p>
","87234","","<p>Maybe because of something like this:</p>

<pre><code>template &lt;typename T&gt;
struct foo
{
    template &lt;typename U&gt;
    struct bar
    {
        typedef U type;
    };
};

template &lt;typename T&gt; 
struct foo&lt;T&gt;::bar&lt;int&gt; // imaginary
{
    typedef void type;
};

template &lt;&gt;
struct foo&lt;float&gt;
{
    template &lt;typename U&gt;
    struct bar
    {
        typedef U* type;
    };
};

// is it void [foo&lt;T&gt;::bar&lt;int&gt;] or 
// int* [foo&lt;float&gt;::bar&lt;U&gt;]?
typedef foo&lt;float&gt;::bar&lt;int&gt;::type ambiguous;
</code></pre>

<p>A sensible solution is to say ""we'll make the entire thing explicit"".</p>
"
"<p>I have the following code structure:</p>

<h3>myClass.h</h3>

<pre><code>class myClass
{
public:
    void DoSomething(void);
};
</code></pre>

<h3>myClass.cpp</h3>

<pre><code>#include myClass.h

static const unsigned length = 5;
static myArray&lt;float, length&gt; arrayX;

void myClass::DoSomething(void)
{
    // does something using length and array X
}
</code></pre>

<p>Now I want to convert the static variable defined at the file scope to be static members of the class. I do the following;</p>

<h3>myClass.h</h3>

<pre><code>class myClass
{
    static const unsigned length;
    static myArray&lt;float,length&gt; arrayX;

public:
    void DoSomething(void);
};
</code></pre>

<h3>myClass.cpp</h3>

<pre><code>#include myClass.h

const unsigned myClass::length = 5;
myArray&lt;float, length&gt; myClass::arrayX;

void myClass::DoSomething(void)
{
    // does something using length and array X
}
</code></pre>

<p>However, I get an error:</p>

<blockquote>
  <p>C2975: 'Length' : invalid template argument for 'myArray', expected compile-time constant expression myClass.h </p>
</blockquote>

<p>I do understand I get this error because length is not initialized in the header file yet.  How can I get around this?</p>
","87234","","<p>It needs to be a constant expression, so the best you can do is move <code>= 5</code> to the header.</p>
"
"<p>if I wanted to return ""this"" from a class member function as reference would this piece of code be correct ?</p>

<pre>
Record& operator=(const Record& that) {
    m_name = that.m_name;
    return *this;
}
</pre>

<p>Shouldn't i just use ""return this"" ?</p>

<p>Thanks for help :)</p>
","87234","","<p>Yup, that's correct.</p>

<p>Return <code>this</code> wouldn't work since <code>this</code> is a pointer. (The reason it's a pointer and not a reference is because references weren't introduced into the language until after classes.)</p>

<p>In this specific case, if you're just going to assign the members anyway you shouldn't write a copy assignment operator; the default will do the same. When you manage some resource (and invoke the <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29"" rel=""nofollow"">Rule of Three</a>), you'd want to use the <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29"" rel=""nofollow"">copy-and-swap idiom</a>.</p>
"
"<p>I have to use an external library, but am getting a ""multiple definition error"" from following template function and its explicit specialization, if it gets called with a std::string.</p>

<pre><code>template &lt;typename T&gt;
void foo(T&amp; value);

template &lt;&gt;
void foo(std::string&amp; value);
</code></pre>

<p>even if I change the 2nd function to</p>

<pre><code>void foo(std::string&amp; value);
</code></pre>

<p>the problem is the same.</p>

<p>According to [1] at least the version without a template (the ""plain old function"") should be prefered over the template version.</p>

<p>Does anybody have a clue, where the problem could be?</p>

<p>[1] <a href=""http://www.gotw.ca/publications/mill17.htm"" rel=""nofollow"">http://www.gotw.ca/publications/mill17.htm</a></p>
","87234","","<p>You're breaking the one-definition rule.</p>

<p>Unless a function is <code>inline</code>, it can only be defined once. If you mark the function as <code>inline</code>, so long as the definitions match they can be defined as often as desired. Template functions behave as if they were implicitly <code>inline</code>, so you don't get errors with templates.</p>

<p>However, an explicit specialization or non-template function is not implicitly <code>inline</code> and because you're including it in multiple translation units, you get multiple definitions; this breaks the rule. You should mark it as <code>inline</code>:</p>

<pre><code>template &lt;&gt;
inline void foo(std::string&amp; value);
</code></pre>

<p>(If you're getting this before link time, you need include guards.)</p>
"
"<p>I'm using an embedded compiler for the TI TMS320F28335, so I'm not sure if this is a general C++ problem (don't have a C++ compiler running on hand) or just my compiler. Putting the following code snippet in my code gives me a compile error: </p>

<pre><code>""build\main.cpp"", line 61: error #317: the object has cv-qualifiers that are not
compatible with the member function
        object type is: volatile Foo::Bar
</code></pre>

<p>The error goes away when I comment out the <code>initWontWork()</code> function below. What is the error telling me and how can I get around it without having to resort to using <code>static</code> functions that operate on a <code>volatile struct</code>?</p>

<pre><code>struct Foo
{
    struct Bar
    {
        int x;
        void reset() { x = 0; }
        static void doReset(volatile Bar&amp; bar) { bar.x = 0; } 
    } bar;
    volatile Bar&amp; getBar() { return bar; }
    //void initWontWork() { getBar().reset(); }
    void init() { Bar::doReset(getBar()); } 
} foo;
</code></pre>
","87234","","<p>In the same way you cannot do this:</p>

<pre><code>struct foo
{
    void bar();
};

const foo f;
f.bar(); // error, non-const function with const object
</code></pre>

<p>You cannot do this:</p>

<pre><code>struct baz
{
    void qax();
};

volatile baz g;
g.qax(); // error, non-volatile function with volatile object
</code></pre>

<p>You must cv-qualify the functions:</p>

<pre><code>struct foo
{
    void bar() const;
};

struct baz
{
    void qax() volatile;
};

const foo f;
f.bar(); // okay

volatile baz g;
g.qax(); // okay
</code></pre>

<p>So for you:</p>

<pre><code>void reset() volatile { x = 0; }
</code></pre>
"
"<p>i have a question about the function call in the following example:</p>

<pre><code>int main()
{
    int a, b;
    cin  &gt;&gt; a &gt;&gt; b &gt;&gt; endl;
    cout &lt;&lt; *f(a,b);
    return 0;
}
</code></pre>

<p>So is *f(a,b) a valid function call?</p>

<p>Edit:: sorry for the errors, i fixed them now i'm a little tired  </p>
","87234","","<p>Whatever <code>f</code> is, <code>*f(a, b)</code> attempts to apply the indirection operator to the result of <code>f(a, b)</code>.</p>

<p>If <code>f</code> is a function pointer and you're trying to call it, while you could do this:</p>

<pre><code>(*f)(a, b)
</code></pre>

<p>Just doing <code>f(a, b)</code> is simpler.</p>
"
"<p>How i return iterator form function :</p>

<p>i worte this :
.
..</p>

<pre><code>template&lt;class S,class T&gt; class Database {
public:
.
..
 map&lt;S,Node&lt;T&gt;*&gt; m_map::iterator Find (S keyToFind);
.
..
....


private:
.
..
 map&lt;S,Node&lt;T&gt;*&gt; m_map;
..
.
};

.
..
template&lt;class S,class T&gt;
map&lt;S,Node&lt;T&gt;*&gt; m_map::iterator Find (S keyToFind) {
 map&lt;S,Node&lt;T&gt;*&gt;::iterator itMap;
 itMap = m_map.find(KeyToUpDate);
 return itMap;
}
..
.
</code></pre>

<p>there are many error because this :
Error 1 error C2653: 'm_map' : is not a class or namespace name
Error 2 error C2146: syntax error : missing ';' before identifier 'Find'
Error 3 error C4430: missing type specifier - int assumed. Note: C++ does not support default-
Error 5 error C2653: 'm_map' : is not a class or namespace name
Error 7 error C2133: 'iterator' : unknown size
..
...</p>

<p>i don't understand what is the problem..</p>
","87234","","<p>Looks like you want:</p>

<pre><code>typename map&lt;S,Node&lt;T&gt;*&gt;::iterator
</code></pre>

<p>You should <em>really</em> use typedef's to clean this stuff up:</p>

<pre><code>template&lt;class S, class T&gt;
class Database
{
public:
    // I hope you have't put `using namespace std;` in a header...
    typedef std::map&lt;S, Node&lt;T&gt;*&gt; map_type;
    typedef typename map_type::iterator iterator;
    // etc...

    // use references to avoid copying
    iterator Find (const S&amp; keyToFind);
private:
    map_type m_map;
};
</code></pre>
"
"<p>I have observed that the general coding convention for a successful completion of a method intended functionality  is  0. (As in exit(0)).</p>

<p>This kind of confuses me because, if I have method in my if statement and method returns a 0, by the ""if condition"" is false and thereby urging me to think for a minute that the method had failed. Of course I do know I have to append with a ""!"" (As in if(!Method()) ), but isn't this convention kind of self contradicting itself ??</p>
","87234","","<p>You need to differentiate between an error code and an error flag. A code is a number representing any number of errors, while a flag is a boolean that indicates success.</p>

<p>When it comes to error codes, the idea is: There is only one way to succeed, but there are many ways to fail. Take 0 as a good single unique number, representing success, then you have every other number is a way of indicating failure. (It doesn't make sense any other way.)</p>

<p>When it comes to error flags, the idea is simple: True means it worked, false means it didn't. You can usually then get the error code by some other means, and act accordingly.</p>

<p>Some functions use error codes, some use error flags. There's nothing confusing or backwards about it, unless you're trying to treat everything as a flag. Not all return values are a flag, that's just something you'll have to get used to. </p>

<p>Keep in mind in C++ you generally handle errors with exceptions. Instead of looking up an error code, you just get the necessary information out of the caught exception. </p>
"
"<p>Hello I have a pump class that requires using a member variable that is a pointer to a wchar_t array containing the port address ie: ""com9"".</p>

<p>The problem is that when I initialise this variable in the constructor my compiler flags up a depreciated conversion warning.</p>

<pre><code>pump::pump(){
   this-&gt;portNumber = L""com9"";}
</code></pre>

<p>This works fine but the warning every time I compile is anoying and makes me feel like I'm doing something wrong.</p>

<p>I tried creating an array and then setting the member variable like this:</p>

<pre><code>pump::pump(){
   wchar_t port[] = L""com9"";
   this-&gt;portNumber = port;}
</code></pre>

<p>But for some reason this makes my portNumber point at 'F'.</p>

<p>Clearly another conceptual problem on my part.</p>

<p>Thanks for help with my noobish questions.</p>

<p>EDIT:</p>

<p>As request the definition of portNumber was:</p>

<pre><code>    class pump
{
private:
   wchar_t* portNumber;
}
</code></pre>

<p>Thanks to answers it has now been changed to:</p>

<pre><code>    class pump
{
private:
   const wchar_t* portNumber;
}
</code></pre>
","87234","","<p>If <code>portNumber</code> is a <code>wchar_t*</code>, it should be a <code>const wchar_t*</code>.</p>

<p>String literals are immutable, so the elements are <code>const</code>. There exists a deprecated conversion from string literal to non-const pointer, but that's dangerous. Make the change so you're keeping type safety and not using the unsafe conversion.</p>

<p>The second one fails because you point to the contents of a local variable. When the constructor finishes, the variable goes away and you're pointing at an invalid location. Using it results in undefined behavior.</p>

<p>Lastly, use an initialization list:</p>

<pre><code>pump::pump() :
portNumber(L""com9"")
{}
</code></pre>

<p>The initialization list is to initialize, the constructor is to finish construction. (Also, <code>this-&gt;</code> is ugly to almost all C++ people; it's not nice and redundant.)</p>
"
"<p>As far as i know, there're only 3 access-specifiers in C++: <strong>private</strong>, <strong>public</strong>, <strong>protected</strong></p>

<p>With these 3 access-specifiers, how can i make a method <strong>usable</strong> to the classes <strong>in the project</strong> but <strong>unusable</strong> to the ""foreigners"" ??(like <strong>internal</strong> and <strong>public</strong> in C#)</p>
","87234","","<p>You can use the <a href=""http://stackoverflow.com/questions/3324898/can-we-increase-the-re-usability-of-this-key-oriented-access-protection-pattern/3324984#3324984"">passkey friend idiom</a>.</p>

<p>This isn't a term you'll be able to search for, though. The idea isn't new, though not terribly common, and sort of arose on SO. The link above is my attempt at a generic solution (impossible to do cleanly in C++03, beautiful in C++0x).</p>

<p>I'm sure there are other ways to try to do it, but for some reason I have an attachment to the above...:)</p>

<hr>

<p>But otherwise, <a href=""http://stackoverflow.com/questions/3785558/c-access-specifiers-too-few/3785571#3785571"">no</a>. A far more common and simpler solution is to just throw your stuff in a <code>detail</code> namespace (common throughout <a href=""http://www.boost.org/"" rel=""nofollow"">Boost</a>, for example), and say ""don't go there"".</p>
"
"<p>I have a library which expects a array and fills it. I would like to use a std::vector instead of using an array. So instead of</p>

<pre><code>int array[256];
object-&gt;getArray(array);
</code></pre>

<p>I would like to do:</p>

<pre><code>std::vector&lt;int&gt; array;
object-&gt;getArray(array);
</code></pre>

<p>But I can't find a way to do it. Is there any chance to use std::vector for this?</p>

<p>Thanks for reading!</p>

<hr>

<p>EDIT:
I want to place an update to this problem:
I was playing around with C++11 and found a better approach. The new solution is to use the function std::vector.data() to get the pointer to the first element.
So we can do the following:</p>

<pre><code>std::vector&lt;int&gt; theVec;
object-&gt;getArray(theVec.data()); //theVec.data() will pass the pointer to the first element
</code></pre>

<p>If we want to use a vector with a fixed amount of elements we better use the new datatype std::array instead (btw, for this reason the variable name ""array"", which was used in the question above should not be used anymore!!).</p>

<pre><code>std::array&lt;int, 10&gt; arr; //an array of 10 integer elements
arr.assign(1); //set value '1' for every element
object-&gt;getArray(arr.data());
</code></pre>

<p>Both code variants will work properly in Visual C++ 2010. Remember: this is C++11 Code so you will need a compiler which supports the features!</p>

<p>The answer below is still valid if you do not use C++11!</p>
","87234","","<p>Yes:</p>

<pre><code>std::vector&lt;int&gt; array(256); // resize the buffer to 256 ints
object-&gt;getArray(&amp;array[0]); // pass address of that buffer
</code></pre>

<p>Elements in a <code>vector</code> are guaranteed to be contiguous, like an array.</p>
"
"<p>im trying to do something here but that error shows up i really have no idea how to get it done right i tried to put all the variables in the Figure.h as GLfloat instead of just float and the same error keeps appearing any idea?
here is my Figure.h</p>

<pre><code>Class Figure
{
    public:
        Figure(float x,float y,float z);
        void Parameters(float x,float y,float z);
        void Draw();
        float paramx(){
        return x1;
        }
        float paramy(){
        return y1;
        }
        float paramz(){
        return z1;
        }
    protected:
    private:
    float x1,y1,z1;
    list &lt;Figure&gt; m_vertices;
};
</code></pre>

<p>and here is my .cpp the one giving me all the trouble >.&lt;</p>

<pre><code>Figure::Figure(float x,float y,float z){
this-&gt;x1=x;
this-&gt;y1=y;
this-&gt;z1=z;
}
void Figure::Parameters(float x,float y,float z)
{
m_vertices.push_back(Figure(x, y, z));
}
void Figure::Draw()
{
    list&lt;Figure&gt;::iterator p = m_vertices.begin();
 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glLoadIdentity();
    gluLookAt(0.0,0.0,4.0,0.0,0.0,0.0,0.0,1.0,0.0);

    glBegin(GL_TRIANGLES);
    while(p != m_vertices.end()){
        glNormal3f(p-&gt;paramx,p-&gt;paramy,p-&gt;paramz);
        glVertex3f(p-&gt;paramx,p-&gt;paramy,p-&gt;paramz);
        p++;
    }
    glEnd();

}
</code></pre>

<p>Supposedly the problem is at glNormal3f and glVertex3f any help would be REALLY appreciated thank you very much</p>
","87234","","<p>You need to <em>call</em> the functions:</p>

<pre><code>    glNormal3f(p-&gt;paramx(), p-&gt;paramy(), p-&gt;paramz());
    glVertex3f(p-&gt;paramx(), p-&gt;paramy(), p-&gt;paramz());
</code></pre>
"
"<p>I heard the temporary objects can only be assigned to constant references.</p>

<p>But this code gives error</p>

<pre><code>#include &lt;iostream.h&gt;    
template&lt;class t&gt;
t const&amp; check(){
  return t(); //return a temporary object
}    
int main(int argc, char** argv){

const int &amp;resCheck = check&lt;int&gt;(); /* fine */
typedef int&amp; ref;
const ref error = check&lt;int&gt;(); / *error */
return 0;
}
</code></pre>

<p>The error that is get is <code>invalid initialization of reference of type 'int&amp;' from expression of type 'const int'</code></p>
","87234","","<p>This:</p>

<pre><code>typedef int&amp; ref;
const ref error;
</code></pre>

<p>Doesn't do what you think it does. Consider instead:</p>

<pre><code>typedef int* pointer;
typedef const pointer const_pointer;
</code></pre>

<p>The type of <code>const_pointer</code> is <code>int* const</code>, <strong>not</strong> <code>const int *</code>. That is, when you say <code>const T</code> you're saying ""make a type where T is immutable""; so in the previous example, the pointer (not the pointee) is made immutable.</p>

<p>References cannot be made <code>const</code> or <code>volatile</code>. This:</p>

<pre><code>int&amp; const x;
</code></pre>

<p>is meaningless, so adding cv-qualifiers to references has no effect.</p>

<p>Therefore, <code>error</code> has the type <code>int&amp;</code>. You cannot assign a <code>const int&amp;</code> to it.</p>

<hr>

<p>There are other problems in your code. For example, this is certainly wrong:</p>

<pre><code>template&lt;class t&gt;
t const&amp; check()
{
    return t(); //return a temporary object
}
</code></pre>

<p>What you're doing here is returning a reference to a temporary object <em>which ends its lifetime when the function returns</em>. That is, you get undefined behavior if you use it because there is no object at the referand. This is no better than:</p>

<pre><code>template&lt;class t&gt;
t const&amp; check()
{
    T x = T();
    return x; // return a local...bang you're dead
}    
</code></pre>

<p>A better test would be:</p>

<pre><code>template&lt;class T&gt;
T check()
{
    return T();
}
</code></pre>

<p>The return value of the function is a temporary, so you can still test that you can indeed bind temporaries to constant references.</p>
"
"<p>When working with Project Euler problems I often need large (> 10**7) bit array's.</p>

<p>My normal approach is one of:</p>

<pre><code>bool* sieve = new bool[N];

bool sieve[N];
</code></pre>

<p>When N = 1,000,000 my program uses 1 MegaByte (8 * 1,000,000 bits).</p>

<p>Is there a more efficient way to use store bit arrays than bool in c++?</p>
","87234","","<p>For better or for worse, <code>std::vector&lt;bool&gt;</code> will use bits instead of bool's, to save space. So just use <code>std::vector</code> like you should have been in the first place.</p>

<p><em>If <code>N</code> is a constant</em>, you can use <code>std::bitset</code>.</p>
"
"<p>I have 2 classes in 2 different files:</p>

<p>RegMatrix.h: </p>

<pre><code>#ifndef _RM_H
#define _RM_H
#include ""SparseMatrix.h""
...
class RegMatrix{
    ...
    RegMatrix(const SparseMatrix &amp;s){...}   //ctor
    ...
};
#endif
</code></pre>

<p>SparseMatrix.h: </p>

<pre><code>#ifndef _SM_H
#define _SM_H
#include ""RegMatrix.h""
...
class SparseMatrix{
    ...
    SparseMatrix(const RegMatrix &amp;r){...}   //ctor
    ...
};
#endif
</code></pre>

<p>On the constructor lines I get the errors:</p>

<p>error C4430: missing type specifier - int assumed.</p>

<p>error C2143: syntax error : missing ',' before '&amp;'</p>

<p>But when i add the classes declarations </p>

<pre><code>class SparseMatrix;
</code></pre>

<p>in the RegMatrix.h file and</p>

<pre><code>class RegMatrix;
</code></pre>

<p>in the SparseMatrix.h file it works fine.
My question is why is it needed if i have the includes?
10x.</p>
","87234","","<p>If you include <code>RegMatrix.h</code> first, it will include <code>SparseMatrix.h</code>. Then that will go back to including <code>RegMatrix.h</code>, and skip because the header guard is defined. Then <code>SparseMatrix</code> continues to be defined, except <code>RegMatrix</code> was never even declared. Then you get an error.</p>

<p>You cannot have circular includes. You must forward declare one or both of them, like you did.</p>
"
"<p>If you have to pass objects across threads which smart pointer type is best to use?</p>

<p>Assuming the object being passed is thread safe.</p>
","87234","","<p>A <code>shared_ptr</code> would work for sharing data. Its counter is atomic, so you won't run into problems there, and when the last thread is done it goes away.</p>
"
"<p>In a recent code review, a contributor is trying to enforce that all <code>NULL</code> checks on pointers be performed in the following manner:</p>

<pre><code>int * some_ptr;
// ...
if( some_ptr == NULL )
{
  // handle null-pointer error
}
else
{
  // proceed
}
</code></pre>

<p>instead of </p>

<pre><code>int * some_ptr;
// ...
if( some_ptr )
{
  // proceed
}
else
{
  //handle null-pointer error
}
</code></pre>

<p>I agree that his way is a little more clear in the sense that it's explicitly saying ""Make sure this pointer is not NULL"" but I would counter that by saying that anyone who's working on this code would understand that using a pointer variable in an <code>if</code> statement is implicitly checking for <code>NULL</code>.  Also I feel the second method has a smaller chance of introducing a bug of the ilk:</p>

<pre><code>if( some_ptr = NULL )
</code></pre>

<p>which is just an absolute pain to find and debug.</p>

<p>Can anyone weigh in on which way you prefer and why?</p>
","87234","","<p>I use <code>if (ptr)</code>, but this is completely not worth arguing about.</p>

<p>I like my way because it's concise, though others say <code>== NULL</code> makes it easier to read and more explicit. I see where they're coming from, I just disagree the extra stuff makes it any easier. (I hate the macro, so I'm biased.) Up to you.</p>

<p>I disagree with your argument. If you're not getting warnings for assignments in a conditional, you need to turn your warning levels up. Simple as that. (And for the love of all that is good, don't switch them around.)</p>

<p>Note in C++0x, we can do <code>if (ptr == nullptr)</code>, which to me <em>does</em> read nicer. (Again, I hate the macro. But <code>nullptr</code> is nice.) I still do <code>if (ptr)</code>, though, just because it's what I'm used to.</p>
"
"<pre><code>// sizeofarray.cpp
#include &lt;iostream&gt;
template &lt;typename T,int N&gt;
int size(T (&amp;Array)[N])
{
  return N;
}

int main()
{
   char p[]=""Je suis trop bon, et vous?"";
   char q[size(p)]; // (A)
   return 0;
}
</code></pre>

<p>I heard that an array size in C++ must be a constant expression. So <code>char q[size(p)]</code> is invalid, am I right? But I got no errors when I tried</p>

<pre><code> g++ -Wall sizeofarray.cpp
</code></pre>

<p>Why?</p>
","87234","","<p>Like <a href=""http://stackoverflow.com/questions/3831158/using-size-of-one-array-in-another-array/3831176#3831176"">Prasoon says</a>, it's not a constant expression. For now, you can get a constant-expression value of the size of an array like this:</p>

<pre><code>template &lt;std::size_t N&gt;
struct type_of_size
{
    typedef char type[N];
};

template &lt;typename T, std::size_t Size&gt;
typename type_of_size&lt;Size&gt;::type&amp; sizeof_array_helper(T(&amp;)[Size]);

#define sizeof_array(pArray) sizeof(sizeof_array_helper(pArray))
</code></pre>

<p>Explanation <a href=""http://stackoverflow.com/questions/3368883/how-does-this-size-of-array-template-function-work-closed"">here</a>. You basically encode the size of the array into the size of a type, then get the <code>sizeof</code> of that type, giving you:</p>

<pre><code>char q[sizeof_array(p)];
</code></pre>
"
"<p>I have an unmanaged C++ application (unmanaged meaning: not using anything of the the fancy .Net stuff).  I want to extend it with some meta information, and it looks like I could use the concept of attributes.</p>

<p>What I actually try to achieve is the following.
Starting from something a simple class like this:</p>

<pre><code>class Book
   {
   public:
      ...
   private:
      string m_name;
      string m_author;
      int    m_year;
   };
</code></pre>

<p>I want to build functionality that can access the 'meta information' of the class and use it to dynamically build logic on it, e.g.</p>

<ul>
<li>a dialog containing 3 edit fields (name, author, year)</li>
<li>a data grid with 3 columns</li>
<li>serialization logic</li>
<li>logic that maps this class to a database table with 3 columns</li>
<li>...</li>
</ul>

<p>I my wildest dreams I imagine modifying this class like this:</p>

<pre><code>[id=""Book""]
class Book
   {
   public:
      ...
   private:
      [id=""Name"", defaultValue="""", maximumLength=100]
      string m_name;

      [id=""Author"", defaultValue="""", maximumLength=100]
      string m_author;

      [id=""Year"", defaultValue=2000, minimum=1900]
      int    m_year;
   };
</code></pre>

<p>And then being able to get this 'meta' information to build up dialogs, filling data grids, serializing and deserializing instances, ...</p>

<p>But, is the concept of attributes limited to .Net/managed code?</p>

<p>And if I could use attributes in unmanaged code, would it be possible to do something like this?  And what is a good place to start? (examples, ...)</p>

<p>Also, can the same (or similar) concepts be found in other compilers, on other platforms?</p>

<p>I am using Visual Studio 2010 and, as said before, unmanaged/native C++.</p>
","87234","","<p>No. C++ does not have introspection or attributes.</p>

<p>Look into <a href=""http://www.boost.org/doc/libs/1_44_0/libs/serialization/doc/index.html"" rel=""nofollow"">Boost Serialization</a> for the serialization stuff, for the others you need to implement it manually, as far as I know.</p>
"
"<p>Recently i saw this piece of code. Shouldnt this line be a compile error?<code>char arr[4]=""Abc"";</code></p>

<p>What happens here? Is arr a pointer? is the char* copied into an array on stack? is this legal in all version of C++ (and what about C?). I tested and seen this works in VS and code pad which i believe uses gcc</p>

<p>-edit- Just for fun I tried replacing ""Abc"" with a static const char *. It gave me an invalid initializer error.</p>

<pre><code>int main()
{
    int j=97;
    char arr[4]=""Abc"";
    printf(arr,j);
    getch();
    return 0;
}
</code></pre>
","87234","","<p>Character arrays can be initialized with string literals, it just assigns each element character by character. It's just a language feature.</p>

<hr>

<p>And no, <code>arr</code> is not a pointer. It's an array. <code>""Abc""</code> is a string literal, which is also a character array.</p>
"
"<p>I have this code that tries to protect the user from array boundary errors.</p>

<p>I don't get why this will compile, tho i've declared the array to be const, therefore, i'm suppose to get a compilation error!</p>

<p>thanks a lot.</p>

<pre><code>/************ file: SafeAccessArray.h ********************/
template&lt;typename T&gt;
class SafeAccessArray
{
private:
int _len;
T * _arr;
public:
SafeAccessArray (int len=2) : _len (len), _arr (new T [len]) {}
~SafeAccessArray () { delete _arr; }
T&amp; operator [](int i) const
{if (i &lt; 0 || i &gt;= _len) throw (-1);
else return _arr[i]; }
};
/************ end of file: SafeAccessArray.h *************/

/************ file: SafeAccessArray1.cpp *************/
#include ""SafeAccessArray.h""
int main()`enter code here`
{
SafeAccessArray&lt;int&gt; intArr (2);
intArr[0] = 0;
intArr[1] = 1;
const SafeAccessArray&lt;int&gt; intArrConst (2); // THIS IS THE ""PROBLEMATIC"" LINE
intArrConst [0] = 0;
intArrConst [1] = 1;
return 0;
}
/************ end of file: SafeAccessArray1.cpp ******/
</code></pre>
","87234","","<p>Yea it's <code>const</code>, but you did <code>T&amp; operator [](int i) const</code> anyway. You're returning a reference, and this function can be called on a const object.</p>

<p>Make it return <code>const T&amp;</code>. Better yet, stop. Just use <code>std::vector</code> and the <code>at()</code> function.</p>
"
"<p>Does a pure-virtual object have a pointer to the vtbl?
(that probably points to NULL?)</p>

<p>thanks, i'm a little bit confused with all the virtual mechanism.</p>
","87234","","<p>Don't worry about it. Virtual tables are an implementation detail, and aren't even guaranteed to exist. The more you worry about how it might be done, the less you learn about the actual language.</p>

<hr>

<p>That said, yes. A concrete class will then set that pointer to point to the correct virtual table.</p>
"
"<p>Is there any downside to using</p>

<pre><code>typedef char bool;
enum boolean { false, true };
</code></pre>

<p>in C to provide a semantic boolean type?</p>
","87234","","<p>In C99, you should be using <code>stdbool.h</code>, which defines <code>bool</code>, <code>true</code>, and <code>false</code>.</p>

<p>Otherwise what you have is fine. Using just the enum may be a bit simpler, but if you really want to save space what you have works.</p>
"
"<p>My knowledge of C++ is small as I have only taken a couple classes.  I undersand the basic case of using a friend function to overload the input, output stream operator for the ""simple book example"" of a Point object that has x, y instance variables.  I am looking at a real project now, trying to understand what someone wrote and am getting the error:</p>

<pre><code>error C2679: binary '&gt;&gt;' : no operator found which takes a right-hand operand of type 'const char [2]' (or there is no acceptable conversion)
1&gt;        c:\program files\microsoft visual studio 9.0\vc\include\istream(1000): could be 'std::basic_istream&lt;_Elem,_Traits&gt; &amp;std::operator &gt;&gt;&lt;std::char_traits&lt;char&gt;&gt;(std::basic_istream&lt;_Elem,_Traits&gt; &amp;,signed char *)' [found using argument-dependent lookup]
1&gt;        with
1&gt;        [
1&gt;            _Elem=char,
1&gt;            _Traits=std::char_traits&lt;char&gt;
1&gt;        ]
</code></pre>

<p>Noob question (1), can someone explain what basic_istream is?  The error points to:</p>

<pre><code>template&lt;class _Traits&gt; inline
    basic_istream&lt;char, _Traits&gt;&amp; __CLRCALL_OR_CDECL  operator&gt;&gt;(
        basic_istream&lt;char, _Traits&gt;&amp; _Istr, signed char *_Str)
    {   // extract a signed char NTBS
    return (_Istr &gt;&gt; (char *)_Str);
    }
</code></pre>

<p>The other part the error points to is:</p>

<pre><code>void input(std::istream &amp;in = std::cin)
    {in &gt;&gt; ""("" &gt;&gt; X &gt;&gt; "","" &gt;&gt; Y &gt;&gt; "","" &gt;&gt; Z &gt;&gt; "")"" ; }

inline friend std::istream&amp; operator &gt;&gt; (std::istream&amp; in, Coord &amp;val)
    {val.input(in); return in; };
</code></pre>

<p>Not sure what the error is looking at with my limited knowledge.  It seems to be complaining about not the right type in the inline friend std::istream&amp; operator>> function because of something wrong in the basic_istream template (which I'm not sure what is happening there).  Any advice would be greatly appreciated.  Thanks!</p>
","87234","","<p>The problem is this:</p>

<pre><code>in &gt;&gt; ""(""
</code></pre>

<p>Conceptually, this makes no sense. You're trying to read input into a string literal. (That's like trying to read input into the constant <code>5</code>.) The error is because a string literal is a const array of characters (hence the <code>const char[2]</code> type) and so cannot be read into.</p>

<p>You might want this:</p>

<pre><code>void input(std::istream &amp;in = std::cin)
{
    char dummy = 0;
    in &gt;&gt; dummy &gt;&gt; X &gt;&gt; dummy &gt;&gt; Y &gt;&gt; dummy &gt;&gt; Z &gt;&gt; dummy;
}
</code></pre>

<p>All this does is read those characters into a dummy variable. It works, but those characters could be anything.</p>

<p>Rather, you should probably do the following:</p>

<pre><code>// if you do it more than once, make it a function
bool expect_char(std::istream&amp; in, char expected)
{
    char check = 0;
    in &gt;&gt; check;

    if (check != expected)
    {
        in.putback(); // replace it
        in.clear(std::ios::failbit); // set fail bit

        return false;
    }
    else
    {
        return true;
    }
}

void input(std::istream &amp;in = std::cin)
{
    if (!in) // if stream is bad, just return
        return; 

    if (!expect_char(in, '('))
        return;

    in &gt;&gt; X;

    if (!expect_char(in, ','))
        return;

    in &gt;&gt; Y;

    if (!expect_char(in, ','))
        return;

    in &gt;&gt; Z;

    if (!expect_char(in, ')'))
        return;
}
</code></pre>

<p>Now the only problem is that if extraction fails half-way, we have modified the point object. Ideally, it would be all or nothing. We store intermediate values, then copy them when it all works:</p>

<pre><code>void input(std::istream &amp;in = std::cin)
{
    if (!in)
        return; 

    if (!expect_char(in, '('))
        return;

    int newX; // or whatever type it is
    in &gt;&gt; newX;

    if (!expect_char(in, ','))
        return;

    int newY;
    in &gt;&gt; newY;

    if (!expect_char(in, ','))
        return;

    int newZ;
    in &gt;&gt; newZ;

    if (!expect_char(in, ')'))
        return;

    X = newX;
    Y = newY;
    Z = newZ;
}
</code></pre>

<p>And we get what we were after.</p>
"
"<p>For testing reasons I would like to cause a division by zero in my C++ code. I wrote this code:</p>

<pre><code>int x = 9;
cout &lt;&lt; ""int x="" &lt;&lt; x;
int y = 10/(x-9);
y += 10;
</code></pre>

<p>I see ""int =9"" printed on the screen, but the application doesn't crash. Is it because of some compiler optimizations (I compile with gcc)? What could be the reason?</p>
","87234","","<p>Make the variables <code>volatile</code>. Reads and writes to volatile variables are considered observable:</p>

<pre><code>volatile x = 1;
volatile y = 0;
volatile z = x / y;
</code></pre>
"
"<p>When I opened a VC6 project in VS2008 and tried building it , initially I got the error:</p>

<blockquote>
  <p>fatal error C1083: Cannot open include file: 'iostream.h': No such file or directory   </p>
  
  <p>error C2259: 'CException' : cannot instantiate abstract class  </p>
  
  <p>error BK1506 : cannot open file '.\Debug\SClientDlg.sbr': No such file or directory    BSCMAKE SClient</p>
</blockquote>

<p>Now I have changed <code>#include""iostream.h""</code> to <code>#include""iostream""</code>  and now getting 7errors ( as I have used  try and catch 7 places) saying:</p>

<blockquote>
  <p>error C2259: 'CException' : cannot instantiate abstract class  </p>
</blockquote>

<p>Below is the snippet from that code:</p>

<pre><code>void SClientDlg::ProcessDomainName(int *m_pDlg,char* strDomainName,int iLen)
{
    try
    {
    //Do Something

    }
    catch(CException ex)
    {
        printf(""Exception: %d"",GetLastError()); 
    }


}
</code></pre>
","87234","","<p>You likely need to do this:</p>

<pre><code>catch(CException&amp; ex) // const&amp; might be better
</code></pre>

<p>Since <code>CException</code> is abstract, you cannot instantiate it, but you can reference a non-abstract object that derives from it.</p>
"
"<p>Say I have a class named <code>Base</code> and a class that derives from it called <code>SuperBase</code>. Given that <code>add</code> takes in a <code>Base*</code>, would either of these be valid:</p>

<pre><code>SuperBase *super = new SuperBase;
bases.add(super);
</code></pre>

<p>Or    </p>

<pre><code>SuperBase *super = new SuperBase;
bases.add((Base*)super);
</code></pre>
","87234","","<p>The first works as long as <code>SuperBase</code> publicly derives from <code>Base</code>, via an implicit conversion from derived-to-base:</p>

<pre><code>struct base { virtual ~base() {} };
struct derived : base {};

base* b = new derived; // okay
</code></pre>

<p>The second works as well, but ignores the protection of <code>Base</code>:</p>

<pre><code>struct derived : private base {}; // private base

base* b = new derived; // not okay, base is private
base* b = (base*)(new derived); // okay, but gross
</code></pre>

<p>If it's <code>private</code>, you probably shouldn't cast to it.</p>
"
"<p>I was wondering if there is a way to declare an object in c++ to prevent it from being subclassed. Is there an equivalent to declaring a final object in Java?</p>
","87234","","<p>No, there isn't really a need to. If your class doesn't have a virtual destructor it isn't safe to derive from it anyway. So don't give it one.</p>

<p>You can use this trick, copied from <a href=""http://www2.research.att.com/~bs/bs_faq2.html#no-derivation"" rel=""nofollow"">Stroustrup's FAQ</a>:</p>

<pre><code>class Usable;

class Usable_lock {
    friend class Usable;
private:
    Usable_lock() {}
    Usable_lock(const Usable_lock&amp;) {}
};

class Usable : public virtual Usable_lock {
    // ...
public:
    Usable();
    Usable(char*);
    // ...
};

Usable a;

class DD : public Usable { };

DD dd;  // error: DD::DD() cannot access
        // Usable_lock::Usable_lock(): private  member
</code></pre>

<p>In C++0x (and as an extension, in MSVC) you can actually make it pretty clean:</p>

<pre><code>template &lt;typename T&gt;
class final
{
private:
    friend T; // C++0x, MSVC extension

    final() {}
    final(const final&amp;) {}
};

class no_derived :
    public virtual final&lt;no_derived&gt; // ah, reusable
{};
</code></pre>
"
"<p>To my understanding the representation of size_t and wchar_t are completely platform/compiler specific. For instance I have read that wchar_t on Linux is now usually 32bit, but on Windows it is 16bit. Is there any way that I can standardize these to a set size (int, long, etc.) in my own code, while still maintaining backwards comparability with the existing standard C libraries and functions on both platforms?</p>

<p>My goal is essentially to do something like typedef them so they are a set size. Is this possible without breaking something? Should I do this? Is there a better way?</p>

<p><strong>UPDATE:</strong> The reason I'd like to do this is so that my string encoding is consistent across both Windows and Linux</p>

<p>Thanks!</p>
","87234","","<p>Sounds like you're looking for C99's &amp; C++0x's <code>&lt;stdint.h&gt;</code>/<code>&lt;cstdint&gt;</code> headers. This defines types like <code>uint8_t</code>, and <code>int64_t</code>.</p>

<p>You can use Boost's <code>cstdint.hpp</code> in the case you don't have those headers.</p>
"
"<p>In the class below, would this mean that onPaintCallback is NULL, or must I make it NULL in the class constructor? I want to start checking for NULL before it is given a valid pointer.</p>

<pre><code>class AguiWidgetBase
{
    virtual void onPaint();
    void (*onPaintCallback)(AguiRectangle clientRect) = 0;
public:
    AguiWidgetBase(void);
    ~AguiWidgetBase(void);
};
</code></pre>
","87234","","<p>What you have isn't legal. You have to initialize it in the constructor:</p>

<pre><code>AguiWidgetBase::AguiWidgetBase() :
onPaintCallback(0)
{}
</code></pre>

<p>You could use <code>boost::function&lt;void(AguiRectangle)&gt;</code>, which aside from being more flexible, initializes itself correctly to null. You can check it like:</p>

<pre><code>if (f)
    // ...
</code></pre>
"
"<p>This is a little subjective I think; I'm not sure if the opinion will be unanimous (I've seen a lot of code snippets where references are returned).</p>

<p>According to a comment toward <a href=""http://stackoverflow.com/questions/752479/am-i-initializing-my-c-reference-variables-correctly"">this question I just asked, regarding initializing references</a>, returning a reference can be evil because, [as I understand] it makes it easier to miss deleting it, which can lead to memory leaks.</p>

<p>This worries me, as I have followed examples (unless I'm imagining things) and done this in a fair few places... Have I misunderstood? Is it evil? If so, just how evil?</p>

<p>I feel that because of my mixed bag of pointers and references, combined with the fact that I'm new to C++, and total confusion over what to use when, my applications must be memory leak hell...</p>

<p>Also, I understand that using smart/shared pointers is generally accepted as the best way to avoid memory leaks, so thanks in advance for your tips ;)</p>
","87234","","<p>Do you mean:</p>

<pre><code>int&amp; getInt(void)
{
    int i;
    return i;
}
</code></pre>

<p>That is all sorts of evil. The stack-allocated <strong>i</strong> will go away and you are referring to nothing. This is semi-evil:</p>

<pre><code>int&amp; getInt(void)
{
    int *i = new int;
    return *i;
}
</code></pre>

<p>Because now the client has to eventually do the strange:</p>

<pre><code>int&amp; myInt = getInt(); // note the &amp;.
int badInt = getInt(); // the &amp; will be easy to miss (source of problems).
delete &amp;myInt; // must delete.
delete &amp;badInt; // won't work. badInt was a copy of the allocated int, which
                // is now lost forever
</code></pre>

<p>I think the best way to do something like that is just:</p>

<pre><code>int *getInt(void)
{
    return new int;
}
</code></pre>

<p>And now the client stores a pointer:</p>

<pre><code>int *myInt = getInt(); // has to be a pointer
int&amp; weirdInt = *getInt(); // but this works too if you really want.
delete myInt; // being a pointer, this is easy to do.
delete &amp;weirdInt; // works.
</code></pre>

<p>Now for members of classes, &amp; is powerful, such as operator chaining (cout's &lt;&lt;), or operator[].</p>
"
"<p>This code illustrates something that I think should be treated as bad practice, and elicit warnings from a compiler about redefining or masking a variable:</p>

<pre><code>#include &lt;iostream&gt;

int *a;

int* f()
{
  int *a = new int;
  return a;
}

int main()
{
  std::cout &lt;&lt; a &lt;&lt; std::endl &lt;&lt; f() &lt;&lt; std::endl;
  return 0;
}
</code></pre>

<p>Its output (compiled with g++):</p>

<pre><code>0
0x602010
</code></pre>

<p>I've looked at a couple references (Stroustrup and The Complete C++ Reference) and can't find anything about when and why this is allowed. I know that it's not within a single local scope, though.</p>

<p>When and why is this allowed? Is there a good use for this construct? How can I get g++ to warn me about it? Do other compilers squawk about it?</p>
","87234","","<p>It's called shadowing, and you can specify -Wshadow to make GCC emit warnings about it:</p>

<blockquote>
  <p>g++ main.cpp -Wshadow</p>
</blockquote>

<p>-Wall will not enable this warning.</p>

<p>With Microsoft's compiler, I could not get a warning, even on Level 4.</p>

<p>This is allowed because there is no ambiguity. Obviously two int's named 'a' in the same scope create an ambiguity (a = 10, which a?)</p>

<p>That said, I think using global variables (which is what's giving you the opportunity to shadow) is worse.</p>

<p>The only ""legit"" time <a href=""http://stackoverflow.com/questions/911740/warning-about-hiding-member-variables"">I have seen this be a problem</a> is when a class has private variable (like std::string name) and in a function somewhere that also uses a variable called ""name"". Now using name will use the local scope ""name"" as opposed to the probably intended private ""name"".</p>

<p>This is of course fixed by having a convention, such as either starting or ending private variable names with an underscore (""<code>_name</code>"", ""<code>name_</code>""), or some other convention. (""<code>m_name</code>"").</p>
"
"<p>I'm putting together a presentation to show some of the productivity gains that I think C# may offer over C++.  I've written some code in C# which I'd like to convert to C++.  I don't have the time or up to date C++ to do the conversion justice, hence posting here.</p>

<p>Code to convert:</p>

<pre><code>using System.Collections.Generic;
using System.Drawing;
using System.Linq;

namespace LinqTest
{
    public class Vehicle
    {
        public int Id { get; set; }
        public Color Colour { get; set; }
    }

    public class Tyre
    {
        public int Id { get; set; }
        public int BikeId { get; set; }
        public int Size { get; set; }
        public string Brand { get; set; }
    }

    public class Car : Vehicle {}

    public class Bike : Vehicle {}

    public class Example
    {
        private readonly IList&lt;Car&gt; cars;
        private readonly IList&lt;Tyre&gt; bikeTyres;
        private readonly IList&lt;Bike&gt; bikes;

        public Example()
        {
            cars = new List&lt;Car&gt;
                       {
                           new Car {Id = 0, Colour = Color.Red},
                           new Car {Id = 1, Colour = Color.Blue},
                           new Car {Id = 2, Colour = Color.Green},
                           new Car {Id = 3, Colour = Color.Green}
                       };

            bikeTyres = new List&lt;Tyre&gt;
                            {
                                new Tyre {Id = 0, BikeId = 0, Brand = ""TyreCo1"", Size = 23},
                                new Tyre {Id = 1, BikeId = 0, Brand = ""TyreCo1"", Size = 23},
                                new Tyre {Id = 2, BikeId = 1, Brand = ""TyreCo2"", Size = 30},
                                new Tyre {Id = 3, BikeId = 1, Brand = ""TyreCo2"", Size = 30},
                                new Tyre {Id = 4, BikeId = 2, Brand = ""TyreCo3"", Size = 23},
                                new Tyre {Id = 5, BikeId = 2, Brand = ""TyreCo3"", Size = 23}
                            };

            bikes = new List&lt;Bike&gt;
                        {
                            new Bike {Id = 0, Colour = Color.Red},
                            new Bike {Id = 1, Colour = Color.Blue},
                            new Bike {Id = 2, Colour = Color.Green}
                        };
        }

        public IEnumerable&lt;Vehicle&gt; FindVehiclesByColour(Color colour)
        {
            var carVehicles = from car in cars
                           where car.Colour == colour
                           select car as Vehicle;

            var bikeVehicles = from bike in bikes
                               where bike.Colour == colour
                               select bike as Vehicle;

            return carVehicles.Union(bikeVehicles);
        }


        public IEnumerable&lt;Bike&gt; FindBikesByTyreSize(int size)
        {
            return (from bike in bikes
                    join tyre in bikeTyres on bike.Id equals tyre.BikeId
                    where tyre.Size == size
                    select bike).Distinct();
        }
    }
}
</code></pre>

<p>Thanks in advance.</p>
","87234","","<p>I'll do this for you, but for the record this is definitely a bad 'question'. This is more of a work request, which is why my answer is community wiki. There are no questions being answered here.</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;string&gt;

namespace LinqTest
{
    // C++ does not specificy a standard GUI library.
    // This is a small hack to make the code work below.
    // In a real solution, one would probably have a real
    // Color class that stores the red, green, and blue
    // components of the colors and provides operations
    // to act upon colors.
    struct Color
    {
    	static const int Red = 0;
    	static const int Green = 1;
    	static const int Blue = 2;

    	Color(void) :
    	value(0)
    	{
    	}

    	Color(int color) :
    	value(color)
    	{
    	}

    	bool operator==(const Color&amp; rhs) const
    	{
    		return value == rhs.value;
    	}

    	int value;
    };

    struct Vehicle
    {
    	Vehicle(void) :
    	Id(0)
    	{
    	}

    	Vehicle(int id, Color colour) :
    	Id(id),
    	Colour(colour)
    	{
    	}

    	bool operator==(const Vehicle&amp; rhs) const
    	{
    		return Id == rhs.Id;
    	}

    	int Id;
    	Color Colour;
    };

    struct Tyre
    {
    	Tyre(void) :
    	Id(0),
    	BikeId(0),
    	Size(0)
    	{
    	}

    	Tyre(int id, int bikeId, int size, std::string brand) :
    	Id(id),
    	BikeId(bikeId),
    	Size(size),
    	Brand(brand)
    	{
    	}

    	int Id;
    	int BikeId;
    	int Size;
    	std::string Brand;
    };

    struct Car :
    	public Vehicle
    {
    	Car(void)
    	{
    	}

    	Car(int id, Color colour) :
    	Vehicle(id, colour)
    	{
    	}
    };

    struct Bike :
    	public Vehicle
    {
    	Bike(int id, Color colour) :
    	Vehicle(id, colour)
    	{
    	}
    };

    class Example
    {
    // I put private up top to match yours, but most C++
    // programmers would prefer it on the bottom, justified
    // by the fact users of the class don't care or want
    // to see how the class works, they want to see how to
    // use it.
    private:
    	std::list&lt;Car&gt; cars;
    	std::list&lt;Tyre&gt; bikeTyres;
    	std::list&lt;Bike&gt; bikes;

    public:
    	Example(void)
    	{
    		cars.push_back(Car(0, Color::Red));
    		cars.push_back(Car(1, Color::Blue));
    		cars.push_back(Car(2, Color::Green));
    		cars.push_back(Car(3, Color::Green));

    		bikeTyres.push_back(Tyre(0, 0, 23, ""TyreCo1""));
    		bikeTyres.push_back(Tyre(1, 0, 23, ""TyreCo1""));
    		bikeTyres.push_back(Tyre(2, 1, 30, ""TyreCo2""));
    		bikeTyres.push_back(Tyre(3, 1, 30, ""TyreCo2""));
    		bikeTyres.push_back(Tyre(4, 2, 23, ""TyreCo3""));
    		bikeTyres.push_back(Tyre(5, 2, 23, ""TyreCo3""));

    		bikes.push_back(Bike(0, Color::Red));
    		bikes.push_back(Bike(1, Color::Blue));
    		bikes.push_back(Bike(2, Color::Green));
    	}

    	// I chose to return pointers to Vehicles to maintain any
    	// polymorphic behavior, since from what I understand C#
    	// would be returning references here.
    	std::list&lt;Vehicle*&gt; FindVehiclesByColour(Color colour)
    	{
    		typedef std::list&lt;Car&gt;::iterator car_iterator;
    		typedef std::list&lt;Bike&gt;::iterator bike_iterator;

    		std::list&lt;Vehicle*&gt; result;

    		for (car_iterator iter = cars.begin(); iter != cars.end(); ++iter)
    		{
    			if (iter-&gt;Colour == colour)
    			{
    				result.push_back(&amp;(*iter));
    			}
    		}

    		for (bike_iterator iter = bikes.begin(); iter != bikes.end(); ++iter)
    		{
    			if (iter-&gt;Colour == colour)
    			{
    				result.push_back(&amp;(*iter));
    			}
    		}

    		return result;
    	}

    	std::list&lt;Bike*&gt; FindBikesByTyreSize(int size)
    	{
    		typedef std::list&lt;Tyre&gt;::const_iterator tyre_iterator;
    		typedef std::list&lt;Bike&gt;::iterator bike_iterator;

    		std::list&lt;Bike*&gt; result;

    		for (tyre_iterator tyreIter = bikeTyres.begin(); tyreIter != bikeTyres.end(); ++tyreIter)
    		{
    			if (tyreIter-&gt;Size == size)
    			{
    				for (bike_iterator bikeIter = bikes.begin(); bikeIter != bikes.end(); ++bikeIter)
    				{
    					if (tyreIter-&gt;BikeId == bikeIter-&gt;Id)
    					{
    						result.push_back(&amp;(*bikeIter));
    					}
    				}
    			}
    		}

    		result.sort();
    		result.unique();
    		return result;
    	}
    };
}
</code></pre>

<p>Note there are a few stylistic things in there, such as <code>Example(void)</code> versus <code>Example()</code> that are my own and don't necessarily represent the style of other C++ programmers. Related, there are other ways of doing this and my way might not even be the best.</p>

<p>There are a lack of comments, I would add them but I think they'd only get in the way, the code is simple enough to understand.</p>

<p>This all said, you obviously don't know much about C++ so stating C# is more productive, while it might even be true, is hard to take seriously coming from yourself. Also, some of the algorithms you do in C# might actually be really inefficient, like only storing the ID of the Tyre's bike, then doing a linear search for the matching Bike.</p>
"
"<p>Can a <code>struct</code> have a constructor in C++?</p>

<p>I have been trying to solve this problem but I am not getting the syntax.</p>
","87234","","<p>Yes. A structure is just like a class, but defaults to <code>public:</code>, in the class definition and when inheriting:</p>

<pre><code>struct Foo
{
    int bar;

    Foo(void) :
    bar(0)
    {
    }
}
</code></pre>

<p>Considering your other question, I would suggest you read through <a href=""http://www.cplusplus.com/doc/tutorial/"">some tutorials</a>. They will answer your questions faster and more complete than we will.</p>
"
"<p>I've scoured the internet and my own intellect to answer this basic question, however, much to my own dismay I've been unable to find a solution. I'm normally pretty good about multiple header files however I have hit a wall. The problem is a function that I've declared in a header and defined in its proper namespace in the source file. I'm developing on windows using Bloodshed.</p>

<p>///////////////////////////////
    //  class Matrix4x3.h
    ///////////////////////////////</p>

<pre><code>#ifndef _MATRIX4X3_H
#define _MATRIX4X3_H

class Matrix4x3{
    public:

        //set to identity
        void identity();

};

#endif
</code></pre>

<p>///////////////////////////////
//  class Matrix4x3.cpp
///////////////////////////////</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;math.h&gt;
#include ""Matrix4x3.h""
.
.
.
void Matrix4x3::identity(){
    //calculations here...
}
</code></pre>

<p>////////////// Main ////////////////</p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

#include ""../Matrix4x3.h""

using namespace std;

int main(int argc, char *argv[])
{
    Matrix4x3 a;

    a.identity();

    cin.get();
    return EXIT_SUCCESS;
}
</code></pre>

<p>I use Bloodshed, and it displays a list of class members and methods when I use the constructed object, however it tells me that the method dipicted above hasn't been referenced come time to compile. If anyone has a response I would be very appreciative. </p>
","87234","","<p>I think <a href=""http://stackoverflow.com/questions/1217575/undefined-reference-to-class-function-issue/1217669#1217669"">litb has it right</a>.</p>

<p><hr /></p>

<p>On a totally unrelated note, you might want to look into templates so you can have this class:</p>

<pre><code>template &lt;size_t Rows, size_t Columns&gt;
class Matrix
{
    ...
};

typedef Matrix&lt;4, 3&gt; Matrix4x3;
</code></pre>

<p>Instead of a new class for each matrix size. You might also throw the type into the mix:</p>

<pre><code>template &lt;size_t Rows, size_t Columns, typename T&gt;
class Matrix
{
    ...
};

typedef Matrix&lt;4, 3, float&gt; Matrix4x3f;
typedef Matrix&lt;4, 3, double&gt; Matrix4x3d;
</code></pre>

<p>Or look into <a href=""http://www.boost.org/doc/libs/1%5F39%5F0/libs/numeric/ublas/doc/index.htm"" rel=""nofollow"">boost</a>.</p>
"
"<p>I had this discussion with my colleague today about using Boost in our new C++ project. He did not agreed to use Boost as he thinks that Boost is huge and another point he added was that Why did Chrome team chose to not to use Boost? I am not sure what to answer ... His whole point is none of the modern day C++ projects make use of Boost other than its libs like SmartPointers.</p>

<p>I like use to Boost and love to code using Boost library, but got no point to prove that Boost is the best bet to be used in any C++ project like desktop application or server applications.</p>

<p>Any thoughts?</p>
","87234","","<p>He's probably suffering from ""Not Invented Here"" syndrome. The moment he begins reinventing something in boost, point it out to him.</p>
"
"<p>I want to store a 4-byte int in a char array... such that the first 4 locations of the char array are the 4 bytes of the int.</p>

<p>Then, I want to pull the int back out of the array...</p>

<p>Also, bonus points if someone can give me code for doing this in a loop... IE writing like 8 ints into a 32 byte array.</p>

<pre><code>int har = 0x01010101;
char a[4];
int har2;

// write har into char such that:
// a[0] == 0x01, a[1] == 0x01, a[2] == 0x01, a[3] == 0x01 etc.....

// then, pull the bytes out of the array such that:
// har2 == har
</code></pre>

<p>Thanks guys!</p>

<p><strong>EDIT:</strong> Assume <code>int</code> are 4 bytes... </p>

<p><strong>EDIT2:</strong> Please don't care about endianness... I will be worrying about endianness.  I just want different ways to acheive the above in C/C++.  Thanks</p>

<p><strong>EDIT3:</strong> If you can't tell, I'm trying to write a serialization class on the low level... so I'm looking for different strategies to serialize some common data types.</p>
","87234","","<p>Don't use unions, Pavel clarifies:</p>

<blockquote>
  <p>It's U.B., because C++ prohibits
  accessing any union member other than
  the last one that was written to. In
  particular, the compiler is free to
  optimize away the assignment to <code>int</code>
  member out completely with the code
  above, since its value is not
  subsequently used (it only sees the
  subsequent read for the <code>char[4]</code>
  member, and has no obligation to
  provide any meaningful value there).
  In practice, g++ in particular is
  known for pulling such tricks, so this
  isn't just theory. On the other hand,
  using <code>static_cast&lt;void*&gt;</code> followed by
  <code>static_cast&lt;char*&gt;</code> is guaranteed to
  work.</p>
</blockquote>

<p>– Pavel Minaev </p>
"
"<p>I have the following function that will convert a string into a numeric data type:</p>

<pre><code>template &lt;typename T&gt;
bool ConvertString(const std::string&amp; theString, T&amp; theResult)
{
    std::istringstream iss(theString);
    return !(iss &gt;&gt; theResult).fail();
}
</code></pre>

<p>This does not work for enumerated types, however, so I have done something like this:</p>

<pre><code>template &lt;typename T&gt;
bool ConvertStringToEnum(const std::string&amp; theString, T&amp; theResult)
{
    std::istringstream iss(theString);
    unsigned int temp;
    const bool isValid = !(iss &gt;&gt; temp).fail();
    theResult = static_cast&lt;T&gt;(temp);
    return isValid;
}
</code></pre>

<p>(I'm making the assumption that theString has a valid value for the enumerated type; I'm using this mainly for simple serialization)</p>

<p>Is there a way to create a single function that combines both of these?  </p>

<p>I've played a bit with the template arguments but haven't come up with anything; it'd just be nice not to have to call one function for enumerated types and another for everything else.</p>

<p>Thank you</p>
","87234","","<p>And just to ""complete"" the question, in C++0x we can just do this:</p>

<pre><code>typedef typename std::underlying_type&lt;T&gt;::type safe_type;
</code></pre>

<p>In place of Johannes <code>get_etype</code> trick.</p>
"
"<p>While pair programing what is the most optimal way to offer constructive criticism?</p>

<p>How do you critique without pointing out flaws?</p>
","87234","","<p>Tell them why, not what.</p>

<p>Nobody wants to hear what they're doing wrong, even people with open minds can get tired of that. Rather, people want to know what the possible downfalls are. If X is good, but Y does it better, don't say that. Tell them what X might fail at, and suggest Y as an improvement.</p>

<p>Let them improve themselves, only show them where.</p>
"
"<p>I have a global member data object, defined in a header (for class MyMainObj) like this.</p>

<pre><code>class MyMainObj
{
    MyDataObj obj;
}
</code></pre>

<p><code>MyDataObj</code> has a default constructor.
When is the constructor for <code>MyDataObj</code> called?
Is it called as part of the creation of <code>MyMainObj</code>?</p>
","87234","","<p>Concerning your code, you have a function with a variable inside. Upon entering the function, you will run to the line of code that declares the variable, and the constructor will be run then.</p>

<p>But you say ""creation of MyMainObj"". It's a function, it can only be called, not created.</p>

<p><hr /></p>

<p>This is all concerning the title question, ""when are members constructed?"" This would apply if <code>MyMainObj</code> was a class and not a function.</p>

<p>Your member objects are constructed in the order of which they appear in the class declaration. All objects are full constructed upon entering the constructor. (But this does not include the class itself!)</p>

<p>That is to say, by the time the class enters its constructor, all the members have finished their constructor.</p>

<p>Objects are destructed in reverse order, in the destructor (after the destructor is run).</p>

<p>In a pseudo-diagram:</p>

<pre><code>MyClass
    Member1
    Member2
    Member3

Construction:
    Member1
    Member2
    Member3
    MyClass

Destruction:
    MyClass
    Member3
    Member2
    Member1
</code></pre>

<p>You can manually call the members constructor using an initialization list:</p>

<pre><code>class foo
{
public:
    foo(void) : i(0) // construct i with 0.
    {
    }

    int i;
};
</code></pre>

<p>There are various question on SO about initialization lists. <a href=""http://stackoverflow.com/questions/1242830/constructor-initialization-list-evaluation-order"">Initialization list order</a>, <a href=""http://stackoverflow.com/questions/754729/copy-constructor-initialization-lists"">Copy-construction initialization list</a>, <a href=""http://stackoverflow.com/search?q=c%2B%2B+initialization+list"">and more</a>.</p>
"
"<pre><code>typedef set&lt;int, less&lt;int&gt; &gt; SetInt;
</code></pre>

<p>Please explain what this code does.</p>
","87234","","<p>It makes an alias to the type called <code>SetInt</code>, which is equivalent to <code>set&lt;int, less&lt;int&gt; &gt;</code>.</p>

<p>About your question about less, that refers to <a href=""http://www.cplusplus.com/reference/std/functional/less/"" rel=""nofollow""><code>std::less</code></a>, the comparer that <a href=""http://www.cplusplus.com/reference/stl/set/"" rel=""nofollow""><code>set</code></a> will use to sort your objects.</p>
"
"<p>This is a question in two parts, the first is the most important and concerns <em>now:</em></p>

<ul>
<li>Are you following the design and evolution of C++11?  What blogs, newsgroups, committee papers, and other resources do you follow?</li>
<li>Even where you're not using any new features, how have they affected your current choices?</li>
<li>What new features are you using now, either in production or otherwise?</li>
</ul>

<p>The second part is a follow-up, concerning the new standard once it is final:</p>

<ul>
<li>Do you expect to use it immediately?  What are you doing to prepare for C++11, other than as listed for the previous questions?</li>
<li>Obviously, compiler support must be there, but there's still co-workers, ancillary tools, and other factors to consider.  What will most affect your adoption?</li>
</ul>

<hr>

<p><em>Edit:</em> The original really was too argumentative; however, I'm still interested in the underlying question, so I've tried to clean it up and hopefully make it acceptable.  This seems a much better avenue than duplicating&mdash;even though some answers responded to the argumentative tone, they still apply to the extent that they addressed the questions, and all answers are community property to be cleaned up as appropriate, too.</p>
","87234","","<p>No, because it's not fully implemented on the compilers I use.</p>

<p>When C++0x comes out, and Visual Studio 2010 is fully released, along with a ""matching"" g++, I will use C++0x when I can. This is likely because I frequently start new projects (I make games).</p>

<p>Although I have an existed code-base, it changes every time I figure out a way to do something better; change isn't an obstacle for me. Taking advantage of C++0x would just be another change.</p>

<p>You'll find different opinions with larger code-bases. Some places prefer code to look uniform, and that means spotty C++0x isn't an option: they'd either have to convert the entire thing to take advantage of C++0x, or not use it.</p>

<p>Other places might encourage the use of C++0x features, and in spare time try to fix up older code to match.</p>

<p>And other places, like me, might immediately want to take advantage of all C++0x has to offer. </p>

<p>The answer is: it depends.</p>
"
"<p>What new kind of functionalities (for debugging or not) do you find helpful by overriding the new operator?</p>
","87234","","<p>Well, custom memory management and debugging. That's about it, and all you can get out of it too.</p>
"
"<p>I'm trying to determine if C++0x features are available when compiling.  Is there a common preprocessor macro?  I'm using Visual Studio 2010's compiler and Intel's compiler.</p>
","87234","","<p>The macro <code>__cplusplus</code> will <a href=""http://www2.research.att.com/~bs/C++0xFAQ.html#0x"" rel=""nofollow"">have a value</a> greater than <code>199711L</code>.</p>

<p>That said, not all compilers will fill this value out. Better to use Roger's solution.</p>
"
"<p>Can anybody tell what's the problem of the code below? </p>

<pre><code>int main () { 
return main() ; 
}
</code></pre>

<p>I tested, it compiles correctly. It's running forever. Anymore trick behind the scene?</p>
","87234","","<p>There seems to be confusion about the terminology used in the standard, and the implications that has for the programmer and compiler.</p>

<p>Firstly, <em>the standard alone</em> determines everything about the C++ language. If your particular version of a particular compiler allows some particular action, that has no bearing on whether or not that action is legal. For the remainder of the post, I'm referring to the ISO03 standard.</p>

<p>So to quote once again, the standard says in §3.6.1.3:</p>

<blockquote>
  <p>The function main shall not be used within a program.</p>
</blockquote>

<p>Additionally, §3.2 defines ""used"" as:</p>

<blockquote>
  <p>An object or non-overloaded function is used if its name appears in a potentially-evaluated expression.</p>
</blockquote>

<p>This means that once the program begins executing, <code>main</code> should <strong>never be entered again</strong>. That means programmers cannot call <code>main</code>, that means the compiler cannot insert another call to <code>main</code> (why it would, who knows), you cannot take the address of main and call that, etc. You cannot even have the potential of calling <code>main</code>.</p>

<p>The only call to <code>main</code> should be by the run-time library the program is running on; all other calls invoke undefined behavior. (Which means anything could happen!)</p>

<hr>

<p>Now onto compiler behavior:</p>

<p>A diagnosable rule is defined as (§1.4.1):</p>

<blockquote>
  <p>The set of diagnosable rules consists of all syntactic and semantic rules in this International Standard except for those rules containing an explicit notation that “no diagnostic is required” or which are described as resulting in “undefined behavior.”</p>
</blockquote>

<p>In our case, §3.6.1.3 defines a diagnosable rule. Here's what compilers should do according to §1.4.2:</p>

<blockquote>
  <p>— If a program contains no violations of the rules in this International Standard, a conforming implementation shall, within its resource limits, accept and correctly execute3) that program.<br>
  — If a program contains a violation of any diagnosable rule, a conforming implementation shall issue at least one diagnostic message, except that<br>
  — If a program contains a violation of a rule for which no diagnostic is required, this International Standard places no requirement on implementations with respect to that program.</p>
</blockquote>

<p>So compilers are <em>not</em> required to enforce rules. All compilers have to do is take <em>well-formed programs</em> (§1.3.14) and turn them into an executable program. A compiler is free to warn, error, etc. however it likes, as long as it does not conflict with the language. It is <em>required</em> to display a message in our particular case, according to the second clause.</p>

<p>For this particular problem, on gcc the <code>-pedantic</code> option will warn about the illegality of calling <code>main</code> within the program. Visual Studio will not warn about calling <code>main</code>, but on any warning level (greater than 0) it will warn about the recursive nature of the program.</p>

<hr>

<p>What does all this mean in terms of the answers you should expect? It means it's completely meaningless to try and define with certainty what the code snippet posted will do. Calling <code>main</code> results in undefined behavior, and trying to define undefined behavior is obviously a lost cause. The only honest answer anyone can give to ""what happens when I call <code>main</code>?"" is ""Anything.""</p>

<p>I hope this clears things up.</p>
"
"<p>I'm trying to use C++0x, and in particular lambda expression and decltype to simplify some of my code, using the MSVC10 RC compiler.</p>

<p>I've run into the following very odd problem:</p>

<pre><code>template &lt;typename F&gt;
auto foo(F f) -&gt; decltype(f()){
  return f();
}

template &lt;typename F&gt;
void bar(F f){
  f();
}

int main() {
  bar([](){
    foo([]() { }); // error C2893: Failed to specialize function template ''unknown-type' foo(F)'
  });
}
</code></pre>

<p>As indicated in the comment, the compiler generates an error on the line <code>foo([]() { })</code>.</p>

<p>I hate to shout ""compiler bug"", but I really can't see any good explanation for this error.
Apparently, while inside the outer lambda expression, the compiler can not specialize the  <code>foo</code> function template for the inner lambda.</p>

<p>However, if the definition of <code>foo</code> is changed to hardcode the return type, like this:</p>

<pre><code>template &lt;typename F&gt;
void foo(F f){
  return f();
}
</code></pre>

<p>then everything compiles just fine.</p>

<p>Is there some obscure quirk of decltype when used to deduce the return type of lambda expression parameters inside the scope of another lambda that I'm not aware of?</p>
","87234","","<p>These are just some test cases for people to observe.</p>

<h2>Works</h2>

<pre><code>template &lt;typename F&gt;
auto foo(F f) -&gt; decltype(f())
{
  return f();
}

void dummy() {}

int main()
{
    auto x = []()
            {   // non-lambda parameter
                foo(dummy);
            };
}
</code></pre>

<hr>

<pre><code>template &lt;typename F&gt;
auto foo(F f) -&gt; decltype(f())
{
  return f();
}

int main()
{
    auto f = [](){};
    auto x = [&amp;]()
            {    // pre-defined lambda
                foo(f);
            };
}
</code></pre>

<h2>Fails</h2>

<pre><code>template &lt;typename F&gt;
auto foo(F f) -&gt; decltype(f())
{
  return f();
}

int main()
{
    auto x = []()
            {   // in-argument lambda
                foo([]{});
            };
}
</code></pre>

<hr>

<pre><code>template &lt;typename F&gt;
auto foo(F f) -&gt; decltype(f())
{
  return f();
}

int main()
{
    auto x = []()
            {   // in-scope lambda
                auto f = []{};
                foo(f);
            };
}
</code></pre>

<hr>

<pre><code>template &lt;typename F&gt;
auto foo(F f) -&gt; decltype(f())
{
  return f();
}

int main()
{
    auto x = []()
            {   // in-scope lambda, explicit return
                // (explicit return type fails too, `-&gt; void`)
                auto f = [](){ return; };
                foo(f);
            };
}
</code></pre>

<hr>

<pre><code>template &lt;typename F&gt;
auto foo(F f) -&gt; decltype(f())
{
  return f();
}

int main()
{
    auto x = []()
            {   // in-argument lambda, explicit return non-void
                // (explicit return type fails too, `-&gt; int`)
                foo([]{ return 5; }); 
            };
}
</code></pre>

<p>So it does seem to have to do with scope <strike>and the <code>void</code> type of the internal lambda, even when made explicit.</strike>(?)</p>
"
"<p>In some sports certain techniques or elements are named after the athlete who invented or first performed them&mdash;for example, <a href=""http://en.wikipedia.org/wiki/Biellmann_spin"">Biellmann spin</a>.</p>

<p>Is their widespread use of such names for programming techniques and idioms?  What are they?  To be clear, I am explicitly not asking about algorithms, which are quite often named after their creators.</p>

<p>For example, one is <a href=""http://en.wikipedia.org/wiki/Schwartzian_transform"">Schwartzian transform</a>, but I can't recall any more.</p>
","87234","","<p>In C++, the <a href=""http://en.wikipedia.org/wiki/Barton-Nackman_trick"" rel=""nofollow"">Barton-Nackman trick</a>.</p>
"
"<p>I have an interesting problem here I've been trying to solve for the last little while:</p>

<p>I have 3 circles on a 2D xy plane, each with the same known radius. I know the coordinates of each of the three centers (they are arbitrary and can be anywhere). </p>

<p>What is the largest triangle that can be drawn such that each vertex of the triangle sits on a separate circle, what are the coordinates of those verticies?</p>

<p>I've been looking at this problem for hours and asked a bunch of people but so far only one person has been able to suggest a plausible solution (though I have no way of proving it).</p>

<p>The solution that we have come up with involves first creating a triangle about the three circle centers. Next we look at each circle individually and calculate the equation of a line that passes through the circle's center and is perpendicular to the opposite edge. We then calculate two intersection points of the circle. This is then done for the next two circles with a result of 6 points. We iterate over the 8 possible 3 point triangles that these 6 points create (the restriction is that each point of the big triangle must be on a separate circle) and find the maximum size.</p>

<p>The results look reasonable (at least when drawn out on paper) and it passes the special case of when the centers of the circles all fall on a straight line (gives a known largest triangle). Unfortunate i have no way of proving this is correct or not.</p>

<p>I'm wondering if anyone has encountered a problem similar to this and if so, how did you solve it?</p>

<p>Note: I understand that this is mostly a math question and not programming, however it is going to be implemented in code and it must be optimized to run very fast and efficient. In fact, I already have the above solution in code and tested to be working, if you would like to take a look, please let me know, i chose not to post it because its all in vector form and pretty much impossible to figure out exactly what is going on (because it's been condensed to be more efficient).</p>

<p>Lastly, yes this is for school work, though it is NOT a homework question/assignment/project. It's part of my graduate thesis (abet a very very small part, but still technically is part of it).</p>

<p>Thanks for your help.</p>

<p>Edit: Heres a new algorithm that i came up with a little while ago.</p>

<p>Starting at a circle's centre, draw a line to the other two centres. Calculate the line that bisects the angle created and calculate the intersections between the circle and the line that passes through the centre of your circle. You will get 2 results. Repeat this for the other two circles to get a total of 6 points. Iterate over these 6 points and get 8 possible solutions. Find the maximum of the 8 solutions.</p>

<p>This algorithm will deal with the collinear case if you draw your lines in one ""direction"" about the three points. </p>

<p>From the few random trials i have attempted using CAD software to figure out the geometries for me, this method seems to outperform all other methods previously stated However, it has already been proven to not be an optimal solution by one of Victor's counter examples.</p>

<p>I'll code this up tomorrow, for some reason I've lost remote access to my university computer and most things are on it.</p>
","87234","","<p><em>Not optimal, works well when all three are not colinear:</em></p>

<p>I don't have a proof (and therefore don't know if it's guaranteed to be biggest). Maybe I'll work on one. But:</p>

<p>We have three circles with radius <strong>R</strong> with positions (from center) <strong>P0</strong>, <strong>P1</strong>, and <strong>P2</strong>. We wish to find the vertices of a triangle such that the area of the triangle is maximum, and the vertices lie on any point of the circles edges.</p>

<p>Find the center of all the circles and call that <strong>C</strong>. Then <strong>C = (P0 + P1 + P2) / 3</strong>. Then we find the point on each circle farthest from <strong>C</strong>.</p>

<p>Find vectors <strong>V0</strong>, <strong>V1</strong>, and <strong>V2</strong>, where <strong>V<sub>i</sub> = P<sub>i</sub> - C</strong>. Then find points <strong>Q0</strong>, <strong>Q1</strong>, and <strong>Q2</strong>, where <strong>Q<sub>i</sub> = norm(V<sub>i</sub>) * R + P<sub>i</sub></strong>. Where <strong>norm</strong> indicates normalization of a vector, <strong>norm(V) = V / |V|</strong>.</p>

<p><strong>Q0</strong>, <strong>Q1</strong>, and <strong>Q2</strong> are the vertices of the triangle. I assume this is optimal because this is the farthest the vertices could be from each other. (I think.)</p>
"
"<p>I cannot figure out why this segment gives unresolved overloaded function error (gcc version 4.3.4 (Debian 4.3.4-6)):</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;boost/function.hpp&gt;

// this does not work
int main1()
{
    typedef boost::function&lt;const int&amp;(const int&amp;, const int&amp;)&gt; max;
    max m(&amp;std::max&lt;int&gt;);
}

// this does not work
int main2() {
    typedef boost::function2&lt;const int&amp;, const int&amp;, const int&amp;&gt; max;
    max m(static_cast&lt;max&gt;(&amp;std::max&lt;int&gt;));
}
</code></pre>

<p>can you help me, thanks</p>

<pre><code>test.cpp: In function âint main()â:
test.cpp:7: error: no matching function for call to âboost::function2&lt;const int&amp;, const int&amp;, const int&amp;&gt;::function2(&lt;unresolved overloaded function type&gt;)â
/usr/include/boost/function/function_template.hpp:747: note: candidates are: boost::function2&lt;R, T1, T2&gt;::function2(const boost::function2&lt;R, T1, T2&gt;&amp;) [with R = const int&amp;, T0 = const int&amp;\
, T1 = const int&amp;]
/usr/include/boost/function/function_template.hpp:739: note:                 boost::function2&lt;R, T1, T2&gt;::function2(boost::function2&lt;R, T1, T2&gt;::clear_type*) [with R = const int&amp;, T0 = cons\
t int&amp;, T1 = const int&amp;]
/usr/include/boost/function/function_template.hpp:707: note:                 boost::function2&lt;R, T1, T2&gt;::function2() [with R = const int&amp;, T0 = const int&amp;, T1 = const int&amp;]
</code></pre>

<p>max/min is defined as</p>

<pre><code>  template&lt;typename _Tp&gt;
    inline const _Tp&amp;
    max(const _Tp&amp; __a, const _Tp&amp; __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept&lt;_Tp&gt;)
      //return  __a &lt; __b ? __b : __a;
      if (__a &lt; __b)
        return __b;
      return __a;
    }
</code></pre>

<p>I have tried all sorts of template explicit instantiation but nothing seems to work.   Same problem appears with g++ 4.1 but not with ICC</p>

<p>this works</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;boost/function.hpp&gt;

namespace std_ {
    template&lt;typename _Tp&gt;
    inline const _Tp&amp;
    max(const _Tp&amp; __a, const _Tp&amp; __b)
    {
        // concept requirements
        //return  __a &lt; __b ? __b : __a;
        if (__a &lt; __b)
            return __b;
        return __a;
    }
}

int main()
{
    typedef const int &amp;T;
    typedef boost::function&lt;T(T,T)&gt; min_;
    //typedef const int&amp;(*min_)(const int&amp;, const int&amp;);
    min_ m(::std_::max&lt;int&gt;);
}
</code></pre>

<p>and this</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;boost/function.hpp&gt;

int main()
{
    //typedef const int &amp;T;
    //typedef boost::function&lt;T(T,T)&gt; min_;
    typedef const int&amp;(*min_)(const int&amp;, const int&amp;);
    min_ m(::std::max&lt;int&gt;);
}
</code></pre>
","87234","","<p>To critique the code, there's no reason to <code>static_cast</code> that. Consider all the cast is going to do is use the constructor of <code>boost::function2</code> to make a new <code>boost::function2</code>, then it will be copy-constructed into <code>m</code>. Just construct directly into <code>m</code>:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;boost/function.hpp&gt;

int main()
{
    typedef boost::function2&lt;const int&amp;, const int&amp;, const int&amp;&gt; max;
    max m(&amp;std::max&lt;int&gt;);
}
</code></pre>

<p>Lastly, the preferred syntax of <code>boost::function</code> is:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;boost/function.hpp&gt;

int main()
{
    typedef boost::function&lt;const int&amp;(const int&amp;, const int&amp;)&gt; max;
    max m(&amp;std::max&lt;int&gt;);
}
</code></pre>

<p>The n-ary specific classes are for older compiler support.</p>
"
"<p>Recently I was debugging a project and the debugger (GDB 7.1) crashed all of a sudden, because of an endless recursion while trying to print a graph structure. At first I couldn't even imagine that a debugger could crash (a stable version) but it had. So it's really interesting to me, have you ever crashed a debugger?</p>
","87234","","<p>Yes​​​​​​​​​​​.</p>
"
"<p>Here is what I'm doing. My application takes points from the user while dragging and in real time displays a filled polygon.</p>

<p>It basically adds the mouse position on MouseMove. This point is a USERPOINT and has bezier handles because eventually I will do bezier and this is why I must transfer them into a vector.</p>

<p>So basically MousePos -> USERPOINT. USERPOINT gets added to a <code>std::vector&lt;USERPOINT&gt;</code> . Then in my UpdateShape() function, I do this:</p>

<p>DrawingPoints is defined like this:</p>

<pre><code>std::vector&lt;std::vector&lt;GLdouble&gt;&gt; DrawingPoints;


Contour[i].DrawingPoints.clear();



 for(unsigned int x = 0; x &lt; Contour[i].UserPoints.size() - 1; ++x)
         SetCubicBezier(
             Contour[i].UserPoints[x],
             Contour[i].UserPoints[x + 1],
             i);
</code></pre>

<p>SetCubicBezier() currently looks like this:</p>

<pre><code>void OGLSHAPE::SetCubicBezier(USERFPOINT &amp;a,USERFPOINT &amp;b, int &amp;currentcontour )
{
std::vector&lt;GLdouble&gt; temp(2);

    if(a.RightHandle.x == a.UserPoint.x &amp;&amp; a.RightHandle.y == a.UserPoint.y 
        &amp;&amp; b.LeftHandle.x == b.UserPoint.x &amp;&amp; b.LeftHandle.y == b.UserPoint.y )
    {

        temp[0] = (GLdouble)a.UserPoint.x;
        temp[1] = (GLdouble)a.UserPoint.y;

        Contour[currentcontour].DrawingPoints.push_back(temp);

        temp[0] = (GLdouble)b.UserPoint.x;
        temp[1] = (GLdouble)b.UserPoint.y;


        Contour[currentcontour].DrawingPoints.push_back(temp);

    }
    else
    {
         //do cubic bezier calculation
        }
</code></pre>

<p>So for the reason of cubic bezier, I need to make USERPOINTS into GlDouble[2] (since GLUTesselator takes in a static array of double.</p>

<p>So I did some profiling. At ~ 100 points,  the code:</p>

<pre><code> for(unsigned int x = 0; x &lt; Contour[i].UserPoints.size() - 1; ++x)
         SetCubicBezier(
             Contour[i].UserPoints[x],
             Contour[i].UserPoints[x + 1],
             i);
</code></pre>

<p>Took 0 ms to execute. then around 120, it jumps to 16ms and never looks back. I'm positive this is due to std::vector. What can I do to make it stay at 0ms. I don't mind using lots of memory while generating the shape then removing the excess when the shape is finalized, or something like this. </p>
","87234","","<p>0ms is no time...nothing executes in no time. This should be your first indicator that you might want to check your timing methods over timing results.</p>

<p>Namely, timers typically don't have good resolution. Your pre-16ms results are probably just actually 1ms - 15ms being incorrectly reported at 0ms. In any case, if we could tell you how to keep it at 0ms, we'd be rich and famous.</p>

<p>Instead, find out which parts of the loop take the longest, and optimize those. Don't work towards an arbitrary time measure. I'd recommend getting a good profiler to get accurate results. Then you don't need to guess what's slow (something in the loop), but can actually see what part is slow.</p>
"
"<p>I am working in a very large legacy C++ code base which shall remain nameless.  Being a legacy code base, it passes raw pointers around all over the place.  But we are gradually trying to modernize it and so there are some smart pointer templates as well.  These smart pointers (unlike, say, Boost's scoped_ptr) have an implicit conversion to the raw pointer, so that you can pass one of them into a routine that takes a raw pointer without having to write <code>.get()</code>.  A big downside of this is that you can also accidentally use one in a <code>delete</code> statement, and then you have a double free bug, which can be a real pain to track down.</p>

<p>Is there a way to modify the template so that it still has the implicit conversion to the raw pointer, but causes a compile error if used in a delete statement?  Like this:</p>

<pre><code>#include &lt;my_scoped_ptr&gt;

struct A {};
extern void f(A*);

struct B
{
    scoped_ptr&lt;A&gt; a;

    B();
    ~B();
};

B::B()
    : a(new A)
{
    f(a); // this should compile
}

B::~B()
{
    delete a; // this should NOT compile
}
</code></pre>
","87234","","<p>There isn't a way to stop one and not the other. Anywhere it can be implicitly converted to a pointer for a function call, it can be implicitly converted for a delete expression.</p>

<p>Your best bet is to remove the conversion function. Your situation is exactly why user-defined conversion operators are dangerous and shouldn't be used often.</p>

<hr>

<p><a href=""http://stackoverflow.com/questions/3312031/c-smart-pointer-template-that-auto-converts-to-bare-pointer-but-cant-be-expl/3312507#3312507"">I'm wrong.</a> :(</p>
"
"<p>I have this function that converts an integer to a std::string:</p>

<pre><code>std::string intToStr(const int n) {
    stringstream ss;
    ss &lt;&lt; n;
    return ss.str();
}
</code></pre>

<p>It's worked well so far, but now I'm trying to construct a string to put into a std::pair, and I'm having some trouble.</p>

<p>Given an integer variable <code>hp</code> and a function that returns an integer <code>int maxHP()</code>, I want to construct a string that looks like this: <code>""5/10""</code> (if <code>hp</code> is 5 and <code>maxHP</code> returns 10).</p>

<p>here's my attempt:</p>

<pre><code>string ratio = intToStr(hp) + ""/"" + intToStr(maxHP());
return pair&lt;string, OtherType&gt;(ratio, someOtherType); 
</code></pre>

<p>Compiling with g++, it fails with this error:</p>

<pre><code>src/Stats.cpp:231: error: no matching function for call to  
‘std::pair&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;,
TCODColor&gt;::pair(&lt;unresolved overloaded function type&gt;, const TCODColor&amp;)’
/usr/include/c++/4.4/bits/stl_pair.h:92: note: candidates are: std::pair&lt;_T1,
_T2&gt;::pair(std::pair&lt;_T1, _T2&gt;&amp;&amp;) [with _T1 = std::basic_string&lt;char, 
std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, _T2 = TCODColor]
/usr/include/c++/4.4/bits/stl_pair.h:83: note:                 std::pair&lt;_T1,
_T2&gt;::pair(const _T1&amp;, const _T2&amp;) [with _T1 = std::basic_string&lt;char, 
std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, _T2 = TCODColor]
/usr/include/c++/4.4/bits/stl_pair.h:79: note:                 std::pair&lt;_T1, 
_T2&gt;::pair() [with _T1 = std::basic_string&lt;char, std::char_traits&lt;char&gt;,
std::allocator&lt;char&gt; &gt;, _T2 = TCODColor]
/usr/include/c++/4.4/bits/stl_pair.h:68: note: 
std::pair&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;,
TCODColor&gt;::pair(const std::pair&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;,
std::allocator&lt;char&gt; &gt;, TCODColor&gt;&amp;)
</code></pre>

<p>so std::pair doesn't like my string.  I've confirmed that it's not <code>OtherType</code> causing the problem, because I have another pair constructor that compiles fine:</p>

<pre><code>pair&lt;string, OtherType&gt;(""astring"", someOtherType);
</code></pre>

<p>Anyone see how I can fix this?</p>

<hr>

<p>Fixed it, though the answer was odd. My problem was that somehow ratio wasn't getting defined, but g++ didn't tell me about it. Changing my code to use <code>make_pair</code> as GMan suggested suddenly made it tell me.  Anyone know why that would happen?</p>

<p>Here's more of the function:</p>

<pre><code>if(verbose) 
    string ratio = intToStr(hp) + ""/"" + intToStr(maxHP());

if(div &gt; 1.0f) {
    if(verbose) return pair&lt;string, OtherType&gt;(ratio, someOtherType); // doesn't compile
    else return pair&lt;string, OtherType(""astring"", someOtherType); // compiles
}
</code></pre>

<p>here's the fixed code:</p>

<pre><code>string ratio = intToStr(hp) + ""/"" + intToStr(maxHP());

if(div &gt; 1.0f) {
    if(verbose) return make_pair(ratio, someOtherType); // compiles now
    else return make_pair(""astring"", someOtherType); // compiles
}
</code></pre>
","87234","","<p>Here's how I would fix your code:</p>

<pre><code>if (div &gt; 1.0f)
{
    string str = verbose ? intToStr(hp) + ""/"" + intToStr(maxHP()) : ""astring"";
    return make_pair(str, someOtherType); 
}
</code></pre>

<p>A little more concise. Also, your formatting could be made <a href=""http://stackoverflow.com/questions/1243428/convert-string-to-int-with-bool-fail-in-c/1243435#1243435"">a bit more generic</a>.</p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/204476/what-should-main-return-in-c-c"">What should main() return in C/C++?</a>  </p>
</blockquote>



<p>This is a pretty basic question, I guess.</p>

<p>I've been programming for a year now but a friend of mine surprised me with a rather stupefying question.</p>

<p>Programs that start with 'int main()' on C++ seem to compile perfectly even with 'return 0;' removed and not replaced by any other return statement. And without a return statement at all, the program still shows that 'Process returned 0'.</p>

<p>Does this have any explanation? 
Sorry if my question is silly!</p>
","87234","","<p>§3.6.1/5:</p>

<blockquote>
  <p>A return statement in <code>main</code> has the effect of leaving the main function (destroying any objects with automatic storage duration) and calling <code>exit</code> with the return value as the argument. If control reaches the end of main without encountering a return statement, the effect is that of executing
  <code>return 0;</code></p>
</blockquote>
"
"<p>I have a producer/consumers design in my application which implement Produce/Consume functions on user types. But it doesn't work very naturally with the standard library and especially with algorithms.</p>

<p>In C# there is the Enumerable and Observable concepts that can be used to easily implement stuff like this and get alot of nice free functionality.</p>

<p>In C++ there is the ios, istream, ostream, input_iterator, output_iterator concepts which I thought might be useful. But it seems to me that all of these are for primitive character types, e.g. char, int etc... and not for user types.</p>

<p>Sure I could use real functions such as Produce/Consumer and std::mem_fn for algorithms. But I was hoping there was a better way.</p>

<p>Im looking on some best-practice advice on how to go about designing i/o similar solutions on user types in C++.</p>

<p>E.g. from C#</p>

<pre><code>class FrameProducer : IEnumerable&lt;Frame&gt; // pull frames
{...}

// Some engine between

class FrameConsumer : IObserver&lt;Frame&gt; // push frames
{...}
</code></pre>

<p>I was hoping for something similar in C++ e.g. which i dont believe is possible.</p>

<pre><code>class FrameProducer : istream&lt;Frame&gt; // pull frames
{...}

// Some engine between

class FrameConsumer : ostream&lt;Frame&gt; // push frames
{...}
</code></pre>

<p>Maybe I'm thinking to hard about it and should just go by KISS.</p>

<p>Thoughts?</p>
","87234","","<p>Th terms are ""insertion operator"" and ""extraction operator"", which insert and extract data from a stream.</p>

<p>Here's an example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;

struct foo
{
    int x;
};

// insertion operator
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const foo&amp; f)
{
    s &lt;&lt; f.x; // insert a foo by inserting x
    return s;
}

// extraction operator
std::istream&amp; operator&gt;&gt;(std::istream&amp; s, foo&amp; f)
{
    s &gt;&gt; f.x; // extract a foo by extracting x
    return s;
}

int main(void)
{
    std::stringstream ss;

    foo f1 = {5};
    ss &lt;&lt; f1;

    foo f2;
    ss &gt;&gt; f2;
}
</code></pre>

<hr>

<p>Based on your desire to do:</p>

<pre><code>MyFrameProducer producer;
MyFrameConsumer consumer;
Frame frame; // frame should probably be in the while loop, since its 
while(!producer.eof()) // lifetime doesn't need to exist outside the loop
{
    producer &gt;&gt; frame;
    consumer &lt;&lt; frame;
} 
</code></pre>

<p>You might make:</p>

<pre><code>struct MyFrameProducer {}; // add an eof function
struct MyFrameConsumer {};
struct Frame {};

// producer produces a frame
MyFrameProducer&amp; operator&gt;&gt;(MyFrameProducer&amp; p, Frame&amp; f)
{
    /* whatever it takes to make a frame */

    return p;
}

// consumer consumes a frame
MyFrameConsumer&amp; operator&lt;&lt;(MyFrameConsumer&amp; c, const Frame&amp; f)
{
    /* whatever it takes to use a frame */

    return c;
}
</code></pre>

<p>Or something akin to it. (Sorry my understanding of the problem is small.) It <em>is</em> a bit weird to desire this interface, since it has nothing to do with streams, and you might be better off with a different interface (explicit methods).</p>
"
"<p>When I ""cout"" an empty array, I get gibberish.  Why?</p>

<pre><code>int main() { char test[10]; cout &lt;&lt; test; return 0; }
</code></pre>

<p>...returns some unicode blather.  An easy answer I'm sure.</p>
","87234","","<p>Because your array isn't initialized. Its contents can be anything, and you get undefined behavior using them.</p>

<p>You can initialize them all to zero:</p>

<pre><code>char test[10] = {};
</code></pre>

<p>And when printed, will print nothing.</p>
"
"<p>it it possible that in some cases <code>NEW</code> returns some value, for example NULL, or it will always throw exception? </p>
","87234","","<p>A standards compliant <code>new</code> expression never evaluates to null.</p>

<p>You may use <code>std::nothrow</code> to return null instead of throw an exception:</p>

<pre><code>new (std::nothrow) T();
</code></pre>
"
"<pre><code>int main(int argc, char** argv) {
    int i=5;
    {
        int i=7;
        printf(""%d\n"", i);
    }
    return 0;
}
</code></pre>

<p>If I want to access outer <code>i</code> (<code>int i=5</code>) value in <code>printf</code> then how it can done?</p>
","87234","","<p>You cannot access it.</p>
"
"<p>How is this done in C++0x?</p>

<pre><code>std::vector&lt;double&gt; myv1;
std::transform(myv1.begin(), myv1.end(), myv1.begin(),
               std::bind1st(std::multiplies&lt;double&gt;(),3));
</code></pre>

<p>Original question and solution is <a href=""http://stackoverflow.com/questions/3885095/c-multiply-vector-elements-by-a-scalar-value-using-stl"">here</a>.</p>
","87234","","<p>Just do as Dario says:</p>

<pre><code>for_each(begin(myv1), end(myv1), [](double&amp; a) { a *= 3; });
</code></pre>

<p><code>for_each</code> is allowed to modify elements, saying it cannot is a myth.</p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/3623631/where-should-non-member-operator-overloads-be-placed"">Where should non-member operator overloads be placed?</a>  </p>
</blockquote>



<p>While browsing on SO, I often find questions or answer that involves overloading/defining a <code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Foo&amp; foo)</code> or a <code>Foo operator+(const Foo&amp; l, const Foo&amp; r)</code>.</p>

<p>While I know how and when (not) to write these operators, I'm confused about the <code>namespace</code> thing.</p>

<p>If I have the following class:</p>

<pre><code>namespace bar
{
  class Foo {};
}
</code></pre>

<p>In which <code>namespace</code> should I write the different operator definitions ?</p>

<pre><code>// Should it be this

namespace bar
{
  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Foo&amp; foo);
}

// Or this ?

namespace std
{
  ostream&amp; operator&lt;&lt;(ostream&amp; os, const bar::Foo&amp; foo);
}

// Or this ?

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const bar::Foo&amp; foo);
</code></pre>

<p>The same question applies for the <code>operator+</code>. So, what is the good practice here and <strong>why</strong> ?</p>
","87234","","<p>It should be in the <code>bar</code> namespace. You must consider <a href=""http://www.gotw.ca/publications/mill02.htm"">what makes up the interface for the class</a>, and group those together.</p>

<p>""A class describes a set of data along with the functions that operate on that data."" Your free function operates on a <code>Foo</code>, therefore it is part of <code>Foo</code>. It should be grouped with <code>Foo</code> in the namespace <code>bar</code>.</p>

<p><a href=""http://en.wikipedia.org/wiki/Argument-dependent_name_lookup"">Argument-dependent lookup</a>, or ADL, will find the function.</p>

<p>We also know that we should <a href=""http://www.drdobbs.com/184401197"">prefer non-friend non-member functions</a>. What this means is that, in general, your classes will have their definition and member functions, followed immediately by free functions which operate on the class.</p>
"
"<p>For <code>char[size]</code>, is it true that <code>size</code> must be <code>constant</code>? </p>

<p>Or say,will it work ?</p>

<pre><code>int length;
...

char[length] arr;
</code></pre>

<p>Sorry,don't have the environment here so can't try it myself.</p>
","87234","","<p>Pre C99, yes; the size of an array must be a constant integral expression. C99, however, adds Variable Length Arrays (VLA's), which allow an array to have a dynamic size.</p>
"
"<p>I am a student, and new to c++. I am  searching for a standard c++ api that is as comprehensive as the java api. I have been using cplusplus.com, and cppreference.com. Please any help would be greatly appreciated.</p>
","87234","","<p>C++ has a <em>standard library</em>.</p>

<p>You can try <a href=""http://rads.stackoverflow.com/amzn/click/0201379260"" rel=""nofollow"">The C++ Standard Library: Tutorial and Reference</a>. While I don't own it myself, it's on our <a href=""http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">book list</a> (which I recommend you check out), so it shouldn't be bad.</p>

<p>Note C++ isn't Java, so the libraries don't necessarily have the same functionality. Another resource you'll want to look at is <a href=""http://stackoverflow.com/tags/boost/info"">Boost</a>, which serves as a source for well-written C++ libraries for things the standard library lacks.</p>
"
"<p>I've currently started on my semester project for my programming course- programming a fully autonomous driving simulator. All cars are steered through AI and the map is printed in the console. </p>

<p>The first sheet wants us to create a couple of basic classes:  FCCompact (The car), Scanner (AI), ID (terrain), and World (The map).</p>

<p>The Scanner is currently implemented as a ""HAS-A"" in my FCCompact class like so:</p>

<pre><code>// FCCompact.h
class FCCompact
{
private:
    struct fImpl;
    fImpl *fImpl_;
/* ... */

// FCCompact.cpp
struct fImpl
{
    Scanner scanner_;
    /* ... */
};
</code></pre>

<p>The scanner function in question is</p>

<pre><code>const ID&amp; scanForID( int fovNumber,            // How far it can see
                     FCCompact::Direction dir, // Direction car is facing
                     const Location&amp; loc);     // Location of car
</code></pre>

<p>So far so good. However, the entire map is located in a container <code>vector&lt; deque&lt;ID&gt; &gt;</code>(1) in the class World; I'm not sure how to access it.</p>

<p>The functions posted so far have been given to us by the teacher, so they should be able to be implemented with the parameters given. I just have no clue how to do that.</p>

<p>My first idea was to call <code>World::getID(Location &amp;)</code>, but it's not static. Upon making it static, it can no longer access non-static members (duh, I forgot that). I have also made a static function that calls a non-static function; same problem (double duh).</p>

<p>Then I tossed the teacher's guidelines and simply passed in the entire <code>World</code> object, but that didn't really work either. </p>

<p>What can I do?</p>

<p>Please keep in mind that this is technically homework and that I do not want full, qualified answers that even gives me the entire implementation of what I want to do. I want to learn as much as possible from this project, so please just point me in the right direction.</p>

<p>(1): Weird choice for a container type? I figured if the world is printed on the console, quick access to each row with a vector would be beneficial, since there will be no insertion or deletion of queues and the access time is brilliant.</p>

<p>A deque, on the other hand, is handily for accessing ranges, which is favorable since I will frequently change adjacent columns (cars driving along the x- or y-axis). This choice did not come swiftly; I'm still torn between this, a list, or a simple vector again.</p>

<p><strong>Classes</strong></p>

<p>class World</p>

<pre><code>class ID;
class World
{
    typedef std::pair&lt;int, int&gt; Location;

private:    
// vector&lt;deque&lt;ID&gt; &gt; map
// int mapHeight, mapWidth
// string mapName
    struct wImpl;
    wImpl *pimpl_;

public:
    World();
    ~World();

    void create(const std::string&amp; name = ""FC-City"");

    int getHeight() const;
    int getWidth() const;

    ID getID(const Location&amp; loc);

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, World&amp; world)
    {
        return os;
    }

private:
    void loadMap(std::string name = ""FC-City"");

private:
    World(const World&amp; other);
    World&amp; operator=(const World&amp; other);
};
</code></pre>

<p>class Scanner</p>

<pre><code>class ID;
class Scanner
{
    typedef std::pair&lt;int, int&gt; Location;

public:
    Scanner();
    ~Scanner();

    const ID&amp; scanForID( int fovNumber, 
                         FCCompact::Direction dir, 
                         const Location&amp; loc);

private:
    Scanner(const Scanner&amp; other);
    Scanner&amp; operator==(const Scanner&amp; other);
};
</code></pre>

<p>class FCCompact</p>

<pre><code>class ID;
class FCCompact
{
    typedef std::pair&lt;int, int&gt; Location;

public:
    enum Direction
    {
        N, E, S, W, 
        NA = -1
    };

private:
// Scanner scanner
// Location loc
// Direction dir
// ID id
    struct    FCCImpl;
    FCCImpl  *pimpl_;

public:
    FCCompact( const ID&amp; id,
               const Location&amp; loc,
               const Direction&amp; dir);

    FCCompact( const char ch,
               const Location&amp; loc,
               const Direction&amp; dir);

    const ID&amp; getID()  const;
    Location  getLoc() const;
    Direction getDir() const;
    void      setDir( Direction&amp; dir );

    void step();
    void hide();
    void show();
};
</code></pre>

<p>class ID</p>

<pre><code>class ID
{
public:
    enum Trait
    {
        Traversable,
        NotTraversable,
        Mobile,
        Undef
    };

private:
    Trait trait_;
    char appearance_;

public:
    ID( char outputChar, Trait trait )
        : appearance_(outputChar), trait_(trait)
    { }

    ID( char outputChar )
        : appearance_(outputChar), trait_(Trait::Undef)
    { }

    char getToken()  const { return appearance_; }
    Trait getTrait() const { return trait_; }

    void setTrait(Trait trait) { trait_ = trait; }
};
</code></pre>
","87234","","<p><code>Scanner</code> should have a constructor that accepts a reference to a <code>World</code>; store a pointer to that argument so later when you need a world you have one.</p>

<p>Don't use a singleton, <a href=""http://jalf.dk/blog/2010/03/singletons-solving-problems-you-didnt-know-you-never-had-since-1995/"" rel=""nofollow"">they're stupid</a>. You could use a global but there really isn't a need here. A <code>Scanner</code> needs a <code>World</code> to operate on, ergo you construct it with a <code>World</code> to operate on:</p>

<pre><code>struct bar;

struct foo
{
    // foo cannot operate without a bar,
    // therefore it needs to be supplied with
    // one to be able to construct
    foo(const bar&amp; pBar) :
    mBar(&amp;pBar)
    {}

    void i_need_bar()
    {
        mBar-&gt;use_bar();
    }

    bar* mBar;
};
</code></pre>
"
"<p>To insert/delete a node with a particular value in DLL (doubly linked list) entire list need to be traversed to find the location hence these operations should be O(n).</p>

<p>If that's the case then how come STL list (most likely implemented using DLL) is able to provide these operations in constant time?</p>

<p>Thanks everyone for making it clear to me.</p>
","87234","","<p>Insertion and deletion <em>at a known position</em> is O(1). However, finding that position is O(n), unless it is the head or tail of the list.</p>

<p>When we talk about insertion and deletion complexity, we generally assume we already know where that's going to occur.</p>
"
"<p>In C++, what's the difference between</p>

<pre><code>char *a = new char[10];
</code></pre>

<p>and</p>

<pre><code>char *a = new char(10);
</code></pre>

<p>Thanks!</p>
","87234","","<p>The first allocates an array of 10 char's. The second allocates one char initialized to 10.</p>

<p>Or:</p>

<p>The first should be replaced with <code>std::vector&lt;char&gt;</code>, the second should be placed into a smart pointer.</p>
"
"<p>If using a <code>char*</code>, I can initialize it to <code>NULL</code> and later check if it is set by doing a comparison. How to do the same thing for a <code>std::string</code>? How to check if the string is set or not?</p>

<p>EDIT:
    What if the string I set to is also empty? Do I have to use an additional flag to check if the <code>std::string</code> is set or not?</p>
","87234","","<p>Use <code>empty()</code>:</p>

<pre><code>std::string s;

if (s.empty())
    // nothing in s
</code></pre>
"
"<p>I have a static const array class member (const pointers to SDL_Surfaces, but that's irrelevant), and have to loop through it in order to populate it. Aside from a const_cast when I'm done looping, which I hear is bad practice, how would I go about doing this?</p>

<p>EDIT: 
The reason I don't just do...</p>

<pre><code>static SDL_Surface *const myArray[3];
...
class::myArray[3] = {...};
</code></pre>

<p>is that I need to read from a different array and run a function on the different array's respective value in order to get the value for this array. Once I've looped all the way through, I'm never changing this array again, so the way I see it, it should be const.</p>

<p>EDIT 2:
I think I might have made a conceptual mistake here. Is it possible to const_cast in some way to make something const, instead of to remove it's constness, which is what I was trying to do? If not, then I was being a little silly asking this :D</p>
","87234","","<p>One method to provide ""logical constness"" is to make the data inaccessible, except by non-mutating means.</p>

<p>For example:</p>

<pre><code>class foo
{
public:
    const bar&amp; get_bar() { return theBar; }

private:
    static bar theBar;
};
</code></pre>

<p>Even though <code>theBar</code> isn't constant, since <code>foo</code> is the only thing that can modify it, as long as it does so correctly you essentially (logically) have a constant <code>bar</code>.</p>
"
"<p>Can I call the C++ placement new on constructors with parameters? I am implementing a custom allocator and want to avoid having to move functionality from non-default constructors into an init function.</p>

<pre><code>class CFoo
{
public:
    int foo;
    CFoo()
    {
        foo = 0;
    }

    CFoo(int myFoo)
    {
        foo = myFoo;
    }
};

CFoo* foo = new (pChunkOfMemory) CFoo(42);
</code></pre>

<p>I would expect an object of type CFoo to be constructed at pChunkOfMemory using the second constructor. When using operator new am I stuck with default constructors only?</p>

<p><strong>Solved! I did not <code>#include &lt;new&gt;</code>. After this, calling placement ::new worked fine with non-default constructors.</strong></p>
","87234","","<p>To use placement new, you need to include the header <code>&lt;new&gt;</code>:</p>

<pre><code>#include &lt;new&gt;
</code></pre>

<p>Otherwise the placement forms of <code>operator new</code> aren't defined.</p>
"
"<p>Some C++ libraries call abort() function in the case of error (for example, SDL). No helpful debug information is provided in this case. It is not possible to catch abort call and to write some diagnostics log output. I would like to override this behaviour globally without rewriting/rebuilding these libraries. I would like to throw exception and handle it. Is it possible?</p>
","87234","","<p>No. <code>abort()</code> is a standard library function, and has no replacement mechanism. It's also the quickest way to end your program, skipping both destructors and <code>atexit</code> functions.</p>

<p>Your best bet is to try and stop the errors from happening by checking values <em>before</em> you make calls to the library.</p>
"
"<p>Here is my issue:</p>

<p>I have a <code>std::vector&lt;AguiWidgetBase*&gt;</code> which is used to keep track of child controls.</p>

<p>I have these two functions to return iterators:</p>

<pre><code>std::vector&lt;AguiWidgetBase*&gt;::const_iterator AguiWidgetBase::getChildBeginIterator() const
{
    return children.begin();
}

std::vector&lt;AguiWidgetBase*&gt;::const_iterator AguiWidgetBase::getChildEndIterator() const
{
    return children.end();
}
</code></pre>

<p>I  then use it like this:</p>

<pre><code>for(std::vector&lt;AguiWidgetBase*&gt;::const_iterator it = box-&gt;getChildBeginIterator(); 
    it != box-&gt;getChildEndIterator(); ++it)
{
    it-&gt;setText(""Hello World"");
}
</code></pre>

<p>and I get these errors:</p>

<pre><code>Error   3   error C2039: 'setText' : is not a member of 'std::_Vector_const_iterator&lt;_Ty,_Alloc&gt;'   c:\users\josh\documents\visual studio 2008\projects\agui\alleg_5\main.cpp   112
Error   2   error C2839: invalid return type 'AguiWidgetBase *const *' for overloaded 'operator -&gt;' c:\users\josh\documents\visual studio 2008\projects\agui\alleg_5\main.cpp   112
</code></pre>

<p>Why is it giving me these errors?</p>

<p>Thanks</p>
","87234","","<p>Because an iterator acts like a pointer, and in this case a pointer <em>to a pointer</em>.</p>

<p>You'd need:</p>

<pre><code>(*it)-&gt;setText(""Hello World""); // dereference iterator, dereference pointer
</code></pre>
"
"<p>I just wondered what the best way is to get rid of the globally available static getInstance() in a Singleton. I do not want my Singleton classes being accessed from every point in my program.</p>

<p>I thought about maybe having a create() public static function that creates one object and returns it but one cannot call this method twice.</p>

<p>But it's not very elegant for me. Than I would have to make an assertion or throw an exception in case create() gets called a second time.</p>

<p>Is there any other way I can achieve what I want?</p>
","87234","","<p>You said that ""creating one a second time would damage the whole application."". My response is: so don't make more then one. In C++, the type system is too weak to easily ensure this at compile-time. We can still write up a utility to approximate it at run-time, though.</p>

<p>Note, though, that this in no way implies you should use a singleton. (You have zero need for a global; it's unfortunate the drones have associated single-instance with global). What you want is this:</p>

<pre><code>#include &lt;stdexcept&gt;

// inherit from this class (privately) to ensure only
// a single instance of the derived class is created
template &lt;typename D&gt; // CRTP (to give each instantiation its own flag)
class single_instance
{
protected: // protected constructors to ensure this is used as a mixin
    single_instance()
    {
        if (mConstructed)
            throw std::runtime_error(""already created"");

        mConstructed = true;
    }

    ~single_instance()
    {
        mConstructed = false;
    }

private:
    // private and not defined in order to
    // force the derived class be noncopyable
    single_instance(const single_instance&amp;);
    single_instance&amp; operator=(const single_instance&amp;);

    static bool mConstructed;
};

template &lt;typename T&gt;
bool single_instance&lt;T&gt;::mConstructed = false;
</code></pre>

<p>Now you get an exception if the class is constructed more than once:</p>

<pre><code>class my_class : private single_instance&lt;my_class&gt;
{
public:
    // usual interface (nonycopyable)
};

int main()
{
    my_class a; // okay
    my_class b; // exception
}
</code></pre>
"
"<p>Given a C++ string str(""ab""), how do I swap the content of str so that it becomes ""ba"".
Here is my code:</p>

<pre><code>    string tmpStr(""ab"");

    const char&amp; tmpChar = tmpStr[0];
    tmpStr[0] = tmpStr[1];
    tmpStr[1] = tmpChar;
</code></pre>

<p>Is there a better way?</p>

<p>Thank you</p>
","87234","","<p>Like this:</p>

<pre><code>std::swap(tmpStr[0], tmpStr[1]);
</code></pre>

<p><code>std::swap</code> is located in <code>&lt;algorithm&gt;</code>.</p>
"
"<p>Suppose I have a class like</p>

<pre><code>class A {
    int x;
    int y;
  public:
    getSum1() const {
        return getx() + y;
    }
    getSum2() const {
        return y + getx();
    }
    getx() const {
        return x;
    }
}
</code></pre>

<p>And then I have</p>

<pre><code>int main(int argc, char **argv) {
    A *a = 0;
    switch(argc) {
    case 0:
        a-&gt;getsum1();
        break;
    default:
        a-&gt;getsum2();
        break;
    }
    return 1;
}
</code></pre>

<p>This program will segfault. I noticed that on my machine, when getsum1 executes, the core
dump says the segfault was caused in getx, and when getsum2 executes it says the fault happened in getsum2.</p>

<p>This makes sense. I have 2 questions:<br>
1. is this behaviour specified, or is it implementation dependent?<br>
And most importantly:<br>
2. Could the core dump say that the segfault happened in main, when a was dereferenced? (i.e. at a->getsum*)</p>

<p>Thanks.</p>
","87234","","<p>When you called those functions on a null pointer, you got <a href=""http://stackoverflow.com/questions/2474018/when-does-invoking-a-member-function-on-a-null-instance-result-in-undefined-behav"">undefined behavior</a>. That's really all that should be said; anything can happen, don't do it.</p>

<p>The reason it segfaults is because there is no <code>A</code> at null. Attempting to access those members is attempting to access an invalid address. (This happens in <code>getx</code> and <code>getSum2</code>, hence the segfault report.)</p>

<p>No, it cannot say the segfault happened in <code>main</code> because null wasn't accessed in main. (You still entered undefined behavior in main, no doubt, but in practice it just called a function with <code>this</code> set to null.) You accessed it in those functions. In practice, if a function never uses <code>this</code>, it won't crash with a null pointer.</p>

<p>But don't.</p>
"
"<p>simplifying my problem we can consider:</p>

<pre><code>template &lt;class T&gt;
class Base{
    typedef typename std::pair&lt;T, T&gt; pair;
};

template &lt;class T&gt;
class Inheritor : public Base&lt;T&gt; {
    pair *p;                          
    // mean that we want to use constructor of std::pair.
    // say: std::pair withou argument list

    Inheritor&lt;T&gt;::pair *p;
    // dont see his typename
    // say: pair does not name a type

    typename pair *p;
    // I was sure that it works.
    // I dont know why it doesnt work.
    // say: expected nested-name-specifier before 'pair

    typename Inheritor&lt;T&gt;::pair *p;
    // ok!
};
</code></pre>

<p>why we cant write typename pair *p ? I dont understand reasons of Inheritor:: ! it make code more complex and bad to read!</p>

<p>PS
(of cource public. as I say ""simplifying my problem..."")</p>

<pre><code>typedef typename Base&lt;T&gt;::pair pair;
</code></pre>

<p>In my mind it is a ... russian word that is hard to translate <a href=""http://www.linux.org.ru/forum/talks/3588892"" rel=""nofollow"">(""костыль"")</a></p>

<p>It look like Kludge or duct tape or hack =)</p>

<p>As I understand:</p>

<p>typedefs inherit as usual function or variable.
but it is not accessible (!!!).
to acess it we should write</p>

<pre><code>typedef typename Base&lt;T&gt;::pair pair;
</code></pre>

<p>or</p>

<pre><code>typedef typename Inheritor&lt;T&gt;::pair pair;
</code></pre>

<p>it looks like funny <a href=""http://lurkmore.ru/%D0%98%D0%BD%D0%B4%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9_%D0%BA%D0%BE%D0%B4"" rel=""nofollow"">Hindu code</a> but we needs it! (>_&lt;)''''</p>

<p>of cource in public scope</p>
","87234","","<p>When a type name depends on a template parameter, it is a <em>dependent name</em>. <a href=""http://pages.cs.wisc.edu/~driscoll/typename.html"" rel=""nofollow"">You have to use <code>typename</code> to indicate you're naming a type.</a> Read that article, and you'll see your use of <code>typename</code> doesn't make sense, except in the last case.</p>

<p>Here's how your code should probably look:</p>

<pre><code>template &lt;class T&gt;
class Base
{
public: // you probably don't want a private typedef
    typedef std::pair&lt;T, T&gt; pair; // typename isn't needed here, this isn't dependent
};

template &lt;class T&gt;
class Inheritor : public Base&lt;T&gt;
{
public: // public again
    typedef typename Base&lt;T&gt;::pair pair; // get the Base's pair type, typedef it

    pair *p; // ah, easy to use
};
</code></pre>
"
"<p>It seems like every library I've ever seen recommended doesn't offer an api as easy as this.</p>

<pre><code>MyClass* instance = (MyClass*)SerializationUtility.serialize(someString);
</code></pre>

<p>Has anyone heard of something this easy for c++?
In hava there are a couple of libraries that are so easy to use for converting text into objects and objects into text. This is one of those ""solved problems"" things, which is why it surprises me that there is no buzz around a c++ library (that I have heard of.)</p>
","87234","","<p>Look at <a href=""http://www.boost.org/doc/libs/1_44_0/libs/serialization/doc/index.html"" rel=""nofollow"">Boost.Serialization</a>.</p>

<p><sub>
8th result when you Google ""c++ serialization"". =/
</sub></p>
"
"<p>Is it worth to write classes representing 1D, 2D, 3D points using templates</p>

<pre><code>template &lt;class T&gt;
class Point2D
{

protected:

    T X, Y;

public:

    Point2D(const T x, const T y) : hot smileyx), Y(y)) {}
    ...
};


template &lt;class T&gt;
class Point3D : public Point2D&lt;T&gt;
{
    protected:
    T Z;

public:

    Point3D(const T x, const T y, const T z) : Point2D&lt;T&gt;(x,y), Z(z) {}
...
};
</code></pre>

<p>...or using this approach:</p>

<pre><code>class Point2D
{

protected:

    double X, Y;

public:

    Point2D(const double x, const double y) : X(x), Y(y)) {}
    ...
};



class Point3D : public Point2D
{
    protected:
    double Z;

public:

   Point3D(const double x, const double y, const double z) : Point2D(x,y), Z(z) {}
...
};
</code></pre>

<p>We understand the coordinates as continuous variables, so it makes sense to express them using double values. A similar situation arises when working with matrices. However in this case templates are widely used...</p>

<p>This class is not only for single use, but it will be part of the library... And my second part of the question. How some ""measure"" functions should be implemented?</p>

<pre><code>template &lt;class T&gt;
T getDist(const Point2D &lt;T&gt; * p1, const Point2D&lt;T&gt; *p2)
{
....
}
</code></pre>

<p>or</p>

<pre><code>double  getDist(const Point2D &lt;T&gt; * p1, const Point2D&lt;T&gt; *p2)
{
....
}
</code></pre>

<p>Is it reasonable to write such function in general or for some specific type?</p>
","87234","","<p>Why repeat yourself? Most of the content of those classes and functions will be the same.</p>

<p>Something like this works much better:</p>

<pre><code>template &lt;std::size_T N, typename T&gt;
class Point
{
public:
    Point()
    {
        std::fill_n(mData, N, T());   
    }

    explicit Point(const T&amp; pX) :
    mData[0](pX)
    {
        // or some variant (enable_if also works)
        static_assert(N == 1, ""X constructor only usable in 1D"");
    }


    explicit Point(const T&amp; pX, const T&amp; pY) :
    mData[0](pX),
    mData[1](pY),
    {
        static_assert(N == 2, ""XY constructor only usable in 2D"");
    }

    // incomplete, left as exercise for reader. :P

private:
    T mData[N];
};
</code></pre>

<p>And you just use loops for the functions:</p>

<pre><code>template &lt;std::size_T N, typename T&gt;
T getDist(const Point&lt;N, T&gt;&amp; pFirst, const Point&lt;N, T&gt;&amp; pSecond)
{
    // generic, compiler will unroll loops
}
</code></pre>
"
"<p>Basically, if I don't do all objects get a copy of all the enum values?</p>

<p>ps: as always, references for your answer are always welcome...</p>
","87234","","<p>You can't, it doesn't make sense. Each instance doesn't store the values, they would store <em>a</em> value that happens to come from the enumerated values.</p>
"
"<p>The proper way to iterate is to use iterators. However, I think by erasing, the iterator is invalidated.</p>

<p>Basically what I want to do is:</p>

<pre><code>for(iterator it = begin; it != end; ++it)
{
    if(it-&gt;somecondition() )
    {
     erase it
    }

}
</code></pre>

<p>How could I do this without v[i] method?</p>

<p>Thanks</p>

<pre><code>struct RemoveTimedEvent
{
    bool operator()(const AguiTimedEvent&amp; pX, AguiWidgetBase* widget) const 
    {
        return pX.getCaller() == widget;
    }
};

void AguiWidgetContainer::clearTimedEvents( AguiWidgetBase* widget )
{
    std::vector&lt;AguiTimedEvent&gt;::iterator it = std::remove_if(timedEvents.begin(),
        timedEvents.end(), RemoveTimedEvent());
    timedEvents.erase(it, timedEvents.end());

}
</code></pre>
","87234","","<p><code>erase()</code> returns a new iterator:</p>

<pre><code>for(iterator it = begin; it != end;)
{
    if (it-&gt;somecondition())
    {
        it = vec.erase(it);
    }
    else
    {
        ++it;
    }
}
</code></pre>

<p>A better method might be to combine <code>std::remove_if</code> and <code>erase()</code>. You change from being O(N<sup>2</sup>) (every element gets erased) to O(N):</p>

<pre><code>iterator it = std::remove_if(begin, end, pred);
vec.erase(it, vec.end());
</code></pre>

<p>Where <code>pred</code> is you predicate, such as:</p>

<pre><code>struct predicate // do choose a better name
{
    bool operator()(const T&amp; pX) const // replace T with your type
    {
        return pX.somecondition();
    }
};

iterator it = std::remove_if(begin, end, predicate());
vec.erase(it, vec.end());
</code></pre>

<p>In your case, you can make it pretty general:</p>

<pre><code>class remove_by_caller
{
public:
    remove_by_caller(AguiWidgetBase* pWidget) :
    mWidget(pWidget)
    {}

    // if every thing that has getCaller has a base, use that instead
    template &lt;typename T&gt; // for now a template
    bool operator()(const T&amp; pX) const
    {
        return pX.getCaller() == mWidget;
    }

private:
    AguiWidgetBase* mWidget;
};

std::vector&lt;AguiTimedEvent&gt;::iterator it =
    std::remove_if(timedEvents.begin(), timedEvents.end(), remove_by_caller(widget));
timedEvents.erase(it, timedEvents.end());
</code></pre>

<p>Note lambda's exist to simplify this process, both in Boost and C++0x.</p>
"
"<p>I need to know the identity of the current thread to keep track of which threads are making certain requests to a shared data structure.</p>
","87234","","<p>You can use <code>boost::this_thread::get_id()</code> to get a <code>boost::thread::id</code> representing the thread.</p>

<p>I don't think you can get a pointer to a <code>boost::thread</code> object, because the thread doesn't necessarily have one attached. And it cannot make one because it might have one attached.</p>
"
"<p>I think this has happened to me before. This is<code>A3.txt</code>:</p>

<pre><code>%INSERT
MARK 29 
DAVID 21
JOHN 44
JOHN 51
LARRY 39
MARK 21
DAVID 18
JOHN 28
MARK 35
DONALD 41
PHIL 26
</code></pre>

<p>Even though I use <code>sourcefile &gt;&gt; reader</code> at the end of the loop, the program keeps outputting <code>""reader: MARK""</code>, meaning the <code>sourcefile &gt;&gt; reader;</code> statement isn't working (i.e., it keeps getting the same input over and over again, or it's not getting any input). </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

using namespace std;  

struct data
{
 string name;
 int id;
 data* link;
};

data* start;
data* node;
ifstream sourcefile;

int main()
{
 data* start = new data;

 start -&gt; link = NULL;

 string input;
 string reader;
 sourcefile.open(""A3.txt"");

 bool firstnode = true;

 sourcefile &gt;&gt; input;

 node = start;

 cout &lt;&lt; ""Recieved command: "" &lt;&lt; input &lt;&lt; endl;

 if(input == ""%INSERT"")
 {
  // unlike the other ones, this function keeps reading until it hits another command
  sourcefile &gt;&gt; reader;

  cout &lt;&lt; ""Insert name: "" &lt;&lt; reader &lt;&lt; endl;


  // iterates through the link list until it hits the final node
  while(node -&gt; link != NULL)
    node = node -&gt; link;


  while(reader[0] != '%')
  {
   if(firstnode)
    start -&gt; link = new data;
   else
    node -&gt; link = new data;


   sourcefile &gt;&gt; node -&gt; name;
   sourcefile &gt;&gt; node -&gt; id;
   node -&gt; link = NULL;

   sourcefile &gt;&gt; reader;
   cout &lt;&lt; ""reader: "" &lt;&lt; reader &lt;&lt; endl;
  }
 }
 else
  return 0;

}
</code></pre>

<p>Also... offtopic. The compiler said that switch statements can't be used with strings, is that really true, or was I doing something else wrong?</p>
","87234","","<p>Right now your code does too much. Programs solve a collection of sub-problems in an attempt to solve a larger problem. This leads to the <a href=""http://en.wikipedia.org/wiki/Single_responsibility_principle"" rel=""nofollow"">Single Responsibility Principle</a>.</p>

<p>What that means is that one object (class, function, etc.) should solve one problem <em>only</em>. But right now that's not happening. For example, <code>main</code> trivially does more than one thing: it manages nodes for the list (incorrectly, too! Nothing is ever deleted!), and gets input from the user. This is too much.</p>

<p>Rather, split things up. You should make a <code>list</code> class that manages nodes, and then <code>main</code> should <em>use</em> it. Note the difference here: <code>main</code> no longer solves that problem, it utilizes something that does.</p>

<p>So with this in mind, it quickly follows the more we split things up, the easier it is to be correct, fix, and maintain. The act of taking code and splitting it up is ""refactoring"". Let's do that.</p>

<p>First, we need a linked list to use. Normally we have <code>std::vector</code> (note: linked lists are generally the worse container there is) or <code>std::list</code>, but since your teacher is <strike>dumb</strike>misguided, he's making you write your own. Your assignment should be <em>either</em> write a list container or use a list container and read input, not both. (Again, in the real world we split things up; why teach people to mix them?)</p>

<p>You already have the basics down, it just needs to be encapsulated. (If you don't know classes yet, let me know and I'll expand there too; while we're at it, if you don't already you might want to get a <a href=""http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">good book</a> to teach yourself what your teacher isn't):</p>

<pre><code>// normally this should be a template so it can store anything,
// and yadda yadda (more features), but let's just make it basic
// this data class is what the linked list holds
struct data
{
    std::string name;
    int id;
};

class linked_list
{
public:
    linked_list() :
    mHead(0)
    {}

    // the magic: the destructor will always run 
    // on objects that aren't dynamically allocated,
    // so we're guaranteed our resources will be
    // released properly
    ~linked_list()
    {
        // walk through the list, free each node
        while (mHead)
        {
            node* toDelete = mHead; // store current head
            mHead = mHead-&gt;next; // move to next node

            delete toDelete; // delete old head
        }
    }

    void push_back(const data&amp; pData)
    {
        // allocate the new node
        node* newNode = new node(pData, mHead); 

        // insert
        mHead = newNode;
    }

    data pop_back()
    {
        // remove
        node* oldNode = mHead;
        mHead = mHead-&gt;next;

        // deallocate
        data d = oldNode-&gt;data;
        delete oldNode;
        return d;

        /*
        the above is *not* safe. if copying the data throws
        an exception, we will leak the node. better would be
        to use auto_ptr like this:

        // now the node will be deleted when the function ends, always
        std::auto_ptr&lt;node&gt; n(oldNode);

        // copy and return, or copy and throw; either way is safe
        return n-&gt;data;

        but who knows if your &lt;strike&gt;dumb&lt;/strike&gt;misguided
        would allow it. so for now, make it unsafe. i doubt
        he'd notice anyway.
        */
    }

private:
    // any class that manages memory (i.e., has a destructor) also needs to
    // properly handle copying and assignment.
    // this is known as The Rule of Three; for now we just make the class
    // noncopyable, so we don't deal with those issues.
    linked_list(const linked_list&amp;); // private and not defined means it
    linked_list&amp; operator=(const linked_list&amp;); // cannot be copied or assigned

    struct node
    {
        // for convenience, give it a constructor
        node(const data&amp; pData, node* pNext) :
        d(pData),
        next(pNext)
        {}

        data d; // data we store
        node* next; // and the next node
    };

    node* mHead; // head of list
};
</code></pre>

<p>Now you have a list to use. <code>main</code> will no longer be troubled with such things:</p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

using namespace std; // should generally be avoided

// your linked_list code

int main()
{
    // don't declare variables until you need them,
    // and avoid globals. (the previous rule helps)
    ifstream sourcefile(""A3.txt"");

    // check that it opened
    if (!sourceFile.is_open())
    {
        cerr &lt;&lt; ""could not open file"" &lt;&lt; endl;

        // EXIT_FAILURE is inside &lt;cstdlib&gt;
        return EXIT_FAILURE;
    }

    string input;
    sourcefile &gt;&gt; input;

    cout &lt;&lt; ""Received command: "" &lt;&lt; input &lt;&lt; endl;

    linked_list datalist;
    if (input == ""%INSERT"")
    {
        string reader;
        sourcefile &gt;&gt; reader;

        cout &lt;&lt; ""Insert name: "" &lt;&lt; reader &lt;&lt; endl;

        while (reader[0] != '%')
        {
            data d;
            d.name = reader;
            sourcefile &gt;&gt; d.id;

            datalist.push_back(d);

            sourcefile &gt;&gt; reader;
            cout &lt;&lt; ""reader: "" &lt;&lt; reader &lt;&lt; endl;
        }
    }
}
</code></pre>

<p>Note how much easier it is to read. You no longer manage a list, but simply use it. And the list manages itself, so you never leak anything.</p>

<p>This is the route you'll want to take: wrap things into working objects that solve one problem correctly, and use them together.</p>
"
"<p>Why is it that I'm finding the size of int and long int are shown to be 4 bytes? Is it that the int is by default long int?</p>
","87234","","<p>They just happen to have the same size.</p>

<p><a href=""http://stackoverflow.com/questions/271076/what-is-the-difference-between-an-int-and-a-long-in-c/271132#271132"">This post</a> summarizes what you can expect out of data types with respect to size and range.</p>
"
"<p>Why do some people use <code>while(true){}</code> blocks in their code? How does it work?</p>
","87234","","<p>It's just a loop that never ends on its own, known as an ""infinite loop"". (Often times, that's a bad thing.)</p>

<p>When it's empty, it serves to halt the program indefinitely*; otherwise there's typically some condition in the loop that, when true, breaks the loop:</p>

<pre><code>while (true)
{
    // ...

    if (stopLoop)
        break;

    // ...
}
</code></pre>

<p>This is often cleaner than an auxiliary flag:</p>

<pre><code>bool run = true;
while (run)
{
    // ...

    if (stopLoop)
    {
        run = false;
        continue; // jump to top
    }

    // ...
}
</code></pre>

<p>Also note some will recommend <code>for (;;)</code> instead, for various reasons. (Namely, it might get rid of a warning akin to ""conditional expression is always true"".)</p>

<p>*In most languages.</p>
"
"<p>I would like to have the closest number below 1.0 as a floating point. By reading wikipedia's article on <a href=""http://en.wikipedia.org/wiki/IEEE_754-1985#Double-precision_64_bit"" rel=""nofollow"">IEEE-745</a> I have managed to find out that the binary representation for 1.0 is <code>3FF0000000000000</code>, so the closest double value is actually <code>0x3FEFFFFFFFFFFFFF</code>.</p>

<p>The only way I know of to initialize a double with this binary data is this:</p>

<pre><code>double a;
*((unsigned*)(&amp;a) + 1) = 0x3FEFFFFF;
*((unsigned*)(&amp;a) + 0) = 0xFFFFFFFF;
</code></pre>

<p>Which is rather cumbersome to use.</p>

<p>Is there any better way to define this double number, if possible as a constant?</p>
","87234","","<p>If you make a <code>bit_cast</code> and use <a href=""http://www.boost.org/doc/libs/1_44_0/boost/cstdint.hpp"" rel=""nofollow"">fixed-width integer types</a>, it can be done safely:</p>

<pre><code>template &lt;typename R, typename T&gt;
R bit_cast(const T&amp; pValue)
{
    // static assert R and T are POD types

    // reinterpret_cast is implementation defined,
    // but likely does what you expect
    return reinterpret_cast&lt;const R&amp;&gt;(pValue);
}

const uint64_t target = 0x3FEFFFFFFFFFFFFFL;
double result = bit_cast&lt;double&gt;(target);
</code></pre>

<p>Though you can probably just <a href=""http://stackoverflow.com/questions/3947159/define-double-constant-as-hexadecimal/3947197#3947197"">subtract <code>epsilon</code> from it</a>.</p>
"
"<p>I've got a code that as you can see I can write in either of two following ways, the matter is the only difference is since in second function the parameter is declared as non-constant I can use that instead of declaring a new variable(num1 in first function) but I' curious which one would be more suited if there would be any difference between output assembly codes generated by compiler for each one:</p>

<pre><code>void Test(const long double input){
 long double num=(6.0*input);
 long double num1=9.0;
 for (int i=0;i&lt;5;i++)
  num1*=num;
 cout &lt;&lt;num1&lt;&lt;'\n';
}

void Test(long double input){
 long double num=(6.0*input);
 input=9.0;
 for (int i=0;i&lt;5;i++)
  input*=num;
 cout &lt;&lt;input&lt;&lt;'\n';
}
</code></pre>
","87234","","<p>Like this:</p>

<pre><code>void Test(long double input)
{
    long double factor = 6.0 * input;
    long double result = 9.0;

    for (int i = 0; i &lt; 5; ++i)
        result *= factor;

    cout &lt;&lt; result &lt;&lt; '\n';
}
</code></pre>

<p>Note we put spaces between things for the same reason weputspacesbetweenwords and give things meaningful names, so it's actually readable...</p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence"">Is it possible to write a C++ template to check for a function&#39;s existence?</a>  </p>
</blockquote>



<p>say there are 2 classes:</p>

<pre><code>struct A{ int GetInt(){ return 10; } };
struct B{ int m; };
</code></pre>

<p>I want to use object of type A or B in following function</p>

<pre><code>tempate&lt; typename T &gt;
int GetInt( const T &amp; t )
{
   //if it's A, I'll call: return t.GetInt();
   //if its' B, I'll call: return t.m;
}
</code></pre>

<p>Now, because there are whole bunch of classes, some contain GetInt(), some don't, I don't want to write specialization for each type, I only want to distinguish them by '<strong>containing GetInt() or not in compile time</strong>', how should I do this ?</p>
","87234","","<p>Stealing from <a href=""http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence/264088#264088"">here</a>, and assuming you fix your code so <code>GetInt</code> is const, we get:</p>

<pre><code>HAS_MEM_FUNC(GetInt, has_GetInt);

template &lt;bool B&gt;
struct bool_type
{
    static const bool value = B;
};

typedef bool_type&lt;true&gt; true_type;
typedef bool_type&lt;false&gt; false_type;

namespace detail
{
    template &lt;typename T&gt;
    int get_int(const T&amp; pX, true_type)
    {
        return pX.GetInt();
    }

    template &lt;typename T&gt;
    int get_int(const T&amp; pX, false_type)
    {
        return pX.m;
    }
}

template &lt;typename T&gt;
int get_int(const T&amp; pX)
{
    return detail::get_int(pX,
                            has_GetInt&lt;T, int (T::*)() const&gt;::value);
}
</code></pre>

<p>This is pretty awful design though. You should fix the problem rather than apply a patch.</p>
"
"<p>Does anyone know a <em>simple</em> way to check if two polygons, especially rectangles, are colliding?  I found a simple way to see if two are touching by just checking if any lines on the two rectangles are colliding, but this will not work if one polygon is in another.  Does anyone know a more efficient way to do this or just a way that works?</p>

<p>Also, can someone please give me a formula for it or something like that and not just your thoughts on the subject.</p>

<p>Thanks</p>
","87234","","<p>Look up the Separating Axis Theorem. There's a tutorial <a href=""http://www.metanetsoftware.com/technique/tutorialA.html"">here</a>.</p>

<p>It's quick, elegant, robust, not too hard, and has lots of resources.</p>
"
"<p>I have made a c++ wrapper for an allegro bitmap. I create an AguiBitmap as a global variable for testing, then  later I say,</p>

<pre><code>bitmap = AguiBitmap(""somepath"");
</code></pre>

<p>after allegro has been initialized.</p>

<p>However, when I close the application, it crashes in the bitmap's destructor. If I do al_destroy_bitmap(0); its fine, but there cant be anything wrong with my bitmap pointer because I use it to render.</p>

<pre><code>AguiBitmap::~AguiBitmap()
{
        al_destroy_bitmap(nativeBitmapPtr); 
}

AguiBitmap::AguiBitmap()
{
    nativeBitmapPtr = 0;
    width = 0;
    height = 0;
}

AguiBitmap::AguiBitmap( char *filename )
{

    if(!filename)
    {
        nativeBitmapPtr = 0;
        return;
    }

    nativeBitmapPtr = al_load_bitmap(filename);

    if(nativeBitmapPtr)
    {

        width = al_get_bitmap_width(nativeBitmapPtr);
        height = al_get_bitmap_height(nativeBitmapPtr);
    }
    else
    {
        width = 0;
        height = 0;
    }
}

AguiBitmap::AguiBitmap( std::string filename )
{
    AguiBitmap((char*)filename.c_str());
}

ALLEGRO_BITMAP* AguiBitmap::getBitmap() const
{
    return nativeBitmapPtr;
}

int AguiBitmap::getWidth() const
{
    return width;
}

int AguiBitmap::getHeight() const
{
    return height;
}
</code></pre>

<p>Thanks</p>
","87234","","<p>Is Allegro being shut down in <code>main</code>? If so, then when the global destructs <em>after</em> <code>main</code>, I suspect <code>al_destroy_bitmap</code> should fail.</p>

<p>And like James says, you're breaking the rule of three; this probably plays a role. This <code>bitmap = AguiBitmap(""somepath"");</code> will call <code>al_destroy_bitmap(nativeBitmapPtr);</code> when the temporary dies; does this leave <code>bitmap</code> with a bad pointer?</p>

<hr>

<p>Aside from the question, why do you have a <code>char*</code> overload of the constructor? That's nasty. The C-style cast is acting like a <code>const_cast</code>, that should be a hint something is wrong. <code>std::string</code> can initialize from literals anyway, so I'm not sure why you even have two. Just have one, and don't cast any const's away. </p>
"
"<pre><code>class Base
{
   protected: 
      int data;
   public:
      virtual int getData() { return data; }
      virtual void setData(int value) { data = value; }
};

class Child : protected Base
{
   public:
   void setData(int value)
   {
       Base::setData(value);
       cout &lt;&lt; ""Data is set.\n"";
   }
};

class Worker
{
   private:
      Child obj;
   public:
      void setGlobalData(int val)
      {
         obj.setData(val); // This is normal
      }

      int getGlobalData()
      {
         return obj.getData();  // Line 140, Error
      }
};
</code></pre>

<p>Error during compiling of file with Worker class:</p>

<pre><code>Base.hpp: In member function ‘int Worker::getGlobalData()’:
Base.hpp:22:19: error: ‘virtual int Base::getData()’ is inaccessible
Worker.cpp:140:34: error: within this context
Worker.cpp:140:34: error: ‘Base’ is not an accessible base of ‘Child’
</code></pre>
","87234","","<p>Did you actually make it a public base class?</p>

<pre><code>//            vvvvvv important
class Child : public Base
</code></pre>

<p>Otherwise it's private, and you get errors similar to what you have, namely:</p>

<blockquote>
  <p>‘Base’ is not an accessible base of ‘Child’</p>
</blockquote>
"
"<p>I need to define a template struct such that:</p>

<pre><code>element&lt;T&gt;::type
</code></pre>

<p>is of type:</p>

<pre><code>T::element_type 
</code></pre>

<p>if T contains a (public) typedef named element_type, otherwise (if it does not contain such typedef)</p>

<pre><code>element&lt;T&gt;::type
</code></pre>

<p>is of type</p>

<pre><code>T::value_type 
</code></pre>

<p>if T is mutable and of type</p>

<pre><code>const T::value_type
</code></pre>

<p>if T is constant.</p>

<p>I am really struggling with this, any suggestion is very appreciated! :)</p>

<p>Thank you very much for your help in advance!</p>
","87234","","<p>Maybe something like:</p>

<pre><code>template &lt;typename T&gt;
struct has_element_type
{
    typedef char yes[1];
    typedef char no[2];

    template &lt;typename C&gt;
    static yes&amp; test(typename C::element_type*);

    template &lt;typename&gt;
    static no&amp; test(...);

    static const bool value = sizeof(test&lt;T&gt;(0)) == sizeof(yes);
};

template &lt;typename T&gt;
struct is_const
{
    static const bool value = false;
};


template &lt;typename T&gt;
struct is_const&lt;const T&gt;
{
    static const bool value = true;
};

template &lt;typename, bool&gt; // true -&gt; const
struct value_type_switch; 

template &lt;typename T&gt;
struct value_type_switch&lt;T, true&gt;
{
    typedef const typename T::value_type type;
};

template &lt;typename T&gt;
struct value_type_switch&lt;T, false&gt;
{
    typedef typename T::value_type type;
};

template &lt;typename, bool&gt; // true -&gt; has element_type
struct element_type_switch;

template &lt;typename T&gt;
struct element_type_switch&lt;T, true&gt;
{
    typedef typename T::element_type type;
};


template &lt;typename T&gt;
struct element_type_switch&lt;T, false&gt;
{
    typedef typename value_type_switch&lt;T, is_const&lt;T&gt;::value&gt;::type type;
};

template &lt;typename T&gt;
struct element
{
    typedef typename element_type_switch&lt;T,
                                    has_element_type&lt;T&gt;::value&gt;::type type;
};
</code></pre>

<p>This should of course be split up and organized.</p>
"
"<p>I have a class declaration in Utils.h:</p>

<pre><code>    class Utils {
 private:
     static boost::mutex outputMutex;
    };
</code></pre>

<p>In the cpp file:</p>

<pre><code>boost::mutex Utils::outputMutex = boost::mutex();
</code></pre>

<p>I get:</p>

<pre><code>Error 1 error C2248: 'boost::mutex::mutex' : cannot access private member declared in class 'boost::mutex'
</code></pre>

<p>If we look inside <code>boost/thread/win32/mutex.hpp</code> we see:</p>

<pre><code>namespace boost
{   
    class mutex:
        public ::boost::detail::underlying_mutex
    {

    // ...       

    public:
        mutex()
        {
            initialize();
        }
</code></pre>

<p>Does anyone know what I'm missing here? It used to compile OK on a different machine with VS2008.</p>

<p>Thank you.</p>
","87234","","<p>What you have is copy-initialization, and is equivalent to:</p>

<pre><code>boost::mutex Utils::outputMutex(boost::mutex());
</code></pre>

<p>Which calls the copy-constructor. However, <code>mutex</code> is noncopyable. Just let it default construct:</p>

<pre><code>boost::mutex Utils::outputMutex;
</code></pre>
"
"<p>let's say i want to have a member variable for a pointer to std::vector but i do not want to specify what type of variable it stores. I want to access only those functions that are independant of it's actual generic type. is this possible with c++? something like this:</p>

<pre><code>class Foo{
public:
    void setVec(std::vector* someVec){
        myVec = someVec;
    };
    int getSize(){
        return myVec.size();
    };
private:
    std::vector* myVec;
};


int main(){
    Foo foo;
    vector&lt;int&gt; vec1;
    vector&lt;float&gt; vec2;
    foo.setVec(&amp;vec1);
    cout&lt;&lt;foo.getSize();
    foo.setVec(&amp;vec2);
    cout&lt;&lt;foo.getSize();
}
</code></pre>

<p>note: i do not want to template Foo and i want to use only a single instance of Foo with vectors of different type.</p>

<p>of course - if I could alter the class vector then i could create an untemplated baseclass</p>

<pre><code>class Ivector{
    virtual int size()=0;
};
</code></pre>

<p>and then make the </p>

<pre><code>class vector&lt;T&gt; : public IVector...
</code></pre>

<p>inherit from Ivector. but what do I do if i can't alter the class in question and the templated class does not have such an untemplated baseclass?</p>

<p>thanks!</p>
","87234","","<p>You could do this:</p>

<pre><code>class vector_container_base
{
public:
    ~vector_container_base() {}

    virtual std::size_t size() const = 0;
};

template &lt;typename T&gt;
class vector_container :
    public vector_container_base
{
public:
    typedef std::vector&lt;T&gt; vector_type;

    std::size_t size() const
    {
        return mVector.size();
    }

private:
    vector_type mVector;
};
</code></pre>

<p>And so on, but I doubt this is too useful in any real situation.</p>
"
"<p>Hi my program is supposed to display a solid red colored sphere in the center of the screen, all i am getting is the boundary of the sphere :</p>

<pre><code>int main(int argc, char **argv) {
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA);
  glutInitWindowSize(800,600); 
  glutInitWindowPosition(0,0);
  glutCreateWindow(""Sphere"");

  glutDisplayFunc(renderScene);
  glutReshapeFunc(changeSize);
  glutMainLoop();

  return 0;
}


void renderScene() {
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glColor3f(1.0f,0.0f,0.0f);

  glutSolidSphere(2.5, 50, 40);

  glutSwapBuffers();
}
</code></pre>
","87234","","<p>What do you mean ""boundary""?</p>

<p>Solid doesn't mean filled, it means the surface contains no openings. This is in contrast to <code>glutWireSphere</code>, which is just the wire frame.</p>
"
"<p>This is a very noobish mistake, but I dont know whats happening here.</p>

<p>There are loads of pimpl examples but I dont understand why this isn't working (this was one of the examples more or less but I dont see the difference).</p>

<p>I have a very simple Pimpl example, but it wont work.</p>

<pre><code>// Foo.hpp
#include &lt;boost/scoped_ptr.hpp&gt;

class Foo
{
 struct Bar;
 //boost::scoped_ptr&lt;Bar&gt; pImpl;
 Bar* pImpl;

public:
 Foo();
 ~Foo() {}

 int returnValue();

private:

};
</code></pre>

<p>and</p>

<pre><code>// Foo.cpp
#include ""foo.hpp""

struct Foo::Bar
{ 
 Bar() {}
 ~Bar() {}
 int value;
};

Foo::Foo() : pImpl(new Bar())
{
 pImpl-&gt;value = 7;
}

int Foo::returnValue() {
 return *pImpl-&gt;value;
}
</code></pre>

<p>Compiling this gives me the error.
C2100: illegal indirection.</p>

<p>Thanks.</p>
","87234","","<p><code>int returnValue()</code> should be a member function:</p>

<pre><code>//  vvvvv
int Foo::returnValue() {
 return pImpl-&gt;value; // no need to dereference, value isn't a pointer
}
</code></pre>

<hr>

<p>You need to define your constructor, copy-constructor, copy assignment operator, and destructor <em>after</em> the implementation class has been defined. (Otherwise the implicit destructor is dangerous, and <code>scoped_ptr</code> won't let you do that):</p>

<pre><code>// Foo.hpp
#include &lt;boost/scoped_ptr.hpp&gt;

class Foo
{
    struct Bar;
    boost::scoped_ptr&lt;Bar&gt; pImpl;

public:
    Foo();
    ~Foo();

    int returnValue(); // could be const (so should be)

private:
    // just disable copying, like scoped_ptr
    Foo(const Foo&amp;); // not defined
    Foo&amp; operator=(const Foo&amp;); // not defined
};
</code></pre>

<p>And:</p>

<pre><code>// Foo.cpp
#include ""foo.hpp""

struct Foo::Bar
{ 
    int value;
};

Foo::Foo() :
pImpl(new Bar())
{
    pImpl-&gt;value = 7;
}

Foo::~Foo()
{
    // okay, Bar defined at this point; scoped_ptr can work
}

int Foo::returnValue()
{
    return pImpl-&gt;value;
}
</code></pre>
"
"<p>A while ago I asked about std::string constants <a href=""http://stackoverflow.com/questions/2312860/correct-idiom-for-stdstring-constants"">http://stackoverflow.com/questions/2312860/correct-idiom-for-stdstring-constants</a>.</p>

<p>What I took away from that was <em>not</em> to use std::string constants but to use char string constants. So what the best idiom for that</p>

<pre><code>#define FOO ""foo""

const char * const FOO = ""foo"";

const char FOO[] = ""foo"";
</code></pre>

<p>Desirable features</p>

<ul>
<li>get length at compile time. 1 &amp; 3 but
not 2 (sizeof doesnt work on 2)</li>
<li>can be included in .h without linker
complaining. all (I think)</li>
<li>no multiple copies in .o, in linked
output. depends on compiler
(probably)</li>
</ul>

<p>So it seems like #3 is best but scott meyers says to use #2 (effective c++ item #1)</p>

<p>summary of answers</p>

<ol>
<li>use jolly complicated template code</li>
<li>use #3</li>
</ol>

<p>The template code feels like overkill. So for now I go with #3;</p>

<p>But I will ruminate on the template code, the macroized version makes it look OKish; but I dont like the fact that its not portable (who knows, maybe gcc will decide that its wrong too)</p>
","87234","","<p>This is just Alf's answer macro'd:</p>

<pre><code>#include &lt;iostream&gt;

#define string_constant(pName, pLiteral)                    \
        template &lt;typename = void&gt;                          \
        struct pName##_detail                               \
        {                                                   \
            static const char value[];                      \
        };                                                  \
                                                            \
        template &lt;typename T&gt;                               \
        const char pName##_detail&lt;T&gt;::value[] = pLiteral;   \
                                                            \
        typedef pName##_detail&lt;&gt; pName

string_constant(my_constant, ""this is a literal"");

int main()
{
    std::cout &lt;&lt; my_constant::value &lt;&lt; std::endl;
    std::cout &lt;&lt; sizeof my_constant::value &lt;&lt; std::endl;
}
</code></pre>

<p><a href=""http://codepad.org/RhoGq3bz"" rel=""nofollow"">codepad</a>. Doesn't seem to work in VS2010. :/</p>
"
"<p>I'm using boost::shared_ptr's and boost::dynamic_pointer_cast. I have a base class, an interface that inherits from that base class, and then a class that inherits from that one.</p>

<p>So A -> B -> C. I create an object of type C and it's stored as a shared_ptr of type A. Then I try and do a dynamic_pointer_cast to type B, but boost::dynamic_pointer_cast returns NULL.</p>

<p>When I do a boost::static_pointer_cast and use the pointer, it doesn't crash the program. But I would prefer if the dynamic cast worked.</p>

<p>Why is this happening?</p>

<p>EDIT: Here's a compact section of the code (otherwise it's too long to put here). Tell me if you need more than the header files.</p>

<pre><code>class A
{
public:
    virtual ~A();

    /** Contains other virtual functions and some static functions */

protected:
    A();
};

class B
{
public:
    /** Pure virtual functions */

    /** Note: No destructor is declared (when I next have
        access to the computer I'll try adding a virtual destructor) */

protected:
    B();
};

class C
{
public:
    C();

    virtual ~C();

    /** Implementation of pure virtual functions */
};
</code></pre>

<p>Also, the dynamic_pointer_cast for this same code works on another computer with the exact same classes. Which has me at a complete loss. The code also worked until about a week ago when I made a change. When I reverted the change, the problem still occurred.</p>
","87234","","<p>It's hard to say without your definitions of <code>A</code>, <code>B</code>, and <code>C</code>, along with your usage.</p>

<p>Compare your program to the following:</p>

<pre><code>#include &lt;boost/shared_ptr.hpp&gt;
#include &lt;iostream&gt;

struct A { virtual ~A() {} };
struct B : A {};
struct C : B {};

int main()
{
    boost::shared_ptr&lt;A&gt; x(new C);
    boost::shared_ptr&lt;B&gt; y(boost::dynamic_pointer_cast&lt;B&gt;(x));

    std::cout &lt;&lt; std::boolalpha
                &lt;&lt; (y.get() != 0) &lt;&lt; std::endl;
}
</code></pre>
"
"<p>I cant seem to find any useful information whether constructor delegates that are proposed for C++0x are already available in Visual Studio 2008 / 2010. I tried to use them and got pretty strange errors, but I can't test this in VS2010 currently. Can anyone tell me if they are available already?</p>

<p>cheers,</p>

<p>Tom</p>
","87234","","<p>They aren't available yet.</p>

<p>:(</p>
"
"<p>It is possible to pass uninitialized object to a parent class like in the following example</p>

<pre><code>class C
{
    public:
        C(int i): 
            m_i(i)
        {};

        int m_i;
}

class T
{
    public:
        T(C &amp; c):
            m_c(c)
        {
        };

        C &amp; m_c;
};


class ST : public T
{
    public:
        ST():
            T(m_ci),
            m_ci(999)
        {
        };

        C m_ci;
};
</code></pre>

<p>In <code>class T</code> constructor, <code>c</code> is a reference to uninitialized object. If <code>class T</code> were using <code>c</code> object during construction, this would possibly lead to an error. But since it's not, this compiles and works fine. My question is - does it brake some kind of paradigm or good design directives? If so, what are the alternatives, because I found it useful to allocate an object required by parent in a subclass.</p>

<p>On a side note, I wonder why it's not possible to change initialization order, so that base class constructor would be called after initialization of some members.</p>
","87234","","<p>You <em>can</em>, but you get undefined behavior.</p>

<p>In Boost's utilities, you'll find the <a href=""http://www.boost.org/doc/libs/1_44_0/libs/utility/base_from_member.html"" rel=""nofollow"">base-from-member idiom</a> created by <a href=""http://stackoverflow.com/users/29809/r-samuel-klatchko"">R. Samuel Klatchko</a>. Basically, you make a private base in the place of the private member. This base gets initialized first, and you can use it for other bases:</p>

<pre><code>// ...

class C_base
{
public:
    C_base(int i) :
    m_ci(i)
    {}

    C m_ci;
};


class ST :
    private C_base
    public T
{
    public:
        ST() :
            C_base(999),
            T(m_ci),
        {
        };
};
</code></pre>

<p>Boost's utility eliminates repeated code.</p>
"
"<p>Someone has given me the following C++ code snippet to try out - and now I have lost contact with them (its a long story). Anyway, it won't compile - I get an error </p>

<blockquote>
  <p>error C2512: 'mstream' : no appropriate default constructor available</p>
</blockquote>

<p>Can anyone explain why, and what is needed to fix it.</p>

<pre><code>class mstream : private ostream
{
  public:

  mstream&amp; operator &lt;&lt; (char *value)
  {
    printf (""[%s]\n"", value);
    return *this;
  }
  mstream&amp; operator &lt;&lt; (int value)
  {
    printf (""[%u]\n"", value);
    return *this;
  }

};
mstream g_mcout;
</code></pre>

<p><strong>EDIT: Oops, missed this out...</strong></p>

<pre><code>ostream&amp; mcout ()
{
  return g_mcout;
}
ostream&amp; SgDebug ()
{
  return g_mcout;
}
</code></pre>

<p><strong>FYI:</strong> the reason for this strange looking code is all to do with merging a C++ with a C program. The printf()'s will actually be changed to my_printf()'s which do a wide variety of custom things.</p>
","87234","","<p><code>ostream</code> has no default constructor; the implicitly created default constructor for <code>mstream</code> is invalid because of it. You need to provide the <code>ostream</code> with a stream buffer:</p>

<pre><code>class mstream : private ostream
{
public:
    mstream() :
    ostream(/* whatever you want */)
    {}

    /* Maybe this is more appropriate:

    mstream(std::streambuf* pBuffer) :
    ostream(pBuffer)
    {}

    */

    // ...
};
</code></pre>

<p>So it can construct. What you put there depends on what you're trying to do.</p>
"
"<p>Is there any advantage defining an array's size to be a multiple of 8, if using 64 bit UNIX OS? I am intended to use this array for loading data from shared memory. So dependencies may exist on the operating system and the page size.</p>
","87234","","<p>Doesn't matter. Your compiler knows whether or not it wants padding there, so let it decide. Don't mud up your code because of guess-work.</p>

<p>Get your program working <em>first</em>, then care about performance with a profiler.</p>
"
"<p>We all know the basic rules for static array:</p>

<pre><code>int size = 20;
char myArray[size];
</code></pre>

<p>is not legal.
And.</p>

<pre><code>const int size = 20;
char myArray[size];
</code></pre>

<p>is OK.</p>

<p>But, what about this.</p>

<pre><code>int f(const int size)
{
    char myArr[size];
}

void main()
{
   f(2);
   f(1024);
}
</code></pre>

<p>MSVC says it is an error, gcc seems to compile and execute it fine.</p>

<p>Obviously, it is not portable, but should it be accepted?</p>

<p>Which compiler does the right thing in that situation?</p>

<p>Also, if it is permited by the compiler, should it be permited by good programming standards/practice?</p>

<p>EDITED:
The idea is that I would want stack allocation for the speed, but I would not know at compile time the size of the array.
I know that there is some other solutions, and that stack alloc would probably not be a significative optimization, but I think it is an interesting usage.</p>
","87234","","<p>No. C++ has no variable-length arrays. C99 does, and gcc allows it via extension.</p>

<p>Use a <code>std::vector</code>.</p>

<hr>

<p>Assuming you have profiled your application and found this to be a bottleneck, write a custom allocator that allocates from the stack and use that. If not, there's not a problem. </p>

<p>Stack allocation is very fast, but this likely isn't going to be a main concern in a real application. (You should have a custom memory management scheme in place that will performance close in speed to stack allocation.)</p>
"
"<p>I have the following code, which doesn't compile:</p>

<pre><code>int *p = new(nothrow) int;
delete (nothrow) p; //Error
</code></pre>

<p>The error I get is: </p>

<blockquote>
  <p>error C2440: 'delete' : cannot convert from 'const std::nothrow_t' to 'void*'</p>
</blockquote>

<p>Does a <code>nothrow</code> version of <code>delete</code> exist? If so, how can I invoke it?</p>

<hr>

<p>In C++: The Complete Reference, it's given that it exists but I saw different opinions online, hence the confusion.</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/30hb2y79%28v=VS.90%29.aspx"">MSDN</a> also talks about its existence, but I couldn't find how it can be used in code.</p>

<p><a href=""http://www.velocityreviews.com/forums/t457132-delete-nothrow.html"">Here</a>, some people are saying that there is no such thing.</p>
","87234","","<p>A <code>std::nothrow_t</code> deallocation function exists, but you cannot call it with a <code>delete</code> expression.</p>

<p>The deallocation function is there for completeness. If a <code>new</code> expression fails because of an exception, the compiler needs to free the memory it allocated via <code>operator new</code> with a <strong>matching</strong> call to <code>operator delete</code>. So there needs to be an <code>operator delete</code> that accepts a <code>std::nothrow_t</code>, to allow this.</p>

<p>(That is, in general, a <code>new</code> expression with the form <code>new (args...) T</code> will allocate memory with a call to <code>operator new(sizeof(T), args...)</code>. To ""match"" means to call <code>operator delete</code> with the same arguments, except the first.)</p>

<p>Note you can call the operator directly: <code>operator delete(memory, std::nothrow);</code>. However, a <code>delete</code> expression never calls a global deallocation function with additional parameters.</p>

<hr>

<p>So you can ""call"" it with:</p>

<pre><code>struct always_throw
{
    always_throw() { throw std::exception(); }
};

new (std::nothrow) always_throw;
</code></pre>

<p>At some point, this will allocate memory with a call to:</p>

<pre><code>void* __memory = operator new(sizeof(always_throw), std::nothrow);
</code></pre>

<p>Since the initialization of the object throws, the compiler needs to free the allocated memory with a matching deallocation function, so it does:</p>

<pre><code>operator delete(__memory, std::nothrow);
</code></pre>

<p>Calling the <code>std::nothrow_t</code> version.</p>
"
"<p>Can I call a non-member static templated function from a static member function where the definition is split into header and cpp:</p>

<pre><code>// zero.cpp

class Zero
{
    static void zero() { one(5); }
};

// one.h

template &lt;typename T&gt;
static void one(T&amp; var);

// one.cpp

template &lt;typename T&gt;
void one(T&amp; var) { }

// main.cpp

...

Zero::zero()

...
</code></pre>

<p>I'm having problems getting this to link, I keep getting undefined reference to the function I'm trying to define in one.cpp.</p>

<p>Initially I thought it was due to a problem with namespacing, but all files are now in the same namespace. Am I doing anything fundamentally wrong here?</p>
","87234","","<p>Template definitions need to be visible at the point of instantiation. That is, it needs to be in the header somehow:</p>

<pre><code>// one.hpp

template &lt;typename T&gt;
static void one(T&amp; var)
{
    // definition visible in header
}
</code></pre>

<p>Though I'm not sure why you'd want it to be static.</p>
"
"<p>I recently stumbled into this this C++/Lua error</p>

<pre><code>int function_for_lua( lua_State* L )
{
   std::string s(""Trouble coming!"");
   /* ... */
   return luaL_error(L,""something went wrong"");
}
</code></pre>

<p>The error is that <code>luaL_error</code> use <code>longjmp</code>, so the stack is never unwound and <code>s</code> is never destructed, leaking memory. There are a few more Lua API's that fail to unwind the stack.</p>

<p>One obvious solution is to compile Lua in C++ mode with exceptions.  I, however, cannot as Luabind needs the standard C ABI.</p>

<p>My current thought is to write my own functions that mimic the troublesome parts of the Lua API:</p>

<pre><code>// just a heads up this is valid c++.  It's called a function try/catch.
int function_for_lua( lua_State* L )
try
{
   /* code that may throw Lua_error */
}
catch( Lua_error&amp; e )
{
   luaL_error(L,e.what());
}
</code></pre>

<p>So my question: Is <code>function_for_lua</code>'s stack properly unwound. Can something go wrong?</p>
","87234","","<p>If I understand correctly, with <code>Luabind</code> functions that throw exceptions are properly caught and translated anyway. (See <a href=""http://www.rasterbar.com/products/luabind/docs.html#exceptions"" rel=""nofollow"">reference</a>.)</p>

<p>So whenever you need to indicate an error, just throw a standard exception:</p>

<pre><code>void function_for_lua( lua_State* L )
{
    std::string s(""Trouble coming!"");
    /* ... */

    // translated into lua error
    throw std::runtime_error(""something went wrong"");
}
</code></pre>

<p><sub>
Disclaimer: I've never used Lubind.
</sub></p>
"
"<p>I'd like to create a class that is associated to another class in some sort of parent-child relationship. For this the ""child"" class needs a reference to it's parent.</p>

<p>For example:</p>

<pre><code>template &lt;typename T&gt;
class TEvent {
    private: T* Owner;
    public: TEvent(T* parent) : Owner(parent) {}
};

class Foo {
    private: TEvent&lt;Foo&gt; Froozle; // see below
};
</code></pre>

<p>Now the problem is that I can't initialize the <code>Froozle</code> instance directly, nor using the instanciation list of Foo's constructor, because <code>this</code> references are not allowed there. Apart from adding another method <code>setParent(T*)</code> (which I don't like too much because it means that I have to leave the <code>TEvent&lt;&gt;</code> instance in an invalid state), is there a way to achieve this?</p>
","87234","","<p>If you're looking to suppress the warning, just do this:</p>

<pre><code>class Foo
{
public:
    Foo() :
    Froozle(get_this())
    {}

private:
    Foo* get_this()
    {
        return this;
    }

    TEvent&lt;Foo&gt; Froozle; // see below
};
</code></pre>

<p>The indirection is enough to stop it.</p>
"
"<p>Hii , I am new to C++ programming and need some help regarding the code i wrote below....
Its a basic exception handling program </p>

<pre><code>#include&lt;iostream&gt;

class range_error
 {
      public:
    int i;
    range_error(int x){i=x;}
 } 

 int compare(int x)
  {
              if(x&lt;100)
                  throw range_error(x);
             return x;               
  }                

 int main()
  {
     int a;
     std::cout&lt;&lt;""Enter a  "";
     std::cin&gt;&gt;a;
     try
      {
         compare(a);        
         }
       catch(range_error)
        {
            std::cout&lt;&lt;""Exception caught"";
            }
      std::cout&lt;&lt;""Outside the try-catch block"";
     std::cin.get();
    return 0;                 
}      
</code></pre>

<p>When i compile this ... i get this ...</p>

<p>New types may not be defined in a return type at line 11.(at the start of compare function).</p>

<p>Please explain me what is wrong...</p>
","87234","","<pre><code>class range_error
 {
      public:
    int i;
    range_error(int x){i=x;}
 }; // &lt;-- Missing semicolon.

 int compare(int x)
  {
              if(x&lt;100)
                  throw range_error(x);
             return x;               
  }      
</code></pre>

<hr>

<p>Here's how your code should probably look:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

// exception classes should inherit from std::exception,
// to provide a consistent interface and allow clients
// to catch std::exception as a generic exception
// note there is a standard exception class called
// std::out_of_range that you can use.
class range_error : 
    public std::exception 
{
public:
    int i;

    range_error(int x) :
    i(x) // use initialization lists
    {}
}; 

// could be made more general, but ok
int compare(int x)
{
    if (x &lt; 100) // insertspacesbetweenthingstokeepthemreadable
        throw range_error(x);

    return x;               
}                

int main()
{
    int a;
    std::cout&lt;&lt;""Enter a  "";
    std::cin&gt;&gt;a;

    try
    {
        compare(a);        
    }
    catch (const range_error&amp; e) // catch by reference to avoid slicing
    {
        std::cout &lt;&lt; ""Exception caught, value was "" &lt;&lt; e.i &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; ""Outside the try-catch block"";
    std::cin.get();

    return 0; // technically not needed, main has an implicit return 0         
}
</code></pre>
"
"<p>How do I get a reference to a ""get""-function for a specific tuple instance?</p>

<p>My best try is given below but does not compile against g++4.5.1</p>

<pre><code>#include &lt;tuple&gt;
#include &lt;string&gt;

typedef std::tuple&lt;int,std::string&gt; Tuple;
auto t=(std::string&amp; (Tuple&amp;))(std::get&lt;1,Tuple&gt;);
</code></pre>

<p>The compiler error is:</p>

<pre><code>a.cc:5: error: invalid cast to function type ‘std::string&amp;(Tuple&amp;)’ 
a.cc:5: error: unable to deduce ‘auto’ from ‘&lt;expression error&gt;’
</code></pre>

<p>I would like to use the function reference as an input to some stl-algorithms. I am actually a bit surprised on how non-trivial this seems to be for me.</p>
","87234","","<p>I think you want:</p>

<pre><code>namespace detail
{
    template &lt;std::size_t I, typename... Types&gt;
    decltype(&amp;std::get&lt;I, Types...&gt;) get_function(std::tuple&lt;Types...&gt;*)
    {
        return &amp;std::get&lt;I, Types...&gt;;
    }
}

template &lt;std::size_t I, typename Tuple&gt;
decltype(detail::get_function&lt;I&gt;((Tuple*)nullptr)) get_function()
{
    return detail::get_function&lt;I&gt;((Tuple*)nullptr);
}

auto t = get_function&lt;I, Tuple&gt;();
</code></pre>

<p>Kind of ugly. Surely there's a better way, but that's all I have for now.</p>
"
"<p>When a expression is evaluated in C/C++, does it follow BODMAS [Bracket open Division Multiply Addition Substraction] rule? If not then how they are evaluated?</p>

<p>EDIT: More clearly, If the following expression is evaluated  according to BODMAS rule,</p>

<p>(5 + 3)/8*9</p>

<p>First what is in brackets is processed.</p>

<p>8/8*9.</p>

<p>Then Division is done.</p>

<p>1*9</p>

<p>And then multiplication and so on.</p>
","87234","","<p>There are far more operators than that. You can find a precedence tables for <a href=""http://www.cppreference.com/wiki/operator_precedence"" rel=""nofollow"">C++</a> and <a href=""http://www.difranco.net/compsci/C_Operator_Precedence_Table.htm"" rel=""nofollow"">C</a>.</p>

<p>But yes, you'll find it respects that. (Though I'm not sure it's exactly what you've said...)</p>
"
"<p>Just had a 'Fundamentals of Programming' lecture at uni and was told that the convention for using/declaring functions is to have the <code>main()</code> function at the top of the program, with functions/procedures below it and to use forward declarations to prevent compiler errors.</p>

<p>However, I've always done it the other way - functions at top <code>main()</code> at bottom and not using forward declarations and don't think I've ever seen it otherwise.</p>

<p>Which is right? Or is it more a case of personal preference? Some clarification would be hugely appreciated.</p>
","87234","","<p>It's up to you. Personally, I keep <code>main</code> on bottom because the times when I have other functions in there, it's either just one or two other little functions or a code snippet.</p>

<p>In real code, you'd have hopefully split your project up (having multiple ""unrelated"" functions in a file is bad) and so <code>main</code> would likely be nearly alone in the file. You'd just <code>#include</code> the things <code>main</code> needs to get things going and use them.</p>
"
"<p>If I make a pointer-to-base-member, I can convert it to a pointer-to-derived-member usually, but not when used within a template like Buzz below, where the first template argument influences the second one. Am I fighting compiler bugs or does the standard really mandate this not work?</p>

<pre><code>struct Foo
{
    int x;
};

struct Bar : public Foo
{
};

template&lt;class T, int T::* z&gt;
struct Buzz
{
};

static int Bar::* const workaround = &amp;Foo::x;

int main()
{
    // This works. Downcasting of pointer to members in general is fine.
    int Bar::* y = &amp;Foo::x;

    // But this doesn't, at least in G++ 4.2 or Sun C++ 5.9. Why not?
    // Error: could not convert template argument '&amp;Foo::x' to 'int Bar::*'
    Buzz&lt;Bar, &amp;Foo::x&gt; test;

    // Sun C++ 5.9 accepts this but G++ doesn't because '&amp;' can't appear in
    // a constant expression
    Buzz&lt;Bar, static_cast&lt;int Bar::*&gt;(&amp;Foo::x)&gt; test;

    // Sun C++ 5.9 accepts this as well, but G++ complains ""workaround cannot
    // appear in a constant expression""
    Buzz&lt;Bar, workaround&gt; test;

    return 0;
}
</code></pre>
","87234","","<p>It simply isn't allowed. According to §14.3.2/5:</p>

<blockquote>
  <p>The following conversions are performed on each expression used as a non-type template-argument. If a non-type template-argument cannot be converted to the type of the corresponding template-parameter then the program is ill-formed.<br>
  — for a non-type template-parameter of integral or enumeration type, integral promotions (4.5) and integral conversions (4.7) are applied.<br>
  — for a non-type template-parameter of type pointer to object, qualification conversions (4.4) and the array-to-pointer conversion (4.2) are applied.
  — For a non-type template-parameter of type reference to object, no conversions apply. The type referred to by the reference may be more cv-qualified than the (otherwise identical) type of the template argument. The template-parameter is bound directly to the template-argument, which must be an lvalue.<br>
  — For a non-type template-parameter of type pointer to function, only the function-to-pointer conversion (4.3) is applied. If the template-argument represents a set of overloaded functions (or a pointer to such), the matching function is selected from the set (13.4).<br>
  — For a non-type template-parameter of type reference to function, no conversions apply. If the template-argument represents a set of overloaded functions, the matching function is selected from the set (13.4).<br>
  — For a non-type template-parameter of type pointer to member function, no conversions apply. If the template-argument represents a set of overloaded member functions, the matching member function is selected from the set (13.4).<br>
  — <strong>For a non-type template-parameter of type pointer to data member, qualification conversions (4.4) are applied.</strong></p>
</blockquote>

<p>I've emphasized the conversion regarding pointer to data members. Note that your conversion (§4.11/2) is not listed. In C++0x, it remains the same in this regard.</p>
"
"<p><strong>Hi!</strong></p>

<p>I've used the following <strong>C</strong> macro, But in <strong>C++</strong> it can't automatically cast <code>void*</code> to <code>type*</code>.</p>

<pre><code>#define MALLOC_SAFE(var, size) { \
    var = malloc(size); \
    if (!var) goto error; \
}
</code></pre>

<p>I know, I can do something like this:</p>

<pre><code>#define MALLOC_SAFE_CPP(var, type, size) { \
    var = (type)malloc(size); \
    if (!var) goto error; \
}
</code></pre>

<p>But I don't want to rewrite a big portion of code, where <code>MALLOC_SAFE</code> was used.</p>

<p>Is there any way to do this without giving the type to the macro? Maybe some <strong>MSVC 2005</strong> <code>#pragma</code>/<code>__declspec</code>/other ?</p>

<p>p.s.: I can't use C compiler, because my code is part (one of hundreds modules) of the large project. And now it's on C++. I know, I can build my code separately. But it's old code and I just want to port it fast.</p>

<p>The question is about void* casting ;) If it's not possible, I'll just replace MACRO_SAFE with MACRO_SAFE_CPP</p>

<p><strong>Thank You!</strong></p>
","87234","","<p>To makes James' answer even dirtier, if you don't have <code>decltype</code> support you can also do this:</p>

<pre><code>template &lt;typename T&gt;
class auto_cast_wrapper
{
public:
    template &lt;typename R&gt;
    friend auto_cast_wrapper&lt;R&gt; auto_cast(const R&amp; x);

    template &lt;typename U&gt;
    operator U()
    {
        return static_cast&lt;U&gt;(mX);
    }

private:
    auto_cast_wrapper(const T&amp; x) :
    mX(x)
    {}

    auto_cast_wrapper(const auto_cast_wrapper&amp; other) :
    mX(other.mX)
    {}

    // non-assignable
    auto_cast_wrapper&amp; operator=(const auto_cast_wrapper&amp;);

    const T&amp; mX;
};

template &lt;typename R&gt;
auto_cast_wrapper&lt;R&gt; auto_cast(const R&amp; x)
{
    return auto_cast_wrapper&lt;R&gt;(x);
}
</code></pre>

<p>Then:</p>

<pre><code>#define MALLOC_SAFE(var, size)                      \
{                                                   \
    var = auto_cast(malloc(size));                  \
    if (!var) goto error;                           \
}
</code></pre>

<p>I expanded on this utility (in C++11) on <a href=""http://www.gmannickg.com/?p=28"">my blog</a>. Don't use it for anything but evil.</p>
"
"<p>What's the purpose of this pattern? What is it called? It looked very strange when I saw it the first time, though I have now seen it many times.</p>

<pre><code>template&lt;typename Derived&gt;
struct Base {
  //...
};

struct Example : Base&lt;Example&gt; {
  //...
};
</code></pre>
","87234","","<p>It's called the <a href=""http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"" rel=""nofollow"">Curiously Recurring Template</a> pattern, and allows for static polymorphism.</p>

<p>It's useful when you want to add functionality to a specific class, but want the utility to be usable in a generic case. By making the utility dependent on and use a template parameter, you can achieve both.</p>
"
"<p>I am developing a tool like memory leak detector. I can track the placement new but how can i track the placement delete. I did a lot of R &amp; D and i found that placement delete cant be called directly, it is called by constructor at the time of exception. So how can i keep the track of placement delete against placement new?</p>

<p>Any help would be appreciated......</p>
","87234","","<p>You don't, there's nothing to keep track of.</p>

<p>Placement new means <em>putting</em> an object at a memory location. The storage for it has already been allocated. You don't call any form of delete on the object itself because that's the job of where you got the storage from.</p>

<p>That is, in this:</p>

<pre><code>void* memory = operator new(sizeof(int)); // A
new (memory) int; // B
operator delete(memory); // C
</code></pre>

<p>A and C are what you should be tracking, not B.</p>
"
"<p>In C++ sometimes a variable will be defined, but not used. Here's an example - a function for use with <a href=""http://msdn.microsoft.com/en-us/library/5b6w5bwx%28VS.80%29.aspx""><code>COM_INTERFACE_ENTRY_FUNC_BLIND</code></a> ATL macro:</p>

<pre><code>HRESULT WINAPI blindQuery( void* /*currentObject*/, REFIID iid, void** ppv, DWORD_PTR /*param*/ ) 
{
    DEBUG_LOG( __FUNCTION__ ); //DEBUG_LOG macro expands to an empty string in non-debug
    DEBUG_LOG( iid );
    iid; // &lt;&lt;&lt;&lt;&lt;&lt;&lt;----silence compiler warning
    if( ppv == 0 ) {
        return E_POINTER;
    }
    *ppv = 0;
    return E_NOINTERFACE;
}
</code></pre>

<p>In the above example <code>iid</code> parameter is used with <code>DEBUG_LOG</code> macro that expands into an empty string in non-debug configurations. So commenting out or removing the <code>iid</code> variable name in the signature is not an option. When non-debug configurations are being compiled the compiler spawns a <code>C4100: 'iid' : unreferenced formal parameter</code> warning, so in order to silence the warning the <code>iid;</code> statement that is believed to be a no-op is added.</p>

<p>The question is the following: if we have any of the following declarations:</p>

<pre><code> CSomeType variableName; //or
 CSomeType&amp; variableName; //or
 CSomeType* variableName;
</code></pre>

<p>will the following statement in C++ code:</p>

<pre><code>variableName;
</code></pre>

<p>be a no-op at all times independent of what <code>CSomeType</code> is?</p>
","87234","","<p>Yes, but you'll likely get another warning.</p>

<p>The standard way of doing this is: <code>(void)iid;</code>.</p>

<hr>

<p>Very technically, this could still load <code>iid</code> into a register and do nothing. Granted that's extremely stupid on the compilers part (I doubt any would ever do that, if it does delete the compiler), but it's a more serious issue if the expression to be ignored is something concerning observable behavior, like calls to IO functions or the reading and writing of <code>volatile</code> variables.</p>

<p>This brings up an interesting question: Can we take an expression and <em>completely</em> ignore it?</p>

<p>That is, what we have now is this:</p>

<pre><code>#define USE(x) (void)(x)

// use iid in an expression to get rid of warning, but have no observable effect
USE(iid); 

// hm, result of expression is gone but expression is still evaluated
USE(std::cout &lt;&lt; ""hmmm"" &lt;&lt; std::endl);
</code></pre>

<p>This is close to a solution:
<strike></p>

<pre><code>// sizeof doesn't evaluate the expression
#define USE(x) (void)(sizeof(x))
</code></pre>

<p>But fails with:</p>

<pre><code>void foo();

// oops, cannot take sizeof void
USE(foo());
</code></pre>

<p>The solution is to simply:</p>

<pre><code>// use expression as sub-expression,
// then make type of full expression int, discard result
#define USE(x) (void)(sizeof((x), 0))
</code></pre>

<p>Which guarantees no operation.
</strike></p>

<p><strong>Edit:</strong> The above indeed guaranteed no effect, but I posted without testing. Upon testing, it generates a warning again, at least in MSVC 2010, because the <em>value</em> isn't used. That's no good, time for more tricks!</p>

<hr>

<p>Reminder: We want to ""use"" an expression without evaluating it. How can this be done? Like this:</p>

<pre><code>#define USE(x) ((void)(true ? 0 : (x)))
</code></pre>

<p>This has a simple problem like last time (worse actually), in that <code>(x)</code> needs to be be convertible to <code>int</code>. This is, again, trivial to fix:</p>

<pre><code>#define USE(x) ((void)(true ? 0 : ((x), 0)))
</code></pre>

<p>And we're back to same kind of effect we had last time (none), but this time <code>x</code> is ""used"" so we don't get any warnings. Done, right?</p>

<p>There is actually still one problem with this solution (and was present in the last un-solution as well, but went unnoticed), and it comes up in this example:</p>

<pre><code>struct foo {};
void operator,(const foo&amp;, int) {}

foo f;
USE(f); // oops, void isn't convertible to int!
</code></pre>

<p>That is, if the type of the expression <code>(x)</code> overloads the comma operator to something not convertible to <code>int</code>, the solution fails. Sure, unlikely, but for the sake of going completely overboard, we can fix it with:</p>

<pre><code>#define USE(x) ((void)(true ? 0 : ((x), void(), 0)))
</code></pre>

<p>To make sure we really end up with zero. <a href=""http://stackoverflow.com/questions/75538/hidden-features-of-c/2176258#2176258"">This trick brought to you by Johannes</a>.</p>

<hr>

<p>Also as noted, if the above wasn't enough, a stupid enough compiler could potentially ""load"" the expression <code>0</code> (into a register or something), then disregard it.</p>

<p>I think it's impossible to be rid of that, since we ultimately need an expression to result in a type of some sort to ignore, but if I ever think of it I'll add it.</p>
"
"<p>While playing with <a href=""http://stackoverflow.com/questions/4030959/will-a-variablename-c-statement-be-a-no-op-at-all-times/4030983#4030983"">this answer</a> by <a href=""http://stackoverflow.com/users/87234/gman"">user GMan</a> I crafted the following snippet (compiled with Visual C++ 9):</p>

<pre><code> class Class {
 public:
     operator void() {}
 };

 Class object;
 static_cast&lt;void&gt;( object );
 (void)object;
 object.operator void();
</code></pre>

<p>after stepping over with the debugger I found out that casting to <code>void</code> doesn't invoke <code>Class::operator void()</code>, only the third invokation (with explicitly invoking the operator) actually invokes the operator, the two casts just do nothing.</p>

<p>Why is the <code>operator void</code> not invoked with the cast syntax?</p>
","87234","","<p>The technical reason why is found in §12.3.2:</p>

<blockquote>
  <p>A conversion function is never used to convert a (possibly cv-qualified) object to the (possibly cv-qualified) same object type (or a reference to it), to a (possibly cv-qualified) base class of that type (or a reference to it), <strong>or to (possibly cv-qualified) void</strong>.</p>
</blockquote>

<p>The rationale is (likely) to allow §5.2.9/4 to work:</p>

<blockquote>
  <p>Any expression can be explicitly converted to type “cv void.” The expression value is discarded.</p>
</blockquote>

<p><code>(void)expr</code> to suppose to do nothing for the resulting value of <em>any</em> expression, but if it called your conversion operator it wouldn't be discarding anything. So they ban the use of <code>operator void</code> in conversions.</p>

<hr>

<p>Why not make it ill-formed to have the conversion-type-id be <code>void</code>? Who knows, but keep in mind it's not <em>totally</em> useless:</p>

<pre><code>struct foo
{
    operator void()
    {
        std::cout &lt;&lt; ""huh?"" &lt;&lt; std::endl;
    }

};

typedef void (foo::*void_function)();

foo f;
void_function func = &amp;foo::operator void;

(f.*func)(); // prints ""huh""
f.operator void(); // also does (which you knew)
</code></pre>

<p>It is still technically potentially useful for <em>something</em>, so maybe that's rationale enough not to make it ill-formed.</p>
"
"<p>I have the following in a for loop and the compiler says 'operator = is ambiguous'.  Not sure how to solve this issue, can anyone help?</p>

<pre><code>rootelement = document-&gt;getDocumentElement();
    boost::interprocess::unique_ptr&lt;DOMNodeIterator, release_deleter&gt; itera (document-&gt;createNodeIterator(rootelement, DOMNodeFilter::SHOW_ALL, NULL, true));
    for(boost::interprocess::unique_ptr&lt;DOMNode, release_deleter&gt; current (itera-&gt;nextNode()); current != 0; current = boost::interprocess::unique_ptr&lt;DOMNode, release_deleter&gt; (itera-&gt;nextNode()))  // Last assignment on current is ambiguous
</code></pre>

<p>Full error:</p>

<p>*</p>

<pre><code>\XMLDocument.cpp(193) : error C2593: 'operator =' is ambiguous
        c:\Program Files\boost\boost_1_44\boost\interprocess\smart_ptr\unique_ptr.hpp(249): could be 'boost::interprocess::unique_ptr&lt;T,D&gt; &amp;boost::interprocess::unique_ptr&lt;T,D&gt;::operator =(int boost::interprocess::unique_ptr&lt;T,D&gt;::nat::* )'
        with
        [
            T=xercesc_3_1::DOMNode,
            D=release_deleter
        ]
        unique_ptr.hpp(211): or       'boost::interprocess::unique_ptr&lt;T,D&gt; &amp;boost::interprocess::unique_ptr&lt;T,D&gt;::operator =(boost::interprocess::rv&lt;boost::interprocess::unique_ptr&lt;T,D&gt;&gt; &amp;)'
        with
        [
            T=xercesc_3_1::DOMNode,
            D=release_deleter
        ]
        while trying to match the argument list '(boost::interprocess::unique_ptr&lt;T,D&gt;, boost::interprocess::unique_ptr&lt;T,D&gt;)'
        with
        [
            T=xercesc_3_1::DOMNode,
            D=release_deleter
        ]
        and
        [
            T=xercesc_3_1::DOMNode,
            D=release_deleter
        ]
  \XMLDocument.cpp(193) : see reference to class template instantiation 'boost::interprocess::detail::unique_ptr_error&lt;T&gt;' being compiled
        with
        [
            T=boost::interprocess::unique_ptr&lt;xercesc_3_1::DOMNode,release_deleter&gt;
        ]
    XMLDocument.cpp(193) : see reference to class template instantiation 'boost::interprocess::detail::unique_ptr_error&lt;T&gt;' being compiled
        with
        [
            T=xercesc_3_1::DOMNode *
        ]
       \XMLDocument.cpp(193) : see reference to class template instantiation 'boost::interprocess::detail::unique_ptr_error&lt;T&gt;' being compiled
        with
        [
            T=xercesc_3_1::DOMNode *
        ]
        XMLDocument.cpp(192) : see reference to class template instantiation 'boost::int
erprocess::detail::unique_ptr_error&lt;T&gt;' being compiled
        with
        [
            T=xercesc_3_1::DOMNodeIterator *
        ]
</code></pre>

<p>*</p>
","87234","","<p>Like Stephane says, <code>unique_ptr</code>'s maintain uniqueness unless you explicitly move them, or assign an rvalue to them. Normally, your code would be fine, but since you're faking rvalues, you'll need to move it explicitly.</p>

<p>I've never used <code>boost::interprocess::unique_ptr</code>, but it looks like you want this:</p>

<pre><code>namespace bi = boost::interprocess; // do these please!
typedef bi::unique_ptr&lt;DOMNode, release_deleter&gt; node_ptr;
typedef bi::unique_ptr&lt;DOMNodeIterator, release_deleter&gt; iterator_ptr;

rootelement = document-&gt;getDocumentElement();
iterator_ptr itera(document-&gt;createNodeIterator(rootelement,
                                           DOMNodeFilter::SHOW_ALL, NULL, true));

for (node_ptr current(itera-&gt;nextNode()); current != 0;
         current = bi::move(node_ptr(itera-&gt;nextNode())))
</code></pre>

<p>Simpler might be:</p>

<pre><code>for (node_ptr current(itera-&gt;nextNode()); current != 0;
         current.reset(itera-&gt;nextNode()))
</code></pre>
"
"<p>Given <a href=""http://stackoverflow.com/users/87234/gman"">GMan's</a> deliciously evil <code>auto_cast</code> utility function concocted <a href=""http://www.gmannickg.com/?p=28"" rel=""nofollow"">here</a>, I've been trying to figure out why it doesn't compile for me when I'm trying to <code>auto_cast</code> from an rvalue (on MSVC 10.0).</p>

<p>Here's the code that I'm using:</p>

<pre><code>template &lt;typename T&gt;
class auto_cast_wrapper : boost::noncopyable
{
  public:
    template &lt;typename R&gt;
    friend auto_cast_wrapper&lt;R&gt; auto_cast(R&amp;&amp; pX);

    template &lt;typename U&gt;
    operator U() const
    {
      return static_cast&lt;U&gt;( std::forward&lt;T&gt;(mX) );
    }

  private:
    //error C2440: 'initializing': cannot convert from 'float' to 'float &amp;&amp;'
    auto_cast_wrapper(T&amp;&amp; pX) : mX(pX) { }

    T&amp;&amp; mX;
};

template &lt;typename R&gt;
auto_cast_wrapper&lt;R&gt; auto_cast(R&amp;&amp; pX)
{
  return auto_cast_wrapper&lt;R&gt;( std::forward&lt;R&gt;(pX) );
}

int main()
{
  int c = auto_cast( 5.0f );  // from an rvalue
}
</code></pre>

<p>To the best of my ability I've tried to follow the C++0x reference collapsing rules and the template argument deduction rules outlined <a href=""http://thbecker.net/articles/rvalue_references/section_08.html"" rel=""nofollow"">here</a>, and as far as I can tell the code given above should work.</p>

<blockquote>
  <p>Recall that in pre-0x C++, it is not allowed to take a reference to a reference: something like A&amp; &amp; causes a compile error. C++0x, by contrast, introduces the following reference collapsing rules:</p>
  
  <ul>
  <li>A&amp; &amp; becomes A&amp;  </li>
  <li>A&amp; &amp;&amp; becomes A&amp;  </li>
  <li>A&amp;&amp; &amp; becomes A&amp;  </li>
  <li>A&amp;&amp; &amp;&amp; becomes A&amp;&amp;  </li>
  </ul>
  
  <p>The second rule is a special template argument deduction rule for function templates that take an argument by rvalue reference to a template argument:</p>

<pre><code>template&lt;typename T&gt;  
void foo(T&amp;&amp;);
</code></pre>
  
  <p>Here, the following rules apply:  </p>
  
  <ol>
  <li>When foo is called on an lvalue of type A, then T resolves to A&amp; and hence, by the reference collapsing rules above, the argument type effectively becomes A&amp;.  </li>
  <li>When foo is called on an rvalue of type A, then T resolves to A, and hence the argument type becomes A&amp;&amp;.</li>
  </ol>
</blockquote>

<p>Now when I mouse over the call to <code>auto_cast( 5.0f )</code>, the tooltip correctly displays its return value as <code>auto_cast_wrapper&lt;float&gt;</code>. This meaning that the compiler has correctly followed rule 2:  </p>

<blockquote>
  <p>When foo is called on an rvalue of type A, then T resolves to A.</p>
</blockquote>

<p>So since we have an <code>auto_cast_wrapper&lt;float&gt;</code>, the constructor should instantiate to take a <code>float&amp;&amp;</code>. But the error message seems to imply that it instantiates to take a <code>float</code> by value.</p>

<p><img src=""http://i.stack.imgur.com/ShB3F.png"" alt=""error showing tooltip""></p>

<p>Here's the full error message, showing again that T=float correctly yet the T&amp;&amp; parameter becomes T?</p>

<blockquote>
<pre><code> main.cpp(17): error C2440: 'initializing' : cannot convert from 'float' to 'float &amp;&amp;'
     You cannot bind an lvalue to an rvalue reference
     main.cpp(17) : while compiling class template member function 'auto_cast_wrapper&lt;T&gt;::auto_cast_wrapper(T &amp;&amp;)'
     with
     [
         T=float
     ]
     main.cpp(33) : see reference to class template instantiation 'auto_cast_wrapper&lt;T&gt;' being compiled
     with
     [
         T=float
     ]
</code></pre>
</blockquote>

<p>Any thoughts?</p>
","87234","","<p>Sorry for posting untested code. :)</p>

<p>DeadMG is correct that the argument should be forwarded as well. I believe the warning is false and the MSVC has a bug. Consider from the call:</p>

<pre><code>auto_cast(T()); // where T is some type
</code></pre>

<p><code>T()</code> will live to the end of the full expression, which means the <code>auto_cast</code> function, the <code>auto_cast_wrapper</code>'s constructor, and the user-defined conversion are all referencing a still valid object.</p>

<p>(Since the wrapper can't do anything but convert or destruct, it cannot outlive the value that was passed into <code>auto_cast</code>.)</p>

<p>I fix might be to make the member just a <code>T</code>. You'll be making a copy/move instead of casting the original object directly, though. But maybe with compiler optimization it goes away.</p>

<hr>

<p>And no, the forwarding is not superfluous. It maintains the value category of what we're automatically converting:</p>

<pre><code>struct foo
{
    foo(int&amp;) { /* lvalue */ }
    foo(int&amp;&amp;) { /* rvalue */ }
};

int x = 5;
foo f = auto_cast(x); // lvalue
foo g = auto_cast(7); // rvalue
</code></pre>

<hr>

<p>And if I'm not mistaken the conversion operator shouldn't be (certainly doesn't need to be) marked <code>const</code>.</p>
"
"<p>I did a program in C++ but it does not allow to save on c:\SomeDirectory\afile.txt</p>

<p>I'm using this:</p>

<pre><code>FILE* m_hFile = fopen(""c:\\SomeDirectory\\afile.txt"", ""a+t"");

fprintf((FILE *)m_hFile, ""testing"");

fclose(m_hFile);
</code></pre>

<p>Why that? Is there a defined folder I can save in?</p>
","87234","GMan","<p>Windows 7 doesn't allow the creation of files in (subdirectories of?)  the root directory. Maybe try running as admin.</p>

<p>Also, that's very C code, not C++. Use streams/good C++, not C with classes.</p>
"
"<p>Given the code below is there a nicer way to right it that doesn't repeat <code>typename std::iterator_traits&lt;T&gt;::iterator_category</code> twice?</p>

<pre><code>template&lt;class T, class T2&gt;
struct foo :
    bar&lt;
        foo&lt;T, T2&gt;, typename 
        std::conditional&lt;
            std::is_same&lt;typename 
                std::iterator_traits&lt;T&gt;::iterator_category,  //Repeated
                std::random_access_iterator_tag
            &gt;::value,
            std::bidirectional_iterator_tag, typename 
            std::iterator_traits&lt;T&gt;::iterator_category       //Repeated
        &gt;::type
    &gt;
{}
</code></pre>
","87234","","<p>Split it up (like it should be anyway):</p>

<pre><code>// put in detail namespace/file or something in real code
template&lt;class T, class T2&gt;
struct foo_base
{
    typedef foo&lt;T, T2&gt; foo_type;
    typedef typename std::iterator_traits&lt;T&gt;::iterator_category category_type;

    static const bool random_access = std::is_same&lt;category_type,
                                        std::random_access_iterator_tag&gt;::value;
    typedef typename std::conditional&lt;random_access,
                                        std::bidirectional_iterator_tag,
                                        category_type&gt;::type tag_type;

    typedef bar&lt;foo_type, tag_type&gt;::type base_type;
}

template&lt;class T, class T2&gt;
struct foo :
   foo_base&lt;T, T2&gt;::base_type
{};
</code></pre>

<p>Even if there was no repeated bit, you should still split it up to keep the base type logic separate from actually inheriting the base type.</p>
"
"<p>Here is simple program.
If I comment constructor, I get an error
Just wanted to check what is the reason for this?</p>

<pre><code>t.cc: In function 'int main(int, char**)':                                                                                                                              
t.cc:26: error: uninitialized const 'const_test'


#include &lt;iostream&gt;                                                                                                                                                     

using namespace std;                                                                                                                                                    

class TestPrint                                                                                                                                                         
{                                                                                                                                                                       
public:                                                                                                                                                                 
  //  TestPrint() {}                                                                                                                                                    
  void Print()                                                                                                                                                          
  {                                                                                                                                                                     
    std::cout &lt;&lt; ""TestPrint"" &lt;&lt; std::endl;                                                                                                                              
  }                                                                                                                                                                     

  void Print() const                                                                                                                                                    
  {                                                                                                                                                                     
    std::cout &lt;&lt; ""const TestPrint"" &lt;&lt; std::endl;                                                                                                                        
  }                                                                                                                                                                     
};                                                                                                                                                                      


int main(int argc, char* argv[])                                                                                                                                        
{                                                                                                                                                                       
  TestPrint normal_test;                                                                                                                                                
  normal_test.Print();                                                                                                                                                  

  const TestPrint const_test;                                                                                                                                           
  const_test.Print();                                                                                                                                                   
}                                                                                                                             
</code></pre>
","87234","","<p>It is indeed ill-formed. §8.5/9:</p>

<blockquote>
  <p>If no initializer is specified for an object, and the object is of (possibly cv-qualified) non-POD class type (or array thereof), the object shall be default-initialized; <strong>if the object is of const-qualified type, the underlying class type shall have a user-declared default constructor</strong>. Otherwise, if no initializer is specified for a nonstatic object, the object and its subobjects, if any, have an indeterminate initial value; if the object or any of its subobjects are of const-qualified type, the program is ill-formed.</p>
</blockquote>

<p>Emphasis mine. Any compiler that does not issue a diagnosis for your program is non-compliant (looking at you MSVC). A simpler test:</p>

<pre><code>struct foo {};

int main()
{
    const foo f;
}
</code></pre>

<p>The idea is simple: constants need to be initialized to something. If you have no user-defined constructor, you have no initialization.</p>
"
"<p>I have the following code, which loops through an array of <code>menuoptions</code> and on each iteration,  creates a <code>ScaledRect</code> object and pushes it to a vector. This vector is a member of a struct.</p>

<p>I have verified that the ScaledRect is created with the correct values, yet when I print back the contents of the <code>regions</code> vector ( in the second loop ), the loop never terminates and the values are garbage. </p>

<pre><code>class ScaledRect : public Rect
{
public:
    ScaledRect(int x1, int y1, int x2, int y2);
};
ScaledRect::ScaledRect(int x1, int y1, int x2, int y2):
    _x1(x1), _y1(y1), _x2(x2), _y2(y2){}

// ScaledRect doesn't have copy constructor, but Rect does
Rect::Rect( const Rect &amp;rect)
{
x1=rect.x1; y1=rect.y1; x2=rect.x2; y2=rect.y2; bClean=KD_FALSE;
}

typedef struct
{
    std::vector&lt;ScaledRect&gt; regions;
}interface;

void PushRegions( interface * myself )
{
    int i = 0;
    while(menuoptions[i].callback != -1 )
    {
        ScaledRect s = 
          ScaledRect(menuoptions[i].x1, 
                     menuoptions[i].y1,
                     menuoptions[i].x2, 
                     menuoptions[i].y2);            
        myself-&gt;regions.push_back( s );
        i++;
    }

    std::vector&lt;ScaledRect&gt;::iterator iter = myself-&gt;regions.begin();
    std::vector&lt;ScaledRect&gt;::iterator done = myself-&gt;regions.end();

    while(iter != done)
    {
        iter-&gt;Dump();
        iter++;
    }
}
</code></pre>

<p>EDIT
Please note - I've just edited - the memory for <code>theinterface</code> is created and I do actually pass in the address of <code>theinterface</code> to this function. (However, I have simplified those two lines here - what actually happens is that <code>PushRegions</code> gets called via a ptr to a function, on a piece of newly allocated memory the size of an <code>interface</code> ).</p>

<p>I can't post all of the code here - but minimally its:</p>

<pre><code>Func pfunc = GetPFuncForInterfaceObj();
size_t  numbytes = GetSizeForInterfaceObj();
char memory = new char[numbytes];
pfunc(memory);
</code></pre>

<p><code>pfunc</code> ends up being <code>PushRegions</code> and <code>memory</code> ends up being passed as an <code>interface</code>.</p>

<p>When I push the <code>ScaledRect</code> object to a <code>vector</code> declared at the top of <code>PushRegions()</code> it works. Has anyone got any ideas why?</p>
","87234","","<p>This is utterly wrong:</p>

<pre><code>size_t  numbytes = GetSizeForInterfaceObj();
char memory = new char[numbytes];
pfunc(memory);
</code></pre>

<p>Even if we ""fix"" it:</p>

<pre><code>size_t  numbytes = GetSizeForInterfaceObj();
char* memory = new char[numbytes]; // note pointer
pfunc((interface*)memory); // and cast
</code></pre>

<p>Your object has never been constructed, so the vector is in a garbage state. (Using the object leads to undefined behavior.)</p>

<p>No, <code>interface</code> may not have a constructor <em>explicitly</em> defined, but there is an implicit constructor, and it's there for a reason. It needs to construct the members. You can use ""placement new"" (by including <code>&lt;new&gt;</code>) to construct an object by placing it at a memory location:</p>

<pre><code>size_t  numbytes = GetSizeForInterfaceObj();
char* memory = new char[numbytes]; // note pointer
pfunc(new (memory) interface); // and CREATE
</code></pre>

<p>Now you're using a valid object.</p>

<hr>

<p>I'll assume there's a good reason for using pointers at all, let alone a manually constructed object. That said, your code does too much. It both <em>manages</em> a resource, and <em>uses</em> one; pick one or the other.</p>

<p>That is:</p>

<pre><code>struct interface_obj
{
    interface_obj() :
    mMemory(GetSizeForInterfaceObj()),
    mInterface(new (&amp;mMemory[0]) interface)
    {}

    ~interface_obj()
    {
        mInterface-&gt;~interface(); // destruct
    }

    interface* get() const
    {
        return mInterface;
    }

private:
    // noncopyable for now, easy to add
    interface_obj(const interface_obj&amp;);    
    interface_obj&amp; operator=(const interface_obj&amp;);

    // again, with the vector we use a resource (dynamic buffer),
    // not manage one.
    std::vector&lt;char&gt; mMemory;
    interface* mInterface;
};
</code></pre>

<p>Much cleaner:</p>

<pre><code>interface_obj obj;
pfunc(obj.get());
</code></pre>

<p>And it will be released <em>no matter what</em>. (Your code wouldn't in the face of exceptions, without messy try-catch blocks and other nonsense.) Again, preferable is to not have this kind of allocation in the first place.</p>
"
"<p>Hey all, just wondering whether the following would cause a memory leak?</p>

<pre><code>char* a = ""abcd""
char* b = new char[80];

strcpy(b, a);

delete[] b;
</code></pre>

<p>Will it delete the whole block of 80 or just the 4 characters copied into it by strcpy? Thanks!</p>
","87234","","<p>A memory leak is when you don't free memory. Just because you allocated more than you need doesn't mean it a memory leak. What you do with your memory is up to you.</p>

<p>Though that should 1) be <code>delete [] b;</code>, or you get undefined behavior, and 2) Be a <code>std::string</code> or <code>std::vector</code>, so you don't both manage and use a resource.</p>
"
"<p>I'm new and a little ignorant in C++ and I encounter a C++ code that used a singleton pattern,</p>

<pre><code>class CFoo
{
 public:
   static CFoo&amp; getInstance()
   {
     static CFoo self;
     return self;
   }

 private:
   CFoo(){}
   ~CFoo(){}
};
</code></pre>

<p>I am just confused why return a static reference? Is this a valid code? Why the programmer didn't use a pointer?</p>
","87234","","<p>Why use a pointer? A reference is simple and matches what I want to do: alias an object, not point to it. The <code>static</code> doesn't apply to the reference, it applies to the function, making it callable without an instance.</p>

<p>(Even better, <a href=""http://jalf.dk/blog/2010/03/singletons-solving-problems-you-didnt-know-you-never-had-since-1995/"" rel=""nofollow"">why use a singleton</a>?)</p>
"
"<p>The following code does not compile ... any idea why? Is this illegal C++?</p>

<pre><code>class Handler {
 public:
  template &lt;typename T&gt;
  void handle(T t) {}    
};

class Initializer {
 public:
  template &lt;typename T, typename H&gt;
  void setup(H *handler) {
    void (H::*handle)(T) = &amp;H::handle&lt;T&gt;; // fails
  }
};

int main() {
  Initializer initializer;
  Handler handler;
  initializer.setup&lt;int, Handler&gt;(&amp;handler);
}
</code></pre>
","87234","","<p>You need <code>template</code>:</p>

<pre><code>void (H::*handle)(T) = &amp;H::template handle&lt;T&gt;; 
</code></pre>

<p>Because the template <code>handle</code> is qualified with a dependent type. (Just like you use <code>typename</code> if a type is qualified with a dependent type.)</p>
"
"<p>I'm trying to learn about <code>string</code>s, but different sources tell my to include different headers.</p>

<p>Some say to use <code>&lt;string.h&gt;</code>, but others mention <code>""apstring.h""</code>.  I was able to do some basic stuff with <code>apstring</code>, but I've been told the other one is more powerful.  When I include <code>&lt;string.h&gt;</code> and try to declare some string variables, however, I get errors.  What is the proper usage?</p>
","87234","","<p>You want to include <code>&lt;string&gt;</code> and use <code>std::string</code>:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    std::string s = ""a string"";
    std::cout &lt;&lt; s &lt;&lt; std::endl;
}
</code></pre>

<p>But what you really need to do is get an <a href=""http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">introductory level book</a>. You aren't going to learn properly any other way, certainly not scrapping for information online.</p>
"
"<p>If I were to follow the RAII rule and would be developing a class in C++, would it be necessary to have static constructors? Will static constructors help me in any way or would be a wrong step to do? </p>
","87234","","<p>That doesn't make any sense, you cannot have a static constructor. The entire purpose of the constructor is to initialize a specific instance of a class; if it were static, it wouldn't belong to any instance.</p>

<p>RAII just says that you need to free a resource in the destructor, and that the acquisition of that resource happens with the initialization (construction) of the object who will run that destructor. (Which <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29"" rel=""nofollow"">entails</a> you need a working or forbidden copy-constructor, along with a <a href=""http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom"">working assignment operator</a>.)</p>
"
"<p>Is it possible to detect if a class is of certain type?</p>
","87234","","<p>Yes:</p>

<pre><code>template &lt;typename T, typename U&gt;
struct is_same
{
    static const bool value = false;
};


template &lt;typename T&gt;
struct is_same&lt;T, T&gt;
{
    static const bool value = true;
};

is_same&lt;int, float&gt;::value; // false
is_same&lt;int, int&gt;::value; // true
</code></pre>

<p>These are called type traits, and you can find a slew of them in <a href=""http://www.boost.org/doc/libs/1_44_0/libs/type_traits/doc/html/index.html"" rel=""nofollow"">Boost.TypeTraits</a> and C++0x.</p>
"
"<p>I have a class called <code>PointF</code> and it has a constructor that takes a <code>Point</code>, and I keep getting ""possible loss of data warnings"". How can I show that my intention is in fact to make a <code>float</code> value into an <code>int</code>, among other tings? I tried <code>static_cast</code> and <code>(float)</code> but they did not fix the warning.</p>

<p>For example:</p>

<pre><code>int curPos = ceil(float(newMouseY / font.getLineHeight())) ; //float to int
</code></pre>

<p>And</p>

<pre><code>outputChars[0] = uc; //converting from size_t to char
</code></pre>
","87234","","<p>A cast should do the trick; that says ""explicitly make this type into that type"", which is generally pretty silly for a compiler to warn for:</p>

<pre><code>int curPos = static_cast&lt;int&gt;(ceil(float(newMouseY / font.getLineHeight())));
</code></pre>

<p>Or:</p>

<pre><code>outputChars[0] = static_cast&lt;char&gt;(uc);
</code></pre>

<p>Make sure the casts you tried were akin to that. You say ""I tried ...<code>(float)</code>"" which leads me to believe you tried something like this:</p>

<pre><code>int curPos = (float)(ceil(float(newMouseY / font.getLineHeight())));
</code></pre>

<p>Which does nothing. The type of the expression is already a <code>float</code>, what would casting it to the same type do? You need to cast it to the destination type.</p>

<hr>

<p>Keep in mind casts are generally to be avoided. In your first snippet, the cast is sensible because when you quantize something you necessarily need to drop information.</p>

<p>But your second cast is not. Why is <code>uc</code> a <code>size_t</code> in the first place? What happens when the cast <em>does</em> drop information? Is that really a good idea?</p>
"
"<p>I'm trying to implement is_base template and I have ""a little problem"". Why this doesn't work as it's suppouse to? </p>

<pre><code>#include &lt;iostream&gt;
using std::cout;
class Car
{
};

class Fiesta : public Car
{
};

template&lt;class Base, class Derived&gt;
struct isBase
{
    typedef char yes[2];
    typedef char no[1];

    template&lt;class B, class D&gt;
    static yes&amp; f(D* d, B* b = d);

    template&lt;class,class&gt;
    static no&amp;  f(...);

    static  bool type;
};




template&lt;class Base, class Derived&gt;
bool isBase&lt;Base,Derived&gt;::type = (sizeof(f&lt;Base,Derived&gt;(0,0)) == sizeof(yes));

int _tmain(int argc, _TCHAR* argv[])
{
    cout &lt;&lt; isBase&lt;Fiesta,Car&gt;::type;//It should say false here but says true

    return 0;
}
</code></pre>
","87234","","<p>You're explicitly providing a value for the pointer: <code>f&lt;Base,Derived&gt;(0, 0)</code>, no conversion needs to occur here, especially not a derived-to-base one; this test will always pass, as the first one is always callable (any pointer can be null).</p>

<p>You want something like this:</p>

<pre><code>template&lt;class Base, class Derived&gt;
struct isBase
{
    typedef char yes[2];
    typedef char no[1];

    template &lt;class B&gt;
    static yes&amp; f(B*);

    template &lt;class&gt;
    static no&amp;  f(...);

    // (1) make it const (as it should be) and just define it inline
    // (2) it's not a type, it's a value; name appropriately
    static const bool value = sizeof(f&lt;Base&gt;((Derived*)0)) == sizeof(yes);
};

// use a standard signature for main
int main() // if you don't need the arguments, don't list them
{
    cout &lt;&lt; isBase&lt;Fiesta, Car&gt;::value;
    cout &lt;&lt; isBase&lt;Car, Fiesta&gt;::value;

   // return 0 is implicit for main, helpful for snippets
}
</code></pre>

<p>The first overload will be called if the pointer type is or can be converted to a <code>Base*</code>. So we make a pointer of the type <code>Derived*</code>, and if it actually is a derived class the conversion will work and the first overload is called; otherwise, the second.</p>
"
"<p>I have a class ""complex"" that contains a Real and an Imaginary value. I'm trying to overload the + operator so I can add real to real and imaginary to imaginary, but I'm banging my head against a wall here.</p>

<p>In the function, I can get the values easy. Returning them however, is a bitch.</p>

<p>My plan is to overload the '=' operator, too, so I can go</p>

<p>complex a, b, c;</p>

<p>(set a and b)</p>

<p>c = a + b;</p>

<p>then have a+b return a complex, then have complex c equal the complex returned by a+b</p>

<p>Any opinion on whether that's a viable path?</p>

<p>Any opinion on whether it can be done easier?</p>
","87234","","<p>I'm not sure I understand the problem. Do you have a <code>complex</code> class?</p>

<pre><code>struct complex
{
    complex(float real, float imag) :
    real(real), imag(imag)
    {}

    // first make the mutating version
    complex&amp; operator+=(const complex&amp; rhs)
    {
        real += rhs.real; 
        imag += rhs.imag;

        return *this;
    }

    float real, imag;
};

// then use that for the non-mutating version
complex operator+(complex lhs, const complex&amp; rhs)
{
    lhs += rhs;
    return lhs;
}
</code></pre>

<p>This is, of course, just an exercise; we have <a href=""http://www.cplusplus.com/reference/std/complex/"" rel=""nofollow""><code>std::complex</code></a>.</p>
"
"<p>Consider the following:</p>

<pre><code>class A {
public:
    const int c; // must not be modified!

    A(int _c)
    :   c(_c)
    {
        // Nothing here
    }

    A(const A&amp; copy)
    : c(copy.c)
    {
        // Nothing here
    }    
};



int main(int argc, char *argv[])
{
    A foo(1337);

    vector&lt;A&gt; vec;
    vec.push_back(foo); // &lt;-- compile error!

    return 0;
}
</code></pre>

<p>Obviously, the copy constructor is not enough. What am I missing?</p>

<p>EDIT:
Ofc. I cannot change this->c in operator=() method, so I don't see how operator=() would be used (although required by std::vector).</p>
","87234","","<p>I'm not sure why nobody said it, but the correct answer is to drop the <code>const</code>, or store <code>A*</code>'s in the vector (using the appropriate smart pointer).</p>

<p>You can give your class terrible semantics by having ""copy"" invoke UB or doing nothing (and therefore not being a copy), but why all this trouble dancing around UB and bad code? What do you get by making that <code>const</code>? (Hint: Nothing.) Your problem is conceptual: <strong>If a class has a const member, the class is const. Objects that are const, fundamentally, cannot be assigned.</strong></p>

<p>Just make it a non-const <em>private</em>, and expose its value immutably. To users, this is equivalent, const-wise. It allows the implicitly generated functions to work just fine.</p>
"
"<p>Im trying to do a simple string splitting function, but im having a problem returning the split string. </p>

<p>i got the string into strings s1, s2, s3. how do i return <code>{s1,s2,s3}</code>? im using brackets but the compiler is telling me </p>

<pre><code>expected primary-expression before '{' token 
expected `;' before '{' token 
expected `;' before '}' token 
</code></pre>

<p>even though there doesnt seem to be any problem. is doing <code>{s1,s2,s3}</code> even allowed?</p>
","87234","","<p>You should populate a <code>std::vector</code> and return that.</p>

<pre><code>std::vector&lt;std::string&gt; tokenize(/*...*/)
{
    std::vector&lt;std::string&gt; result;

    // ...
    result.push_back(s); // s: s1 - s3
    // ...

    return result;
}
</code></pre>

<p>Note you shouldn't actually have the variables <code>s1</code>, <code>s2</code>, or <code>s3</code>, or you're just limiting the process to three outputs. You should have a loop through the string, pushing results into the vector.</p>
"
"<p>How do i include two .h/class files that both have <code>#include ""h_file.h""</code>? both require the .h file definitions, and both are included in the main program. how do i prevent the redefinition of the .h definitions (which causes the compiler to not compile)?</p>

<p>i have:</p>

<pre><code>main.cpp
class1.h/class1.cpp
class2.h/class2.cpp
h_file.h
</code></pre>
","87234","","<p>Use include guards:</p>

<pre><code>#ifndef INCLUDE_GUARD_IDENTIFIER_GOES_HERE
#define INCLUDE_GUARD_IDENTIFIER_GOES_HERE

// code for header

#endif
</code></pre>

<p>The second time it's included, it's effectively an empty file.</p>

<hr>

<p>There are many different ways of choosing the identifier <code>INCLUDE_GUARD_IDENTIFIER_GOES_HERE</code>, with rationales for each. Personally, I do <code>FILE_DIRECTORY_FILE_NAME_CLASS/FUNCTION_NAME_HPP</code>:</p>

<pre><code>#ifndef UTILITY_FOO_HPP
#define UTILITY_FOO_HPP

namespace utility
{
    void foo();
}

#endif
</code></pre>

<p>Others will generate GUID's and attach them to a base name, like this:</p>

<pre><code>INCLUDE_GUARD_A629F54A136C49C9938CB33EF8EDE676
</code></pre>

<p>This almost guarantees it'll never collide. Ultimately, it's up to you. However, regardless of what you come up with, make sure it follows <a href=""http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier"">the rules</a>: No double underscores anywhere, and don't start it with an underscore followed by an upper-case letter.</p>
"
"<p>I have a class that resembles this:</p>

<p>However, after the initial constructor, the copy constructor is being called 10 times.
If I don't do the thread creation step.  It gets called 4 times which is what I'd expect.
Why is that, and how do I avoid it?</p>

<p>Should I avoid using std::vector in this case and just do new delete instead?</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;vector&gt;

class A
{
    public:
        A() { printf(""hello\n""); }
        ~A() { printf(""Goodbye\n""); }
        A(const A&amp;)
        {
            printf(""copy constructing\n"");
        }

        Thread() { }
};


int main()
{
    std::vector&lt;A&gt; a(4, A);

    for (int i = 0; i &lt; a.size(); i++){
        threads_.create_thread(boost::bind(&amp;A::Thread, a[i]));
    }
}
</code></pre>

<p>Ok, I found the problem.  </p>

<p>This:</p>

<pre><code>        threads_.create_thread(boost::bind(&amp;A::Thread, a[i]));
</code></pre>

<p>Should be:</p>

<pre><code>        threads_.create_thread(boost::bind(&amp;A::Thread, &amp;a[i]));
</code></pre>
","87234","","<p>Threads are irrelevant here. The ""problem"" is with <code>boost::bind</code>; it makes copies of the arguments you give it, so it can use the value later when invoked. <a href=""http://stackoverflow.com/questions/4133385/why-is-this-calling-the-copy-constructor-so-many-times/4133486#4133486"">Use <code>ref</code></a> so have it store a reference instead.</p>

<blockquote>
  <p>Should I avoid using std::vector in this case and just do new delete instead?</p>
</blockquote>

<p>Huh? Why would you do that? You need to get over the fact copies are made; that just happens. You should be worried about writing clean, maintainable code first, not whether or not you happen to make a copy. There's no reason to use <code>new[]</code> over a <code>std::vector</code>; <strong>never</strong> use <code>delete</code>.</p>
"
"<p>I've been looking at the C++ documentation for a function which would move a range of elements from one container to another, using move semantics. However, I have not found such a function. What am I missing?</p>

<p>How would I do the following without copying and using explicit loops?</p>

<pre><code>// Move 10 elements from beginning of source to end of dest
dest.end() &lt;- move(source.begin(), source.begin() + 10) 
</code></pre>
","87234","","<p>I think you're looking for <code>std::move</code> in <code>&lt;algorithm&gt;</code>:</p>

<pre><code>std::move(source.begin(), source.begin() + 10,
            std::insert_iterator(dest, dest.end()));
</code></pre>

<p>It's just like <code>std::copy</code>, except it move-assigns instead of copy-assigns.</p>
"
"<p>I have a container std::vector and I would like to efficiently split it into sub-ranges with x items in each. The original container is not needed so the items should be moved and not copied into the sub-ranges.</p>

<p>I've managed to do the splitting using copying, however I'm unsure how to do it with move assignments?</p>

<pre><code>    range.insert(range.end(), new_items.begin(), new_items.end());
    while(range.size() &gt;= x)
    {
        sub_ranges.push_back(std::vector&lt;int&gt;(range.begin(), range.begin() + x));
        range = std::vector&lt;int&gt;(range.begin() + x, range.end());
    }
</code></pre>

<p>EDIT:</p>

<p>Some progress... still not quite there, and a bit ugly</p>

<pre><code>    while(range.size() &gt;= x)
    {
        std::vector&lt;short&gt; sub_range(x); // Unnecessary allocation?
        std::move(range.begin(), range.begin() + x, sub_range.begin());
        sub_ranges_.push_back(std::move(sub_range));

        std::move(range.begin() + x, range.end(), range.begin());
        range.resize(range.size() - x);
    }
</code></pre>
","87234","","<p>You can use <code>std::make_move_iterator</code> in <code>&lt;iterator&gt;</code> to wrap your iterator into a <code>move_iterator</code>. This iterator will <code>std::move</code> the result of dereferencing its base iterator, allowing that to be moved elsewhere.</p>

<pre><code>// assuming I understand your code, which I don't
range.insert(range.end(), new_items.begin(), new_items.end());
while(range.size() &gt;= x)
{
    auto first = std::make_move_iterator(range.begin());
    auto last = std::make_move_iterator(range.begin() + x);

    sub_ranges.push_back(std::vector&lt;int&gt;(first, last));
    range = std::vector&lt;int&gt;(range.begin() + x, range.end());
}
</code></pre>

<hr>

<p>EDIT: And like you found, there's a mapping between <code>std::move()</code> and <code>make_move_iterator</code>:</p>

<pre><code>std::move(first, last, out); // is the same as
std::copy(std::make_move_iterator(first), std::make_move_iterator(last), out);
</code></pre>

<p>So which you find cleaner is up to you. (The first one, to me.)</p>
"
"<p>I'm building a hashmap class that can have <strong>string keys</strong> and <em>ints, bools, strings or pointers</em> of different types as its <em>values</em>, and I want it to work. For the program I'm using it for I create the pointer and pass it into the hashmap. The problem comes when I need to destruct the map. If the type for the hashmap is a pointer I need to delete it(the value) before I delete it's container.</p>

<p>so the code I have right now goes something like this:
I have a hashNode** drawers, which I use as a two dimensional array to hold pointer to hashNodes in the map. Those same pointers are also held in another hashNode** array, which stores them as they are added to map (for ease/speed of growing and copying the hashmap).</p>

<pre><code>template &lt;typename V&gt;
class str_map {
public:
    // ...
    virtual ~str_map() {
        str_map&lt;V&gt;::~str_map();
    }
    // ....
};
</code></pre>

<p>and then later I have a bunch of methods like these:
one for regular values:</p>

<pre><code>template &lt;&gt;
str_map&lt;int&gt;::~str_map() {
    for(int i=0; i &lt; count &amp;&amp; array[i] != NULL; i++){
        delete array[i];
    }
    delete array;
    delete drawers;
}
</code></pre>

<p>and one for pointers:</p>

<pre><code>template &lt;&gt;
str_map&lt;str_map&lt;int&gt;*&gt;::~str_map() {
    for(int i=0; i &lt; count &amp;&amp; array[i]-&gt;val() != NULL; i++)
        delete array[i]-&gt;val();
    for(int i=0; i &lt; count &amp;&amp; array[i] != NULL; i++){
        delete array[i];
    }
    delete array;
    delete drawers;
}
</code></pre>

<p>Is there another better way to deconstruct an instance of str_map class correctly so that all the memory is handled correctly? Or at least a way to make this work?</p>
","87234","","<p>Your container should handle <em>values</em>. That's it, no more, no less. If someone wants to stick pointers in, <em>let them</em>. Don't take ownership of whatever they may or may not be pointing at.</p>

<p>It's up to the users of your hash map to know how to manage the lifetime of their memory. They should be using smart pointers, so your class just copies them around and the smart pointer manages the memory.</p>

<p>The guideline is <strong>manage one resource, or none at all</strong>. If you are managing more than one resource, you've set yourself up for failure.</p>

<p>I suspect <code>delete array</code> should be <code>delete [] array;</code>. What this means is you really should be using <code>std::vector</code>. Again, either manage one resource or none at all. <code>std::vector</code> manages <em>one</em> resource, so you don't have to. And so on.</p>
"
"<p>why <code>sizeof("""")</code> is equivalent to 1 and <code>sizeof(NULL)</code> is equivalent to 4  in c-language ?</p>
","87234","","<p>A string literal is an <strong>array</strong> of characters* (with static storage), which contains all the characters in the literal along with a terminator. The size of an array is the size of the element multiplied by the number of elements in the array.</p>

<p>The literal <code>""""</code> is an array that consists of one <code>char</code> with the value <code>0</code>. The type is <code>char[1]</code>, and <code>sizeof(char)</code> is always one; therefore<code>sizeof(char[1])</code> is always one.</p>

<p>In C, <code>NULL</code> is implementation-defined, and is often <code>((void*)0)</code>. The size of a <code>void*</code>, <em>on your particular implementation</em>, is 4. It may be a different number depending on the platform you run on. <code>NULL</code> may also expand to an integer of some type of the value 0, and you'd get the size of that instead.</p>

<p>*A literal is not a pointer, arrays are not pointers, pointers do not play a role in this part of the question.</p>
"
"<p>Tonight I've been taking a look at some code I've been working on over the last few days, and began reading up on move semantics, specifically std::move.  I have a few questions to ask you pros to ensure that I am going down the right path and not making any stupid assumptions!</p>

<p>Firstly:</p>

<p><strong>1) Originally, my code had a function that returned a large vector:</strong></p>

<pre><code>template&lt;class T&gt; class MyObject
{
public:
    std::vector&lt;T&gt; doSomething() const;
    {
        std::vector&lt;T&gt; theVector;

        // produce/work with a vector right here

        return(theVector);
    }; // eo doSomething
};  // eo class MyObject
</code></pre>

<p>Given ""theVector"" is temporary in this and ""throw-away"", I modified the function to:</p>

<pre><code>    std::vector&lt;T&gt;&amp;&amp; doSomething() const;
    {
        std::vector&lt;T&gt; theVector;

        // produce/work with a vector right here

        return(static_cast&lt;std::vector&lt;T&gt;&amp;&amp;&gt;(theVector));
    }; // eo doSomething
</code></pre>

<p>Is this correct?  Any pitfalls in doing it this way?</p>

<p><strong>2) I noticed in a function I have that returns <code>std::string</code> that it automatically called the move constructor.  Debugging in to Return of the String (thankyou, Aragorn), I noticed it called an explicit move constructor.  Why is there one for the string class and not vector?</strong></p>

<p>I didn't have to make any modifications to this function to take advantage of move semantics:</p>

<pre><code>// below, no need for std::string&amp;&amp; return value?
std::string AnyConverter::toString(const boost::any&amp; _val) const
{
    string ret;
    // convert here
    return(ret); // No need for static_cast&lt;std::string&amp;&amp;&gt; ?
}; // eo toString
</code></pre>

<p><strong>3) Finally, I wanted to do some performance tests, is the amazingly-fast results I got because of std::move semantics or did my compiler (VS2010) do some optimizing too?</strong></p>

<p>(Implementation of <code>_getMilliseconds()</code> omitted for brevity)</p>

<pre><code>std::vector&lt;int&gt; v;
for(int a(0); a &lt; 1000000; ++a)
    v.push_back(a);

std::vector&lt;int&gt; x;
for(int a(0); a &lt; 1000000; ++a)
    x.push_back(a);

    int s1 = _getMilliseconds();
std::vector&lt;int&gt; v2 = v;
    int s2 =  _getMilliseconds();
std::vector&lt;int&gt; v3 = std::move(x);
    int s3 =  _getMilliseconds();

    int result1 = s2 - s1;
    int result2 = s3 - s2;
</code></pre>

<p>The results were, obviously, awesome.  result1, a standard assignment, took 630ms.  The second result, was 0ms.  Is this a good performance test of these things?</p>

<p>I know some of this is obvious to a lot of you, but I want to make sure I understand the semantics right before I go blazer on my code.</p>

<p>Thanks in advance!</p>
","87234","","<p>A reference is still a reference. In the same way you cannot return a reference to a local in C++03 (or you get UB), you can't in C++0x. You'll end up with a reference to a dead object; it just happens to be an rvalue reference. So this is wrong:</p>

<pre><code>std::vector&lt;T&gt;&amp;&amp; doSomething() const
{
    std::vector&lt;T&gt; local;

    return local; // oops
    return std::move(local); // also oops
}
</code></pre>

<p>You should just do what you saw in number two:</p>

<pre><code>// okay, return by-value 
std::vector&lt;T&gt; doSomething() const
{
    std::vector&lt;T&gt; local;

    return local; // exactly the same as:
    return std::move(local); // move-construct value
}
</code></pre>

<p>Variables local to a function are temporary when you return, so there's no need to change any of your code. The return type is the thing responsible for implementing move semantics, not you.</p>

<p>You want to use <code>std::move</code> to <em>explicitly</em> move something, when it wouldn't be done normally, like in your test. (Which seems to be fine; was that in Release? You should output the contents of the vector, or the compiler will optimize it away.)</p>

<p>If you want to learn about rvalue references, <a href=""http://thbecker.net/articles/rvalue_references/section_01.html"">read this</a>.</p>
"
"<p>I recently tried adding parallax occlusion mapping to my landscape renderer and it looks and works fine, but I've faced some problems.</p>

<p>Here are 2 images <em>(one with only normal texture mapping, another with parallax occlusion mapping also).</em></p>

<p><strong>I have some aliasing issues which I marked with the red circles (you might want to see the FULL image by it's link).</strong></p>

<p><img src=""http://i.stack.imgur.com/tz7KZ.png"" alt=""alt text""></p>

<p><img src=""http://i.stack.imgur.com/n5ZuO.jpg"" alt=""alt text""></p>

<p>These are obviously the result of the ray approximation, which is a part of the parallax occlusion technique, but I'm pretty sure there are some ways to improve the visual effect.</p>

<p><em>Could someone point the ways of removing these (maybe some abstracts, papers, researches, anything)?</em></p>

<p>Thanks.</p>
","87234","","<p>Take a look at GPU Gems 3, ""Relaxed Cone Stepping for Relief Mapping"" (Chapter 18, p. 409). It's also available online <a href=""http://developer.download.nvidia.com/books/gpu_gems_3/samples/gems3_ch18.pdf"" rel=""nofollow"">here</a> (PDF link).</p>

<p>The main purpose of cone stepping is to reduce the artifacts you see, but that introduces other kinds of artifacts. Relaxed cone stepping solves both problems, well enough where you can pragmatically say there are no more artifacts.</p>
"
"<p>My gut feeling is it is not. I am in the following situation:</p>

<pre><code>class PluginLoader
{
   public:
      Builder* const p_Builder;
      Logger* const p_Logger;

      //Others
};

PluginLoader::PluginLoader(Builder* const pBuilder)
   :p_Builder(pBuilder), p_Logger(pBuilder-&gt;GetLogger())
{
   //Stuff
}
</code></pre>

<p>Or should I change the constructor and pass a <code>Logger* const</code> from where <code>PluginLoader</code> is constructed?</p>
","87234","","<p>That's perfectly fine and normal. <code>p_Builder</code> was initialized before it.</p>
"
"<p><code>d1 + 4</code> works but <code>4 + d1</code> doesn't even though 4 can be converted implicitly to a GMan. Why aren't they equivalent?</p>

<pre><code>struct GMan
{
    int a, b;

    GMan() : a(), b() {}
    GMan(int _a) : a(_a), b() {}
    GMan(int _a, int _b) : a(_a), b(_b) {}

    GMan operator +(const GMan&amp; _b)
    {
         GMan d;
         d.a = this-&gt;a + _b.a;
         d.b = this-&gt;b + _b.b;
         return d;
    }
};

int main()
{
    GMan d1(1, 2), d(2);
    GMan d3;
    d3 = d1 + 4; 
    d3 = 4 + d1;
}
</code></pre>
","87234","","<p><a href=""http://stackoverflow.com/questions/4165072/no-implicit-conversion-in-operator-overloading/4165125#4165125"">This</a> answer is correct. Those points then entail the canonical way of implementing such operators:</p>

<pre><code>struct GMan
{
    int a, b;

    /* Side-note: these could be combined:
    GMan():a(),b(){}
    GMan(int _a):a(_a),b(){}
    GMan(int _a, int _b):a(_a),b(_b){}
    */
    GMan(int _a = 0, int _b = 0) : a(_a), b(_b){} // into this

    // first implement the mutating operator
    GMan&amp; operator+=(const GMan&amp; _b)
    {
        // the use of 'this' to access members
        // is generally seen as noise
        a += _b.a;
        b += _b.b;

        return *this;
    }
};

// then use it to implement the non-mutating operator, as a free-function
// (always prefer free-functions over member-functions, for various reasons)
GMan operator+(GMan _a, const GMan&amp; _b)
{
    _a += b; // code re-use
    return _a;
}
</code></pre>

<p>And so on for other operators.</p>
"
"<p>I do not believe that it is possible to completely avoid C-style casts when writing C++. I was surprised to <a href=""http://stackoverflow.com/questions/4219160/avoiding-truncation-warnings-from-my-c-compiler-when-initializing-signed-values"">find out</a> that I needed to use a C-style cast to avoid a compiler truncation warning:</p>

<pre><code>short value_a = 0xF00D;                     // Truncation warning in VS2008
short value_b = static_cast&lt;short&gt;(0xF00D); // Truncation warning in VS2008
short value_c = (short)0xF00D;              // No warning!
</code></pre>

<p>Are there other scenarios where there is no C++-style substitute for a C-style cast?</p>
","87234","","<p>In C++, the C-style cast is defined (§5.4) in terms of C++-style casts. So for every cast you can do C-style, there's a matching C++-style cast (almost).</p>

<p>The ""almost"" is that C-style casts ignore base class accessibility. That is, there is no equivalent C++-style cast for the following:</p>

<pre><code>struct foo {};
struct bar : private foo {};

bar b;
foo* f = (foo*)&amp;b; // only way this can be done in a well-defined manner
</code></pre>

<p>So, no it's not strictly-speaking possible to completely ditch C-style casts. But the number of areas where a (combination  of) C++-style casts doesn't suffice is few in count.</p>

<hr>

<p>The above is the ""language answer"". What you're experiencing has nothing to do with C-style casts versus C++ casts, but just compiler implementation. Warnings are absolutely implementation-specific, and have nothing to do with C++.</p>

<p>So don't make the mistake of using your findings <em>on this particular compiler in this particular situation</em> for concluding things <em>about C++ in general</em>.</p>
"
"<p>Consider the following C++ program:</p>

<pre><code>#include &lt;cstdlib&gt; // for exit(3)
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;

void die()
{
    exit(0);
}

int main()
{
    string s(""Hello, World!"");
    cout &lt;&lt; s &lt;&lt; endl;
    die();
}
</code></pre>

<p>Running this through valgrind shows this (some output trimmed for brevity):</p>

<pre><code>==1643== HEAP SUMMARY:
==1643==     in use at exit: 26 bytes in 1 blocks
==1643==   total heap usage: 1 allocs, 0 frees, 26 bytes allocated
==1643==
==1643== LEAK SUMMARY:
==1643==    definitely lost: 0 bytes in 0 blocks
==1643==    indirectly lost: 0 bytes in 0 blocks
==1643==      possibly lost: 26 bytes in 1 blocks
==1643==    still reachable: 0 bytes in 0 blocks
==1643==         suppressed: 0 bytes in 0 blocks
</code></pre>

<p>As you can see, there's a <strong>possibility</strong> that 26 bytes allocated on the heap were lost.  I know that the <code>std::string</code> class has a 12-byte struct (at least on my 32-bit x86 arch and GNU compiler 4.2.4), and ""Hello, World!"" with a null terminator has 14 bytes.  If I understand it correctly, the 12-byte structure contains a pointer to the character string, the allocated size, and the reference count (someone correct me if I'm wrong here).</p>

<p>Now my questions:  How are C++ strings stored with regard to the stack/heap? Does a stack object exist for a <code>std::string</code> (or other STL containers) when declared?</p>

<p>P.S. I've read somewhere that valgrind <strong>may</strong> report a false positive of a memory leak in some C++ programs that use STL containers (and ""almost-containers"" such as <code>std::string</code>).  I'm not too worried about this leak, but it does pique my curiosity regarding STL containers and memory management.</p>
","87234","","<p>Calling <code>exit</code> ""terminates the program without leaving the current block and hence without
destroying any objects with automatic storage duration"".</p>

<p>In other words, leak or not, you shouldn't really care. When you call <code>exit</code>, you're saying ""close this program, I no longer care about anything in it."" So stop caring. :)</p>

<p>Obviously it's going to leak resources because you never let the destructor of the string run, absolutely regardless of how it manages those resources.</p>
"
"<p>I'm following along with the OpenGL Super Bible 5th edition, and they define a vector(vector as in math) as </p>

<pre><code>typedef float   M3DVector3f[3];
</code></pre>

<p>I'm trying to add an instance of this to an std::vector(the 're sizable array' in c++), however I keep getting an error saying: </p>

<pre><code>array initialization needs curly braces
</code></pre>

<p><a href=""http://pastebin.com/HDZYmyNa"" rel=""nofollow"">Full Error</a></p>

<p>The way I defined the std::vector and the way I'm adding to it is:</p>

<pre><code>std::vector&lt;M3DVector3f&gt; vertices;

float vertex[3];
sscanf_s(line.c_str(), ""%*s %f %f %f"", &amp;vertex[0], &amp;vertex[1], &amp;vertex[2]);

M3DVector3f v = {vertex[0], vertex[1], vertex[3]};

vertices.push_back(v);
</code></pre>

<p>I've gathered that the problem is with the vertices.push_back(v) call, because I don't get an error when I comment that out. Could someone explain to me and help me figure out why it won't let me add this vector to my vector?</p>
","87234","","<p>Arrays cannot be (directly) copied or assigned, and standard containers requires types to be copyable and assignable.</p>

<p>However, you can (and probably should) do this instead:</p>

<pre><code>struct M3DVector3f // a basic vector class
{
    float x;
    float y;
    float z;
};
</code></pre>

<p>Which <em>is</em> copyable and just as usable.</p>
"
"<p>I find myself repeatedly baffled by the <code>rdstate()</code> flags - <code>good()</code>, <code>bad()</code>, <code>eof()</code>, <code>fail()</code> - and how they are expressed in <code>basic_ios::operator!</code>, <code>operator bool</code> and <code>operator void*</code>. </p>

<p>Could somebody put me out of my misery and explain this so I never have to think twice again?</p>
","87234","","<p>In addition to <a href=""http://stackoverflow.com/questions/4258887/semantics-of-flags-on-basic-ios/4258924#4258924"">James' answer</a>, it's important to remember that these flags indicate <em>results</em> of operations, so won't be set unless you perform one.</p>

<p>A common error is to do this:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::ifstream file(""main.cpp"");

    while (!file.eof()) // while the file isn't at eof...
    {
        std::string line;
        std::getline(file, line); // ...read a line...

        std::cout &lt;&lt; ""&gt; "" &lt;&lt; line &lt;&lt; std::endl; // and print it
    }
}
</code></pre>

<p>The problem here is that <code>eof()</code> won't be set until <em>after</em> we try to get the last line, at which point the stream will say ""nope, no more!"" and set it. This means the ""correct"" way is:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::ifstream file(""main.cpp"");

    for (;;)
    {
        std::string line;
        std::getline(file, line); // read a line...

        if (file.eof()) // ...and check if it we were at eof
            break;

        std::cout &lt;&lt; ""&gt; "" &lt;&lt; line &lt;&lt; std::endl;
    }
}
</code></pre>

<p>This places the check in the correct location. This is very unruly though; luckily for us, the return value for <code>std::getline</code> is the stream, and the stream has a conversion operator that allows it to be tested in a boolean context, with the value of <code>fail()</code>, which includes <code>eof()</code>. So we can just write:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::ifstream file(""main.cpp"");

    std::string line;
    while (std::getline(file, line)) // get line, test if it was eof
        std::cout &lt;&lt; ""&gt; "" &lt;&lt; line &lt;&lt; std::endl;
}
</code></pre>
"
"<p>Would you write the following simple container any other way or it's totally sensible as it is:</p>

<pre><code>template &lt;typename T, bool small_&gt;
struct TransType
{
   typedef const T&amp; param_type;
};

template &lt;typename T&gt;
struct TransType&lt;T, true&gt;
{
   typedef const T param_type;
};

template &lt;class T&gt;
class Container:public TransType&lt;T,sizeof(T)&lt;=sizeof(void*)&gt; {
 public:
  param_type getVal(){
   return obj;
  }
  void setVal(param_type input){
   containment=input;
  }
 private:
  T containment;
};
</code></pre>
","87234","","<p>Look into <a href=""http://www.boost.org/doc/libs/1_45_0/libs/utility/call_traits.htm"" rel=""nofollow"">Boost.CallTraits</a>. Namely, <code>boost::call_traits&lt;T&gt;::param_type</code>.</p>

<p>You shouldn't need the client to specify whether the type is small or not, that's the metafunction's job. Nor is there really a need to inherit from anything.</p>

<p>In fact your code right now is <strong>ill-formed</strong>. Because <code>param_type</code> isn't a dependent type, the lookup is done without taking into consideration the base class; and will not be found. You'd need to either explicitly qualify it with the base class, add a using-directive, or re-typedef it.</p>

<p>You just want to end up with:</p>

<pre><code>template &lt;typename T&gt;
struct Container
{
    //typedef typename boost::call_traits&lt;T&gt;::param_type param_type;
    typedef typename TransType&lt;T&gt;::param_type param_type;

    // ...
};
</code></pre>

<p>By:</p>

<pre><code>namespace detail
{
    template &lt;typename T, bool small_&gt;
    struct TransType
    {
       typedef const T&amp; param_type;
    };

    template &lt;typename T&gt;
    struct TransType&lt;T, true&gt;
    {
       typedef const T param_type;
    };
}

template &lt;typename T&gt;
struct TransType&lt;T&gt;
{
   typedef detail::TransType&lt;T, sizeof(T)&lt;=sizeof(void*)&gt; param_type;
};
</code></pre>

<p>Now the condition is automatic, and there's no base class hassle.</p>
"
"<p>following, variable in code has no initial value and printed this variable.</p>

<pre><code>int var;
cout &lt;&lt; var &lt;&lt; endl;
</code></pre>

<p>output : 2514932</p>

<pre><code>double var;
cout &lt;&lt; var &lt;&lt; endl;
</code></pre>

<p>output : 1.23769e-307</p>

<p>i don't understand this numbers of output. Can any one explain me?</p>
","87234","","<p>Put simply, <code>var</code> is not initialized and reading an uninitialized variable leads to <a href=""http://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior""><strong>undefined behavior</strong></a>.</p>

<p>So don't do it. The moment you do, your program is no longer guaranteed to do anything you say.</p>

<hr>

<p>Formally, ""reading"" a value means performing an lvalue-to-rvalue conversion on it. And §4.1 states ""...if the object is uninitialized, a program that necessitates this conversion has undefined behavior.""</p>

<p>Pragmatically, that just means the value is garbage (after all, it's easy to see reading an <code>int</code>, for example, just gets random bits), but we can't <em>conclude</em> this, or you'd be defining undefined behavior.</p>

<p>For a real example, consider:</p>

<pre><code>#include &lt;iostream&gt;

const char* test()
{
    bool b; // uninitialized

    switch (b) // undefined behavior!
    {
    case false:
        return ""false"";      // garbage was zero (zero is false)
    case true: 
        return ""true"";       // garbage was non-zero (non-zero is true)
    default:
        return ""impossible""; // options are exhausted, this must be impossible...
    }
}

int main()
{
    std::cout &lt;&lt; test() &lt;&lt; std::endl;
}
</code></pre>

<p>Naïvely, one would conclude (via the reasoning in the comments) that this should never print <code>""impossible""</code>; but with undefined behavior, anything is possible. Compile it with <code>g++ -02</code>.</p>
"
"<p>Simplified: Because the way the problem was presented before was misleading. My mistake. Also not to make peoples' time a complete waste :) :::</p>

<p><strong>Y.h</strong></p>

<pre><code>#ifndef Y_H
#define Y_H

#include &lt;iostream&gt;

class X;
class Y
{
    private:
        friend class X;
        void Print()
        {
            std::cout &lt;&lt; ""Y::Print"" &lt;&lt; std::endl;
        }
};

#endif
</code></pre>

<p><strong>X.h</strong></p>

<pre><code>#ifndef X_H
#define X_H

#include ""Y.h""

class X
{
    public:
        void Something(Y* pY)
        {
            pY-&gt;Print();
        }
};          

#endif
</code></pre>

<p>This is somewhat different from my original problem. I apologize for all the trouble :). I assure you, this IS possible.</p>

<p>Rules:
Don't change Y.h or X.h. 
Get <code>X::Something</code> to do something other than what it is doing now.</p>

<p>This came to me when I was thinking about <a href=""http://stackoverflow.com/questions/4256803/is-there-any-way-to-replace-a-function-in-a-library"">this.</a></p>
","87234","","<p>It's impossible.</p>

<p>At this point:</p>

<pre><code>pRoot-&gt;Evaluate();
</code></pre>

<p>The compiler already knows it'll be calling <code>Node::Evaluate</code>, because it's non-virtual. You've said you cannot edit this implementation, so now you know the only path to take is to modify the implementation of <code>Node::Evaluate</code>.</p>

<p>Which you said you also cannot do. So that's it, you can't.</p>

<hr>

<p>I'd recommend you stop beating around the bush and ask a real question. Say ""this is the library I'm using, this is how I'm using it, here's what's happening, but here's what I want to happen. How?"" Or even expand the scope to ""Here's the problem I'm solving, and to solve it..."" to allow completely different approaches.</p>

<p>But asking these ""puzzle"" questions with ill-defined parameters and goals is silly. So don't.</p>
"
"<p>I have written the following basic Tuple template:</p>

<pre><code>template &lt;typename... T&gt;
class Tuple;

template &lt;uintptr_t N, typename... T&gt;
struct TupleIndexer;

template &lt;typename Head, typename... Tail&gt;
class Tuple&lt;Head, Tail...&gt; : public Tuple&lt;Tail...&gt; {

    private:
    Head element;

    public:
    template &lt;uintptr_t N&gt;
    typename TupleIndexer&lt;N, Head, Tail...&gt;::Type&amp; Get() {
        return TupleIndexer&lt;N, Head, Tail...&gt;::Get(*this);
    }

    uintptr_t GetCount() const {
        return sizeof...(Tail) + 1;
    }

    private:
    friend struct TupleIndexer&lt;0, Head, Tail...&gt;;

};

template &lt;&gt;
class Tuple&lt;&gt; {

    public:
    uintptr_t GetCount() const {
        return 0;
    }

};

template &lt;typename Head, typename... Tail&gt;
struct TupleIndexer&lt;0, Head, Tail...&gt; {

    typedef Head&amp; Type;

    static Type Get(Tuple&lt;Head, Tail...&gt;&amp; tuple) {
        return tuple.element;
    }

};

template &lt;uintptr_t N, typename Head, typename... Tail&gt;
struct TupleIndexer&lt;N, Head, Tail...&gt; {

    typedef typename TupleIndexer&lt;N - 1, Tail...&gt;::Type Type;

    static Type Get(Tuple&lt;Head, Tail...&gt;&amp; tuple) {
        return TupleIndexer&lt;N - 1, Tail...&gt;::Get(*(Tuple&lt;Tail...&gt;*) &amp;tuple);
    }

};
</code></pre>

<p>It works just fine, and I can access elements in array-like fashion by using <code>tuple.Get&lt;<em>Index</em>>()</code> - but I can only do that if I know the index at compile-time.  However, I need to access elements in the tuple by index at runtime, and I won't know at compile-time which index needs to be accessed.  Example:</p>

<pre><code>int chosenIndex = getUserInput();
void* chosenElement = tuple.Get(chosenIndex);
cout &lt;&lt; ""The option you chose was: "" &lt;&lt; ((MyAbstractBaseClass*) chosenElement)-&gt;getInfo() &lt;&lt; endl;
</code></pre>

<p>What's the best way to do this?</p>

<p><strong>EDIT:</strong></p>

<p><strong>Hackish solution below:</strong></p>

<p>Okay, I've got an idea.  I already figured out one way of doing this before I even posted this question, but it was hackish and produced warnings.  Since another solution isn't forthcoming right away, maybe you guys could help me improve my hackish one. :-)</p>

<p>The tuple can't normally be accessed like an array because the elements are not all necessarily of the same size.  (Hence array-style multiplication to arrive at the correct offset in the class structure will not help.)  However, I managed to work around this by creating a static table that contains a list of offsets for a tuple.  Here's the complete tuple and related templates:</p>

<pre><code>#include &lt;cstddef&gt;

template &lt;typename... T&gt;
class Tuple;

template &lt;uintptr_t N, typename... T&gt;
struct TupleIndexer;

template &lt;typename... T&gt;
struct TupleOffsets;

template &lt;typename Head, typename... Tail&gt;
struct TupleOffsets&lt;Head, Tail...&gt; {

    TupleOffsets() { Init(offsets); }
    static void Init(uintptr_t* offsets);
    uintptr_t const&amp; operator[] (uintptr_t i) const { return offsets[i]; }

    private:
    uintptr_t offsets[sizeof...(Tail) + 1];

};

template &lt;typename Head, typename... Tail&gt;
void TupleOffsets&lt;Head, Tail...&gt;::Init(uintptr_t* offsets) {

    typedef Tuple&lt;Head, Tail...&gt; Type;

    *offsets = offsetof(Type, element);
    TupleOffsets&lt;Tail...&gt;::Init(++offsets);

}

template &lt;&gt;
struct TupleOffsets&lt;&gt; {

    TupleOffsets() {}
    static void Init(uintptr_t* offsets) {}

};

template &lt;typename Head, typename... Tail&gt;
class Tuple&lt;Head, Tail...&gt; : public Tuple&lt;Tail...&gt; {

    private:
    Head element;

    public:
    void* Get(uintptr_t i) {
        return (uint8_t*) this + offsets[i];
    }

    template &lt;uintptr_t N&gt;
    typename TupleIndexer&lt;N, Head, Tail...&gt;::Type&amp; Get() {
        return TupleIndexer&lt;N, Head, Tail...&gt;::Get(*this);
    }

    uintptr_t GetCount() const {
        return sizeof...(Tail) + 1;
    }

    private:
    static const TupleOffsets&lt;Head, Tail...&gt; offsets;

    friend struct TupleOffsets&lt;Head, Tail...&gt;;
    friend struct TupleIndexer&lt;0, Head, Tail...&gt;;

};

template &lt;typename Head, typename... Tail&gt;
const TupleOffsets&lt;Head, Tail...&gt; Tuple&lt;Head, Tail...&gt;::offsets;

template &lt;&gt;
class Tuple&lt;&gt; {

    public:
    uintptr_t GetCount() const {
        return 0;
    }

};

template &lt;typename Head, typename... Tail&gt;
struct TupleIndexer&lt;0, Head, Tail...&gt; {

    typedef Head&amp; Type;

    static Type Get(Tuple&lt;Head, Tail...&gt;&amp; tuple) {
        return tuple.element;
    }

};

template &lt;uintptr_t N, typename Head, typename... Tail&gt;
struct TupleIndexer&lt;N, Head, Tail...&gt; {

    typedef typename TupleIndexer&lt;N - 1, Tail...&gt;::Type Type;

    static Type Get(Tuple&lt;Head, Tail...&gt;&amp; tuple) {
        return TupleIndexer&lt;N - 1, Tail...&gt;::Get(*(Tuple&lt;Tail...&gt;*) &amp;tuple);
    }

};
</code></pre>

<p>In practice it works.  However, the compiler gives me a warning for using offsetof on a non-POD data type, and I'm not sure how portable this solution is.  Anyone know how I might improve this solution?</p>
","87234","","<p>Do something like this:</p>

<pre><code>namespace detail
{
    template &lt;std::size_t I, typename R, typename Tuple, typename Func&gt;
    R select(Tuple&amp;&amp; pTuple, Func pFunc)
    {
        return pFunc(get&lt;I&gt;(std::forward&lt;Tuple&gt;(pTuple)));
    }

    template &lt;std::size_t I, typename R, typename Tuple, typename Func&gt;
    R select_element(Tuple&amp;&amp; pTuple, std::size_t pIndex, Func pFunc)
    {
        if (pIndex == I)
            return select&lt;I, R&gt;(std::forward&lt;Tuple&gt;(pTuple), pFunc);
        else
            return select&lt;I + 1, R&gt;(std::forward&lt;Tuple&gt;(pTuple), pIndex, pFunc);
    }
}

template &lt;typename Tuple, typename Func&gt;
R select(Tuple&amp;&amp; pTuple, std::size_t pIndex, Func pFunc)
{
    typedef typename std::remove_reference&lt;Tuple&gt;::type tuple_type;

    // assumes all possible calls to Func return the same type
    typedef typename std::tuple_element&lt;0, tuple_type&gt;::type dummy_type;
    typedef typename std::result_of&lt;Func, dummy_type&gt;::type result_type;

    if (pIndex &gt;= std::tuple_size&lt;tuple_type&gt;::value)
        throw std::out_of_range(""select out of range"");

    return detail::select&lt;0, result_type&gt;(
                                    std::forward&lt;Tuple&gt;(pTuple), pIndex, pFunc);
}
</code></pre>

<p>This lets you call a functor with a run-time selected element, by checking each index incrementally. It returns whatever the function call returns, but it assumes that all invocations result in the same type. (Though right now, it'll ""work"" as long as all invocations happen to be implicitly convertible to the same type as an invocation of the first element. You can assert they all match if you want to, but that's outside the scope of this question.)</p>

<p>I'd be surprised if the compiler didn't unroll it, but I don't know for certain. In any case, it's simple and works (well, untested, but I assume it does) and that's far more important.</p>

<p>So whatever you wanted to do with your run-time selected element, operate on it with this. You can make the call templated:</p>

<pre><code>struct print_element
{
    // T is determined at compile time for each possible element type,
    // but which overload gets selected is determined at run-time
    template &lt;typename T&gt;
    void operator()(const T&amp; pX) const
    {
        std::cout &lt;&lt; pX &lt;&lt; std::endl;
    }
};
</code></pre>

<p>If you really just want the value as some type, then you can make a simple functor:</p>

<pre><code>namespace detail
{
    template &lt;typename R&gt;
    struct get_element
    {
        template &lt;typename T&gt;
        R operator()(T&amp;&amp; pValue) const
        {
            return std::forward&lt;T&gt;(pValue);
        }
    };
}

template &lt;typename R, typename Tuple&gt;
R get(Tuple&amp;&amp; pTuple, std::size_t pIndex)
{
   return select(std::forward&lt;Tuple&gt;(pTuple), pIndex, get_element&lt;R&gt;());
}
</code></pre>

<p>You can use it like this:</p>

<pre><code>auto x = get&lt;boost::any&gt;(myTuple, i);
</code></pre>

<p>To get <code>void*</code>'s (yuck), you need one last simple utility (too bad we don't get polymorphic lambda's):</p>

<pre><code>class get_address
{
public:
    template &lt;typename T&gt;
    get_address(T&amp; pValue) :
    mResult(&amp;pValue)
    {}

    void* get() const
    {
        return mResult;
    }

    operator void*() const
    {
        return get();
    }

private:
    void* mResult;
};
</code></pre>

<p>Allowing:</p>

<pre><code>void* addr = get&lt;get_address&gt;(myTuple, i);
</code></pre>
"
"<p>It just happened to me I wondered how resources are freed in the following case.</p>

<pre><code>class Base {
  Resource *r;

public:
  Base() { /* ... */ }
  ~Base() {
    delete r; 
  }
};

class Derived : public Base {
public:
  Derived() { /* ... */ }
  ~Derived() {
    /* Suddenly something here throws! */
  }
};

int main() {
  try {
    Derived d;
  } catch(...) {
    /* what happened with Base::r !? */
  }
}
</code></pre>

<p>Will the base class destructor be called if the derived class destructor throws? Or will there be a leak?</p>
","87234","","<p>According to §15.2/2:</p>

<blockquote>
  <p>An object that is partially constructed or partially destroyed will have destructors executed for all of its fully constructed subobjects, that is, for subobjects for which the constructor has completed execution and the destructor has not yet begun execution.</p>
</blockquote>

<p>So the base class destructor should be called. That is, just like we know this will clean up the base class:</p>

<pre><code>#include &lt;iostream&gt;

struct foo
{
    ~foo()
    {
        std::cout &lt;&lt; ""clean"" &lt;&lt; std::endl;
    }
};

struct bar : foo
{
    bar()
    { // foo is initialized...
        throw 0; // ...so its destructor is run
    }
};

int main()
{
    try
    {
        bar b;
    }
    catch (...)
    {
        std::cerr &lt;&lt; ""caught"" &lt;&lt; std::endl;
    }
}
</code></pre>

<p>And that this will clean up the member:</p>

<pre><code>#include &lt;iostream&gt;

struct foo
{
    ~foo()
    {
        std::cout &lt;&lt; ""clean"" &lt;&lt; std::endl;
    }
};

struct bar
{
    ~bar()
    { // f has been initialized...
        throw 0; // ...so its destructor will run
    }

    foo f;
};

int main()
{
    try
    {
        bar b;
    }
    catch (...)
    {
        std::cerr &lt;&lt; ""caught"" &lt;&lt; std::endl;
    }
}
</code></pre>

<p>This will also clean up the base class:</p>

<pre><code>#include &lt;iostream&gt;

struct foo
{
    ~foo()
    {
        std::cout &lt;&lt; ""clean"" &lt;&lt; std::endl;
    }
};

struct bar : foo
{
    ~bar()
    { // foo has been initialized...
        throw 0; // ...so its destructor will run
    }
};

int main()
{
    try
    {
        bar b;
    }
    catch (...)
    {
        std::cerr &lt;&lt; ""caught"" &lt;&lt; std::endl;
    }
}
</code></pre>

<p>That's my understanding of the quote.</p>
"
"<p>If a class is always going to be inherited, does it make sense to make the constructor <code>protected</code>?</p>

<pre><code>class Base
{
protected:
    Base();
};

class Child : protected Base
{
public:
    Child() : Base();
};
</code></pre>

<p>Thanks.</p>
","87234","","<p>If it's always going to be a base (a ""mixin""), yes. Keep in mind a class with pure virtual functions will always be a base, but you won't need to do this since it cannot be instantiated anyway.</p>

<p>Also, give it either <a href=""http://www.gotw.ca/publications/mill18.htm"" rel=""nofollow"">a public virtual destructor or a protected non-virtual destructor</a>.</p>
"
"<p>I lack industry experience with the language. But in my spare time I have encountered a couple of places where I need to compare pointers, preferably with behavior defined by the standard.</p>

<p>First case, if I decide to use ordered binary tree as a container in my application (and not hash table) and I want equality to be the object's identity (i.e. equal means the same instance) then I find no portable way to do this.</p>

<p>Second, if I want to test the containment relationship between the ""complete objects"" and their sub-objects, I again seem to have no portable approach. That is if I have two void* pointers ""p"" and ""q"", and I have the size of the object pointed to by ""q"", I see no way to test whether ""p"" is a non-static member variable of ""q"" or not. I fail to find encouragement in paragraph 5.9 (""Relational operators"") from the standard. The latter scenario appears, for example, in the garbage collector from this boost forum <a href=""http://lists.boost.org/Archives/boost/2009/04/150748.php"" rel=""nofollow"">post</a>. I liked the general idea and started to explore it, but certain parts seem to use pointers and allocation semantics in ways which are not portable.</p>

<p>That is I want to know how to make the <code>contains</code> function from the following code portable:</p>

<pre><code>#include &lt;stddef.h&gt;
#include &lt;assert.h&gt;

struct A {
    int x;
} a;

struct B {
    int y;
} b;

bool contains(const void *outer, size_t size, const void *inner)
{
    return (outer &lt;= inner) &amp;&amp;
        (inner &lt; static_cast&lt;const char *&gt;(outer) + size);
}

int main()
{
    assert(contains(&amp;a, sizeof(a), &amp;a.x));
    assert(contains(&amp;b, sizeof(b), &amp;b.y));
    assert(!contains(&amp;a, sizeof(a), &amp;b.y));
    assert(!contains(&amp;b, sizeof(b), &amp;a.x));
}
</code></pre>

<p>Thanks and best regards.</p>

<p>PS:<br>
Ok, after consulting the standard again, I see that it states explicitly, as GMan informs in his answer, that the functors such as <code>less</code> and <code>less_equal</code> provide total ordering for pointers. I think it is also implied that the ordering will be consistent with the built-in comparison operators <code>&lt;</code> and <code>&lt;=</code>, but that point could be addressed more pedantically. The built-in operators are not predictable when the pointers do not point in the same array, or to sub-objects of the same object. I mean, what is the test for distinctiveness in this total order - the binary representation of the pointer? For example, when not comparable in well-defined manner with the built-in operators, what does it mean to be non-identical in the total order on <code>void*</code> pointers?</p>

<p>For member variables with the same access control, the standard defines their order in memory, i.e. when observed through pointer comparison. It is the order of appearance in the object's type definition. From the perspective of the built-in comparison operators, the first member variable has the smallest address and the last member variable has the biggest address. Also, in the section on types, it is stated that objects of a ""trivially copyable type"" will be laid out in memory in the range between the value of the <code>&amp;</code> operator and the following <code>sizeof</code> characters. Now lets assume that the functors provide total order in the sense of pointers to distinct objects being distinct. Doesn't this mean that, even if inadvertently, the standard implies the behavior of the snippet above, if functors are used instead of the built-in operators in the <code>contains</code> function?  </p>

<p>Just want to get the point clear - if the standard has omission, or simply needs clarification, or it leaves flexibility for the implementation of pointer comparison.</p>
","87234","","<p>I'm not quite sure what you're asking for (i.e., what exactly are you trying to accomplish?), but I think this is what you want to know:</p>

<p>The relational functors <code>greater</code>, <code>greater_equal</code>, <code>less</code>, and <code>less_equal</code> defined in <code>&lt;functional&gt;</code> yield total ordering for any pointer type, even if the built-in relational operators do not.</p>

<p>That is:</p>

<pre><code>#include &lt;functional&gt;
#include &lt;iostream&gt;

int main()
{
    int i, *j = &amp;i;    
    int k, *l = &amp;k;

    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::less&lt;int*&gt;()(j, l) &lt;&lt; std::endl;
}
</code></pre>

<p>is well-defined. (Note the output is implementation-defined, but you <em>are</em> guaranteed total ordering.)</p>

<p>The associative containers predicate defaults to <code>std::less</code>, so it's okay to use pointers as keys.</p>
"
"<p>If I've a class like this,</p>

<pre><code>class Sample
{
private:
      int X;
};
</code></pre>

<p>Then we cannot access X from outside, so this is illegal,</p>

<pre><code>    Sample s;
    s.X = 10; // error - private access
</code></pre>

<p>But we can make it accessible <strong>without editing the class</strong>! All we need to do is this,</p>

<pre><code>#define private public  //note this define!

class Sample
{
private:
      int X;
};

//outside code
Sample s;
s.X = 10; //no error!
</code></pre>

<p>Working code at ideone : <a href=""http://www.ideone.com/FaGpZ"" rel=""nofollow"">http://www.ideone.com/FaGpZ</a></p>

<p>That means, we can change the access-specifiers by defining such macros just before the class definition, or before <code>#include &lt;headerfile.h&gt;</code>,</p>

<pre><code>#define public private //make public private
//or
#define protected private //make protected private
//or
#define so on
</code></pre>

<p>Isn't it a problem with C++ (Macros/access-specifiers/whatever)? </p>

<p>Anyway, the point of this topic is: </p>

<p><strong>Using macros, we can easily violate encapsulation. Access-specifiers are not foolproof!</strong> Am I right?</p>
","87234","","<p>First of all, it's illegal to do that. <code>private</code> is a keyword, and you can't use it as an identifier in a macro; your program would be ill-formed.</p>

<p>But in any case, it's not a problem with macro's at all. It's with the fool who used them in a silly manner. :) (They're there to help you be safe, they're not there to help you be safe and block all access to them no matter what you try. C++ protects against Murphy, not Machiavelli.)</p>

<p>Note that you can access privates in a well-formed and well-defined manner, as <a href=""http://bloglitb.blogspot.com/2010/07/access-to-private-members-thats-easy.html"">demonstrated here</a>. Again, this isn't a problem with the language, it's just not the job of the language to do more than necessary to keep prying hands out.</p>
"
"<p>I'm trying to recreate the inbuilt vector class in cpp to get a bit more practice with classes and memory management. I keep getting an error that says 'ISO C++ forbids declaration of ‘allocator’ with no type' and I can't figure out why for the life of me. Is there something I'm missing?</p>

<pre><code>#include &lt;cstddef&gt;
#include &lt;memory&gt;

template &lt;class T&gt;
class myvector{
public:
    typedef T* iterator;
    typedef const T* const_iterator;
    typedef size_t size_type;

    myvector(){ data = avail = limit = 0; }

    explicit myvector(size_type n, const T&amp; t = T()) { create(n,t); }

    myvector(const myvector&amp; v){  create(v.begin(), v.end());  }

    ~myvector() {  uncreate();  }

    myvector&amp; operator=(const myvector&amp; v)
    {
        if (&amp;v != this){
            uncreate();
            create(v.begin(), v.end());
        }
        return *this;
    }


    T&amp; operator[](size_type i) { return data[i];  }
    const T&amp; operator[](size_type i) const {  return data[i];  }

    iterator begin(){  return data;  }
    const_iterator begin() const{  return data;  }

    iterator end(){  return limit;  }    
    const_iterator end() const{  return limit;  }

    size_type size(){  return avail - data;  }

    void push_back(T t)
    {
        if(avail == limit)
            size_type new_size = max(2*(limit-data),ptrdiff_t(1));
            iterator new_data = alloc.allocate(new_size);
            iterator new_avail = uninitialized_copy(data,avail,new_data);
            uncreate();
            data = new_data;
            avail = new_avail;
            limit = data + new_size;
        alloc.construct(avail++,t);
    }
private:
    iterator data;
    iterator avail;
    iterator limit;
    allocator&lt;T&gt; alloc;

    void create(size_type n, const T&amp; t)
    {
        data = alloc.allocate(n);
        limit = avail = data+n;
        uninitialized_fill(data,limit,t);
    }

    void create(const_iterator i, const_iterator j)
    {
        data = alloc.allocate(j-i);
        limit = avail = uninitialized_copy(i,j,data);
    }

    void uncreate()
    {
        if(data){
            iterator it = avail;
            while(it != data) {   alloc.destroy(--it);    }
            alloc.deallocate(data,limit-data);
        }
        data = limit = avail = 0;
    }
};
</code></pre>
","87234","","<p>It should be, <code>std::allocator&lt;T&gt; alloc;</code>, everything in the standard library is contained within the namespace <code>std</code>.</p>
"
"<p>Okay I'm going to give a simple example of my problem:</p>

<pre><code>void Increment(Tuple&lt;int, int&gt;&amp; tuple) {
    ++tuple.Get&lt;0&gt;();
}

int main() {

    Tuple&lt;int, int&gt; tuple;

    tuple.Get&lt;0&gt;() = 8;

    Increment(tuple);

    printf(""%i\n"", tuple.Get&lt;0&gt;()); // prints 9, as expected

    return 0;

}
</code></pre>

<p>This compiles just fine, and all is peachy.  The Increment function just increments the first element in the tuple, and then I print that element.  However, wouldn't it be nice if my Increment function could be used on any kind of element?</p>

<pre><code>template &lt;typename T&gt;
void Increment(Tuple&lt;T, T&gt;&amp; tuple) {
    ++tuple.Get&lt;0&gt;(); // &lt;-- compile ERROR
}

int main() {

    Tuple&lt;int, int&gt; tuple;

    tuple.Get&lt;0&gt;() = 8;

    Increment&lt;int&gt;(tuple);

    printf(""%i\n"", tuple.Get&lt;0&gt;());

    return 0;

}
</code></pre>

<p>My second example spits out the following error at compile-time:</p>

<pre><code>error: expected primary-expression before ')' token
</code></pre>

<p>I'm at my wits end trying to figure out why this causes problems.  Since the template parameter is 'int', the generated code should be <em>identical</em> to my hard-coded example.  How can I get this to work?</p>
","87234","","<p>It should be:</p>

<pre><code>++tuple.template Get&lt;0&gt;();
</code></pre>

<p>In the same way you need <code>typename</code> to specify a type qualified from a dependent type, you need <code>template</code> to specify a template function qualified from a dependent type.</p>
"
"<p>What are your techniques of optimizing your code in c++?</p>
","87234","","<p>1) Write the cleanest and most straightforward code I can.<br>
2) Use a modern compiler with optimized settings.<br>
3) Be done.</p>

<p>Optional:<br>
4) If I think something is noticeably slow, profile my application.<br>
5) Use my profile results to find out what's slow, and fix it.<br>
6) Make sure it's still as clean and straightforward as possible.<br>
7) Be done.  </p>
"
"<p>Is the following legal C++ with well-defined behaviour?</p>

<pre><code>class my_class { ... };

int main()
{
    char storage[sizeof(my_class)];
    new ((void *)storage) my_class();
}
</code></pre>

<p>Or is this problematic because of pointer casting/alignment considerations?</p>
","87234","","<p>Yes, it's problematic. You simply have no guarantee that the memory is properly aligned.</p>

<p>While various tricks exist to get storage with proper alignment, you're best off using Boost's or C++0x's <code>aligned_storage</code>, which hide these tricks from you.</p>

<p>Then you just need:</p>

<pre><code>// C++0x
typedef std::aligned_storage&lt;sizeof(my_class),
                                alignof(my_class)&gt;::type storage_type;

// Boost
typedef boost::aligned_storage&lt;sizeof(my_class),
                        boost::alignment_of&lt;my_class&gt;::value&gt;::type storage_type;

storage_type storage; // properly aligned
new (&amp;storage) my_class(); // okay
</code></pre>

<p>Note that in C++0x, using attributes, you can just do this:</p>

<pre><code>char storage [[align(my_class)]] [sizeof(my_class)];
</code></pre>
"
"<p>I've got some non-copyable classes. I don't invoke any of the copy operators or constructor, and this code compiles fine. But then I upgraded to Visual Studio 2010 Ultimate instead of Professional. Now the compiler is calling the copy constructor- even when the move constructor should be invoked. For example, in the following snippet:</p>

<pre><code>inline D3D9Mesh CreateSphere(D3D9Render&amp; render, float radius, float slices) {
    D3D9Mesh retval(render);
    /* ... */
    return std::move(retval);
}
</code></pre>

<p>Error: Cannot create copy constructor, because the class is non-copyable. However, I quite explicitly moved it.</p>

<p>Edit:</p>

<pre><code>class D3D9Mesh 
: public Monitor&lt;D3D9Mesh&gt; 
{
public:
    std::unique_ptr&lt;ID3DXMesh, COMDeleter&gt; Mesh;
    std::unique_ptr&lt;ID3DXBuffer, COMDeleter&gt; Adjacency;

    inline D3D9Mesh(D3D9Render&amp; ref)
    : Monitor&lt;D3D9Mesh&gt;(&amp;ref) 
    {
    }
};
</code></pre>

<p>where Monitor is a simple class that is copyable/etc. It's the unique_ptrs which are clearly not kosher for the compiler.</p>

<p>Monitor's code:</p>

<pre><code>class D3DCommon {};
template&lt;typename T&gt; class Monitor : public D3DCommon {
protected:
    D3D9Render* render;
    Monitor(D3D9Render* ptr) 
    : render(ptr) {
        render-&gt;AddPointer(static_cast&lt;T*&gt;(this));
    }
    Monitor(Monitor&amp;&amp; ref) {
        render-&gt;AddPointer(static_cast&lt;T*&gt;(this));
    }
    Monitor(const Monitor&amp; ref) {           
        render-&gt;AddPointer(static_cast&lt;T*&gt;(this));
    }
    ~Monitor() {
        render-&gt;RemovePointer(static_cast&lt;T*&gt;(this));
    }
public:
    D3D9Render&amp; GetRender() {
        return *render;
    }
};
</code></pre>
","87234","","<p>MSVC doesn't do implicit move constructors. You need to make it yourself:</p>

<pre><code>class D3D9Mesh 
: public Monitor&lt;D3D9Mesh&gt; 
{
public:   
    inline D3D9Mesh(D3D9Render&amp; ref)
    : Monitor(&amp;ref) // don't need to re-state template argument, by the way
    {
    }

    D3D9Mesh(D3D9Mesh&amp;&amp; other)
    : Monitor(std::move(other))
    {}
};
</code></pre>

<p>Now it's movable.</p>
"
"<p>I need random numbers from 1 to 9 (without 0).</p>

<pre><code>//numbers 0 to 9
int iRand = rand() % 10;
</code></pre>

<p>But I need 1 to 9.</p>

<p>Thanks.</p>
","87234","","<p>Well, you know how to get a random integer in the range [0, x], right? That's:</p>

<pre><code>rand() % (x + 1)
</code></pre>

<p>In your case, you've set x to 9, giving you <code>rand() % 10</code>. So how can you manipulate a range to get to 1-9? Well, since 0 is the minimum value coming out of this random number generator scheme, we know we'll need to add one to have a minimum of one:</p>

<pre><code>rand() % (x + 1) + 1
</code></pre>

<p>Now you get the range [1, x + 1]. If that's suppose to be [1, 9], then x must be 8, giving:</p>

<pre><code>rand() % 9 + 1
</code></pre>

<p>That's how you should think about these things.</p>
"
"<pre><code>#include&lt;iostream&gt;
using namespace std;

class aClass
{
public:
    char *message;

    aClass(const char *message);
    ~aClass(){delete[] message;}
};

aClass::aClass(const char* newmessage)
{
    message = new char[strlen(newmessage) +1];
    strcpy(message,newmessage);
}

const ostream&amp; operator&lt;&lt;(const ostream&amp; o, const aClass &amp;a)
{
    o &lt;&lt; a.message;
    return o;
}

int main()
{
    aClass b(""Hello"");
    cout &lt;&lt; b;
}
</code></pre>

<p>Can someone explain to me why the code above produces an infinite loop?</p>
","87234","","<p>Because you have <code>const</code> where it shouldn't be:</p>

<pre><code>/////                     /////
const ostream&amp; operator&lt;&lt;(const ostream&amp; o, const aClass &amp;a)
</code></pre>

<p>The output stream is suppose to be non-const; after all, outputting data is changing something. So when you do this:</p>

<pre><code>o &lt;&lt; a.message;
</code></pre>

<p>It cannot use the normal overload for <code>char*</code>, because that one operates on a non-const stream. Instead, it searches for an appropriate overload and finds yours, determines it can construct an <code>aClass</code> from <code>a.message</code> (because your constructor is not <code>explicit</code>), does so, and calls it. This repeats forever.</p>

<p>It should be written as:</p>

<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; o, const aClass &amp;a)
{
    o &lt;&lt; a.message;
    return o;
}
</code></pre>
"
"<p>I am a bit confused about the differences between</p>

<pre><code>Type  operator +  (const Type &amp;type);
Type &amp;operator += (const Type &amp;type);
</code></pre>

<p>and</p>

<pre><code>friend Type  operator +  (const Type &amp;type1, const Type &amp;type2);
friend Type &amp;operator += (const Type &amp;type1, const Type &amp;type2);
</code></pre>

<p>which way is preferred, what do they look like and when should either be used?</p>
","87234","","<p>The proper way to implement operators, with respect to C++03 and C++0x (<a href=""http://msdn.microsoft.com/en-us/library/ms364057%28v=vs.80%29.aspx"" rel=""nofollow"">NRVO</a> and move-semantics), is:</p>

<pre><code>struct foo
{
    // mutates left-operand =&gt; member-function
    foo&amp; operator+=(const foo&amp; other)
    {
        x += other.x;

        return *this;
    }

    int x;
};

// non-mutating =&gt; non-member function
foo operator+(foo first, // parameter as value, move-construct (or elide)
                const foo&amp; second) 
{
    first += second; // implement in terms of mutating operator

    return first; // NRVO (or move-construct)
}
</code></pre>

<p>Note it's tempting to combine the above into:</p>

<pre><code>foo operator+(foo first, const foo&amp; second) 
{
    return first += second;
}
</code></pre>

<p>But sometimes (in my testing) the compiler doesn't enable NRVO (or move semantics) because it can't be certain (until it inlines the mutating operator) that <code>first += second</code> is the same as <code>first</code>. Simpler and safer is to split it up.</p>
"
"<p>Without iterating through each element, how do I create an array using new and initialize each element to a certain value?</p>

<pre><code>bool* a = new bool[100000];
</code></pre>

<p>Using VS 2008.</p>

<p>Thanks!</p>
","87234","","<p>In that case, the only value you can set it to is <code>false</code> with:</p>

<pre><code>bool* a = new bool[100000]();
</code></pre>

<p>That said, I'm not sure why you'd think you can't use a loop. They're there for a reason. You should just use the ready-made function <code>fill</code> or <code>fill_n</code> (depending on taste).</p>

<hr>

<p>Note using <code>new</code> ""raw"" like that is terrible programming practice. Use a <code>std::vector&lt;bool&gt;</code>*:</p>

<pre><code>std::vector&lt;bool&gt; v;

v.resize(100000);
std::fill(v.begin(), v.end(), true); // or false
</code></pre>

<p>Or:</p>

<pre><code>std::vector&lt;bool&gt; v;

v.reserve(100000);
std::fill_n(std::back_inserter(v), 100000, true); // or false
</code></pre>

<p>*Of course, <code>std::vector&lt;bool&gt;</code> happens to break the proper container interface so doesn't actually store <code>bool</code>'s. If that's a problem use a <code>std::vector&lt;char&gt;</code> instead.</p>
"
"<p>I have a function that uses basic_istream as an argument, and I have a std::string with the data I need to pass it. How do I do that?</p>
","87234","","<p>You can put the string data into a stream:</p>

<pre><code>std::string x;
std::stringstream ss(x); // put string into stream

function_taking_stream(ss);
</code></pre>
"
"<p>I was just thinking about the implementation of <code>std::string::substr</code>. It returns a new <code>std::string</code> object, which seems a bit wasteful to me. Why not return an object that refers to the contents of the original string and can be implicitly assigned to a <code>std::string</code>? A kind of lazy evaluation of the actual copying. Such a class could look something like this:</p>

<pre><code>template &lt;class Ch, class Tr, class A&gt;
class string_ref {
public:
    // not important yet, but *looks* like basic_string's for the most part

private:
    const basic_string&lt;Ch, Tr, A&gt; &amp;s_;
    const size_type pos_;
    const size_type len_;    
};
</code></pre>

<p>The public interface of this class would mimic all of the read-only operations of a real <code>std::string</code>, so the usage would be seamless. <code>std::string</code> could then have a new constructor which takes a <code>string_ref</code> so the user would never be the wiser. The moment you try to ""store"" the result, you end up creating a copy, so no real issues with the reference pointing to data and then having it modified behind its back.</p>

<p>The idea being that code like this:</p>

<pre><code>std::string s1 = ""hello world"";
std::string s2 = ""world"";
if(s1.substr(6) == s2) {
    std::cout &lt;&lt; ""match!"" &lt;&lt; std::endl;
}
</code></pre>

<p>would have no more than 2 <code>std::string</code> objects constructed in total. This seems like a useful optimization for code which that performs a lot of string manipulations. Of course, this doesn't just apply to <code>std::string</code>, but to any type which can return a subset of its contents.</p>

<p>As far as I know, no implementations do this.</p>

<p>I suppose the core of the question is:</p>

<p>Given a class that can be implicitly converted to a <code>std::string</code> as needed, would it be conforming to the standard for a library writer to change the prototype of a member's to return type? Or more generally, do the library writers have the leeway to return ""proxy objects"" instead of regular objects in these types of cases as an optimization?</p>

<p>My gut is that this is not allowed and that the prototypes must match exactly. Given that you cannot overload on return type alone, that would leave no room for library writers to take advantage of these types of situations. Like I said, I think the answer is no, but I figured I'd ask :-).</p>
","87234","","<p>This idea is <em><a href=""http://en.wikipedia.org/wiki/Copy-on-write"" rel=""nofollow"">copy-on-write</a></em>, but instead of COW'ing the entire buffer, you keep track of which subset of the buffer is the ""real"" string. (COW, in its normal form, was (is?) used in some library implementations.)</p>

<p>So you don't need a proxy object or change of interface at all because these details can be made completely internal. Conceptually, you need to keep track of four things: a source buffer, a reference count for the buffer, and the start and end of the string within this buffer.</p>

<p>Anytime an operation modifies the buffer at all, it creates its own copy (<em>from the start and end delimiters</em>), decreases the old buffer's reference count by one, and sets the new buffer's reference count to one. The rest of the reference counting rules are the same: copy and increase count by one, destruct a string and decrease count by one, reach zero and delete, etc.</p>

<p><code>substr</code> just makes a new string instance, except with the start and end delimiters explicitly specified.</p>
"
"<p>I am just porting some old code:</p>

<pre><code>#define NewArrayOnHeap(TYPE, COUNT, HEAP, NEWPTR, ERROR) \
((*(NEWPTR) = new ( #TYPE ""["" #COUNT ""]"", __alignof(TYPE), (HEAP), &amp;hr, (ERROR)) TYPE[COUNT] ), hr)
</code></pre>

<p>It looks like the original was supposed to define their own magical <code>new</code> operator. I am curious about this usage.</p>

<h3>Example usage</h3>

<pre><code>int main()
{
    void*   heap = /* Don't know how to define this */
    double* ptr;
    HRESULT hr;

    hr = NewArrayOnHeap(double, 10, heap, ptr, ""Help /* Just guessing here */"");
}
</code></pre>

<p>When I use <code>g++ -E</code> to get the preprocessor output, it's:</p>

<pre><code>int main()
{
    double* ptr;
    HRESULT hr;

    hr = ((*(ptr) = new ( ""double[ 10 ]"", __alignof(double), (NULL), &amp;hr, (""Help"")) double[10] ), hr);
}
</code></pre>

<p>This looks slightly more like a <code>placement new</code>.</p>

<p>But is this now an overloaded new call (with some funky parameters, a five parameter <code>new</code> call), or are the commas here the comma operator and thus it gets reduced to <code>(""Help"")</code> (which wouldn't make sense).</p>

<p>Was <code>new</code> historically (or even now) allowed to have more than two parameters, <code>(size, hint)</code>?</p>

<p>Any help on decoding would be appreciated.</p>
","87234","","<p>The section you want to look at is §5.3.4/11-12, paraphrased here:</p>

<blockquote>
  <p>The new-placement syntax is used to supply additional arguments to an allocation function. If used, overload resolution is performed on a function call created by assembling an argument list consisting of the amount of space requested (the first argument) and the expressions in the new-placement part of the new-expression (the second and succeeding arguments). The first of these arguments has type size_t and the remaining arguments have the corresponding types of the expressions in the new-placement.</p>
  
  <p>[Example:<br>
  — new T results in a call of operator new(sizeof(T)),<br>
  — new(2,f) T results in a call of operator new(sizeof(T),2,f),<br>
  — new T[5] results in a call of operator new, and<br>
  — new(2,f) T[5] results in a call of operator new[](sizeof(T)*5+y,2,f).]  </p>
</blockquote>

<p>So your macro, to be used correctly, requires that somewhere there's an <code>operator new</code> overload defined similar to:</p>

<pre><code>void* operator new[](size_t, const char*, size_t, void*, HRESULT*, const char*);
</code></pre>

<p>Which I suspect uses the information given to it to allocate memory (potentially from a pre-allocated source) that satisfies alignment requirements, while logging this allocation and providing a custom error message if the allocation could not be made.</p>

<p>Personally, I find it gross. :)</p>

<hr>

<p>The typical ""placement new"" operator you're referring to is defined in <code>&lt;new&gt;</code>, and is just another overload that accepts a <code>void*</code> and returns that as the allocation result.</p>
"
"<p>I've been trying to make a for loop that will iterate based off of the length of a network packet. In the API there exists a variable (size_t) by event.packet->dataLength. I want to iterate from 0 to event.packet->dataLength - 7 increasing i by 10 each time it iterates but I am having a world of trouble.</p>

<p>I looked for solutions but have been unable to find anything useful. I tried converting the size_t to an unsigned int and doing the arithmetic with that but unfortunately it didn't work. Basically all I want is this:</p>

<pre><code>for (int i = 0; i &lt; event.packet-&gt;dataLength - 7; i+=10) { }
</code></pre>

<p>Though every time I do something like this or attempt at my conversions the i &lt; # part is a huge number. They gave a printf statement in a tutorial for the API which used ""%u"" to print the actual number however when I convert it to an unsigned int it is still incorrect. I'm not sure where to go from here. Any help would be greatly appreciated :)</p>
","87234","","<p>Why don't you change the type of <code>i</code>?</p>

<pre><code>for (size_t i = 0; i &lt; event.packet-&gt;dataLength - 7; i+=10) { }
</code></pre>

<p>Try to keep the types of all variables used together the same type; casts should be avoided.</p>

<p>There is no format specifier for <code>size_t</code> in C++03, you have to cast to the largest unsigned integer type you can and print that. (The format specifier for <code>size_t</code> in C++0x is <code>%zu</code>). However, you shouldn't be using <code>printf</code> anyway:</p>

<pre><code>std::cout &lt;&lt; i; // print i, even if it's a size_t
</code></pre>

<p>While streams may be more verbose, they're more type safe and don't require you to memorize anything.</p>

<p>Keep in mind your actual loop logic may be flawed. (What happens, as genpfault notes, when <code>dataLength - 7</code> is negative?)</p>
"
"<pre><code>#define BLAH word

cout &lt;&lt; BLAH;
</code></pre>

<p>Is there any way to do this?</p>
","87234","","<p>I suspect you want something like this:</p>

<pre><code>#include &lt;typeinfo&gt;

template &lt;typename T&gt;
void print_type()
{
    std::cout &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
}

int main()
{
    print_type&lt;float&gt;();
    print_type&lt;int&gt;();
}
</code></pre>

<p>Note that value of <code>typeid(T).name()</code> is implementation defined, and may be nothing at all. There is no way to print out a type in a guaranteed way without writing a function yourself, for each type.</p>

<p>You can make an overload that deduces the type of the expression too:</p>

<pre><code>#include &lt;typeinfo&gt;

template &lt;typename T&gt;
void print_type(const T&amp;)
{
    std::cout &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
}

int main()
{
    print_type(5.0f);
    print_type(5.0);
}
</code></pre>

<p>(Note that this evaluates the expression, which is unnecessary, but I doubt that is a concern.)</p>
"
"<p>I was experimenting with C++0x variadic templates when I stumbled upon this issue:</p>

<pre><code>template &lt; typename ...Args &gt;
struct identities
{
    typedef Args type; //compile error: ""parameter packs not expanded with '...'
};

//The following code just shows an example of potential use, but has no relation
//with what I am actually trying to achieve.
template &lt; typename T &gt;
struct convert_in_tuple
{
    typedef std::tuple&lt; typename T::type... &gt; type;
};

typedef convert_in_tuple&lt; identities&lt; int, float &gt; &gt;::type int_float_tuple;
</code></pre>

<p>GCC 4.5.0 gives me an error when I try to typedef the template parameters pack.</p>

<p>Basically, I would like to ""store"" the parameters pack in a typedef, without unpacking it. Is it possible? If not, is there some reason why this is not allowed?</p>
","87234","","<p>Another approach, which is slightly more generic than Ben's, is as follows:</p>

<pre><code>#include &lt;tuple&gt;

template &lt;typename... Args&gt;
struct variadic_typedef
{
    // this single type represents a collection of types,
    // as the template arguments it took to define it
};

template &lt;typename... Args&gt;
struct convert_in_tuple
{
    // base case, nothing special,
    // just use the arguments directly
    // however they need to be used
    typedef std::tuple&lt;Args...&gt; type;
};

template &lt;typename... Args&gt;
struct convert_in_tuple&lt;variadic_typedef&lt;Args...&gt;&gt;
{
    // expand the variadic_typedef back into
    // its arguments, via specialization
    // (doesn't rely on functionality to be provided
    // by the variadic_typedef struct itself, generic)
    typedef typename convert_in_tuple&lt;Args...&gt;::type type;
};

typedef variadic_typedef&lt;int, float&gt; myTypes;
typedef convert_in_tuple&lt;myTypes&gt;::type int_float_tuple;

int main()
{}
</code></pre>
"
"<p>I have the following code in C++:</p>

<pre><code>string str=""a b c"";
stringstream sstr(str);
vector&lt;string&gt; my_vec((istream_iterator&lt;string&gt;(sstr)), 
                       istream_iterator&lt;string&gt;());
</code></pre>

<p>Is there any way to save the use of <code>sstr</code>, something like the following?</p>

<pre><code>vector&lt;string&gt; my_vec((istream_iterator&lt;string&gt;(str)), 
                       istream_iterator&lt;string&gt;());
</code></pre>
","87234","","<p><code>istream_iterator</code>'s argument needs to be able to bind to a non-const reference, and a temporary cannot. However, (as Alf points out), <code>ostream</code> happens to have a function, <code>flush()</code>, that returns a non-const reference to itself. So a possibility is:</p>

<pre><code>string str=""a b c"";
vector&lt;string&gt; my_vec(istream_iterator&lt;string&gt;(
                        static_cast&lt;stringstream&amp;&gt;(stringstream(str).flush())
                        ), istream_iterator&lt;string&gt;());
</code></pre>

<p>Though that's an eye-sore. If you're concerned about having too many lines, then use a <em>function</em>:</p>

<pre><code>vector&lt;string&gt; string_to_vector(const string&amp; str)
{
    stringstream sstr(str);
    return vector&lt;string&gt;(istream_iterator&lt;string&gt;(sstr),
                            istream_iterator&lt;string&gt;());
}
</code></pre>

<p>Giving:</p>

<pre><code>string str=""a b c"";
vector&lt;string&gt; my_vec = string_to_vector(str);
</code></pre>

<p>This is even cleaner than what you'd get even if you could shorten your code, because now what is being done is not expressed in code but rather the name of a function; the latter is much easier to grasp.</p>

<hr>

<p>*Of course, we can add boiler-plate code to do silly things:</p>

<pre><code>class temporary_stringstream
{
public:
    temporary_stringstream(const string&amp; str) :
    mStream(str)
    {}

    operator stringstream&amp;()
    {
        // only persists as long as temporary_stringstream!
        return mStream;
    }

private:
    stringstream mStream;
};
</code></pre>

<p>Giving:</p>

<pre><code>string str=""a b c"";
vector&lt;string&gt; my_vec((istream_iterator&lt;string&gt;(temporary_stringstream(str))),
                        istream_iterator&lt;string&gt;());
</code></pre>

<p>But this is just as ugly as the first solution.</p>
"
"<p>So I have a class like</p>

<pre><code>class mySafeData
{
public:
    void Set( int i ) 
    {
        myMutex.lock();
        myData = i;
        myMutex.unlock();
    }
    void Get( int&amp; i)
    {
        myMutex.lock();
        i = myData;
        myMutex.unlock();
    }
private:
    int myData;
    boost::mutex myMutex;

};
</code></pre>

<p>its instance is running. Lets call instance A. I want to create a new class that would take as a start up argument some kind of link to Getter from A and would be capable to somehow save link to thet getter for calling it inside its private methods vhen needed. how to do such thing?</p>
","87234","","<p>Sounds like you want something like this:</p>

<pre><code>class myOtherData
{
public:
    myOtherData(mySafeData&amp; dataSource) :
    myDataSource(&amp;dataSource)
    {}

private:
    // note that if you take the advice in the comments,
    // you don't need this wrapper function at all,
    // it's simple just to call myDataSource.Get()
    int GetData()
    {
        int result;
        myDataSource.Get(result);

        return result;
    }

    mySafeData* myDataSource;
};

mySafeData a;
myOtherData b(a);

// b uses a as its data source (make sure it lives as long!)
</code></pre>
"
"<p>Why do we declare constructor's as <code>public</code>?</p>
","87234","","<p>Constructors are the way objects are created. If your constructor were not public, then it couldn't be used to construct a new object from outside the class.</p>

<p>Note that sometimes a non-public constructor is useful, for example:</p>

<pre><code>class foo
{
public:
    static foo make_foo(int i)
    {
        // only functions of foo can use that constructor,
        // because it's private; return a foo
        return foo(i);
    }

private:
    foo(int i) { /* construct */ }
};
</code></pre>

<p>Now <code>foo</code> can only be created via the function <code>make_foo</code>, for whatever reason.</p>
"
"<p>I am trying to make a C++ compiled model for simple SQL commands. For example this could be a part of my main function which i must be able to handle : </p>

<pre><code>CREATE_TABLE(books) [             // create(""books"");ovr[
    COLUMN(c1) TYPE(string),      // ""title string"",
    COLUMN(c2) TYPE(string),      // ""author string"",
    COLUMN(num1) TYPE(int)        // ""price int""
                    ];
</code></pre>

<p>So in order to do that i had to overload the ""[]"" and "","" operators. After doing so, I figured out that the "","" overloader is executed before the ""[]"" one. Whereas my guess would be that ""[]"" should be executed first. Is there any particular reason why this happens? Or is it simply because the ""[]"" is executed when ""]"" is found?</p>
","87234","","<p>Because in order to call <code>operator[]</code>, it needs a single parameter. It treats what's inside the brackets as an expression with commas, and uses <code>operator,</code> to get a single result with which to call your <code>operator[]</code>.</p>
"
"<p>Lets say I have a polymorphic class Structure like that</p>

<pre><code>class Base
{
//some implementation
};

class Deriv: public Base
{
//implementation
}

class Case1
{
  boost::scoped_ptr&lt;A&gt; a_ //polymorphic data member owned by C
public:
  Case1(A* a):a_(a)
  {

  }
};
class Case2
{
  boost::scoped_ptr&lt;A&gt; a_ //polymorphic data member owned by C
public:
  Case2(std::auto_ptr&lt;A&gt; a):a_( a.release() )
  {

  }
};
</code></pre>

<p>And I've got a third class case1/2 which owns one of those polymorphic object described above. Now I need to pass a pointer to a Base/Deriv object to the constructor of the case1/2 class which takes ownership of this object. Should I pass this object as a smart pointer e.g. auto_ptr to make it clear I'm takin care of this object, or allow raw pointers( case 1 ) to allow a much simpler syntax like</p>

<pre><code>Case1 c(new Deriv);
//compared to 
Case2 c(std::auto_ptr&lt;Base&gt;(new Deriv));
</code></pre>
","87234","","<p>I don't have a source for this being a best practice, but in general if you're going to store a resource in some way, I find it's best to acquire that resource in the same way. </p>

<p>The reason for this is that in C++0x, the copying/moving is done when the argument is given, then you just move it into storage, such as:</p>

<pre><code>struct store_string
{
    store_string(std::string s) : // potentially free, copy if not
    s(std::move(s)) // free
    {}

    std::string s;
};
</code></pre>

<p>Or in C++03, if your type can be cheaply default constructed:</p>

<pre><code>struct store_string
{
    store_string(std::string ss) // make necessary copy
    {
        s.swap(ss); // free
    }

    std::string s;
};
</code></pre>

<p>So for you, I would do:</p>

<pre><code>class Case2
{
    boost::scoped_ptr&lt;A&gt; a_ //polymorphic data member owned by C
public:
    Case2(boost::scoped_ptr&lt;A&gt;&amp; aa)
    {
        a.swap(aa); // take resource
    }
};
</code></pre>

<p>This makes things simple for you, and lets the client know exactly how the resource is going to be managed.</p>
"
"<p>I need a class that redirects one ostream to another ostream during the lifetime of its object. After some tinkering I came up with this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;


class ScopedRedirect
{
public:
    ScopedRedirect(std::ostream &amp; inOriginal, std::ostream &amp; inRedirect) :
        mOriginal(inOriginal),
        mRedirect(inRedirect)
    {
        mOriginal.rdbuf(mRedirect.rdbuf(mOriginal.rdbuf()));
    }

    ~ScopedRedirect()
    {
        mOriginal.rdbuf(mRedirect.rdbuf(mOriginal.rdbuf()));
    }    

private:
    ScopedRedirect(const ScopedRedirect&amp;);
    ScopedRedirect&amp; operator=(const ScopedRedirect&amp;);

    std::ostream &amp; mOriginal;
    std::ostream &amp; mRedirect;
};


int main()
{
    std::cout &lt;&lt; ""Before redirect."" &lt;&lt; std::endl;
    std::ofstream filestream(""redirected.txt"");
    {
        ScopedRedirect redirect(std::cout, filestream);
        std::cout &lt;&lt; ""During redirect."" &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; ""After redirect."" &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>It seems to work fine. However, it's weird that the following line is repeated in <em>both</em> the constructor and destructor:</p>

<pre><code>mOriginal.rdbuf(mRedirect.rdbuf(mOriginal.rdbuf()));
</code></pre>

<p>I think it's correct, but I would like to verify with the SO community. Can you find any errors or dangers in this code?</p>

Edit

<p>Make non-copyable.</p>
","87234","","<p>The reason those lines are the same is because what you're doing is <em>swapping</em> the buffers. (That is, you ""redirect"" by swapping the original buffer with the redirect buffer; restoration is the swap back.)</p>

<p>While this might give you the intended effect with respect to the output stream, it's not correct because the redirect stream now outputs somewhere else. To <em>redirect</em> means to take one stream and make it output somewhere else; note this doesn't effect that 'somewhere else'. </p>

<p>Your class is not a redirect; as is, it should really be named <code>ScopedStreamSwap</code>. For example, try this instead:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

class ScopedRedirect
{
public:
    ScopedRedirect(std::ostream &amp; inOriginal, std::ostream &amp; inRedirect) :
        mOriginal(inOriginal),
        mRedirect(inRedirect)
    {
        mOriginal.rdbuf(mRedirect.rdbuf(mOriginal.rdbuf()));
    }

    ~ScopedRedirect()
    {
        mOriginal.rdbuf(mRedirect.rdbuf(mOriginal.rdbuf()));
    }    

private:
    ScopedRedirect(const ScopedRedirect&amp;);
    ScopedRedirect&amp; operator=(const ScopedRedirect&amp;);

    std::ostream &amp; mOriginal;
    std::ostream &amp; mRedirect;
};


int main()
{
    std::cout &lt;&lt; ""Before redirect."" &lt;&lt; std::endl;
    std::ofstream filestream(""redirected.txt"");
    {
        ScopedRedirect redirect(std::cout, filestream);
        std::cout &lt;&lt; ""During redirect."" &lt;&lt; std::endl;

        // oops:
        filestream &lt;&lt; ""also to the file, right?...nope"" &lt;&lt; std::endl;
        filestream &lt;&lt; ""ah, why am i on the screen?!"" &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; ""After redirect."" &lt;&lt; std::endl;

    // in main, return 0 is implicit, if there is no return statement;
    // helpful to keep in mind in snippets and short things
}
</code></pre>

<p>What you want is this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

class ScopedRedirect
{
public:
    ScopedRedirect(std::ostream &amp; inOriginal, std::ostream &amp; inRedirect) :
        mOriginal(inOriginal),
        mOldBuffer(inOriginal.rdbuf(inRedirect.rdbuf()))
    { }

    ~ScopedRedirect()
    {
        mOriginal.rdbuf(mOldBuffer);
    }    

private:
    ScopedRedirect(const ScopedRedirect&amp;);
    ScopedRedirect&amp; operator=(const ScopedRedirect&amp;);

    std::ostream &amp; mOriginal;
    std::streambuf * mOldBuffer;
};


int main()
{
    std::cout &lt;&lt; ""Before redirect."" &lt;&lt; std::endl;
    std::ofstream filestream(""redirected.txt"");
    {
        ScopedRedirect redirect(std::cout, filestream);
        std::cout &lt;&lt; ""During redirect."" &lt;&lt; std::endl;

        // yay:
        filestream &lt;&lt; ""also to the file, right?...yes"" &lt;&lt; std::endl;
        filestream &lt;&lt; ""i am not on the screen"" &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; ""After redirect."" &lt;&lt; std::endl;

    return 0;
}
</code></pre>
"
"<pre><code>#include &lt;iostream&gt;
class Car
{
private:
  Car(){};
  int _no;
public:
  Car(int no)
  {
    _no=no;
  }
  void printNo()
  {
    std::cout&lt;&lt;_no&lt;&lt;std::endl;
  }
};
void printCarNumbers(Car *cars, int length)
{
    for(int i = 0; i&lt;length;i++)
         std::cout&lt;&lt;cars[i].printNo();
}

int main()
{
  int userInput = 10;
  Car *mycars = new Car[userInput];
  for(int i =0;i &lt; userInput;i++)
         mycars[i]=new Car[i+1];
  printCarNumbers(mycars,userInput);
  return 0;
}    
</code></pre>

<p>I want to create a car array but I get the following error:</p>

<pre><code>cartest.cpp: In function ‘int main()’:
cartest.cpp:5: error: ‘Car::Car()’ is private
cartest.cpp:21: error: within this context
</code></pre>

<p>is there a way to make this initialization without making Car() constructor public?</p>
","87234","","<p>Nope.</p>

<p>But lo! If you use <code>std::vector&lt;Car&gt;</code>, like you should be (never ever use <code>new[]</code>), then you can specify exactly how elements should be constructed*.</p>

<p>*Well sort of. You can specify the value of which to make copies of.</p>

<hr>

<p>Like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

class Car
{
private:
    Car(); // if you don't use it, you can just declare it to make it private
    int _no;
public:
    Car(int no) :
    _no(no)
    {
        // use an initialization list to initialize members,
        // not the constructor body to assign them
    }

    void printNo()
    {
        // use whitespace, itmakesthingseasiertoread
        std::cout &lt;&lt; _no &lt;&lt; std::endl;
    }
};

int main()
{
    int userInput = 10;

    // first method: userInput copies of Car(5)
    std::vector&lt;Car&gt; mycars(userInput, Car(5)); 

    // second method:
    std::vector&lt;Car&gt; mycars; // empty
    mycars.reserve(userInput); // optional: reserve the memory upfront

    for (int i = 0; i &lt; userInput; ++i)
        mycars.push_back(Car(i)); // ith element is a copy of this

    // return 0 is implicit on main's with no return statement,
    // useful for snippets and short code samples
} 
</code></pre>

<p>With the additional function:</p>

<pre><code>void printCarNumbers(Car *cars, int length)
{
    for(int i = 0; i &lt; length; i++) // whitespace! :)
         std::cout &lt;&lt; cars[i].printNo();
}

int main()
{
    // ...

    printCarNumbers(&amp;mycars[0], mycars.size());
} 
</code></pre>

<p>Note <code>printCarNumbers</code> really should be designed differently, to accept two iterators denoting a range.</p>
"
"<p>I don't want my program to crash, so i enabled C++ Exception with SEH. So that, if there's some errors i.e. NULL pointer access happens, my program can catch it with catch(...).</p>

<p>I want to known:
1. Is there any drawback of enable C++ exception with SEH? 
2. How can i know exception details when it is catched by catch(...)?</p>
","87234","","<ol>
<li><p>As far as I know, there are no performance drawbacks, because I'm pretty sure C++ exceptions are implemented via SEH anyway. All you're doing is enabling the extension to get OS-level exceptions as well. However, there is one major drawback, touched on in two.</p></li>
<li><p>You normally use <code>__try</code> and <code>__except</code> to catch SEH exceptions; <a href=""http://msdn.microsoft.com/en-us/library/ms680657%28VS.85%29.aspx"" rel=""nofollow"">more information here</a>. Note this is where the drawback is: exceptions caught this way do not run destructors. However, what you can do is use the function <code>_set_se_translator</code> to translate SEH exceptions into C++ exceptions.</p></li>
</ol>

<p>Here's something from one of my projects that does this (uses Boost and C++0x in MSVC 2010):</p>

<pre><code>bool ignore_exception(unsigned pCode)
{
    const unsigned ignoreList[] = {EXCEPTION_BREAKPOINT,
        EXCEPTION_FLT_DENORMAL_OPERAND, EXCEPTION_FLT_DIVIDE_BY_ZERO,
        EXCEPTION_FLT_INEXACT_RESULT, EXCEPTION_FLT_OVERFLOW, EXCEPTION_FLT_UNDERFLOW,
        EXCEPTION_INT_OVERFLOW, EXCEPTION_SINGLE_STEP};

    auto result = std::search_n(std::begin(ignoreList), std::end(ignoreList),
                    1, pCode);
    return result != std::end(ignoreList);              
}

std::string code_string(unsigned pCode)
{
    switch (pCode)
    {
    case EXCEPTION_ACCESS_VIOLATION:
        return ""Access violation"";
    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
        return ""Out of array bounds"";
    case EXCEPTION_BREAKPOINT:
        return ""Breakpoint"";
    case EXCEPTION_DATATYPE_MISALIGNMENT:
        return ""Misaligned data"";
    case EXCEPTION_FLT_DENORMAL_OPERAND:
        return ""Denormalized floating-point value"";
    case EXCEPTION_FLT_DIVIDE_BY_ZERO:
        return ""Floating-point divide-by-zero"";
    case EXCEPTION_FLT_INEXACT_RESULT:
        return ""Inexact floating-point value"";
    case EXCEPTION_FLT_INVALID_OPERATION:
        return ""Invalid floating-point operation"";
    case EXCEPTION_FLT_OVERFLOW:
        return ""Floating-point overflow"";
    case EXCEPTION_FLT_STACK_CHECK:
        return ""Floating-point stack overflow"";
    case EXCEPTION_FLT_UNDERFLOW:
        return ""Floating-point underflow"";
    case EXCEPTION_GUARD_PAGE:
        return ""Page-guard access"";
    case EXCEPTION_ILLEGAL_INSTRUCTION:
        return ""Illegal instruction"";
    case EXCEPTION_IN_PAGE_ERROR:
        return ""Invalid page access"";
    case EXCEPTION_INT_DIVIDE_BY_ZERO:
        return ""Integer divide-by-zero"";
    case EXCEPTION_INT_OVERFLOW:
        return ""Integer overflow"";
    case EXCEPTION_INVALID_DISPOSITION:
        return ""Invalid exception dispatcher"";
    case EXCEPTION_INVALID_HANDLE:
        return ""Invalid handle"";
    case EXCEPTION_NONCONTINUABLE_EXCEPTION:
        return ""Non-continuable exception"";
    case EXCEPTION_PRIV_INSTRUCTION:
        return ""Invalid instruction"";
    case EXCEPTION_SINGLE_STEP:
        return ""Single instruction step"";
    case EXCEPTION_STACK_OVERFLOW:
        return ""Stack overflow"";
    default:
        return ""Unknown exception"";
    }
}

void stack_fail_thread()
{
    std::cerr &lt;&lt; ""Unhandled exception:\n""
                &lt;&lt; code_string(EXCEPTION_STACK_OVERFLOW) &lt;&lt; '\n';
    std::cerr &lt;&lt; ""Terminating."" &lt;&lt; std::endl;

    // can print a stack dump of the failed
    // thread to see what went wrong, etc...

    std::exit(EXIT_FAILURE);
}

void exception_translator(unsigned pCode, _EXCEPTION_POINTERS*)
{
    // minimize function calls if it's a stack overflow
    if (pCode == EXCEPTION_STACK_OVERFLOW)
    {
        // do some additional processing in another thread,
        // because the stack of this thread is gone
        boost::thread t(stack_fail_thread);
        t.join(); // will never exit
    }
    else if (!ignore_exception(pCode))               
    {
        // can add a stack dump to the exception message,
        // since these tend to be pretty severe, etc...
        BOOST_THROW_EXCEPTION(std::runtime_error(code_string(pCode)));
    }
}

void hook_signals()
{
    _set_se_translator(exception_translator);
}
</code></pre>

<p>I stripped several things out, but you get the idea. You can extract all the same information this way.</p>
"
"<p>I need to obtain auto_ptr from shared_ptr in my code. I can do reverse operation - convert auto_ptr to shared_ptr as shared_ptr has such constructor:</p>

<pre><code>template&lt;class Y&gt; explicit shared_ptr(std::auto_ptr&lt;Y&gt; &amp; r);
</code></pre>

<p>Can I convert shared_ptr to auto_ptr? Or it is impossible by design?</p>
","87234","","<p>A shared pointer can be shared by many things, you can't just take it from them all somehow. This is elaborated by <a href=""http://stackoverflow.com/questions/4773546/convert-shared-ptr-to-auto-ptr/4773563#4773563"">Artyom</a> and <a href=""http://stackoverflow.com/questions/4773546/convert-shared-ptr-to-auto-ptr/4773560#4773560"">peoro</a>.</p>

<p>One approach is to make a temporary <code>auto_ptr</code>, and release it from handling the pointer at the end of the scope. <a href=""http://stackoverflow.com/questions/4773546/convert-shared-ptr-to-auto-ptr/4773566#4773566"">dalle</a> outlines a first approach, but this suffers from lack of exception-safety (might accidentally delete), and it cannot protect you from accidentally passing it to a function that's going to transfer ownership (where the delete falls out of our hands).</p>

<p>We can make our own wrapper to avoid this, though:</p>

<pre><code>template &lt;typename T&gt;
class auto_ptr_facade
{
public:   
    auto_ptr_facade(shared_ptr&lt;T&gt; ptr) :
    mPtr(ptr),
    mAuto(ptr.get())
    {}

    ~auto_ptr_facade()
    {
        // doesn't actually have ownership
        mAuto.release();
    }

    // only expose as const, cannot be transferred
    const auto_ptr&lt;T&gt;&amp; get() const
    {
         return mAuto;
    }

    operator const auto_ptr&lt;T&gt;&amp;() const
    {
         return get();
    }

private:
    auto_ptr_facade(const auto_ptr_facade&amp;);
    auto_ptr_facade&amp; operator=(const auto_ptr_facade&amp;);

    shared_ptr&lt;T&gt; mPtr;
    auto_ptr&lt;T&gt; mAuto;
};
</code></pre>

<p>Now you can treat a <code>shared_ptr</code> like a <code>const auto_ptr</code>, in a scope:</p>

<pre><code>template &lt;typename T&gt;
void foo(shared_ptr&lt;T&gt; ptr)
{
    auto_ptr_facade&lt;T&gt; a(ptr);

    // use a
}
</code></pre>
"
"<p>Is there a good reason why should a class function member be part of the class if it does not depend on any of the members of the class?</p>
","87234","","<p>No. In fact, <a href=""http://www.drdobbs.com/184401197"" rel=""nofollow"">you should prefer free-functions over member functions</a>. Only functions that really need to operate on the members should be member functions, <a href=""http://www.gotw.ca/gotw/084.htm"" rel=""nofollow"">the rest should use them to provide functionality</a>.</p>
"
"<p>What's the best way of making <em>all</em> of the commented code below work in a standard C++/Qt way?</p>

<pre><code>class A {
public:
    A() { }
    virtual ~A() { }
    virtual QString toString() { return ""A""; }
};

class B: A {
public:
    B() { }
    ~B() { }
    QString toString() { return ""B""; }
};

int main(int argc, char *argv[]) {
    QCoreApplication a(argc, argv);

    A a_;
    B b_;

    // qDebug() &lt;&lt; a_;  // I can make this work by overloading &lt;&lt; yes?
    // qDebug() &lt;&lt; b_;

    // QString x = a_;  // How do I make this work?
    // QString y = b_;

    QString s = a_.toString(); // What I'm doing at present
    qDebug() &lt;&lt; b_.toString(); // What I'm doing at present

    return a.exec();
}
</code></pre>

<p>I have a hierarchy of instances of my own Qt classes that all derive from the same base class.  I'd like to turn them into strings implicitly in a standard way to be displayed in a Qt ui:</p>

<p>I can do it explicitly myself as above with my own standard method like <code>toString</code> above, but it's not implicit and I'd rather follow a Qt or C++ convention as I believe there is one I'm not aware of.</p>

<p>The strings will eventually be displayed in Q*View controls which I believe means overloading <code>operator &lt;&lt;</code> won't be enough on it's own.</p>
","87234","","<p>You just add a so-called <em>conversion function</em>:</p>

<pre><code>struct foo
{
    operator int() { return 5; }
};

foo f;
int i = f; // uses operator to convert to int
</code></pre>

<p>So in your case, just replace <code>virtual QString toString()</code> with <code>virtual operator QString()</code>.</p>

<hr>

<p>That said, implicit operators are generally frowned-upon. Not only are casts frowned upon, but now you're allowing a cast to happen implicitly. C++0x actually allows us to tack on <code>explicit</code> to the conversion functions to make sure we explicitly cast, but I don't know which compilers support that.</p>

<p>I think you'd be much better off leaving what you have, and just adding:</p>

<pre><code>// I assume qDebug() is convertible to std::ostream
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const A&amp; val)
{
    stream &lt;&lt; val.toString(); // would need to make function const, of course

    return stream;
}
</code></pre>

<p>And leaving the rest explicit.</p>
"
"<p>I've made a simple program and compiled it with GCC 4.4/4.5 as follows:</p>

<pre><code>int main ()
{
  char u = 10;
  char x = 'x';
  char i = u + x;

  return 0;
}
</code></pre>

<p>g++ -c -Wconversion a.cpp</p>

<p>And I've got the following:</p>

<pre><code>a.cpp: In function ‘int main()’:
a.cpp:5:16: warning: conversion to ‘char’ from ‘int’ may alter its value
</code></pre>

<p>The same warning I've got for the following code:</p>

<pre><code>  unsigned short u = 10;
  unsigned short x = 0;
  unsigned short i = u + x;

a.cpp: In function ‘int main()’:
a.cpp:5:16: warning: conversion to ‘short unsigned int’ from ‘int’ may alter its value
</code></pre>

<p>Could anyone please explain me why addition of two chars (or two unsigned shorts) produces int? 
Is it a compiler bug or is it standard compliant?</p>

<p>Thanks.</p>
","87234","","<p>What you're seeing is the result of the so-called ""usual arithmetic conversions"" that occur during arithmetic expressions, particularly those that are binary in nature (take two arguments).</p>

<p>This is described in §5/9:</p>

<blockquote>
  <p>Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result. This pattern is called the <em>usual arithmetic conversions</em>, which are defined as follows:  </p>
  
  <p>— If either operand is of type <code>long double</code>, the other shall be converted to<code>long double</code>.<br>
  — Otherwise, if either operand is <code>double</code>, the other shall be converted to <code>double</code>.<br>
  — Otherwise, if either operand is <code>float</code>, the other shall be converted to <code>float</code>.<br>
  — Otherwise, the integral promotions (4.5) shall be performed on both operands.<sup>54)</sup><br>
  — Then, if either operand is <code>unsigned long</code> the other shall be converted to <code>unsigned long</code>.<br>
  — Otherwise, if one operand is a <code>long int</code> and the other <code>unsigned int</code>, then if a <code>long int</code> can represent all the values of an <code>unsigned int</code>, the <code>unsigned int</code> shall be converted to a <code>long int</code>; otherwise both operands shall be converted to <code>unsigned long
   int</code>.<br>
  — Otherwise, if either operand is <code>long</code>, the other shall be converted to <code>long</code>.<br>
  — Otherwise, if either operand is <code>unsigned</code>, the other shall be converted to <code>unsigned</code>.  </p>
  
  <p>[Note: otherwise, the only remaining case is that both operands are <code>int</code>]</p>
</blockquote>

<p>The promotions alluded to in §4.5 are:</p>

<blockquote>
  <p>1 An rvalue of type <code>char</code>, <code>signed char</code>, <code>unsigned char</code>, <code>short int</code>, or <code>unsigned short int</code>can be converted to an rvalue of type <code>int</code> if <code>int</code> can represent all the values of the source type; otherwise, the source rvalue can be converted to an rvalue of type <code>unsigned int</code>.  </p>
  
  <p>2 An rvalue of type <code>wchar_t</code> (3.9.1) or an enumeration type (7.2) can be converted to an rvalue of the first of the following types that can represent all the values of its underlying type: <code>int</code>, <code>unsigned int</code>, <code>long</code>, or <code>unsigned long</code>.  </p>
  
  <p>3 An rvalue for an integral bit-field (9.6) can be converted to an rvalue of type <code>int</code> if <code>int</code> can represent all the values of the bit-field; otherwise, it can be converted to <code>unsigned int</code> if <code>unsigned int</code> can represent all the values of the bit-field. If the bit-field is larger yet, no integral promotion applies to it. If the bit-field has an enumerated type, it is treated as any other value of that type for promotion purposes.  </p>
  
  <p>4 An rvalue of type <code>bool</code> can be converted to an rvalue of type <code>int</code>, with <code>false</code> becoming zero and <code>true</code> becoming <code>one</code>.  </p>
  
  <p>5 These conversions are called integral promotions.</p>
</blockquote>

<p>From here, sections such as ""<strong>Multiplicative operators</strong>"" or ""<strong>Additive operators</strong>"" all have the phrase: ""<em>The usual arithmetic conversions are performed...</em>"" to specify the type of the expression.</p>

<p>In other words, when you do integral arithmetic the type is determined with the categories above. In your case, the promotion is covered by §4.5/1 and the type of the expressions are <code>int</code>.</p>
"
"<p>I'm a simple programmer.  My class members variables most often consists of POD-types and STL-containers. Because of this I seldom have to write assignment operators or copy constructors, as these are implemented by default.</p>

<p>Add to this, if I use <code>std::move</code> on objects not movable, it utilizes the assignment-operator, meaning <code>std::move</code> is perfectly safe.</p>

<p>As I'm a simple programmer, I'd like to take advantage of the move-capabilities without adding a move constructor/assignment operator to every class I write, as the compiler could simply implemented them as ""<code>this-&gt;member1_ = std::move(other.member1_);...</code>""</p>

<p>But it doesn't (at least not in Visual 2010), is there any particular reason for this?</p>

<p>More importantly; <strong>is there any way to get around this?</strong></p>

<p><em><strong>Update:</em></strong>
If you look down at GManNickG's answer he provides a great macro for this. And if you didn't know, if you implement move-semantics you can remove the swap member function.</p>
","87234","","<blockquote>
  <p>(as for now, I'm working on a stupid macro...)</p>
</blockquote>

<p>Yeah, I went that route too. Here's your macro:</p>

<pre><code>// detail/move_default.hpp
#ifndef UTILITY_DETAIL_MOVE_DEFAULT_HPP
#define UTILITY_DETAIL_MOVE_DEFAULT_HPP

#include &lt;boost/preprocessor.hpp&gt;

#define UTILITY_MOVE_DEFAULT_DETAIL_CONSTRUCTOR_BASE(pR, pData, pBase) pBase(std::move(pOther))
#define UTILITY_MOVE_DEFAULT_DETAIL_ASSIGNMENT_BASE(pR, pData, pBase) pBase::operator=(std::move(pOther));

#define UTILITY_MOVE_DEFAULT_DETAIL_CONSTRUCTOR(pR, pData, pMember) pMember(std::move(pOther.pMember))
#define UTILITY_MOVE_DEFAULT_DETAIL_ASSIGNMENT(pR, pData, pMember) pMember = std::move(pOther.pMember);

#define UTILITY_MOVE_DEFAULT_DETAIL(pT, pBases, pMembers)                                               \
        pT(pT&amp;&amp; pOther) :                                                                               \
        BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM(                                                       \
            UTILITY_MOVE_DEFAULT_DETAIL_CONSTRUCTOR_BASE, BOOST_PP_EMPTY, pBases))                      \
        ,                                                                                               \
        BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM(                                                       \
            UTILITY_MOVE_DEFAULT_DETAIL_CONSTRUCTOR, BOOST_PP_EMPTY, pMembers))                         \
        {}                                                                                              \
                                                                                                        \
        pT&amp; operator=(pT&amp;&amp; pOther)                                                                      \
        {                                                                                               \
            BOOST_PP_SEQ_FOR_EACH(UTILITY_MOVE_DEFAULT_DETAIL_ASSIGNMENT_BASE, BOOST_PP_EMPTY, pBases)  \
            BOOST_PP_SEQ_FOR_EACH(UTILITY_MOVE_DEFAULT_DETAIL_ASSIGNMENT, BOOST_PP_EMPTY, pMembers)     \
                                                                                                        \
            return *this;                                                                               \
        }

#define UTILITY_MOVE_DEFAULT_BASES_DETAIL(pT, pBases)                                                   \
        pT(pT&amp;&amp; pOther) :                                                                               \
        BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM(                                                       \
            UTILITY_MOVE_DEFAULT_DETAIL_CONSTRUCTOR_BASE, BOOST_PP_EMPTY, pBases))                      \
        {}                                                                                              \
                                                                                                        \
        pT&amp; operator=(pT&amp;&amp; pOther)                                                                      \
        {                                                                                               \
            BOOST_PP_SEQ_FOR_EACH(UTILITY_MOVE_DEFAULT_DETAIL_ASSIGNMENT_BASE, BOOST_PP_EMPTY, pBases)  \
                                                                                                        \
            return *this;                                                                               \
        }

#define UTILITY_MOVE_DEFAULT_MEMBERS_DETAIL(pT, pMembers)                                               \
        pT(pT&amp;&amp; pOther) :                                                                               \
        BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM(                                                       \
            UTILITY_MOVE_DEFAULT_DETAIL_CONSTRUCTOR, BOOST_PP_EMPTY, pMembers))                         \
        {}                                                                                              \
                                                                                                        \
        pT&amp; operator=(pT&amp;&amp; pOther)                                                                      \
        {                                                                                               \
            BOOST_PP_SEQ_FOR_EACH(UTILITY_MOVE_DEFAULT_DETAIL_ASSIGNMENT, BOOST_PP_EMPTY, pMembers)     \
                                                                                                        \
            return *this;                                                                               \
        }

#endif
</code></pre>

<p>​</p>

<pre><code>// move_default.hpp
#ifndef UTILITY_MOVE_DEFAULT_HPP
#define UTILITY_MOVE_DEFAULT_HPP

#include ""utility/detail/move_default.hpp""

// move bases and members
#define UTILITY_MOVE_DEFAULT(pT, pBases, pMembers) UTILITY_MOVE_DEFAULT_DETAIL(pT, pBases, pMembers)

// base only version
#define UTILITY_MOVE_DEFAULT_BASES(pT, pBases) UTILITY_MOVE_DEFAULT_BASES_DETAIL(pT, pBases)

// member only version
#define UTILITY_MOVE_DEFAULT_MEMBERS(pT, pMembers) UTILITY_MOVE_DEFAULT_MEMBERS_DETAIL(pT, pMembers)

#endif
</code></pre>

<p>(I've removed the real comments, which are length and documentary.)</p>

<p>You specify the bases and/or members in your class as a preprocessor list, for example:</p>

<pre><code>#include ""move_default.hpp""

struct foo
{
    UTILITY_MOVE_DEFAULT_MEMBERS(foo, (x)(str));

    int x;
    std::string str;
};

struct bar : foo, baz
{
    UTILITY_MOVE_DEFAULT_BASES(bar, (foo)(baz));
};

struct baz : bar
{
    UTILITY_MOVE_DEFAULT(baz, (bar), (ptr));

    void* ptr;
};
</code></pre>

<p>And out comes a move-constructor and move-assignment operator.</p>

<p>(As an aside, if anyone knows how I could combine the details into one macro, that would be swell.)</p>
"
"<p>What is the proper way to declare the iterator i in the following code? </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

template&lt;class Mat&gt; 
void f(const Mat&amp; mat) 
{
    typedef typename Mat::value_type::iterator itr;
    //itr i = (mat.begin())-&gt;begin(); //This Line Gives an error
    typeof((mat.begin())-&gt;begin()) i = (mat.begin())-&gt;begin(); 
}

int main() 
{
    vector&lt;vector&lt;int&gt; &gt; vvi;
    f(vvi);
    return 0; 
}
</code></pre>
","87234","","<p>Your container is <code>const</code>, but your iterator type is not. Make that <code>const_iterator</code>:</p>

<pre><code>template&lt;class Mat&gt; 
void f(const Mat&amp; mat) 
{
    typedef typename Mat::value_type::const_iterator itr;

    itr i = mat.begin()-&gt;begin();
}
</code></pre>
"
"<p>I think I'll get right into it and start with the code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

class test : public std::ofstream
{
    public:
        test(const std::string&amp; filename) { this-&gt;open(gen_filename(filename)); };
        test(const test&amp;) = delete;
        //test(test&amp;&amp; old) = default; // Didn't compile
        test(test&amp;&amp; old) {};
    private:
        std::string gen_filename(const std::string&amp; filename) 
        { return filename + "".tmp""; }
};

int main()
{
    auto os = test(""testfile"");
    os &lt;&lt; ""Test1\n"";
    os &lt;&lt; ""Test2\n"";
}
</code></pre>

<p>Basically, I need to return an ofstream. Of course you can't copy an ofstream, so I fiddled around with the code in the class test, and I got the above to compile and work as you would expect (on gcc 4.5).</p>

<p>But I have a bad feeling this is just due to my compiler doing ""Return Value Optimization"" (RTO) on ""auto os = test()"". Indeed, if modify to the following:</p>

<pre><code>int main()
{
    auto os = test(""testfile"");
    os &lt;&lt; ""Test1\n"";
    auto os2 = std::move(os);
    os2 &lt;&lt; ""Test2\n"";
}
</code></pre>

<p>I no longer get both Test1 and Test2 in the output.</p>

<p>The thing is, the class ""test"" isn't copyable, so there's no chance of the ofstream being duplicated. I just want to be able to return it from a function. And I seem to be able to do that with GCC.</p>

<p>I'd rather not have dereference smart pointers to a heap allocated ofstream, or reopen the file, as it currently works without doing those things. I just have a feeling I'm being a little ""non-standard"" in my approach, so a standard way of doing what I've described would be great.</p>
","87234","","<p>The problem is with this:</p>

<pre><code>test(test&amp;&amp; old) {};
</code></pre>

<p>This lets you construct a new <code>test</code> from an rvalue <code>test</code>, yes, but it says nothing about your base, which is simply being default constructed (no open file). What you want is this:</p>

<pre><code>test(test&amp;&amp; old) : std::ofstream(std::move(old)) {};
</code></pre>

<p>Which will move the stream from <code>old</code> into the base.</p>
"
"<p>A virtual function's return type should be the same type that is in base class, or covariant. But why do we have this restriction?</p>
","87234","","<p>Because of the nonsense that would ensue:</p>

<pre><code>struct foo
{
    virtual int get() const { return 0; }
};

struct bar : foo
{
    std::string get() const { return ""this certainly isn't an int""; }
};

int main()
{
    bar b;
    foo* f = &amp;b;

    int result = f-&gt;get(); // int, right? ...right?
}
</code></pre>

<p>It isn't sensible to have a derived class return something completely unrelated.</p>
"
"<p>Hallo,</p>

<p>is there some easy way in C++ to tell (in compile-time) if a class/struct has no data members?</p>

<p>E.g. <code>struct T{};</code></p>

<p>My first thought was to compare <code>sizeof(T)==0</code>, but this always seems to be at least 1.</p>

<p>The obvious answer would be to just look at the code, but I would like to switch on this.</p>
","87234","","<p>If your compiler supports this aspect of C++0x, you can use <code>std::is_empty</code> from <code>&lt;type_traits&gt;</code>.</p>

<p>It's specification is:</p>

<blockquote>
  <p><code>T</code> is a class type, but not a union type, with no non-static data members other than bit-fields of length 0, no virtual member functions, no virtual base classes, and no base class <code>B</code> for which <code>is_empty&lt;B&gt;::value</code> is <code>false</code>.</p>
</blockquote>

<p>I don't think there's a standard way to find if a class is empty with regards to polymorphism.</p>
"
"<p>I would simply like to do something of the following:</p>

<pre><code>template &lt;typename T&gt;
class gvar {
private:
    T var;
public:
    gvar(T var) : var(var) {}
};

std::stack&lt;gvar&gt; some_stack;
</code></pre>

<p>g++ spits out all kinds of errors about how gvar is not a type. Is this achievable in some relatively easy way? I prefer not to use boost::any / boost::variant.</p>

<p>edit:</p>

<p>To clarify on what I want:</p>

<p>An std::stack that can hold variables of different types (just primitives is fine). </p>
","87234","","<p>Because <code>gvar</code> isn't a type, it's a type template. You need to specify a template argument for it:</p>

<pre><code>std::stack&lt; gvar&lt;int&gt; &gt; some_stack;
</code></pre>
"
"<p>Consider the following:</p>

<pre><code>struct X
{
    Y y_;

    X(const Y &amp; y) :y_(y) {}    
    X(Y &amp;&amp; y) :y_(std::move(y)) {}
};
</code></pre>

<p>Is it necessary to define a constructor like the second one in order to take full advantage of move semantics? Or will it be taken care of automatically in the appropriate situations?</p>
","87234","","<p>Yes, but no. Your code should just be this:</p>

<pre><code>struct X
{
    Y y_;

    X(Y y) : // either copy, move, or elide a Y
    y_(std::move(y)) // and move it to the member
    {} 
};
</code></pre>

<p>If you ever say in design ""I need my own copy of this data""*, then you should just take the argument by value and move it to where it needs to be. It isn't your job to decide how to construct that value, that's up to the available constructors for that value, so let it make that choice, whatever it is, and work with the end result.</p>

<p>*This applies to functions too, of course, for example:</p>

<pre><code>void add_to_map(std::string x, int y) // either copy, move or elide a std::string
{
    // and move it to where it needs to be
    someMap.insert(std::make_pair(std::move(x), y));
}
</code></pre>

<hr>

<p>Note that is applied in C++03 too, somewhat, if a type was default constructible and swappable (which is all moving does anyway):</p>

<pre><code>// C++03
struct X
{
    std::string y_;

    X(std::string y) // either copy or elide a std::string
    {
        swap(y_, y); // and ""move"" it to the member
    } 
};
</code></pre>

<p>Though this didn't seem to be as widely done.</p>
"
"<p>Let's say I have an array <code>arr</code>. When would the following not give the number of elements of the array: <code>sizeof(arr) / sizeof(arr[0])</code>?</p>

<p>I can thing of only one case: the array contains elements that are of different derived types of the type of the array.</p>

<p>Am I right and are there (I am almost positive there <em>must</em> be) other such cases?</p>

<p>Sorry for the trivial question, I am a Java dev and I am rather new to C++.</p>

<p>Thanks!</p>
","87234","","<p>There are no cases where, given an array <code>arr</code>, that the value of <code>sizeof(arr) / sizeof(arr[0])</code> is not the count of elements, by the definition of array and <code>sizeof</code>.</p>

<p>In fact, it's even directly mentioned (§5.3.3/2):</p>

<blockquote>
  <p>.... When applied to an array, the result is the total number of bytes in the array. <strong>This implies that the size of an array of <em>n</em> elements is <em>n</em> times the size of an element.</strong></p>
</blockquote>

<p>Emphasis mine. Divide by the size of an element, <code>sizeof(arr[0])</code>, to obtain <em>n</em>.</p>
"
"<p>I am trying to use a stringstream to do something like this (I simplified my code to pinpoint the error):</p>

<p>Token.h</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;

using namespace std;

class Token {
public:
   static stringstream ss (stringstream::in | stringstream::out);
   static void set_input_string(std::string str);
};
</code></pre>

<p>Token.cpp</p>

<pre><code>#include ""Token.h""

void Token::set_input_string(std::string str)
{
   ss &lt;&lt; str;
}
</code></pre>

<p>When I try to compile i get:
<code>error C2061: syntax error : identifier 'in'</code> in Token.h on line <code>static stringstream ss (stringstream::in | stringstream::out);</code> and visual studios 2010 underlines in red <code>stringstream::in |</code></p>
","87234","","<p>You cannot initialize non-integral values in the class definition. You should have:</p>

<pre><code>// Token.h
#include &lt;cstdio&gt; // thisis the C++ header
#include &lt;vector&gt;
#include &lt;sstream&gt;

// don't do this, especially not in a header file - function-scope at best
// using namespace std;

class Token {
public:
    static std::stringstream ss; // declare

    // probably want this parameter to be a const-reference
    static void set_input_string(std::string str);
};
</code></pre>

<p>And:</p>

<pre><code>// Token.cpp
#include ""Token.h""

// define
std::stringstream Token::ss(std::stringstream::in | std::stringstream::out); 

void Token::set_input_string(std::string str)
{
   ss &lt;&lt; str;
}
</code></pre>
"
"<p>I frequently run into the problem, that I must extend a compiler generated copy constructor. Example:</p>

<pre><code>class xyz;
class C
{
    ...
    int a, b, c; 
    std::set&lt;int&gt; mySet;
    xyz *some_private_ptr;
};
</code></pre>

<p>Assume, that <code>some_private_ptr</code> should only be copied under certain conditions. For other conditions it should be reset to <code>NULL</code> on copy. So I have to write a copy constructor like:</p>

<pre><code>C::C(const C &amp;other) : 
     a(other.a), 
     b(other.b), 
     c(other.c), 
    mySet(other.mySet)
{      
   if(CanCopy(other.some_private_ptr)) // matches condition
      some_private_ptr = other.some_private_ptr;
   else
      some_private_ptr = NULL;
}
</code></pre>

<p>The problem is that the class might have a number of data members, and that I very likely may forget to update the copy constructor when I add a data member. It would be very nice if I just could write. </p>

<pre><code>C::C(const C &amp;other) :
   C::default_copy(other)
{      
   if(CanCopy(other.some_private_ptr)) // matches condition
      some_private_ptr = other.some_private_ptr;
   else
      some_private_ptr = NULL;
}
</code></pre>

<p>This would make my code more safe and easier to maintain. Unfortunately I don't know of such a possibility. Is there any?</p>
","87234","","<p>The problem here is your class is trying to do too much. Either <em>use</em> a resource, or <em>manage</em> a resource. You don't do both, ever, because your code will become an unsafe, pile of slop. And that's no good.</p>

<p>You need to design a class that <em>manages</em> a resource that is only copied under certain conditions. You haven't really expanded on what those conditions on and why they're there in the first place (that's an awfully strange way to ""copy"" data, are you sure this is the best route?), but it'd be something like this:</p>

<pre><code>// pointer to your condition member (not sure if this is even needed,
// is this condition knowable via the pointer alone? you get the point)
template &lt;typename T, typename D, class Tag = void&gt;
class copy_conditional_ptr
{
public:
    copy_conditional_ptr(bool (D::*condition)(T*) const, T* value = 0) :
    mCondition(condition),
    mValue(value)
    {}

    // here's where the unique copy-semantics go
    copy_conditional_ptr(const copy_conditional_ptr&amp; other) :
    mCondition(other.mCondition),
    mValue(do_copy(other.mValue) ? other.mValue : 0)
    {}

    // other stuff for a smart pointer,
    // copy-and-swap, etc...

protected:
    // protected because it's meant to be a base class
    ~copy_conditional_ptr()
    {
        // whatever
    }

private:
    bool do_copy(T* value) const
    {
        const D&amp; self = static_cast&lt;const D&amp;&gt;(*this);
        return (self.*mCondition)(other.value);
    }

    bool (D::*mCondition)(T*) const;
    T* mValue;
};
</code></pre>

<p>Then you use it like this:</p>

<pre><code>class xyz;

class C : private copy_conditional_ptr&lt;xyz, C&gt;
{
public:
    C() :
    /* others, */
    copy_conditional_ptr(&amp;C::CanCopy)
    {}

private:
    int a, b, c; 
    std::set&lt;int&gt; mySet;
};
</code></pre>

<p>And let the management be automatic for the rest of the class. The tag is so you can have multiple in the same class:</p>

<pre><code>class C : private copy_conditional_ptr&lt;xyz, C, struct C_first&gt;,
            private copy_conditional_ptr&lt;xyz, C, struct C_second&gt;
{
    // ...
};
</code></pre>
"
"<p>Suppose I've got a function <code>functionProxy</code> that takes a generic parameter <code>function</code> and call its <code>operator()</code>:</p>

<pre><code>template&lt; typename Function &gt; void functionProxy( Function function ) {
    function();
}
</code></pre>

<hr>

<p>The object passed to it may be:</p>

<ul>
<li><p>a functor:</p>

<pre><code>struct Functor {
    void operator()() const {
        std::cout &lt;&lt; ""functor!"" &lt;&lt; std::endl;
    }
};
</code></pre></li>
<li><p>a function:</p>

<pre><code>void function( ) {
    std::cout &lt;&lt; ""function!"" &lt;&lt; std::endl;
}
</code></pre></li>
<li><p>a (C++0x) lambda function:</p>

<pre><code>[](){ std::cout &lt;&lt; ""lambda!"" &lt;&lt; std::endl; }
</code></pre></li>
</ul>

<hr>

<pre><code>int main( )
{
    functionProxy( Functor() );
    functionProxy( function );
    functionProxy( [](){ std::cout &lt;&lt; ""lambda!"" &lt;&lt; std::endl; } );
    return 0;
}
</code></pre>

<hr>

<p>Will the compiler be able to inline <code>function</code> within <code>functionProxy</code> in all the above cases?</p>
","87234","","<p>Sure thing.</p>

<p>It knows the value of <code>function</code> is the same as the value it passes it, knows the definition of the function, so just replaces the definition inline and calls the function directly.</p>

<p>I can't think of a condition where a compiler won't inline a one-line function call, it's just replacing a function call with a function call, no possible loss. </p>

<hr>

<p>Given this code:</p>

<pre><code>#include &lt;iostream&gt;

template &lt;typename Function&gt;
void functionProxy(Function function)
{
    function();
}

struct Functor
{
    void operator()() const
    {
        std::cout &lt;&lt; ""functor!"" &lt;&lt; std::endl;
    }
};

void function()
{
    std::cout &lt;&lt; ""function!"" &lt;&lt; std::endl;
}

//#define MANUALLY_INLINE

#ifdef MANUALLY_INLINE
void test()
{
    Functor()();

    function();

    [](){ std::cout &lt;&lt; ""lambda!"" &lt;&lt; std::endl; }();
}
#else
void test()
{
    functionProxy(Functor());

    functionProxy(function);

    functionProxy([](){ std::cout &lt;&lt; ""lambda!"" &lt;&lt; std::endl; });
}
#endif

int main()
{
    test();
}
</code></pre>

<p>With <code>MANUALLY_INLINE</code> defined, we get this:</p>

<pre><code>test:
00401000  mov         eax,dword ptr [__imp_std::endl (402044h)]  
00401005  mov         ecx,dword ptr [__imp_std::cout (402058h)]  
0040100B  push        eax  
0040100C  push        offset string ""functor!"" (402114h)  
00401011  push        ecx  
00401012  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (401110h)  
00401017  add         esp,8  
0040101A  mov         ecx,eax  
0040101C  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (40204Ch)]  
00401022  mov         edx,dword ptr [__imp_std::endl (402044h)]  
00401028  mov         eax,dword ptr [__imp_std::cout (402058h)]  
0040102D  push        edx  
0040102E  push        offset string ""function!"" (402120h)  
00401033  push        eax  
00401034  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (401110h)  
00401039  add         esp,8  
0040103C  mov         ecx,eax  
0040103E  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (40204Ch)]  
00401044  mov         ecx,dword ptr [__imp_std::endl (402044h)]  
0040104A  mov         edx,dword ptr [__imp_std::cout (402058h)]  
00401050  push        ecx  
00401051  push        offset string ""lambda!"" (40212Ch)  
00401056  push        edx  
00401057  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (401110h)  
0040105C  add         esp,8  
0040105F  mov         ecx,eax  
00401061  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (40204Ch)]  
00401067  ret  
</code></pre>

<p>And without, this:</p>

<pre><code>test:
00401000  mov         eax,dword ptr [__imp_std::endl (402044h)]  
00401005  mov         ecx,dword ptr [__imp_std::cout (402058h)]  
0040100B  push        eax  
0040100C  push        offset string ""functor!"" (402114h)  
00401011  push        ecx  
00401012  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (401110h)  
00401017  add         esp,8  
0040101A  mov         ecx,eax  
0040101C  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (40204Ch)]  
00401022  mov         edx,dword ptr [__imp_std::endl (402044h)]  
00401028  mov         eax,dword ptr [__imp_std::cout (402058h)]  
0040102D  push        edx  
0040102E  push        offset string ""function!"" (402120h)  
00401033  push        eax  
00401034  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (401110h)  
00401039  add         esp,8  
0040103C  mov         ecx,eax  
0040103E  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (40204Ch)]  
00401044  mov         ecx,dword ptr [__imp_std::endl (402044h)]  
0040104A  mov         edx,dword ptr [__imp_std::cout (402058h)]  
00401050  push        ecx  
00401051  push        offset string ""lambda!"" (40212Ch)  
00401056  push        edx  
00401057  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (401110h)  
0040105C  add         esp,8  
0040105F  mov         ecx,eax  
00401061  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (40204Ch)]  
00401067  ret
</code></pre>

<p>The same. (Compiled with MSVC 2010, vanilla Release.)</p>
"
"<p>I want to pass an rvalue through <code>std::bind</code> to a function that takes an rvalue reference in C++0x.  I can't figure out how to do it.  For example:</p>

<pre><code>#include &lt;utility&gt;
#include &lt;functional&gt;

template&lt;class Type&gt;
void foo(Type &amp;&amp;value)
{
    Type new_object = std::forward&lt;Type&gt;(value);    // move-construct if possible
}

class Movable
{
public:
    Movable(Movable &amp;&amp;) = default;
    Movable &amp;operator=(Movable &amp;&amp;) = default;
};

int main()
{
    auto f = std::bind(foo&lt;Movable&gt;, Movable());
    f();    // error, but want the same effect as foo(Movable())
}
</code></pre>
","87234","","<p>The reason this fails is because when you specify <code>foo&lt;Movable&gt;</code>, the function you're binding to is:</p>

<pre><code>void foo(Movable&amp;&amp;) // *must* be an rvalue
{
}
</code></pre>

<p>However, the value passed by <code>std::bind</code> will not be an rvalue, but an lvalue (stored as a member somewhere in the resulting <code>bind</code> functor). That, is the generated functor is akin to:</p>

<pre><code>struct your_bind
{
    your_bind(Movable arg0) :
    arg0(arg0)
    {}

    void operator()()
    {
        foo&lt;int&gt;(arg0); // lvalue!
    }

    Movable arg0;
};
</code></pre>

<p>Constructed as <code>your_bind(Movable())</code>. So you can see this fails because <code>Movable&amp;&amp;</code> cannot bind to <code>Movable</code>.†</p>

<p>A simple solution might be this instead:</p>

<pre><code>auto f = std::bind(foo&lt;Movable&amp;&gt;, Movable());
</code></pre>

<p>Because now the function you're calling is:</p>

<pre><code>void foo(Movable&amp; /* conceptually, this was Movable&amp; &amp;&amp;
                        and collapsed to Movable&amp; */)
{
}
</code></pre>

<p>And the call works fine (and, of course, you could make that <code>foo&lt;const Movable&amp;&gt;</code> if desired). But an interesting question is if we can get your original bind to work, and we can via:</p>

<pre><code>auto f = std::bind(foo&lt;Movable&gt;,
            std::bind(static_cast&lt;Movable&amp;&amp;(&amp;)(Movable&amp;)&gt;(std::move&lt;Movable&amp;&gt;),
                Movable()));
</code></pre>

<p>That is, we just <code>std::move</code> the argument before we make the call, so it can bind. But yikes, that's ugly. The cast is required because <code>std::move</code> is an overloaded function, so we have to specify <em>which</em> overload we want by casting to the desired type, eliminating the other options.</p>

<p>It actually wouldn't be so bad if <code>std::move</code> wasn't overloaded, as if we had something like:</p>

<pre><code>Movable&amp;&amp; my_special_move(Movable&amp; x)
{
    return std::move(x);
}


auto f = std::bind(foo&lt;Movable&gt;, std::bind(my_special_move, Movable()));
</code></pre>

<p>Which is much simpler. But unless you have such a function laying around, I think it's clear you probably just want to specify a more explicit template argument.</p>

<hr>

<p>† This is different than calling the function without an explicit template argument, because explicitly specifying it removes the possibility for it to be deduced. (<code>T&amp;&amp;</code>, where <code>T</code> is a template parameter, can be deduced to <em>anything</em>, <a href=""http://stackoverflow.com/questions/3582001/advantages-of-using-forward"">if you let it be</a>.)</p>
"
"<p>I came across some code written in VS7.1 and now I'm trying to get it to work for MacOSX. The code snippet below I understand is <strong>about the <a href=""http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error"" rel=""nofollow"">SFINAE</a> principle</strong>. From what I understand, the code is used to at compile-time know what type something is by relying on some template instantiation magic. In short, the right overload is picked by looking at the template argument.</p>

<p>Here's the code I have. Somewhat simplified to only show the problem.</p>

<pre><code>template &lt;typename T&gt;
struct SomeClass
{
};

template &lt;&gt;
struct SomeClass&lt;char&gt;
{
    typedef char Type;
};

template &lt;typename T&gt;
struct IsChar
{
    typedef char Yes;
    typedef int No;

    template &lt;typename U&gt;
    static Yes Select(U*, typename SomeClass&lt;U&gt;::Type* p = 0);
    template &lt;typename U&gt;
    static No Select(U*, ...);
    static T* MakeT();

    const static bool Value = sizeof(Select(MakeT())) == sizeof(Yes);
};
</code></pre>

<p>I'm simply using this like this:</p>

<pre><code>if (IsChar&lt;int&gt;::Value)
{
    ...
</code></pre>

<p>When compiling <strong>the above code works well</strong> and it picks the topmost class due to the missing typedef for Type when using int.</p>

<p>If I now use char instead...</p>

<pre><code>if (IsChar&lt;char&gt;::Value)
{
    ...
</code></pre>

<p>...the <strong>compiler will complain about ambiguous Select functions</strong>, because it doesn't know which one to use. From what I've read overload resolution gives least preference to the ellipsis parameter (...). Thus, it should know to select the first one.</p>

<p>The code was working fine on at least VS7.1, but not on gcc for MacOSX and not gcc4.4 for Linux.</p>

<p>Any suggestions how to correct this? Maybe it's usually done in another way?</p>

<p>Thanks!</p>

<p>UPDATE: I realized that the sample code I gave is maybe slightly too much simplified, because I believe we're not jsut checking for type here even if I mistakenly make it look like that. I'll have to gather a bit more information for you tonight as I don't have the code here. Sorry for that.</p>

<p>UPDATE2: Even if my presenation in bad and it's due to not being familiar with the original code or using templates this way. Meanwhile I dig out a bit more information, let's assume these constructs are there for some reason X and the names I have given are all wrong, what about the compiler problem? Why is it not able to select the right overloaded function here? This is also interesting me. As I said, I'll get back with a better explanation what the overall aim is.</p>

<p><strong>Edit</strong></p>

<p>After taking  closer look at the original code, it is using boost::integral_constant and also boost::enable_if like what was suggested here. The problem is something specific to how the template arguments are deduced and it didn't work the way it was set up. However, following what Georg suggested in the end of his answer I could correct things to accept things. I have now the following:</p>

<pre><code>typedef char Yes;
typedef int No;

template &lt;typename U&gt; static Yes Select(typename SomeClass&lt;U&gt;::Type* p);
template &lt;typename U&gt; static No Select(...);

static const bool Value = sizeof(Select&lt;T&gt;(0)) == sizeof(Yes);
</code></pre>

<p>This works well. While experimenting a bit I found out that having two function parameters in the Select functions results in a problem. I haven't found the reason. I'll come back to this when I understand things better.</p>

<p>Thanks for all your help. At least I understand the principles here now and how things should work. Only some details, which are still unknown.</p>
","87234","","<p>In my comment I said that you don't typically use the results of these predicates as values for an <code>if</code>, and this is why:</p>

<pre><code>// assume we have has_typedef_type from the Wikipedia page:

template &lt;typename T&gt;
void foo(const T&amp; x)
{
    if (has_typedef_type&lt;T&gt;::value)
    {
        // the predicate is true, so T::type exists
        typename T::type y = x;
    }
    else
    {
        // the predicate is false, so T::type doesn't exist, do something else
        float y = x;
    }
}
</code></pre>

<p>This may look fine, but consider when the predicate is false, the compiler is going to try and compile this:</p>

<pre><code>// let's say we called it with double
void foo&lt;double&gt;(const double&amp; x)
{
    if (false)
    {
        // wait, double doesn't have this!
        typename double::type y = x;
    }
    else
    {
        float y = x;
    }
}
</code></pre>

<p>The problem is that the code, even though it'll be removed with dead-code removal, is ill-formed. The solution is to make the <code>if</code> compile-time as well, but first some boiler-plate:</p>

<pre><code>// in C++0x, these are defined in &lt;type_traits&gt;, but we'll do it ourselves
// (Boost has these as well)
typename &lt;typename T, T Value&gt;
struct integral_constant
{
    typedef T type;
    static const T value = Value;
};

typedef integral_constant&lt;bool, true&gt; true_type;
typedef integral_constant&lt;bool, false&gt; false_type;
</code></pre>

<p>With that out of the way, we define our functions:</p>

<pre><code>namespace detail
{
    // here are the real implementations
    template &lt;typename T&gt;
    void foo(const T&amp; x, true_type)
    {
        // the predicate is true, so T::type exists
        typename T::type y = x;
    }

    template &lt;typename T&gt;
    void foo(const T&amp; x, false_type)
    {
        // the predicate is false, so T::type doesn't exist, do something else
        float y = x;
    }
}

template &lt;typename T&gt;
void foo(const T&amp; x)
{
    detail::foo(x, // chose which function to call, using the type of this:
                integral_constant&lt;bool, has_typedef_type&lt;T&gt;::value&gt;());
}
</code></pre>

<p>Now everything is okay, because the branches are completely independent from one another.</p>
"
"<p>I can't find an answer in the standard documentation. Is <code>sizeof(bool)</code> always 1-byte, or is it implementation defined?</p>
","87234","","<p>Yes, it's implementation defined, and the standard puts notable emphasis on making that clear.</p>

<p>§5.3.3/1, abridged:</p>

<blockquote>
  <p><code>sizeof(char)</code>, <code>sizeof(signed char)</code> and <code>sizeof(unsigned char)</code> are 1; the result of <code>sizeof</code> applied to any other fundamental type is implementation-defined. [Note: in particular, <code>sizeof(bool)</code> and <code>sizeof(wchar_t)</code> are implementation-defined.<sup>69)</sup>]</p>
</blockquote>

<p>Footnote 69):</p>

<blockquote>
  <p><code>sizeof(bool)</code> is not required to be 1.</p>
</blockquote>
"
"<p>I'm trying to make an arkanoid-like game, and now I'm facing a problem with the collisions. As usual, the bricks are rectangles (in my case, squares) and the ball is a circle, so it's all about axis aligned bounding boxes.</p>

<p>So far, I've got the trivial collision detection algorithm, but I need to know what side of each brick the ball hits. For example:
<img src=""http://i.stack.imgur.com/H0YA1.png"" alt=""Collision cases""></p>

<p>So far I have an algorithm that checks whether each side has been hit:</p>

<pre><code>up = left = right = down = 0;

if(mouse.left &lt; brick.left &amp;&amp; brick.left &lt; mouse.right &amp;&amp; mouse.right &lt; brick.right){   
    left = 1;
}

if(brick.left &lt; mouse.left &amp;&amp; mouse.left &lt; brick.right &amp;&amp; brick.right &lt; mouse.right){
    right = 1;
}

if(mouse.top &lt; brick.top &amp;&amp; brick.top &lt; mouse.bottom &amp;&amp; mouse.bottom &lt; brick.bottom){
    up = 1;
}

if(brick .top &lt; mouse.top &amp;&amp; mouse.top &lt; brick.bottom &amp;&amp; brick.bottom &lt; mouse.bottom){
    down = 1;
}
</code></pre>

<p>But in the collisions close to the corners, like the third in the image, two flags (for instance, left and down) are set to 1, so I don't know how to decide. </p>

<p>What is usually done in these cases?</p>
","87234","","<p>Don't just set it to one, set it to the penetration depth:</p>

<pre><code>// why is it named mouse?
if(mouse.left &lt; brick.left &amp;&amp; brick.left &lt; mouse.right &amp;&amp;
    mouse.right &lt; brick.right)
{
    left = mouse.right - brick.left;
}

// and so on...
</code></pre>

<p>Then when you're done, you can pick whichever is minimum to be your main side.</p>

<hr>

<p>By the way, I don't think you want that third conditional. Imagine a case like this:</p>

<pre>
   +-+
   |B|
+--| |--+
|M | |  |
|  | |  |
+--| |--+
   +-+
</pre>

<p>Here, you have no left or right collision.</p>

<p>(You may also want to review the remaining conditionals for correctness.)</p>
"
"<p>Why can I create an object of a class with private destructor on free store but not on the stack ? </p>

<p>For example this is illegal:</p>

<pre><code>class Foo
{
public:
   explicit Foo( int );
   static void delete_foo(Foo* foo ) { delete foo; }
private:
   int x;
   ~Foo();
   Foo( const Foo&amp; );
   Foo&amp; operator=(const Foo&amp; );
};

int main()
{
   Foo * fooptr = new Foo(5); // legal
   Foo::delete_foo( fooptr ); // legal 
   Foo foo(5); // illegal
}
</code></pre>
","87234","","<p>Because an object with <em>automatic storage</em>* needs to be, well, automatically destructed. So the destructor needs to be available to call; if it's not, you can't have that type in automatic storage.</p>

<p>Contrarily, it's up to you to delete it when you allocate it dynamically. You can, of course, not do so.</p>

<p>*Objects here are, on ""typical"" platforms, commonly allocated on the stack.</p>
"
"<p>I'm wondering which one is better of these two implementations of passing addresses to pointers.  Is there a data exchange in the 1st one that doesn't happen in the 2nd one? Is the second one a more efficient way?  More readable? both the same?</p>

<p><strong>Version 1</strong></p>

<pre><code>void ptrFunction(int&amp; arg)
{
    int* ptr = &amp;arg;
    std::cout&lt;&lt;""The pointer's value:"" &lt;&lt; *ptr &lt;&lt; ""\n"";
}

int main()
{
    int  x=5;
    ptrFunction(x);
    return 0;
}
</code></pre>

<p><strong>Version 2</strong></p>

<pre><code>void CallViaPointers(int *arg)
{
  int *ptr = *arg;
  std::cout &lt;&lt; ""The pointer's value: "" &lt;&lt; *ptr;
}

int main()
{
    int x = 100;
    CallViaPointers(&amp;x);
    return 0;
}
</code></pre>
","87234","","<p>I'd say it depends on what the function does. <strike>Right now your function name doesn't match what it does. If it did, it'd be named <code>print_pointer</code> and it'd be clear it should just take a pointer directly.</strike> (I read the question incorrectly. But yes, it still depends on what your function does.)</p>

<p>Let's say you have a function that prints a pointer, like:</p>

<pre><code>void print_pointer(void* ptr)
{
    std::cout &lt;&lt; ptr &lt;&lt; std::endl;
}
</code></pre>

<p>It doesn't make sense for this function to be written to take a reference, then get the address of it, because you don't want an object, you want a pointer to an object, and null is valid in this context.</p>

<p>If, however, you need an <em>object</em>, like your code does, you should take a reference, because pointing to that object is an implementation detail; the interface, with a reference, clearly documents you need an object to refer to.</p>

<p>As it stands, version two is <em>broken</em>, because passing null crashes the program, yet null is a valid pointer value. Don't advertise you want a pointer value when it isn't the case. To fix it, check for null and do something clearly documented, like nothing or throw an exception. But best it to change the parameter to a reference, because you leave those issues to the <em>caller</em>, and your function works regardless.</p>

<p>(If someone has a pointer to an object, they can be responsible for dereferencing it safely to pass a valid object to your function. In other words, using a reference is self-documenting: ""null isn't valid here"".)</p>

<p>Performance is irrelevant.</p>
"
"<pre><code>class A
{
  A a;//why can't we do this
};
</code></pre>
","87234","","<p>Because the class would be infinite in size.</p>

<p>(This is done language-wise by specifying you can't have incomplete types as members, only reference or pointers to them, and that <code>A</code> is an incomplete type until the end of the class definition.)</p>
"
"<p>A company's internal c++ coding standards document states that even for basic data types like int, char, etc. one should define own typedefs like ""typedef int Int"". This is justified by advantage of portability of the code.
However are there general considerations/ advice about when (in means for which types of projects) does it really make sense?
Thanks in advance..</p>
","87234","","<p>Rubbish.</p>

<p>""Portability"" is non-sense, because <code>int</code> is always an <code>int</code>. If they think they want something like an integer type that's 32-bits, then the typedef should be <code>typedef int int32_t;</code>, because then you are naming a real invariant, and can actually ensure that this invariant holds, via the preprocessor etc.</p>

<p>But this is, of course, a waste of time, because you can use <code>&lt;cstdint&gt;</code>, either in C++0x, or by extensions, or use Boost's implementation of it anyway.</p>
"
"<p>The following code represents a container based on std::vector</p>

<pre><code>template &lt;typename Item&gt;
struct TList
{
    typedef std::vector &lt;Item&gt; Type;
};


template &lt;typename Item&gt;
class List
{
private
            typename TList &lt;Item&gt;::Type items;
    ....
}

int main()
{
  List &lt;Object&gt; list;
}
</code></pre>

<p>Is it possible to templatize std::vector and create a general container, something like that?</p>

<pre><code>template &lt;typename Item, typename stl_container&gt;
struct TList
{
    typedef stl_container&lt;Item&gt;;
};
</code></pre>

<p>where stl_container represents std::vector, std::list, std::set...? I would like to choose the type of container at the time of the creation. </p>

<pre><code>List &lt;Object, std::vector&gt; list; //vector of objects, not a real code
List &lt;Object, std::vector&gt; list; //list of objects, not a real code
</code></pre>

<p>Thanks for your answers...</p>

<p><strong>Updated question:</strong></p>

<p>I tried the following code but there are errors:</p>

<pre><code>#include &lt;vector&gt;
template &lt;typename Item, typename Container&gt;
struct TList
{
   typedef typename Container &lt;Item&gt;::type type; //Error C2059: syntax error : '&lt;', Error C2238: unexpected token(s) preceding ';
};


template &lt;typename T&gt;
struct vector_container
{
  typedef std::vector&lt;T&gt; type;
};

int _tmain(int argc, _TCHAR* argv[])
{
TList &lt;int, vector_container&gt; v;
TList &lt;int, map_container&gt; m;
}
</code></pre>
","87234","","<p>Yes, but not directly:</p>

<pre><code>template &lt;typename Item, template &lt;typename&gt; class Container&gt;
struct TList
{
    typedef typename Container&lt;Item&gt;::type type;
};
</code></pre>

<p>Then you can define different container policies:</p>

<pre><code>template &lt;typename T&gt;
struct vector_container
{
    typedef std::vector&lt;T&gt; type;
};

template &lt;typename T&gt;
struct map_container
{
    typedef std::map&lt;T, std::string&gt; type;
};

TList&lt;int, vector_container&gt; v;
TList&lt;int, map_container&gt; m;
</code></pre>

<p>A bit verbose, though.* To do things directly, you'd need to take <a href=""http://stackoverflow.com/questions/4962518/templates-and-stl/4962623#4962623"">the route described by James</a>, but as he notes this is ultimately very inflexible.</p>

<p>However, with C++0x we can do this just fine:</p>

<pre><code>#include &lt;map&gt;
#include &lt;vector&gt;

template &lt;typename Item,
            template &lt;typename...&gt; class Container, typename... Args&gt; 
struct TList
{
    // Args lets the user specify additional explicit template arguments
    Container&lt;Item, Args...&gt; storage;
};

int main()
{
    TList&lt;int, std::vector&gt; v;
    TList&lt;int, std::map, float&gt; m;
}
</code></pre>

<p>Perfect. Unfortunately there's no way to reproduce this in C++03, except via the indirection policy classes introduce as described above.</p>

<hr>

<p>*I want to emphasize that by ""A bit verbose"" I mean ""this is unorthodox"". The correct solution for your problem is what the standard library does, <a href=""http://stackoverflow.com/questions/4962518/templates-and-stl/4962828#4962828"">as Jerry explains</a>. You just let the user of your container adapter specify the entire container type directly:</p>

<pre><code>template &lt;typename Item, typename Container = std::vector&lt;Item&gt;&gt;
struct TList
{};
</code></pre>

<p>But this leaves a big problem: what if I don't want the value type of the container to be <code>Item</code> but <code>something_else&lt;Item&gt;</code>? In other words, how can I change the value type of an existing container to something else? In your case you don't, so read no further, but in the case we do, we want to <em>rebind</em> a container.</p>

<p>Unfortunately for us, the containers don't have this functionality, though allocators do:</p>

<pre><code>template &lt;typename T&gt;
struct allocator
{
    template &lt;typename U&gt;
    struct rebind
    {
        typedef allocator&lt;U&gt; type;
    };

    // ...
};
</code></pre>

<p>This allows us to get an <code>allocator&lt;U&gt;</code> given an <code>allocator&lt;T&gt;</code>. How can we do the same for containers without this intrusive utility? In C++0x, it's easy:</p>

<pre><code>template &lt;typename T, typename Container&gt;
struct rebind; // not defined

template &lt;typename T, typename Container, typename... Args&gt;
struct rebind&lt;T, Container&lt;Args...&gt;&gt;
{
    // assumes the rest are filled with defaults**
    typedef Container&lt;T&gt; type; 
};
</code></pre>

<p>Given <code>std::vector&lt;int&gt;</code>, we can perform <code>rebind&lt;float, std::vector&lt;int&gt;&gt;::type</code>, for example. Unlike the previous C++0x solution, this one can be emulated in C++03 with macros and iteration..</p>

<hr>

<p>**Note this mechanism can be made much more powerful, like specifying which arguments to keep, which to rebind, which to rebind themselves before using as arguments, etc., but that's left as an exercise for the reader. :)</p>
"
"<p>I'm working on some code using decltype in CodeGear RAD Studio. I've tried the naive solution, which looks not unlike this:</p>

<pre><code>int main(int, char**) {
    int i;
    int &amp;ir = i;
    decltype((ir)) ir_clone = ir;
}
</code></pre>

<p>Of course, this fails to compile: Internal Compiler Error. I rather suspect that there is nothing particularly wrong with that code and there is a compiler bug regarding reference expressions. (Incidentally, g++ has no problem with the code and compiles it fine.) That doesn't help solve the problem, however, as the platform is non-negotiable.</p>

<p>If, above, I had written</p>

<pre><code>    decltype(ir) ir_clone = ir; /* No extra parens */
</code></pre>

<p>it compiles and works as expected. However, the problem doesn't end there, since that doesn't correctly compute constness from the environment. In particular:</p>

<pre><code>struct S { int i; } s;
const S* p = &amp;s;
decltype(p-&gt;i)   i0 = s.i; /* i0 is an int */
decltype((p-&gt;i)) i1 = s.i; /* i1 is a const int&amp; */
</code></pre>

<p>If I don't use the parens to make the argument an expression, I lose the constness of the argument, which I need.</p>

<p>Another tool I can use is simple templates, like so:</p>

<pre><code>template&lt;class T&gt; struct unref     { typedef T type; }
template&lt;class T&gt; struct unref&lt;T&amp;&gt; { typedef T type; }
</code></pre>

<p>That lets me strip away the reference portion of a type, by using <code>unref&lt;int&amp;&gt;::type</code>.</p>

<p>What I can't seem to figure out is how to put all these tools together to get a successful expression for the type I need. For one of things I need, I'm working on a generalized macro that does 'foreach'. (Yes, I know Boost does it better.) It needs to handle the following scenarios:</p>

<pre><code>(vector&lt;int&gt;) vi          =&gt; vector&lt;int&gt;
(vector&lt;int&gt;&amp;)vir         =&gt; vector&lt;int&gt;
(const vector&lt;int&gt;) cvi   =&gt; const vector&lt;int&gt;
(const vector&lt;int&gt;&amp;)cvir  =&gt; const vector&lt;int&gt;
(const P*) cp-&gt;vi         =&gt; const vector&lt;int&gt;
(P*) p-&gt;vi                =&gt; vector&lt;int&gt;
</code></pre>

<p>So far, my simple attempts fail:</p>

<pre><code>unref&lt;decltype(cp-&gt;vi)&gt;   /* is vector&lt;int&gt;, not what I need. */
unref&lt;decltype((cp-&gt;vi))&gt; /* is const vector&lt;int&gt;, which is right. */

unref&lt;decltype(vir)&gt;      /* is vector&lt;int&gt;, which is right. */
unref&lt;decltype((vir))&gt;    /* Internal Compiler Error, which is a headache. */
</code></pre>

<p>Any ideas to get me on the right track? Hopefully there's just something simple I'm missing. Maybe I'm attacking the problem from the wrong angle.</p>
","87234","","<p>Try making a different, more complex expression that results in the same type that you want, such as:</p>

<pre><code>decltype((void(), ir))
</code></pre>

<p>I couldn't tell you why it fixes it, but sometimes a different expression will do the trick.</p>
"
"<p>I sometimes need a ""null"" implementation of named_mutex(i.e. always succeeds and does nothing).</p>

<p>Is there is such implementation ? If not, what's the recommended way to implement?</p>
","87234","","<p>Why not just have a class with empty definitions?</p>

<pre><code>class named_mutex
{
public:
    named_mutex(create_only_t, const char *) {}
    named_mutex(open_or_create_t, const char *) {}
    named_mutex(open_only_t, const char *) {}
    ~named_mutex() {}

    void unlock() {}
    void lock() {}
    bool try_lock() {}
    bool timed_lock(const boost::posix_time::ptime &amp;) {}

    static bool remove(const char *) {}
};
</code></pre>

<p>Use an instance of this as your <code>named_mutex</code> and it's like it never existed.</p>
"
"<p>How the performance of <code>boost::array</code> compares to that of <code>std::vector</code>, and which factors have significant influence on it?</p>
","87234","","<p>Faster at what? <code>std::vector</code> is faster to type because it has one less character.</p>

<p>It doesn't matter what's faster, you're comparing two different things, a statically-sized array with a dynamically-sized array. Which to use depends on your application, and has nothing to do with speed.</p>

<p>Do you want to operate a plane or a car to some place? It depends on more than which is simply ""faster"".</p>

<hr>

<p>A <code>boost::array</code> might be faster to allocate because it's, on typical machines, on the stack. Or <code>std::vector</code> might be nearly as fast because of some custom memory allocation scheme.</p>

<p>But that's just allocation. What about use? Well both are just indices into an array, so maybe not difference there. But what about moving or swapping? <code>boost::array</code> certainly cannot do that as fast, because <code>std::vector</code> only has to move/swap a pointer. Or maybe not, who knows?</p>

<p>You have to profile and look at the assembly. Nobody can magically know how things perform for you.</p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/2795023/c-template-typedef"">C++ template typedef</a>  </p>
</blockquote>



<p>I am trying to derive a template type of another template by pre-specializing of another template:</p>

<pre><code>template&lt;unsigned a, unsigned b, unsigned c&gt;
struct test
{
    enum
    {
        TEST_X = a,
        TEST_Y = b,
        TEST_Z = c,
    };
};

template&lt;unsigned c&gt;
typedef test&lt;0, 1, c&gt; test01;
</code></pre>

<p>However, on GCC 4.4.5, I am getting this error: <code>error: template declaration of ‘typedef’</code> on the second type (<code>test01</code>).</p>

<p>Guidance would be highly appreciated, as I don't understand what is wrong with my code.</p>
","87234","","<p>This syntax isn't allowed by C++03. The nearest work-around is:</p>

<pre><code>template&lt;unsigned c&gt;
struct test01
{
    typedef test&lt;0, 1, c&gt; type;
};

typedef test01&lt;2&gt;::type my_type;
</code></pre>

<p>In C++0x, we can do this:</p>

<pre><code>template&lt;unsigned c&gt;
using test01 = test&lt;0, 1, c&gt;;
</code></pre>
"
"<p>This is some C code from the Make Controller firmware. I'm familiar with what void pointers are, but I've never seen syntax like the first line of this function. What precisely is being accomplished by that?</p>

<pre><code>void MakeStarterTask(void* parameters)
{
  (void)parameters;
  Run();
  TaskDelete(NULL);
}
</code></pre>
","87234","","<p>It ""uses"" <code>parameters</code> so the compiler won't emit a warning about an unused parameter, but the expression does itself nothing. Any expression can be cast to <code>void</code>, which discards the result.</p>

<p>(Keep in mind that the expression is still evaluated; <a href=""http://stackoverflow.com/questions/4030959/will-a-variablename-c-statement-be-a-no-op-at-all-times/4030983#4030983"">to make an expression completely ignored is trickier</a>.)</p>
"
"<p>(I'm trying to make this a Community Wiki, but for some reason there's no checkbox to do that.  Any advice on how to do this would be appreciated!)</p>

<p>I have a perennial thought experiment about how to write a line of C++ code that has the maximum number of unique reserved words in it.  In this challenge, you can duplicate keywords as much as you'd like, but all that matters is the number of unique keywords you use.  For example, if you write</p>

<pre><code>void MyFunction(int, int, int, int);
</code></pre>

<p>There are four instances of int, but the above line has a score of 2 because it only has two unique keywords in it (<code>void</code> and <code>int</code>, namely).  This line, though,</p>

<pre><code>void MyFunction(int, double, short, long);
</code></pre>

<p>Has a score of 5 for its five reserved words.</p>

<p>So far, the best I've been able to come up with is</p>

<pre><code>export template &lt;typename T, class C&gt;
inline void DiabolicalFunc (int, char, short, 
                            long, double, signed, 
                            unsigned, bool, float,
                            wchar_t, const int,
                            volatile int, 
                            enum MyEnum,
                            void* (*)(size_t) = &amp;(operator new), 
                            void (*)(void*) = &amp;(operator delete), 
                            int = const_cast&lt;int*&gt;(static_cast&lt;const int *&gt;(reinterpret_cast&lt;int*&gt;(0))), 
                            void* = dynamic_cast&lt;void*&gt;(reinterpret_cast&lt;ios_base*&gt;(0)),
                            bool = true, bool = false, int = sizeof(int), 
                            const std::type_info&amp; = typeid(int),
                            struct MyStruct = MyStruct(), union MyUnion = MyUnion(), 
                            int = 0 and 0,
                            int = 0 bitand 0,
                            int = 0 bitor 0, 
                            int = compl 0, 
                            int = not 0, 
                            int = 0 not_eq 0,
                            int = 0 or 0, 
                            int = 0 xor 0) throw();
</code></pre>

<p>This has a whopping 39 reserved words in it.  It assumes that you have defined an <code>enum MyEnum</code>, <code>struct MyStruct</code>, and <code>union MyUnion</code> before declaring it, though.  And yes, this <em>does</em> compile in <code>g++</code> if you set up the appropriate types before using it (though it does give a warning about <code>export</code>.)</p>

<p>I'm curious if anyone sees any way to cram even more unique keywords into a line of code.  Can someone top my example?  Or find a way to make it Even More Diabolical?</p>

<p>I know that C++ is freeform so a ""line of code"" is not a really good measure of structure, but I think we can come to a reasonable interpretation of what this means.</p>

<p>Have fun!</p>

<p><strong>EDIT:</strong> Just added <code>throw()</code> to the end of the function to get one more keyword in there.</p>
","87234","","<p>A line of C++ code you say?</p>

<pre><code>// asm auto bool break case catch char class const ...
</code></pre>

<p>I kid, I kid.</p>
"
"<p>When i try to compile the following code:</p>

<pre><code>#include &lt;string.h&gt;
using namespace std;
typedef std::basic_string&lt;char&gt; foostring;
foostring foo = ""foo"";
</code></pre>

<p>I get the following error:</p>

<pre><code>stringtest.cpp:5: error: expected initializer before ‘&lt;’ token
stringtest.cpp:6: error: ‘foostring’ does not name a type
</code></pre>

<p>My compiler is: g++ (Ubuntu 4.4.1-4ubuntu9) 4.4.1<br>
What am i doing wrong? i intend to use this with windows TCHAR for unicode support once i figure out how to use it.</p>
","87234","","<p>The header is <code>&lt;string&gt;</code>, not <code>&lt;string.h&gt;</code>.</p>

<p>None of the standard library headers end with an extension. (You're including the C header <code>string.h</code>, which should be included in C++ via <code>&lt;cstring&gt;</code>, had that been what you actually wanted.)</p>
"
"<p>If I run the following code, no file is created at all:</p>

<pre><code>std::ofstream outputFile(strOutputLocation.c_str(), std::ios::binary);
outputFile.write((const char*)lpResLock, dwSizeRes);
outputFile.close();
</code></pre>

<p>However, if I add a flush() before the close, it works:</p>

<pre><code>std::ofstream outputFile(strOutputLocation.c_str(), std::ios::binary);
outputFile.write((const char*)lpResLock, dwSizeRes);
outputFile.flush();
outputFile.close();
</code></pre>

<p>Does the standard library actually require this, or is it a bug in the Visual C++ CRT?</p>
","87234","","<p>It's a bug. Reading §27.8.1.10/4, abridged:</p>

<blockquote>
  <p><code>void close();</code><br>
  Effects: Calls <code>rdbuf()-&gt;close()</code>...</p>
</blockquote>

<p>What does <code>rdbuf()-&gt;close()</code> do? According to §27.8.1.3/6, abridged, emphasis mine:</p>

<blockquote>
  <p><code>basic_filebuf&lt;charT,traits&gt;* close();</code><br>
  If <code>is_open() == false</code>, returns a null pointer. <strong>If a put area exists, calls <code>overflow(EOF)</code> to flush characters.</strong> ...</p>
</blockquote>

<p>That is, it's suppose to flush. (Indeed, the call to <code>flush()</code> ultimately does the same thing.)</p>

<hr>

<p>Note the call to <code>close()</code> itself isn't needed, as the destructor of <code>basic_ofstream</code> will call <code>close()</code>.</p>
"
"<p>I've got code that calls ::fgetpos, which results in a kernel exception that can't be caught (I have option /ehs in my VS 2008 project).  But I can't help think that standard library routines should <strong>never</strong> throw these kinds of exceptions.  </p>

<p><strong>update</strong>: I've tried calling ::fgetpos(0, &amp;foo), which is clearly wrong, and I indeed received a kernel-level exception.  I'm baffled.  Why would the C++ standard library not perform the most basic of argument checks (check for null-pointer) and raise a std::invalid_argument?</p>

<p>Do any standard library routines perform such basic checks, or do they all happily cause program termination?</p>
","87234","","<blockquote>
  <p>Why would the C++ standard library not perform the most basic of argument checks (check for null-pointer) </p>
</blockquote>

<p>Because you can do that yourself if you need the check. The philosophy of C++ is that you don't pay for what you don't need. If I'm a smart programmer and will never pass invalid arguments to the function, why should I have my program's performance potentially suffer with needless checks?</p>

<p>This is why <code>std::vector</code>, for example, provides both <code>operator[]</code> and <code>at()</code>, where the latter performs a bounds-check and the former doesn't. If you need the check, add it.</p>
"
"<p>Why does returning the reference to a pointed-to member variable work, but not the other?  I know that a <code>const</code> member function should only return <code>const</code> references, but why does that not seem true for pointers?</p>

<pre><code>class MyClass
{
  private:
    int * a;
    int b;
  public:
    MyClass() { a = new int; }
    ~MyClass() { delete a; }

    int &amp; geta(void) const { return *a; } // good?
    int &amp; getb(void) const { return b; }  // obviously bad
};

int main(void)
{
  MyClass m;

  m.geta() = 5;  //works????
  m.getb() = 7;  //doesn't compile

  return 0;
}
</code></pre>
","87234","","<p>Because <code>a</code> becomes <code>int * const a;</code>. That is, you cannot change the value of <code>a</code> (change what it points at), just as <code>const</code> says. The const-ness of what <code>a</code> <em>points at</em> is a completely different issue.</p>

<p>Please see my answer <a href=""http://stackoverflow.com/questions/3484233/const-method-that-modifies-this-without-const-cast/3485333#3485333"">here</a> for a thorough discussion of const and const member functions.</p>
"
"<p>The following seems perfectly logical to me, but isn't valid c++. A union cannot be implicitly cast to one of it's member types. Anyone know a good reason why not?</p>

<pre><code>union u {
  int i;
  char c;
}
function f(int i) {
}
int main() {
  u v;
  v.i = 6;
  f(v);
}
</code></pre>

<p>And can anyone suggest a clean alternative (the cleanest I can come up with is <code>f(v.i);</code>, which I admit is very clean, but the above just seems even cleaner)</p>
","87234","","<p>How would the compiler know which member to use? It would need to keep track of which member was last assigned so it knows what to convert to. This is called a <em>tagged union</em>, and while it's certainly possible for the language to specify such a thing, that's not the case (it's a hold-over from C).</p>

<p>But that's okay, because we have <a href=""http://www.boost.org/doc/libs/1_45_0/doc/html/variant.html"" rel=""nofollow""><code>boost::variant</code></a>. Not only is it safer and more flexible than a union, it's more powerful. You can apply <em>visitors</em> to the variant, and it'll call (visit) the specified function with whichever member is currently active, with no further work from the user.</p>
"
"<p>I am facing compilation error while working with assembly instructions in VC++ as MACRO inline based assembler blocks.</p>

<pre><code>error C2400: inline assembler syntax error in 'second operand'; found 'register'
</code></pre>

<p>Here is the code:</p>

<pre><code>_asm {\

        mov esi,dword ptr [pMemBlock]\
        sub esp,sizeOfblock\
        mov ebx,sizeOfblock\
        mov shrResult,ebx\
        shr shrResult,2\
        mov ecx,shrResult\
        mov shrResult,0\
        mov edi,esp\
        rep movs dword ptr es:[edi],dword ptr[esi]\
}
</code></pre>

<p>Regards
Usman</p>
","87234","","<p>That blank line after the <code>_asm {</code> line will complete the macro. It should be deleted or have \ on it. </p>
"
"<p>I am a hobbyist C++ programmer and currently working on a game (using Ogre3D) and I have a question regarding the memory allocation for my main classes.</p>

<p>I have read a lot on memory allocation, allocating automatically on the stack and dynamically on the heap, and their differences (performance, limited stack size). Still I am not sure what to use for my main class (Application) and some other 'factory' classes (created by a single instance of the Application class), which will all have a single instance existing throughout the entire execution.</p>

<p>Below is a simplified snippet of the layout:</p>

<pre><code>int main() 
{
    // like this (automatic)
    Application app;
    app.create();    // initializing
    app.run();       // runs the game-loop

    // or like this (dynamic)
    Application* app;
    app = new Application();
    app-&gt;create();
    app-&gt;run();

    return(0);       // only reached after exiting game
}



class Application
{
public:
    Application();   // ctor
    ~Application();  // dtor

    // like this, using 'new' in ctor and 'delete' in dtor (dynamic)
    SceneManager* sceneManager_;   // a factory for handling scene objects
    DebugManager* debugManager_;   // a factory for handling debugging objects

    // or like this (automatic)
    SceneManager sceneManager_;
    DebugManager debugManager_;
};
</code></pre>

<p>Is it better to allocate memory on the stack or on the heap (both for the Application class and the factory classes)? And by what arguments?</p>

<p>Thanks in advance!</p>
","87234","","<p>Always prefer automatic allocation over dynamic allocation. And when you need dynamic allocation, make sure its lifetime is managed by automatically allocated resource wrappers, like smart pointers.</p>
"
"<p>Why inline keyword should used in the definition of member function. and Not in declaration?</p>
","87234","","<p><code>inline</code> has some pre-historic use, but nowadays it's best to remember it as saying: ""this definition is going to be defined multiple times, and that's okay.""</p>

<p>That is, normally the one-definition rule prohibits multiple definitions of a function. This:</p>

<pre><code>// foo.hpp
void foo() { /* body */ }

// a.cpp
#include ""foo.hpp""

// b.cpp
#include ""foo.hpp""
</code></pre>

<p>results in an error, as <code>foo</code> is defined in two translation units. You can <em>declare</em> things as often as you want. This:</p>

<pre><code>// foo.hpp
void foo();

// foo.cpp
void foo()
{
    /* body */
}

// a.cpp
#include ""foo.hpp""

// b.cpp
#include ""foo.hpp""
</code></pre>

<p>is fine, as <code>foo</code> is defined once, and declared multiple times. What <code>inline</code> does is allow this:</p>

<pre><code>// foo.hpp
inline void foo() { /* body */ }

// a.cpp
#include ""foo.hpp""

// b.cpp
#include ""foo.hpp""
</code></pre>

<p>to work. It says ""if you see <code>foo</code> more than once, just assume they are the same and be okay with it"". </p>
"
"<p>I'm using C++ Visual Studio .Net 4.0 on Windows 7.0 x64. This happens just on the first loop of the while statement.</p>

<pre><code>int main()
{
  char *string = new char[11];

  string = ""characters\0"";

  toUppercase(string);

  return 0;
}



void toUppercase(char *stringPtr)
{
 while(*stringPtr != '\0')
 {
    if(*stringPtr &gt;= 'a' &amp;&amp; *stringPtr &lt;= 'z')
    {
        *stringPtr = *stringPtr - 32; // this is the culprit
    }

    ++stringPtr;    
 }
}
</code></pre>
","87234","","<p>I suspect you're doing something like this:</p>

<pre><code>toUppercase(""test"");
</code></pre>

<p>The problem is <code>""test""</code> is an array of <code>const char</code>, not <code>char</code>, so cannot be modified. However, due to a terribly stupid deprecated special conversion, a string literal can be treated as <code>char*</code> anyway.</p>

<p>(Your function also fails to test for <code>toUppercase(0)</code>.)</p>
"
"<pre><code>template&lt;typename T, typename R&gt;
T f(R &amp;r) { return T(r); }

int main() {
    int o;
    f&lt;int&amp;&gt;(o);
}
</code></pre>

<p>Is this ok?  Comeau didnt complain, so I assume <code>int&amp;(...)</code> form is fine?</p>

<p>reason example:</p>

<pre><code>    typename boost::mpl::if_c&lt;
        (rank == 1),
        reference,
        tensor_ref&lt;typename detail::array_ref&lt;A&gt;::type&gt;
        &gt;::type
    operator[](const int &amp;i) {
        typedef typename boost::mpl::if_c&lt;
            (rank == 1),
            reference,
            tensor_ref&lt;typename detail::array_ref&lt;A&gt;::type&gt;
                &gt;::type T;
        return T(detail::array_ref&lt;A&gt;::generate(this-&gt;data()));
    }
</code></pre>
","87234","","<p>This is fine, it acts like a cast from <code>int&amp;</code> to <code>int&amp;</code>, and returns <code>int&amp;</code>, referring back to <code>o</code>.</p>

<p>I'm not sure what purpose this would serve, though.</p>
"
"<p>I like some features of D, but would be interested if they come with a
runtime penalty?</p>

<p>To compare, I implemented a simple program that computes scalar products of many short vectors both in C++ and in D. The result is surprising:</p>

<ul>
<li>D:   18.9 s   [see below for final runtime] </li>
<li>C++:  3.8 s</li>
</ul>

<p>Is C++ really almost five times as fast or did I make a mistake in the D
program (it is my first one, please forgive me)?</p>

<hr>

<p><strong>Summary of answers:</strong>
D is as fast as C++ (for numerical computations) if</p>

<ol>
<li>one uses the correct optimization options (-O -release -inline -m64)</li>
<li>uses gdc/gdmd instead of dmd </li>
<li>uses correct D calling conventions (<code>in vector_t x</code> instead of <code>const ref vector_t x</code> in the arguments to function <code>scalar_product</code> below; --- while replacing the <code>for</code> loops by <code>foreach</code> looks nicer, but does not affect runtimes). </li>
</ol>

<p>Here all the figures on my machine:</p>

<ul>
<li>D (<code>const ref</code> arguments, dmd compiler, correct optimization): 9.6s</li>
<li>D (<code>in</code> arguments, dmd compiler, correct optimization): 6.1s</li>
<li>D (<code>in</code> arguments, gdmd compiler, correct optimization): 3.9s</li>
<li>C++: 3.8s</li>
</ul>

<p>I used gdc/gdmd 4.3. The combination D(<code>const ref</code> arguments, gdmd compiler) did not compile and thus has not been tested. Aside: gdc/gdmd did not have the datetime library yet and compiling it from sources failed for me, so it seems not as easy to handle as dmd right now. </p>

<p>Thanks CyberShadow and GMan and all others!</p>

<hr>

<p><strong>Continuation of original question:</strong></p>

<p>I compiled C++ with g++ -O3 (gcc-snapshot 2011-02-19) and D with dmd -O (dmd 2.052) on a moderate recent linux desktop. The results are reproducible over several runs and standard deviations negligible.</p>

<p>Here the C++ program:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;chrono&gt;
#include &lt;string&gt;

#include &lt;vector&gt;
#include &lt;array&gt;

typedef std::chrono::duration&lt;long, std::ratio&lt;1, 1000&gt;&gt; millisecs;
template &lt;typename _T&gt;
long time_since(std::chrono::time_point&lt;_T&gt;&amp; time) {
      long tm = std::chrono::duration_cast&lt;millisecs&gt;( std::chrono::system_clock::now() - time).count();
  time = std::chrono::system_clock::now();
  return tm;
}

const long N = 20000;
const int size = 10;

typedef int value_type;
typedef long long result_type;
typedef std::vector&lt;value_type&gt; vector_t;
typedef typename vector_t::size_type size_type;

inline value_type scalar_product(const vector_t&amp; x, const vector_t&amp; y) {
  value_type res = 0;
  size_type siz = x.size();
  for (size_type i = 0; i &lt; siz; ++i)
    res += x[i] * y[i];
  return res;
}

int main() {
  auto tm_before = std::chrono::system_clock::now();

  // 1. allocate and fill randomly many short vectors
  vector_t* xs = new vector_t [N];
  for (int i = 0; i &lt; N; ++i) {
    xs[i] = vector_t(size);
      }
  std::cerr &lt;&lt; ""allocation: "" &lt;&lt; time_since(tm_before) &lt;&lt; "" ms"" &lt;&lt; std::endl;

  std::mt19937 rnd_engine;
  std::uniform_int_distribution&lt;value_type&gt; runif_gen(-1000, 1000);
  for (int i = 0; i &lt; N; ++i)
    for (int j = 0; j &lt; size; ++j)
      xs[i][j] = runif_gen(rnd_engine);
  std::cerr &lt;&lt; ""random generation: "" &lt;&lt; time_since(tm_before) &lt;&lt; "" ms"" &lt;&lt; std::endl;

  // 2. compute all pairwise scalar products:
  time_since(tm_before);
  result_type avg = 0;
  for (int i = 0; i &lt; N; ++i)
    for (int j = 0; j &lt; N; ++j) 
      avg += scalar_product(xs[i], xs[j]);
  avg = avg / N*N;
  auto time = time_since(tm_before);
  std::cout &lt;&lt; ""result: "" &lt;&lt; avg &lt;&lt; std::endl;
  std::cout &lt;&lt; ""time: "" &lt;&lt; time &lt;&lt; "" ms"" &lt;&lt; std::endl;
}
</code></pre>

<p>And here the D version:</p>

<pre><code>import std.stdio;
import std.datetime;
import std.random;

const long N = 20000;
const int size = 10;

alias int value_type;
alias long result_type;
alias value_type[] vector_t;
alias uint size_type;

value_type scalar_product(const ref vector_t x, const ref vector_t y) {
  value_type res = 0;
  size_type siz = x.length;
  for (size_type i = 0; i &lt; siz; ++i)
    res += x[i] * y[i];
  return res;
}

int main() {   
  auto tm_before = Clock.currTime();

  // 1. allocate and fill randomly many short vectors
  vector_t[] xs;
  xs.length = N;
  for (int i = 0; i &lt; N; ++i) {
    xs[i].length = size;
  }
  writefln(""allocation: %i "", (Clock.currTime() - tm_before));
  tm_before = Clock.currTime();

  for (int i = 0; i &lt; N; ++i)
    for (int j = 0; j &lt; size; ++j)
      xs[i][j] = uniform(-1000, 1000);
  writefln(""random: %i "", (Clock.currTime() - tm_before));
  tm_before = Clock.currTime();

  // 2. compute all pairwise scalar products:
  result_type avg = cast(result_type) 0;
  for (int i = 0; i &lt; N; ++i)
    for (int j = 0; j &lt; N; ++j) 
      avg += scalar_product(xs[i], xs[j]);
  avg = avg / N*N;
  writefln(""result: %d"", avg);
  auto time = Clock.currTime() - tm_before;
  writefln(""scalar products: %i "", time);

  return 0;
}
</code></pre>
","87234","","<p>Seems like a quality of implementation issue. For example, here's what I've been testing with:</p>

<pre><code>import std.datetime, std.stdio, std.random;

version = ManualInline;

immutable N = 20000;
immutable Size = 10;

alias int value_type;
alias long result_type;
alias value_type[] vector_type;

result_type scalar_product(in vector_type x, in vector_type y)
in
{
    assert(x.length == y.length);
}
body
{
    result_type result = 0;

    foreach(i; 0 .. x.length)
        result += x[i] * y[i];

    return result;
}

void main()
{   
    auto startTime = Clock.currTime();

    // 1. allocate vectors
    vector_type[] vectors = new vector_type[N];
    foreach(ref vec; vectors)
        vec = new value_type[Size];

    auto time = Clock.currTime() - startTime;
    writefln(""allocation: %s "", time);
    startTime = Clock.currTime();

    // 2. randomize vectors
    foreach(ref vec; vectors)
        foreach(ref e; vec)
            e = uniform(-1000, 1000);

    time = Clock.currTime() - startTime;
    writefln(""random: %s "", time);
    startTime = Clock.currTime();

    // 3. compute all pairwise scalar products
    result_type avg = 0;

    foreach(vecA; vectors)
        foreach(vecB; vectors)
        {
            version(ManualInline)
            {
                result_type result = 0;

                foreach(i; 0 .. vecA.length)
                    result += vecA[i] * vecB[i];

                avg += result;
            }
            else
            {
                avg += scalar_product(vecA, vecB);
            }
        }

    avg = avg / (N * N);

    time = Clock.currTime() - startTime;
    writefln(""scalar products: %s "", time);
    writefln(""result: %s"", avg);
}
</code></pre>

<p>With <code>ManualInline</code> defined I get 28 seconds, but without I get 32. So the compiler isn't even inlining this simple function, which I think it's clear it should be.</p>

<p>(My command line is <code>dmd -O -noboundscheck -inline -release ...</code>.)</p>
"
"<p>Does anyone know why template arguments are needed for return-types but not for argument-types when defining template-methods?  An example:</p>

<pre><code>template&lt;typename T&gt;
struct Car {
  Car drive(Car);  // will be defined after the template declaration.
};

// Attempt #1: does not compile.
// Error: use of class template Car requires template arguments
template&lt;typename T&gt;
inline Car Car&lt;T&gt;::drive(Car) {}

// Attempt #2: compiles!  
// The only difference is the use of template argument in return type.
// However, note that the argument to func does not require template argument!
template&lt;typename T&gt;
inline Car&lt;T&gt; Car&lt;T&gt;::drive(Car) {}
</code></pre>

<p>Not sure why the template argument is needed for the return-type but not required for the argument-type.  When Attempt #1 failed, I was expecting Attempt #2 to fail too and expected I would need:</p>

<pre><code>template&lt;typename T&gt;
inline Car&lt;T&gt; Car&lt;T&gt;::drive(Car&lt;T&gt;) {}  // but no need to go this far.
</code></pre>

<p>but Attempt #2 worked!</p>

<p>Is there good reason for this behavior?</p>
","87234","","<p>First, you acknowledge this makes no sense: <code>Car c;</code>, right? <code>Car</code> must have template arguments. That's why you need to specify it on the return type, and on the class name.</p>

<p>But after the scope-resolution operator (<code>::</code>), <code>Car&lt;T&gt;</code> is <em>injected</em> as <code>Car</code>*, so <code>Car</code> is an alias to <code>Car&lt;T&gt;</code>. But this only happens inside the scope of <code>Car&lt;T&gt;</code>, which is why you need it everywhere else but not after <code>::</code>. Of course, you are free to explicitly specify the arguments yourself anyway.</p>

<hr>

<p>*This feature is better explained like this:</p>

<pre><code>template &lt;typename T&gt;
struct foo
{
    // as if the compiler did this:
    typedef foo&lt;T&gt; foo; // (of course, actually illegal)
};
</code></pre>

<p><code>foo</code> is available within the scope of <code>foo&lt;T&gt;</code> as <code>foo&lt;T&gt;</code>. After the scope-resolution operator, though, that scope is available for use, and the template arguments are optional.</p>
"
"<p>I don't know why the destruction of an object in vector is called at the following point of time. </p>

<pre><code>class Something
{
public:
    Something() {}
    ~Something()    { cout &lt;&lt; ""destruction called"" &lt;&lt; endl; }
};

int main()
{
    std::vector&lt;Something&gt; vec;
    Something sth1 = Something();   
    Something sth2 = Something();
    vec.push_back(sth1);
    vec.push_back(sth2);
    vec.clear();
}
</code></pre>

<p>After I push sth2, destruction for sth1 is called. Why? Shouldn't sth1 be kept in vec[0]?</p>
","87234","","<p>Because the <code>vector</code> has to resize its capacity to be able to store two elements instead of one. It allocates a new buffer, it copies the old buffer to the new one, <em>removes the old buffer</em>, and then adds the new object.</p>
"
"<p>I'm incrementing/decrementing boost::detail::atomic_count in multiple threads.<br>
Wonder if this practice is ok or if I need a lock around it(then I could just use regular int variable)?</p>

<p>Thank you.</p>
","87234","","<p>The entire purpose of an atomic variable is to be lock-free* and thread-safe.</p>

<p>So yes, it's perfectly safe; no, you don't need a lock.</p>

<hr>

<p>*That is, the ""lock"" is done at hardware level. Are you using something without understanding it first? :)</p>
"
"<pre><code>float minTime[7]={FLT_MAX};
    for(int i=0;i&lt;7;i++)
        cout &lt;&lt; ""Min: "" &lt;&lt; minTime[i] &lt;&lt; endl;
</code></pre>

<p>Why do I get in the following output :</p>

<pre><code>Min: 3.40282e+038
Min: 0
Min: 0
Min: 0
...
</code></pre>

<p>Shoudln't all have the same value as the first one? As it is refered here:
<a href=""http://www.fredosaurus.com/notes-cpp/arrayptr/array-initialization.html"" rel=""nofollow"">C++ Notes</a></p>
","87234","","<p>Your linked page says ""...the unspecified elements are set to zero.""</p>

<p>This is correct; as such, only the first element in your array was specified to be <code>FLT_MAX</code>, the rest are initialized to zero. If you want to set them all to the same value you can use a for-loop, or more succinctly:</p>

<pre><code>std::fill_n(minTime, 7, FLT_MAX);
</code></pre>

<hr>

<p>As a warning, C++ is a hard language. This means lots of people have lots of misinformation, and this is especially easy to find on the internet. You'd be better off learning from a <a href=""http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">book on our list</a>. (And yes, the ones <em>not</em> on our list are so because they too contain misinformation!)</p>
"
"<p>I'm working with a legacy C library interface (to C++) that exposes opaque pointers as </p>

<pre><code>typedef void * OpaqueObject
</code></pre>

<p>In the library:</p>

<pre><code>OpaqueObject CreateObject()
{
   return new OurCppLibrary::Object();
}
</code></pre>

<p>This of course provides absolutely no type safety for clients of this library. Should changing the typedef from a void pointer to structure pointer work exactly the same, but provide a small amount type safety?</p>

<pre><code>typedef struct OpaqueObjectInternal_ *OpaqueObject 
// OpaqueObjectInternal_ is NEVER defined anywhere in client or library code
</code></pre>

<p>Are there any alignment issues or other gotchas that I have to worry about now that I am explicitly pointing to a structure, even though I'm really not pointing to one?</p>
","87234","","<p>There are no gotcha's; that form is preferred exactly because of type safety.</p>

<p>No, alignment is not an issue here. The pointer itself has a known alignment, and the alignment of the object it will point at is only of concern to the library implementation, not the user.</p>
"
"<p>I have a little trouble in understanding a wrapper class. It would be great if some one could help providing apt examples.</p>

<ol>
<li>What is a C++ Wrapper Class and what are the circumstances of writing it ?</li>
<li>What is it's use any way ? </li>
</ol>

<p>Thanks.</p>
","87234","","<p>A ""wrapper class"" is a de facto term meaning a class that ""wraps around"" a resource; i.e, that manages the resource. When people write a wrapper, then, they are doing something like this:</p>

<pre><code>class int_ptr_wrapper
{
public:
    int_ptr_wrapper(int value = 0) :
    mInt(new int(value))
    {}

    // note! needs copy-constructor and copy-assignment operator!

    ~int_ptr_wrapper()
    {
        delete mInt;
    }

private:
    int* mInt;
};
</code></pre>

<p>This class manages (""wraps"") a pointer to an <code>int</code>. All resources should be wrapped in some fashion, for cleanliness (no explicit clean up code or noise) and correctness (destructor is guaranteed to run; cannot forget to clean up, and safe with exceptions).</p>

<p>This pattern is called Scoped-bound Resource Management (SBRM), though a far more common (but most esoteric) name is Resource-Acquisition is Initialization (RAII). The idea is to bind a resource's clean-up to a destructor, for the reasons given above: the scope handles the rest.</p>

<p>Note that I said it was missing a copy-constructor and copy-assignment operator. This is due to the <a href=""http://stackoverflow.com/questions/4172722/what-is-the-rule-of-three"">Rule of Three</a>. (See linked question for detailed explanation.) The simplest way to correctly implement this rule is with the copy-and-swap idiom, explained <a href=""http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom"">here</a>.</p>

<hr>

<p>Sometimes, it's not pragmatic to write wrapper class for resource clean-up, usually when the resource is unique or used once. (Or with transactional programming.) The solution to this is called <em>scope guard</em>, a way of writing clean-up code inside the function that needs it.</p>

<p>You may find more information by searching for it in your favorite search provider (that is, Google), or going to the ""primary"" document <a href=""http://drdobbs.com/184403758"">here</a>. Note that Boost provides <a href=""http://www.boost.org/doc/libs/1_46_0/libs/scope_exit/doc/html/index.html"">a utility</a> for this, as it usually does for good idioms.</p>
"
"<p>If my std::vector has 100 elements, and I only want to keep the first 10 and erase the rest, is there a convenient way to do this?
Thanks</p>
","87234","","<pre><code>vec.resize(10); // drops the rest (capacity remains the same)
</code></pre>
"
"<p>Quick question. If I have an array and have properly overloaded the assignment operator, then when I do something like this:</p>

<pre><code>A = B 
</code></pre>

<p>When A and B are both objects of type array, am I calling the copy constructor, or just the overloaded assignment operator(=)? </p>

<p>I know that a copy constructor is called when </p>

<ol>
<li>Pass By value</li>
<li>return a value of class type</li>
<li>when an object is being declared and initialized by another object of the same type given in parenthesis.</li>
</ol>

<p>3 above makes me confused and thinking that A = B is also calling the copy constructor.</p>

<p>Is it just calling the overloaded assignment operator?</p>

<p>Thanks!</p>
","87234","","<p>None of the above: you cannot assign arrays.</p>

<hr>

<p>If you have your own array class, and it has something like this:</p>

<pre><code>struct arr
{
    arr&amp; operator=(const arr&amp; other)
    {
        // ...
    }
};

arr a, b;
</code></pre>

<p>Then these are equivalent:</p>

<pre><code>a = b;
a.operator=(b);
</code></pre>

<p>It's just like calling a function.</p>
"
"<p>If i have</p>

<pre><code>void f(vector&lt;object&gt; *vo) {

}
</code></pre>

<p>And i pass the address of a vector to f</p>

<pre><code>vector&lt;object&gt; vo;
f(&amp;vo);
</code></pre>

<p>How would i use push_back() to add to the vector? (I'm new to pointers)</p>
","87234","","<p>Dereference the pointer:</p>

<pre><code>(*vo).push_back(object());
vo-&gt;push_back(object()); // short-hand
</code></pre>

<p>Note this is a basic concept of the language, you may benefit from reading a <a href=""http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">good book</a>.</p>

<hr>

<p>Note this has a glaring shortcoming:</p>

<pre><code>f(0); // oops, dereferenced null; undefined behavior (crash)
</code></pre>

<p>To make your function safe, you need to correctly handle all valid pointer values (yes, null is a valid value). Either add a check of some kind:</p>

<pre><code>if (!vo) return;
// or:
if (!vo) throw std::invalid_argument(""cannot be null, plz"");
</code></pre>

<p>Or make your function inherently correct by using a reference:</p>

<pre><code>void f(vector&lt;object&gt;&amp; vo) // *must* reference a valid object, null is no option
{
    vo.push_back(object()); // no need to dereference, no pointers; a reference
}
</code></pre>

<p>Now the onus is on the caller of the function to provide you with a valid reference.</p>
"
"<p>I have in my class definition the following enum:</p>

<pre><code>static class Myclass {
     ...
  public:    
     enum encoding { BINARY, ASCII, ALNUM, NUM };
     Myclass(Myclass::encoding);
     ...
}
</code></pre>

<p>Then in the method definition:</p>

<pre><code>Myclass::Myclass(Myclass::encoding enc) {
    ...
}
</code></pre>

<p>This doesn't work, but what am I doing wrong? How do I pass an enum member correctly, that is defined inside a class for member methods (and other methods as well)?</p>
","87234","","<p>This code is fine:</p>

<pre><code>/* static */ class Myclass
{
  public:    
     enum encoding { BINARY, ASCII, ALNUM, NUM };
     Myclass(Myclass::encoding); // or: MyClass( encoding );
     encoding getEncoding() const;
}; // semicolon

Myclass::Myclass(Myclass::encoding enc)
{    // or:     (enum Myclass::encoding enc), they're the same
     // or:     (encoding enc), with or without the enum
}

enum Myclass::encoding Myclass::getEncoding() const
//or Myclass::encoding, but Myclass:: is required
{
}

int main()
{
    Myclass c(Myclass::BINARY);
    Myclass::encoding e = c.getEncoding();
}
</code></pre>

<p>Update your question with the real code and errors you're getting so we can solve real problems instead of fake ones. (Give us a * compilable* example that reproduces your problem.)</p>
"
"<p>what's the right way to export template function from c++ into python using boost.python? Here is the code:</p>

<pre><code>template&lt;typename T&gt;
T getValue(const std::string &amp;key, const T &amp;defaultValue = T()) {}

// Export into some python class:
class_&lt;ConfigManager&gt;(...)
.def(""GetValue"", getValue&lt;int&gt;)
.def(""GetValue"", getValue&lt;float&gt;)
.def(""GetValue"", getValue&lt;std::string&gt;);
</code></pre>

<p>And usage:</p>

<pre><code>    print GetValue(""width"")
Boost.Python.ArgumentError: Python argument types in
    GetValue(ConfigManager, str)
did not match C++ signature:
    GetValue(ConfigManager {lvalue}, std::string, int)
</code></pre>

<p>What's wrong?</p>
","87234","","<p>You should read the relevant <a href=""http://www.boost.org/doc/libs/1_46_1/libs/python/doc/tutorial/doc/html/python/functions.html#python.default_arguments"" rel=""nofollow"">Boost documentation</a> regarding default arguments. I'll summarize below.</p>

<hr>

<p>The problem here is that default arguments are used when calling functions <em>in C++</em>. Get rid of them and you'll see the problem from Python's perspective:</p>

<pre><code>// this function *must* be called with two parameters
template&lt;typename T&gt;
T getValue(const std::string &amp;key, const T &amp;defaultValue) {}

class_&lt;ConfigManager&gt;(...)
.def(""GetValue"", getValue&lt;int&gt;) // two arguments!
.def(""GetValue"", getValue&lt;float&gt;) // Python has no idea about the defaults,
.def(""GetValue"", getValue&lt;std::string&gt;); // they are a C++ feature for calling
</code></pre>

<p>The fundamental issue is that function types don't carry default argument information. So how can we simulate it? Essentially, by overloading:</p>

<pre><code>template&lt;typename T&gt;
T getValue(const std::string &amp;key, const T &amp;defaultValue) {}

template&lt;typename T&gt;
T getValueDefault(const std::string &amp;key)
{
    // default available in C++,
    // transitively available in Python
    return getValue(key);
}

class_&lt;ConfigManager&gt;(...)
.def(""GetValue"", getValue&lt;int&gt;) // two arguments
.def(""GetValue"", getValueDefault&lt;int&gt;) // one argument
// and so on
</code></pre>

<p>A maintenance hassle. Luckily, Boost makes this easy:</p>

<pre><code>template&lt;typename T&gt;
T getValue(const std::string &amp;key, const T &amp;defaultValue) {}

// creates utility class x, which creates overloads of function y,
// with argument count as low as a and as high as b:
// BOOST_PYTHON_FUNCTION_OVERLOADS(x, y, a, b);

BOOST_PYTHON_FUNCTION_OVERLOADS(getValueIntOverloads, getValue&lt;int&gt;, 1, 2);

class_&lt;ConfigManager&gt;(...)
.def(""GetValue"", getValue&lt;int&gt;, getValueIntOverloads()) // one or two arguments

// and so on
</code></pre>

<p>The macro also exists for class members. This is in the documentation, if any of it is unclear.</p>
"
"<p>how to check if wstring is null or empty?</p>

<p>Thanks,</p>

<p>SYD</p>
","87234","","<p><code>wstring</code> is not a pointer, it cannot be null. You can check if it's empty (that is, is equivalent to <code>""""</code>) either by direct comparison to the previous, or by:</p>

<pre><code>str.empty(); // == (str.size() == 0)
</code></pre>
"
"<p>I have a function that will pass a string and manipulate. in the function call i am passing the string as such like <code>myfunc (""hello"");</code></p>

<p>In the function definition i have </p>

<pre><code>myfunc (char *array)
{
    xxxx
};
</code></pre>

<p>The program is working fine, but it throws a warning ""pointer targets in passing argument 1 of 'myfunc' differ in signedness"".</p>

<p>How to rectify this problem?</p>
","87234","","<p>Strings are actually arrays of <em>constant</em> characters. That is, the type of <code>""hello""</code> is <code>const char[6]</code>.</p>

<p>What this means is you cannot modify it. However, due to a silly conversion in C++, the array (in string literal form) can be implicitly converted to a <em>non-const</em> pointer to the first element. This is misleading, and dangerous. (Indeed, a const-stripping implicit conversion  doesn't exist anywhere else.)</p>

<p>You should make sure you have a modifiable buffer instead:</p>

<pre><code>char buffer[] = ""hello"";
myfunc(buffer);
</code></pre>
"
"<p>I expected the following code to work, but I received a compile error:</p>

<blockquote>
<pre><code>error C2975: 'n' : invalid template argument for 'foo', expected compile-time constant expression
</code></pre>
</blockquote>

<pre><code>#include &lt;iostream&gt;
using namespace std;

template&lt;int N&gt;
struct foo
{
    foo() { cout &lt;&lt; N &lt;&lt; endl; }
};

int main()
{
    foo&lt; __LINE__ &gt; f;
}
</code></pre>

<p>Why does this happen?  I though <code>__LINE__</code> would paste in the line number before template instantiation occurred?</p>

<p>If I wanted to do this should I just introduce a <code>static const int</code> to hold the line number or is there a standard solution?</p>
","87234","","<p>For what it's worth, this is suppose to be valid code. <code>__LINE__</code> is suppose to behave as if it were:</p>

<pre><code>#define __LINE__ 0
</code></pre>

<p>Of course, replacing 0 with the current line number.</p>
"
"<p>As question states, is there a reason why people use the struct version over the normal conditionals?</p>
","87234","","<p>An excerpt from the <a href=""http://www.boost.org/development/int_const_guidelines.html"">Boost Coding Guidelines for Integral Constant Expressions</a>:</p>

<blockquote>
  <p><strong>Don't use logical operators in integral constant expressions; use template meta-programming instead.</strong>  </p>
  
  <p>The header  contains a number of workaround templates, that fulfil the role of logical operators, for example instead of:  </p>
  
  <blockquote>
    <p><code>INTEGRAL_CONSTANT1 || INTEGRAL_CONSTANT2</code></p>
  </blockquote>
  
  <p>Use:  </p>
  
  <blockquote>
    <p><code>::boost::type_traits::ice_or&lt;INTEGRAL_CONSTANT1,INTEGRAL_CONSTANT2&gt;::value</code></p>
  </blockquote>
  
  <p>Rationale: A number of compilers (particularly the Borland and Microsoft compilers), tend to not to recognise integral constant expressions involving logical operators as genuine integral constant expressions. The problem generally only shows up when the integral constant expression is nested deep inside template code, and is hard to reproduce and diagnose.</p>
</blockquote>

<p>So I'd say never on a compliant compiler. (But if you need to support non-compliant compilers, use it.)</p>
"
"<p>I came across this code snippet <sup>1</sup> </p>

<pre><code>int return_printChar1()
{
    // code
    // oops! no return statement
}
int return_printChar2()
{
    // code
    return printf(""Return"");
}
int main()
{  
   int i;
   // some more code
   i = return_printChar2();
   if((return_printChar1(),i))
   {
      printf (""Gotcha"");
   }
}
</code></pre>

<p><sub>1: This is not a real life example.</sub></p>

<p>My question is ""<strong>Is the behaviour of the code snippet well defined in C and C++?</strong>""</p>

<p>My take :</p>

<p>In C the behaviour is well defined because <code>6.5.17</code> says</p>

<blockquote>
  <p>The  left  operand  of  a  comma  operator  is  evaluated  as  a  <strong>void  expression</strong>;  there  is  a sequence point after its evaluation</p>
</blockquote>

<p>In C++03 the behaviour is well defined because <code>5.18</code> says</p>

<blockquote>
  <p>A pair of expressions separated by a comma is evaluated left-to-right and the value of the left expression is <strong>discarded</strong>.</p>
</blockquote>

<p>However C++03 (in section <code>6.6.3</code>) also says that</p>

<blockquote>
  <p>Flowing off the end of a function is equivalent to a returnwith no value; this results in undefined behavior in a value-returning function.</p>
</blockquote>

<p>Similarly in C </p>

<blockquote>
  <p>If control reaches end (<code>}</code>) of non-void function (except <code>main()</code>) the behaviour is undefined.</p>
</blockquote>

<p>So taking all these points into consideration I can't judge the actual behaviour. What do you people think?</p>

<p><sub>P.S : If you think the question is useless and you have got better things to do, help yourself :D. </sub></p>
","87234","","<p>It's undefined behavior.</p>

<p>The evaluation of the left expression results in flowing off the end of a value-returning function with no return. Just because the value is discarded doesn't mean the evaluation never happened.</p>
"
"<p>Is there a way to change what THIS point to?</p>

<pre><code>class foo{...}

foo* fooinstance = new foo();
foo* otherfooinstance = new foo();

void
foo::bar(){
    this = otherfooinstance;
}

fooinstance-&gt;bar();
</code></pre>

<p>for those of you who are wondering in what case I would change the this pointer here is case. I had to do a tree recursion where I had to remove intermediate nodes.. for this example lets assume the intermediate nodes of removal have the title d. and these intermediate nodes only have one child. So in lisp notation if we have a tree like</p>

<p>(g (d (i 4)) (i 5)) </p>

<p>the function removeIntermediates(tree) would in effect cause the above to become</p>

<p>(g (i 4) (i 5))</p>

<p>and the pseudo code for this IF the this pointer was reassignable would look like the following..</p>

<pre><code>DTREE::removeIntermediates(){
    this = child(0); removeIntermediates();
}

TREE::removeIntermediates(){
    for each child { child-&gt;removeIntermediates();
}
</code></pre>

<p>I wanted to do this without knowing what the child node was therefore making code factorable into different functions for each node type and having a general function for other types. 
Sadly, I just ended up doing something like this..</p>

<pre><code>TREE::removeIntermediates(){
    for each child { if(child-&gt;name == ""d"") {
        setchild(child-&gt;child(0));
        child-&gt;removeIntermediates();
    }
    else { child-&gt;removeIntermediates();}
}
</code></pre>
","87234","","<p>No, <code>this</code> is not modifiable.</p>

<p>Conceptually that doesn't make sense, <a href=""http://www.catb.org/esr/faqs/smart-questions.html"">what are you trying to accomplish</a>?</p>
"
"<p>To my surprise the following code compiles:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

int main() {
   std::string s=""nawaz"";
   std::string S;
   std::transform(s.begin(),s.end(), std::back_inserter(S), ::toupper);
   std::cout &lt;&lt; S ;
}
</code></pre>

<p>I had expected it to fail because of the <code>::toupper</code> which I believed should be in the <code>std</code> namespace. A quick check of cctype shows that it is but it is imported from the root namesapce (Mystery solved there).</p>

<pre><code>namespace std
{
  // Other similar `using` deleted for brevity.
  using ::toupper;
}
</code></pre>

<p>So first problem solved but if I change the <code>transform()</code> line above too:</p>

<pre><code>std::transform(s.begin(),s.end(), std::back_inserter(S), std::toupper);
</code></pre>

<p>I would now expect this to now also compile. But I get a compiler error:</p>

<blockquote>
  <p>kk.cpp:12: error: no matching function for call to `transform(__gnu_cxx::__normal_iterator&lt;char*, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;char*, std::basic_string&lt;char, std::cha
  r_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;, std::back_insert_iterator&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;, &lt;<strong><em>unresolved overloaded function type</em></strong>&gt;)'</p>
</blockquote>

<p>Which with manual editing resolved too:</p>

<pre><code>kk.cpp:12: error: no matching function for call to
         `transform(iterator&lt;std::string&gt;,
                    iterator&lt;std::string&gt;,
                    std::back_insert_iterator&lt;std::string&gt;,
                    &lt;unresolved overloaded function type&gt;)'
</code></pre>

<p>What am I missing?</p>
","87234","","<p>It doesn't work because there are overloads of <code>std::toupper</code>. You can fix it by casting to your desired function overload:</p>

<pre><code>std::transform(s.begin(),s.end(), std::back_inserter(S),
                (int(&amp;)(int))std::toupper);
</code></pre>
"
"<p>I am getting an error saying that I can't access private members x and y. How do I write the methods getX() and getY() so that they could see x and y? Thanks.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Point {
public:
    Point(int x, int y);
    Point();
    int getX();
    int getY();

private:
    int x, y;
};


int Point::getX() {
    return x;
}

int Point::getY() {
    return y;
}

void main () {

    Point p(5,5);
    Point g;

    cout &lt;&lt; p.x &lt;&lt; endl;
    cout &lt;&lt; g.y;
    string s;
    cin &gt;&gt; s;

}
</code></pre>
","87234","","<p>Um, you already <em>have</em> written <code>getX</code> and <code>getY</code>, you just need to use them:</p>

<pre><code>cout &lt;&lt; p.getX() &lt;&lt; endl;
cout &lt;&lt; g.getY();
</code></pre>

<hr>

<p>Note that, because <code>getX()</code> and <code>getY()</code> don't modify your class, they should be <code>const</code>:</p>

<pre><code>class Point {
public:
    // ...

    int getX() const;
    int getY() const;

    // ...
};

// ...

int Point::getX() const {
    return x;
}

int Point::getY() const {
    return y;
}

// ...
</code></pre>
"
"<p>I have some hierarchy: base, derived classes and some structure storing user data as void*. That void can store both Base and Derived classes pointers. Main problem that I do not know what is stored there base or derived pointer.</p>

<p><pre><code>
class Base
{
public:
  int type;
};
class Derived: public Base
{};</p>

<p>Base* base;//init base pointer
Derived* derived;//init derived pointer
void* base_v = base;
void* derived_v = derived;
//void pointers are correct. They point to base and derived variables.</p>

<p>//try to get type field after converting pointers back
Derived* d_restored = (Derived*)derived_v;//d_restored correct
Base* b_restored = (Base*)base_v;//b_restored correct
Base* d_restored_to_base = (Base*)derived_v;// INCORRECT
</pre></code></p>

<p>How to convert void* to get [type] field for both pointers?
Thanks in advance.</p>
","87234","","<p><code>void*</code>'s can only be converted back to their original type. When you store a <code>Derived*</code> in a <code>void*</code>, you can only cast back to <code>Derived*</code>, <strong>not</strong> <code>Base*</code>.</p>

<p>This is especially noticeable with multiple inheritance, as your derived object might not necessarily be at the same address as your base. If you really need to store things (and retrieve things) with <code>void*</code>, <em>always</em> cast to the base type first, so you have a stable way of getting the object back:</p>

<pre><code>#include &lt;iostream&gt;

struct base { int type; };
struct intruder { int iminyourclassstealingyourbase; };
struct derived : intruder, base {};

int main()
{
    derived d; d.type = 5;

    void* good = (base*)&amp;d;
    void* bad = &amp;d;

    base* b1 = (base*)good;
    base* b2 = (base*)bad;

    std::cout &lt;&lt; ""good: "" &lt;&lt; b1-&gt;type &lt;&lt; ""\n"";
    std::cout &lt;&lt; ""bad: "" &lt;&lt; b2-&gt;type &lt;&lt; ""\n"";
}
</code></pre>

<p>If you then want to go back to the derived type, use a <code>dynamic_cast</code> (or <code>static_cast</code> if you're guaranteed it has to be of the derived type.)</p>
"
"<p>Is this correct?:</p>

<pre><code>std::vector&lt;Enemy*&gt; enemies;
enemies.push_back(new Enemy());

Enemy* enemy = enemies[0];
enemies.erase(enemies.begin() + 0);
delete enemy;
</code></pre>
","87234","","<p>It works, yes, but it's not an ideal approach.</p>

<p>Firstly, adding 0 is just noise, you can remove that. But even better, just use <code>pop_front()</code>. Also, no need for the intermediate step, you can delete before removing.</p>

<p>But <code>std::vector</code> isn't good as popping from the front, especially if it's large (because the remaining elements need to be shifted to fill the void). If you don't need contiguous memory, use a <code>std::deque</code> instead. Or, if order doesn't matter, you can use something like this:</p>

<pre><code>template &lt;typename T, typename A&gt;
void unordered_pop_front(std::vector&lt;T, A&gt;&amp; vec)
{
    using std::swap;
    swap(vec.front(), vec.back()); // constant time

    vec.pop_back(); // constant time
}
</code></pre>

<p>It swaps the front element with the back element, then pops it off. Of course, order is not retained.</p>

<p>The other problem is with your approach to memory management. Anytime you have explicit clean up code, you've done something wrong. It should be <a href=""http://stackoverflow.com/questions/712639/please-help-us-non-c-developers-understand-what-raii-is"">done automatically</a>.</p>

<p>Use either <a href=""http://www.boost.org/doc/libs/1_46_1/libs/ptr_container/doc/ptr_vector.html"">Boost's <code>ptr_vector</code></a>, or a <code>std::vector</code> of <a href=""http://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby"">smart pointers</a>. (Note: do not use <code>std::auto_ptr</code> in a container, it's broken in this regard.) For a quick smart pointer suggestion, use either <code>std::unique_ptr</code> (if your compiler supports C++0x), or <code>std::/boost::shared_ptr</code>.</p>
"
"<p>I have converted C++ source from using GLUT to using SDL/OpenGL The problem is since I have changed from GLUT the 'camera's position is not getting updated, so rather than moving around using the keyboard, the screen just sits there renders what it needs and does not update.</p>

<p>The keyboard strokes are working as I have set it up so when ESC is pressed it exits and this is fine.</p>

<p>Here is my Display function this gets called every loop and also upon keypress(wasd):</p>

<pre><code>glClear(GL_COLOR_BUFFER_BIT);
glLoadIdentity();
Camera.Render();
glTranslatef(0.0,-0.5,-6.0);

....Draw some stuff....

SDL_GL_SwapBuffers();
</code></pre>

<p>next up the Camera.Render();</p>

<pre><code>SF3dVector ViewPoint = Position+ViewDir;
gluLookAt(Position.x,Position.y,Position.z,ViewPoint.x,ViewPoint.y,ViewPoint.z,UpVector.x,UpVector.y,UpVector.z);
</code></pre>

<p>Now what happens once a key is pressed(w which should move the camera forward):</p>

<pre><code>case SDLK_w:
    CCamera().MoveForward( -0.1 ) ;
    Display();
    break;
</code></pre>

<p>and finally CCamera().MoveForward() function:</p>

<pre><code>MoveForward(GLfloat Distance){
    Position = Position + (ViewDir*-Distance);
}
</code></pre>

<p>I cant for the life of me work out why once a key is pressed it doesnt update the position.
Any help would be greatly appreciated! Thanks.</p>
","87234","","<p><code>CCamera()</code> just creates a temporary camera. (Which you then move.) Then the temporary goes away.</p>

<p>Perhaps you meant to modify <code>Camera</code>?</p>
"
"<p>Are the following constructors allowed in the same <code>IntList</code> class?</p>

<pre><code>IntList(int length);
IntList(int data[]);
</code></pre>
","87234","","<p>That's fine, but note that latter is the same as <code>int* data</code>, which is a pointer and not an array.</p>

<p>Arrays are non-copyable and must be passed by reference:</p>

<pre><code>typedef int array_type[5];

IntList(const array_type&amp; arr); // same as: IntList(const int (&amp;arr)[5]);
</code></pre>

<p>You can also take an array of any size using templates:</p>

<pre><code>template &lt;std::size_t N&gt;
IntList(const int (&amp;arr)[N]); // N is the number of elements
</code></pre>

<p>But your approach is ultimately unorthodox. If you want to initialize with a range of data, use iterators:</p>

<pre><code>template &lt;typename InputIterator&gt;
IntList(InputIterator begin, InputIterator end);
</code></pre>

<p>Now you can iterate from <code>begin</code> to <code>end</code>, which can be iterators from any kind of container, like arrays, <code>std::vector</code>'s, <code>std::map</code>'s and more.</p>

<p>But you should be using <code>std::vector&lt;int&gt;</code> instead of <code>IntList</code> anyway.</p>
"
"<p>I have the following two classes that exhibit the Command pattern.  (Unfortunately, both have a unique method name.)</p>

<pre><code>//pseudocode 
class Subscriber {
    virtual void receive(const Event&amp;) = 0;
}

class Dispatcher {
    virtual void dispatch(const Event&amp;) = 0;
}
</code></pre>

<p>I have a class template that has a list of some type with a method to iterate over this list.</p>

<pre><code>//pseudocode
template&lt;typename T&gt;
class Registry {
    typedef list&lt;T&gt; ObjectList;
    ObjectList _objects;
    void iterate(const Event&amp; event) {
        for_each(_objects.begin(), _objects.end(), ...);  //not sure what to do here
    }
}
</code></pre>

<p>I would like to use <code>mem_fun</code> to create a Functor that calls <code>receive</code> or <code>dispatch</code> as appropriate.  I'm able to create a simple use case where I simply invoke a method without any params.  I.e.</p>

<pre><code>//pseudocode
class Simple {
    void simple() {/*...*/}
}
</code></pre>

<p>and then I iterate:</p>

<pre><code>for_each(_objects.begin(), _objects.end(), mem_fun(&amp;Simple::simple);
</code></pre>

<p>Unfortunately, I have no idea how to get the <code>event</code> param passed to mem_fun.  Looking at the headers, it does appear that I can pass a single param, but I'm not well versed in C++ to understand what I need to do.</p>

<p>Ultimately, I would like to make the <code>iterate</code> method accept a type of functor so it will fire that method on every method in the list.</p>

<p>I would prefer to avoid Boost...I think this is entirely possible without dragging this framework into the mix.</p>

<p>Thanks!</p>
","87234","","<p>This may be the most straight-forward way:</p>

<pre><code>class event_forwarder // make private in Registry
{
public:
    event_forwarder(const Event&amp; event) :
    mEvent(event)
    {}

    void operator()(Subscriber&amp; subcriber) const
    {
        subscriber.receive(mEvent);
    }

    void operator()(Dispatcher&amp; dispatcher) const
    {
        dispatcher.dispatch(mEvent);
    }

private:
    const Event&amp; mEvent;
};
</code></pre>

<p>Then:</p>

<pre><code>for_each(_objects.begin(), _objects.end(), event_forwarder(event));
</code></pre>
"
"<p>in this code, compiler complain about <strong>undefined</strong> <code>MyClassB</code>, which is understandable :</p>

<pre><code>class MyClassA;
class MyClassB;

template &lt;class T&gt; class BaseClass : public T {
};

class MyClassA : public BaseClass&lt;MyClassB&gt; {
};

class MyClassB : public BaseClass&lt;MyClassA&gt; {
};
</code></pre>

<p>but in this code, compile is <strong>successful and no complain</strong> about <code>MyClassB</code> :</p>

<pre><code>class MyClassA;
class MyClassB;

template &lt;class T&gt; class BaseClass : public T {
};

class MyClassA : public BaseClass&lt;std::vector&lt;MyClassB&gt;&gt; {
};

class MyClassB : public BaseClass&lt;std::vector&lt;MyClassA&gt;&gt; {
};
</code></pre>

<p>why the second code compile, since <code>MyClassB</code> is not yet defined when constructing <code>std::vector&lt;MyClassB&gt;</code>?</p>
","87234","","<p>Because your implementation of <code>std::vector</code> allows an incomplete type. This is a side effect of the instantiation rules of member functions of class templates: they aren't instantiated until they're used. So the functions that <em>do</em> need it to be a complete type aren't instantiated, yet. So no errors.</p>

<p>Contrarily, it does need to be a complete type to be a base class, so you get an error in that case.</p>

<hr>

<p>However, it's actually undefined behavior to pass an incomplete type to <code>std::vector</code> (or any other standard library container), and ""it works"" is a valid undefined outcome. You shouldn't do it.</p>
"
"<p>Given the following code,</p>

<pre><code>class A
{
public:
  A() : str(0) {}
private:
  string str;
};
</code></pre>

<p>Based on this <a href=""http://www.cplusplus.com/reference/string/string/string/"" rel=""nofollow"">http://www.cplusplus.com/reference/string/string/string/</a></p>

<pre><code>string ( );
string ( const string&amp; str );
string ( const string&amp; str, size_t pos, size_t n = npos );
string ( const char * s, size_t n );
string ( const char * s );
string ( size_t n, char c );
template&lt;class InputIterator&gt; string (InputIterator begin, InputIterator end);
</code></pre>

<p>I don't see which constructor of string is called when we use the 'str(0)'.</p>

<p>Question> Can someone tell me which string constructor is used for 'str(0)'?</p>
","87234","","<p>This one:</p>

<pre><code>string ( const char * s );
</code></pre>

<p>It's converted to a null pointer. (And also gives you undefined behavior, since <code>s</code> cannot be a null pointer.)</p>
"
"<p>I wanted to create an array:</p>

<pre><code>template &lt; typename T, typename ... A &gt; struct a {
  T x [1 + sizeof... (A)];
  a () = default;
  a (T &amp;&amp; t, A &amp;&amp; ... y) : x { t, y... } {}
};

int main () {
  a &lt; int, int &gt; p { 1, 1 }; // ok
  a &lt; a &lt; int, int &gt;, a &lt; int, int &gt; &gt; q { { 1, 1 }, { 3, 3 } }; // error: bad array initializer
}
</code></pre>

<p>Why doesn't it compile? (tested with g++ 4.6)</p>
","87234","","<p>I'm pretty sure that's a bug. <code>{}</code> can be used in place of <code>()</code> for supplying the constructor with arguments. Therefore your code should be ok:</p>

<pre><code>int main ()
{
    // this is fine, calls constructor with {1, 1}, {3, 3}
    a&lt;a&lt;int, int&gt;, a&lt;int, int&gt;&gt; q({ 1, 1 }, { 3, 3 });

    // which in turn needs to construct a T from {1, 1},
    // which is fine because that's the same as:
    a&lt;int, int&gt;{1, 1}; // same as: a&lt;int, int&gt;(1, 1);

    // and that's trivially okay (and tested in your code)

    // we do likewise with A..., which is the same as above
    // except with {3, 3}; and the values don't affect it
}
</code></pre>

<p>So the whole thing should be okay.</p>
"
"<p>I'm trying to create a set of function templates that can take different types and numbers of parameters, like this:</p>

<pre><code>template &lt;T0&gt;
void call(T0 arg0);

template &lt;T0, T1&gt;
void call(T0 arg0, T1 arg1);

template &lt;T0, T1, T2&gt;
void call(T0 arg0, T1 arg1, T2 arg2);

template &lt;T0, T1, T2, T3&gt;
void call(T0 arg0, T1 arg1, T2 arg2, T3 arg3);

template &lt;T0, T1, T2, T3, T4&gt;
void call(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);

[...]
</code></pre>

<p>The parameters are all treated the same within the functions (as arguments to a single-parameter template function). This is for a library, so extra effort on my part is acceptable, if it means less effort or a more pleasing interface for the library user.</p>

<p>I've had to do this several times for different projects, and I'm heartily tired of having to manually write all of them by hand. It gets worse when I don't know beforehand the maximum number of parameters the project using the library will need.</p>

<p>Before I start writing a Python script to generate all of the overloads, is there some metaprogramming way to have the compiler do it for me instead?</p>
","87234","","<p>Here's how I make variadic templates in my code, without C++0x support and with Boost (very abridged):</p>

<pre><code>// blah.hpp
// (include guards)

#ifndef BLAH_MAX_PARAMETERS
    // allow this to be changed to a higher number if needed,
    // ten is a good default number
    #define BLAH_MAX_PARAMETERS 10
#endif

#if BLAH_MAX_PARAMETERS &lt; 0
    // but don't be stupid with it
    #error ""Invalid BLAH_MAX_PARAMETERS value.""
#endif

// include premade functions, to avoid the costly iteration
#include ""detail/blah_premade.hpp""

// generate classes if needed
#if BLAH_MAX_PARAMETERS &gt; BLAH_PREMADE_PARAMETERS
    #define BOOST_PP_ITERATION_LIMITS (BOSST_PP_INC(BLAH_PREMADE_PARAMETERS), \
                                        BLAH_MAX_PARAMETERS)
    #define BOOST_PP_FILENAME_1 ""detail/blah.hpp""
    #include BOOST_PP_ITERATE()
#endif
</code></pre>

<p>That's the ""main"" include. As you can see, it just sets up the number of iterations desired, and makes sure that enough exist. I include a premade file because this iteration (especially when used multiple times) can really add to your compile time. I premake up to ten, so by default no iteration is done:</p>

<pre><code>// detail/blah_premade.hpp
// (include guards)

// a bunch of manually made (however you want to do that)
// pastes of what our iteration normally generates

// allow this file to change the assumed count
#define BLAH_PREMADE_PARAMETERS 10
</code></pre>

<p>Then we have our preprocessor template:</p>

<pre><code>// detail/blah.hpp
// no header guards

#define N BOOST_PP_ITERATION()

// use N to generate code

#undef
</code></pre>

<p>And that's it. I leave it to you to fill in the middle for whatever you want; perhaps check out <a href=""http://stackoverflow.com/questions/5475046/any-metaprogramming-way-to-generate-overloads-for-various-numbers-of-template-par/5475461#5475461"">Xeo's answer</a>.</p>
"
"<p>guys,
I want VC has the same strict compile rules as GCC when it compiles the c++ template code. But I don't know how to set this in my VC9.0 (Visual Studio 2008).</p>

<p>For example,
the following code is not allowed in GCC.</p>

<p><code>
AutoPtr&lt;RefCounted&lt;Shape&gt;&gt; shape;
</code></p>

<p>since ""&gt;&gt;"" is not allowed here, and gcc requests to add at least one space between ""&gt;&gt;"" .</p>

<p><code>
AutoPtr&lt;  RefCounted&lt;Shape&gt;   &gt; shape;
</code></p>

<p>VC will not treat this as a error. From my understanding, VC has a more loose restriction on template code compiling. </p>

<p>How do I add more restriction in VC to make it be a same rules as GCC?</p>
","87234","","<p>You don't. :( MSVC++ simply handles templates incorrectly, and you have to be careful.</p>

<hr>

<p>Note that your particular example isn't actually an error in <a href=""http://stackoverflow.com/tags/c%2b%2b0x/info"">C++0x</a>, so MSVC2010 would actually be right to accept it. (It's still wrong on lots of other things, though, but it's gotten a bit better.)</p>

<p>You might even ""cheat"" and enable C++0x for your gcc compile to allow it; just be sure not to accidentally use C++0x stuff MSVC2008 (or MSVC2010!) can't support.</p>
"
"<p>In my application, I create a <code>char*</code> like this:</p>

<pre><code>class sample
{
    public:
        char *thread;
};

sample::sample()
{
    thread = new char[10];
}

sample::~sample()
{
    delete []thread;
}
</code></pre>

<p>Am I doing the right thing in the code?</p>
","87234","","<p>It's ""right""*, but it's very wrong.</p>

<p>You should not use <code>new[]</code>, but instead use <code>std::vector&lt;char&gt;</code> or <code>std::string</code>. Even if you weren't doing that, you need to respect the <a href=""http://stackoverflow.com/questions/4172722/what-is-the-rule-of-three"">rule of three</a>, or your class is broken.</p>

<p>*Assuming you meant <code>new char[10]</code>. Also, more orthodox is <code>delete[] thread</code>.</p>
"
"<p>So I am wondering what happens if I have the following code</p>

<pre><code>int i;
cin&gt;&gt; i;
</code></pre>

<p>But I actually entered <code>""abc""</code> instead of an integer. It fails? What are the ways to make sure reading from commmand line does not fail? </p>
","87234","","<p>The fail bit of the stream will be set, and further operations will do nothing until the bit is cleared. You can read more about stream bits <a href=""http://stackoverflow.com/questions/4258887/semantics-of-flags-on-basic-ios"">here</a>.</p>

<p>If you don't want it to fail, simply check the bit:</p>

<pre><code>int i;
std::cin &gt;&gt; i;

if (!std::cin)
{
    // didn't read correctly, handle it
}
</code></pre>

<p>Or in one fell-swoop:</p>

<pre><code>int i;

if (!(std::cin &gt;&gt; i))
{
    // didn't read correctly, handle it
}
</code></pre>

<p>There may be more robust ways of gathering input, but what you want depends on your situation.</p>
"
"<p>I get this error while compiling:
 error: aggregate 'X x' has incomplete type and cannot be defined</p>

<p>I have three classes in 6 different files(header file + 3 implementation files). when I try to compile all these classes with a main, It gives me the above error. I am not including any header file in other header files, I am doing that in implementation files. So, I think its not a case of ""cross reference"". I am not sure what is the problem with my code can anyone help me in that?</p>

<p>Thanks</p>
","87234","","<p>Somehow, that class isn't being defined when it needs to be.</p>

<p>Firstly, make sure the header has actually been included. Further, make sure you have include guards, and that you don't have circular includes and recursive definitions. Aside from that, without the code we cannot give specifics.</p>
"
"<p>I'm sick of writing constructors manually. How can I automate this?</p>

<pre><code>struct MyFunctor {
public:
  MyFunctor(/* repeat what I wrote again!*/)
  :/* repeat what I wrote again! */
  { }

  bool operator()() { return true; }

private:
  Controller *m_controller;
  String m_action;
  bool m_allowRejection;
  /* ... */
};
</code></pre>
","87234","","<p>A macro like this could be of use, though it's arguably ugly:</p>

<pre><code>#include &lt;boost/preprocessor.hpp&gt;

#define AUTO_CONSTRUCTOR_DETAIL_PARAM(r, data, member) \
        BOOST_TYPEOF(member) member

#define AUTO_CONSTRUCTOR_DETAIL_INIT(r, data, member) \
        member(member)

#define AUTO_CONSTRUCTOR_DETAIL(className, mems) \
        className(BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM( \
                    AUTO_CONSTRUCTOR_DETAIL_PARAM, BOOST_PP_EMPTY, members))) : \
        BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM( \
            AUTO_CONSTRUCTOR_DETAIL_INIT, BOOST_PP_EMPTY, member)) \
        {}  

#define AUTO_CONSTRUCTOR(className, members) \
        AUTO_CONSTRUCTOR_DETAIL(className, members)
</code></pre>

<p>Use as:</p>

<pre><code>struct MyFunctor {
public:
  AUTO_CONSTRUCTOR(MyFunctor, (m_controller)(m_action)(m_allowRejection)) 

  bool operator()() { return true; }

private:
  Controller *m_controller;
  String m_action;
  bool m_allowRejection;
  /* ... */
};
</code></pre>

<p>Untested, of course.</p>
"
"<p>Could anyone tell me why there is a compile error with the following code? </p>

<pre><code>struct Foo {
  char m_p[8];
  inline operator char *() const { return m_p; }
};
</code></pre>

<p>With GCC 4.5 I am given the message:</p>

<blockquote>
  <p>error: invalid conversion from 'const
  char*' to 'char*'</p>
</blockquote>

<p>while the Digital Mars compiler has no problem with it.</p>

<p>Edit: The answers listed below mention the const qualifier on the function. What I really don't get then is why the following code has no such problem:</p>

<pre><code>struct Foo2 {
  char *m_p;
  inline operator char *() const { return m_p; }
};
</code></pre>
","87234","","<p>Because within the function (being const-qualified) the type of your array is <code>const char[8]</code>, and that can't be converted to <code>char*</code>, only <code>const char*</code>.</p>

<p>Either ditch the const-qualification on the function, or add it to the return type. Also, <code>inline</code> is redundan here, because members defined within the class definition are implicitly <code>inline</code> anyway.</p>
"
"<p>I was going through some code at work and I found this</p>

<pre><code>inline
  FLAGS get_flags(void) {
  FLAGS res;
  memset(&amp;res, 0, sizeof(res));
  return res
}
</code></pre>

<p>This is declared in a header file included in the program.  I realize it would be a very bad thing if it was not inlined as this is allocated on the stack.  We have never had problems with the code in question, but I was just curious about it.  </p>
","87234","","<p><code>inline</code> has two purposes, but only one matters anymore.</p>

<p>As others have said, the purpose of hinting to the compiler that the function should be inlined is all but useless. The compiler is much better at determining what should be inlined than the programmer.</p>

<p>However, the important second use (which <em>applies</em> in your case) is that it breaks the one-definition rule (ODR). That is, under normal circumstances the linker must not accept seeing a symbol defined more than once. However, if that symbol was declared <code>inline</code>, it is free to assume the definition of each is the same and ignore the rest.</p>

<p>Because your function is in a header file, it might get defined in more than one translation unit, so you need to break the ODR to allow your code to compile without error.</p>
"
"<p>I am having some difficulty compiling a C++ program that I've written.</p>

<p>This program is very simple and, to the best of my knowledge, conforms to all the rules set forth in the C++ Standard.  I've read over the entirety of ISO/IEC 14882:2003 twice to be sure.</p>

<p>The program is as follows:</p>

<p><img src=""http://i.stack.imgur.com/JQXWL.png"" alt=""enter image description here""></p>

<p>Here is the output I received when trying to compile this program with Visual C++ 2010:</p>

<pre><code>c:\dev&gt;cl /nologo helloworld.png
cl : Command line warning D9024 : unrecognized source file type 'helloworld.png', object file assumed
helloworld.png : fatal error LNK1107: invalid or corrupt file: cannot read at 0x5172
</code></pre>

<p>Dismayed, I tried g++ 4.5.2, but it was equally unhelpful:</p>

<pre><code>c:\dev&gt;g++ helloworld.png
helloworld.png: file not recognized: File format not recognized
collect2: ld returned 1 exit status
</code></pre>

<p>I figured that Clang (version 3.0 trunk 127530) must work, since it is so highly praised for its standards conformance.  Unfortunately, it didn't even give me one of its pretty, highlighted error messages:</p>

<pre><code>c:\dev&gt;clang++ helloworld.png
helloworld.png: file not recognized: File format not recognized
collect2: ld returned 1 exit status
clang++: error: linker (via gcc) command failed with exit code 1 (use -v to see invocation)
</code></pre>

<p>To be honest, I don't really know what any of these error message mean.</p>

<p>Many other C++ programs have source files with a <em>.cpp</em> extension, so I thought perhaps I needed to rename my file.  I changed its name to <em>helloworld.cpp</em>, but that didn't help.  I think there is a very serious bug in Clang because when I tried using it to compile the renamed program, it flipped out, printed ""84 warnings and 20 errors generated."" and made my computer beep a lot!</p>

<p>What have I done wrong here?  Have I missed some critical part of the C++ Standard?  Or are all three compilers really just so broken that they can't compile this simple program?  </p>
","87234","","<p>In the standard, §2.1/1 specifies:</p>

<blockquote>
  <p>Physical source file characters are mapped, in an implementation-defined manner, to the basic source character set (introducing new-line characters for end-of-line indicators) if necessary.</p>
</blockquote>

<p>Your compiler doesn't support that format (aka cannot map it to the <em>basic source character set</em>), so it cannot move into further processing stages, hence the error. It is entirely possible that your compiler support a mapping from image to basic source character set, but is not required to. </p>

<p>Since this mapping is implementation-defined, you'll need to look at your implementations documentation to see the file formats it supports. Typically, every major compiler vendor supports (canonically defined) text files: any file produced by a text editor, typically a series of characters. </p>

<hr>

<p>Note that the C++ standard is based off the C standard (§1.1/2), and the C(99) standard says, in §1.2:</p>

<blockquote>
  <p>This International Standard does not specify<br>
  — the mechanism by which C programs are transformed for use by a data-processing
  system;<br>
  — the mechanism by which C programs are invoked for use by a data-processing
  system;<br>
  — the mechanism by which input data are transformed for use by a C program;</p>
</blockquote>

<p>So, again, the treatment of source files is something you need to find in your compilers documentation.</p>
"
"<p>Most of the D language tutorials I've seen use <code>printf</code> to output text to the console, but that can't be right.  I know that D provides direct access to the C/C++ libraries, but shouldn't D's console output function be used instead?  What is the preferred method for outputting text (formatted or otherwise) to a console window?</p>
","87234","","<p>Within the module <code>std.stdio</code>, you'll find <code>write</code> and friends: <code>writeln</code>, <code>writef</code>, and <code>writefln</code>.</p>

<hr>

<p><code>write</code> just takes each argument, converts it to a string, and outputs it:</p>

<pre><code>import std.stdio;

void main()
{
    write(5, "" &lt;- that's five""); // prints: 5 &lt;- that's five
}
</code></pre>

<p><code>writef</code> treats the first string as a format-specifier (much like C's <code>printf</code>), and uses it to format the remaining arguments:</p>

<pre><code>import std.stdio;

void main()
{
    writef(""%d %s"", 5, ""&lt;- that's five""); // prints: 5 &lt;- that's five
}
</code></pre>

<p>The versions ending with ""<code>ln</code>"" are equivalent to the version without it, but also append a newline at the end of printing. All versions are type-safe (and therefore extensible).</p>
"
"<p>If I define a function which accepts an rvalue reference parameter:</p>

<pre><code>template &lt;typename T&gt;
void fooT(T &amp;&amp;x) {}
</code></pre>

<p>I can call it, using GCC 4.5, with either <code>a</code>, <code>ar</code>, or <code>arr</code>:</p>

<pre><code>int a, &amp;ar = a, &amp;&amp;arr = 7;
fooT(a); fooT(ar); fooT(arr);
</code></pre>

<p>However, calling a similar, <em>non-template</em> function, </p>

<pre><code>void fooInt(int &amp;&amp;x) {}
</code></pre>

<p>with any of those three arguments will fail. I was preparing to strengthen my knowledge of <code>forward</code>, but this has knocked me off course. Perhaps it's GCC 4.5; I was surprised to find that the first example from <a href=""http://www.artima.com/cppsource/rvalue.html"" rel=""nofollow"">A Brief Introduction to Rvalue References</a> also gives a compile error:</p>

<pre><code>A a;
A&amp;&amp; a_ref2 = a;  // an rvalue reference
</code></pre>
","87234","","<p>The behavior of deduction in template parameters is unique, and is the reason your template version works. I've explained exactly how this deduction works <a href=""http://stackoverflow.com/questions/3582001/advantages-of-using-forward/3582313#3582313"">here</a>, in the context of another question.</p>

<p>Summarized: when the argument is an lvalue, <code>T</code> is deduced to <code>T&amp;</code>, and <code>T&amp; &amp;&amp;</code> collapses to <code>T&amp;</code>. And with the parameter at <code>T&amp;</code>, it is perfectly valid to supply an lvalue <code>T</code> to it. Otherwise, <code>T</code> remains <code>T</code>, and the parameter is <code>T&amp;&amp;</code>, which accepts rvalues arguments.</p>

<p>Contrarily, <code>int&amp;&amp;</code> is always <code>int&amp;&amp;</code> (no template deduction rules to coerce it to something else), and can only bind to rvalues.</p>
"
"<p>I was given with a MSVC project that doesn't worked with gcc. Particularly this error is interesting:</p>

<pre><code>    void * str;
    str = ""data""; // error
    str = (char*)""data""; // working
</code></pre>

<p>Error is: <code>Error: invalid conversion from ‘const void*’ to ‘void*’</code>, so g++ (gcc 4.x) treats the string as const void, but how that MSVC treats it!?</p>

<p>Strange question: is there any other way to make this code working on both compilers, without moving away from void type, using union's or *_cast's? (Please answer with standards, I want to give something to MSVC fans out there :))</p>
","87234","","<p>Strings are arrays of constant characters. Such an array can be converted to <code>const char*</code>.</p>

<p>Note the const-qualifier: <code>const char*</code>, not <code>char*</code>. Converting a string literal to <code>char*</code> is a deprecated (removed in C++0x) and unsafe conversion. You should make your target <code>const void*</code>.</p>
"
"<p>The following quote is from <em>C++ Templates by Addison Wesley</em>. Could someone please help me understand in <em>plain English/layman's terms</em> its gist?</p>

<blockquote>
  <p>Because string literals are objects with <strong>internal linkage</strong> (two string literals with the same value but in different modules are different objects), you can't use them as template arguments either: </p>
</blockquote>
","87234","","<p>Your compiler ultimately operates on things called <a href=""http://stackoverflow.com/questions/2795443/in-c-whats-the-difference-between-the-terms-source-file-and-translation-un""><em>translation units</em>, informally called <em>source files</em></a>. Within these translation units, you identify different entities: objects, functions, etc. The linkers job is to connect these units together, and part of that process is merging identities.</p>

<p>Identifiers have <em>linkage</em><sup>†</sup>: <em>internal linkage</em> means that the entity named in that translation unit is only visible to that translation unit, while <em>external linkage</em> means that the entity is visible to other units. </p>

<p>When an entity is marked <code>static</code>, it is given <em>internal</em> linkage. So given these two translation units:</p>

<pre><code>// a.cpp
static void foo() { /* in a */ } 

// b.cpp
static void foo() { /* in a */ } 
</code></pre>

<p>Each of those <code>foo</code>'s refer to an entity (a function in this case) that is only visible to their respective translation units; that is, each translation unit has its own <code>foo</code>.</p>

<p>Here's the catch, then: string literals are the same type as <code>static const char[..]</code>. That is:</p>

<pre><code>// str.cpp
#include &lt;iostream&gt;

// this code:

void bar()
{
    std::cout &lt;&lt; ""abc"" &lt;&lt; std::endl;
}

// is conceptually equivalent to:

static const char[4] __literal0 = {'a', 'b', 'c', 0};

void bar()
{
    std::cout &lt;&lt; __literal0 &lt;&lt; std::endl;
}
</code></pre>

<p>And as you can see, the literal's value is internal to that translation unit. So if you use <code>""abc""</code> in multiple translation units, for example, they all end up being different entities.<sup>‡</sup></p>

<p>Overall, that means this is conceptually meaningless:</p>

<pre><code>template &lt;const char* String&gt;
struct baz {};

typedef baz&lt;""abc""&gt; incoherent;
</code></pre>

<p>Because <code>""abc""</code> is <em>different</em> for each translation unit. Each translation unit would be given a <em>different</em> class because each <code>""abc""</code> is a different entity, even though they provided the ""same"" argument.</p>

<p>On the language level, this is imposed by saying that template non-type parameters can be pointers to entities with <em>external linkage</em>; that is, things that <em>do</em> refer to the same entity across translation units.</p>

<p>So this is fine:</p>

<pre><code>// good.hpp
extern const char* my_string;

// good.cpp
const char* my_string = ""any string"";

// anything.cpp
typedef baz&lt;my_string&gt; coherent; // okay; all instantiations use the same entity
</code></pre>

<hr>

<p>†Not all identifiers have linkage; some have none, such as function parameters.</p>

<p>‡ An optimizing compiler will store identical literals at the same address, to save space; but that's a quality of implementation detail, not a guarantee.</p>
"
"<p>Is it possible to check this:  </p>

<pre><code>template&lt;class IntType,IntType value&gt;
struct X{};
</code></pre>

<p>What I mean by this is, is it possible to check that value supplied by user will ""fit"" into IntType (which can be any of std integer types) type? For example, I would like to detect something like this:  </p>

<pre><code>X&lt;char,300&gt; a;//here 300 is out of range and I would like to be able to detect that.
</code></pre>
","87234","","<p>No. Given your code, <code>300</code> is converted to a <code>char</code> by the compiler before you ever get to see it.</p>

<p>The closest thing you can do is accept the argument into an integer parameter who's range is larger than your target type. Then check that the value will fit before converting. The only problem is <code>signed</code> versus <code>unsigned</code>, for which I don't think there's a general solution.</p>

<p>But not to worry: it's not your class's job to make sure the arguments are being supplied correctly; that would be the job of a utility type that simply doesn't exist. For better or for worse, C++ doesn't provide a clean mechanism for this because it assumes the programmer won't make these mistakes.</p>
"
"<p>(I'm sorry if this is a duplicate question, since I am having trouble searching for this operator!)</p>

<p>What is the meaning of operator() in C++? I see that is often used for ""functors,"" or function objects such as comparators. But then how are such functions called? Is it useful in other situations? And how many parameters can I declare for such an operator? E.g., is the following acceptable?</p>

<pre><code>bool operator() (Foo f, Baz b, Quz q, Oik o) {...}
</code></pre>

<p>Thanks</p>
","87234","","<p>It's just a normal function that gets called when you apply function-call syntax to a user-defined type.</p>

<p>So it has all the restrictions and features of a regular member function. It can be a template, it can take as many parameters as you want, it needs a return type, it can be <code>const</code>, etc.</p>
"
"<p>I am having a consuming application which needs to store a maximum of 100 objects in a list to feed to a callback for processing, since it will be redundant to keep old data if the consumer does not catch up. As new data is arrived, it can simply overwrite the oldest element.</p>

<p>I was thinking of using circular buffer container and guessed that it would be deque , but found that it does not use circular list, as well as does not have option to set fixed maximum size. </p>

<p>There is a max_size method in dequeue, but documentation says ""This is the maximum potential size the container can reach due to system or library implementation limitations.""</p>

<p>Is there some other container I can use?</p>

<p>PS : I am using Visual C++ 2010 express</p>
","87234","","<p>There is no standard library container that does what you want directly. However, you should take a look at <a href=""http://www.boost.org/doc/libs/release/libs/circular_buffer/index.html"">Boost's Circular Buffer Container</a>. If you can't use Boost, you can at least view its source and redo it. </p>
"
"<p>I have a container class (called Atom) that I want to store objects of type Term in.  Many STL container constructors have the form <code>Container(Iterator first, Iterator last)</code> to initialize the container with some set of elements.</p>

<p>Now, I'd like to be able to use this form for my Atom class, but I'm unsure how to untie the iterator from its container class.  For instance, currently I have:</p>

<pre><code>class Atom {
public:
  Atom(std::string str, 
    std::vector&lt;Term&gt;::const_iterator start, 
    std::vector&lt;Term&gt;::const_iterator end);
</code></pre>

<p>This only allowed vector iterators.  How can I generalize the type of iterator I take? </p>
","87234","","<p>Whenever you need to generalize on types, think templates:</p>

<pre><code>class Atom {
public:
  template &lt;typename ForwardIterator&gt;
  Atom(std::string str, 
    ForwardIterator start, 
    ForwardIterator end);
</code></pre>

<p>Now just iterate over the range, whatever it may be.</p>
"
"<p>now I have <code>std::map&lt;std::string, Object&gt; myMap</code>. Class <code>Object</code> has funcions: <code>int getPriority()</code> and <code>void Work()</code>. Now I go through the map and want to call <code>Work</code> due to the priority of object. </p>

<p>I wrote very crazy idea: the clone of that map, but it stores in the key it's priority, for example:</p>

<pre><code>myMap[""3_key1""] = Object();
myMap[""6_key2""] = Object();
myMap[""0_key3""] = Object();
</code></pre>

<p>It sorts and calling is in right queue: <code>0_key3; 3_key1; 6_key2</code>.</p>

<p>But this is very slow, I think. And I want to replace <code>std::map</code> with <code>unordered_map</code> from <strong>boost</strong> because it's a lot faster. And there isn't sorting by key.</p>

<p>So, any ideas?</p>
","87234","","<p>Use <a href=""http://www.boost.org/doc/libs/1_46_1/libs/multi_index/doc/index.html"" rel=""nofollow"">Boost.MultiIndex</a>:</p>

<pre><code>// your class
#include &lt;iostream&gt;
#include &lt;string&gt;

class foo
{
public:
    foo(std::string name, unsigned priority, std::string msg) :
    mPriority(priority)
    {
        mName.swap(name); // primitive std::move :)
        mMsg.swap(msg); // (default-construct &amp; swap)
    }

    const std::string&amp; name() const
    {
        return mName;
    }

    unsigned priority() const
    {
        return mPriority;
    }

    void work() const
    {
        std::cout &lt;&lt; mMsg &lt;&lt; std::endl;
    }

private:
    std::string mName;

    unsigned mPriority;
    std::string mMsg;
};

// your container
#include &lt;boost/multi_index_container.hpp&gt;
#include &lt;boost/multi_index/mem_fun.hpp&gt;
#include &lt;boost/multi_index/ordered_index.hpp&gt;
#include &lt;boost/multi_index/sequenced_index.hpp&gt;

namespace bmi = boost::multi_index;

typedef boost::multi_index_container&lt;foo,
            bmi::indexed_by&lt;
                // order by name (std::map)
                bmi::ordered_unique&lt;
                    bmi::const_mem_fun&lt;foo, const std::string&amp;, &amp;foo::name&gt;
                        &gt;,

                // order by priority (std::multi_map)
                bmi:: ordered_non_unique&lt;
                    bmi::const_mem_fun&lt;foo, unsigned ,&amp;foo::priority&gt;
                        &gt;
                &gt; 
            &gt; foo_set;

// test
#include &lt;boost/foreach.hpp&gt;

int main()
{
    foo_set fooSet;
    fooSet.insert(foo(""a"", 4, ""this is a, priority 4""));
    fooSet.insert(foo(""b"", 3, ""this is b, priority 3""));
    fooSet.insert(foo(""c"", 7, ""this is c, priority 7""));
    fooSet.insert(foo(""d"", 1, ""this is c, priority 1""));

    // view as map from name to value
    foo_set::nth_index&lt;0&gt;::type&amp; nameView = fooSet.get&lt;0&gt;();

    nameView.find(""a"")-&gt;work(); // find ""a"", print its message
    if (nameView.find(""e"") == nameView.end())
        std::cerr &lt;&lt; ""e not found"" &lt;&lt; std::endl;

    std::cout &lt;&lt; std::endl;

    // view as multi_map from priority to value
    foo_set::nth_index&lt;1&gt;::type&amp; priorityView = fooSet.get&lt;1&gt;();

    BOOST_FOREACH(const foo&amp; f, priorityView)
        f.work(); // work, in order of priority
}
</code></pre>

<p>I don't have any performance tests on it, but it certainly better expresses your intent, and that's usually indicative of improved performance anyway.</p>
"
"<p>So I was trying out some features of C++0x using GCC, but I also wanted to make sure the code could be compiled with a standard C++ compiler. So I was playing around with the __cplusplus macro with ifdefs to exclude C++0x code when it wasn't asked for.</p>

<p>I found that the value of __cplusplus wasn't 199711L, it was 1! After a little bit of googling, I found <a href=""http://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html#Standard-Predefined-Macros"" rel=""nofollow"">this</a> where it says GCC isn't a fully conforming implementation.</p>

<p>Are there any fully conforming implementations? I know of clang, gcc, and msvc. GCC isn't a fully conforming implementation, are clang and msvc?</p>
","87234","","<p>No. It's possible to have a conforming compiler, but the language is <em>extremely</em> complex. There are corner-cases, ambiguities, and sometimes outright contradictions in the language that compiler writers struggle to get working.</p>

<p>The best way to make sure your code is standards-compliant is to brain-compile it, because you can verify things match the standard. Of course, this hinges on your ability to fully understand the standard; and whether or not any person can do that is an entirely new question. ;)</p>
"
"<p>I am using the pthreads library and when I create a thread I am giving it the pointer to an object that is a templated type.</p>

<p>I'm inexperienced with templates (just read about them today) and need to cast the void* parameter from the method declaration the pthread runs to the templated type so I can access its members. In short something that looks like so:</p>

<p>In short something like this:</p>

<pre><code>template &lt;typename T&gt;
class A {
    ...
    ...
    ...
    void aMember() { ... }
};

int main() {
    A&lt;int&gt; a;

    pthread_create(..., ..., &amp;run, &amp;a);

    ...
    ...
    ...
}

void *run(void *arg) {
    (A*)arg-&gt;aMember()
}
</code></pre>

<p>My problem is I get all these errors that I don't know how to rectify. I do in fact understand the errors but don't know the solution. Here are the errors:</p>

<p>error: expected primary-expression before ( token
error: missing template arguments before * token
error: expected primary-expression before ) token
error: expected `)' before 'info'</p>

<p>I just don't see how I could ever know the argument types of A when I am casting to it once in the thread?</p>

<p>I'm using the C++ Templates: The Complete Guide book as a reference/learning resource and must say I am over whelmed with all the info needed to fully understand templates. I was wondering if anyone had a solution to the problem, or could point me in the direction of another resource that might provide answers.</p>

<p>As always I appreciate your help greatly.</p>

<p><strong>EDIT/UPDATE</strong></p>

<p>It seems that adding context to my problem might help. Alternatively maybe someone can provide a different solution using a different design.</p>

<p>I am using libcurl to make HTTP Requests and depending on the Response I receive I will create an object of a specific type (thus the templates). I create a new thread for each Request I would like to make so that everything runs Asynchronously. </p>
","87234","","<p>Class templates are not classes, they <em>generate</em> classes when given template arguments. Likewise, you cannot make a cookie from a cookie cutter until you supply cookie dough. Casting to <code>A</code> is meaningless.</p>

<p>It's hard to say what the right solution is since <a href=""http://www.catb.org/esr/faqs/smart-questions.html"" rel=""nofollow"">you haven't said what you're trying to accomplish, just the step you're taking</a>. If <code>run</code> should only ever work on one type, you know the template argument will always be the same; you could do this:</p>

<pre><code>void *run(void *arg) {
    A&lt;int&gt;* a = static_cast&lt;A&lt;int&gt;*&gt;(arg);
    a-&gt;aMember();
}
</code></pre>

<p>If <code>run</code> can operate on different <code>A</code> instantiations, and need not worry about others, <code>run</code> itself can be a template:</p>

<pre><code>template &lt;typename T&gt;
void *run(void *arg) {
    A&lt;T&gt;* a = static_cast&lt;A&lt;T&gt;*&gt;(arg);
    a-&gt;aMember();
}

pthread_create(..., ..., &amp;run&lt;int&gt;, &amp;a);
</code></pre>

<p>If <code>run</code> needs to operate uniformly on any type, this is not possible. You can, however, factor out the common type-independent interface, and refer to a <em>non-template</em> base:</p>

<pre><code>class ABase {
public:
    // functionality present regardless of template argument
    virtual void aMember() = 0;

    // polymorphic bases should always have virtual destructors
    virtual ~ABase() {}
};

template &lt;typename T&gt;
class A : public ABase {
public:
    void aMember() { /* use type information */ }
};

void *run(void *arg) {
    ABase* a = static_cast&lt;ABase*&gt;(arg);
    a-&gt;aMember(); // dynamic dispatch
}
</code></pre>
"
"<p>Is there a max limit to the number of bytes you can allocate to an array pointer?</p>

<p>For example if i use a size of 16000 then this works.</p>

<pre><code>char* iobuffer=new char(16000);
iobuffer[15000]='a';
</code></pre>

<p>However</p>

<pre><code>char* iobuffer=new char(160000);
iobuffer[150000]='a';
</code></pre>

<p>this does not.</p>

<p>It shouldn't be a memory issue so is there some internal restriction?  After looking further it might be that the heap cannot store that much.</p>
","87234","","<p>You've actually got your allocation code wrong. You're using <em>parenthesis</em>, which provide an initializer for your newly allocated value. In other words, in both cases you have a <em>single</em> <code>char</code> allocated for use, initialized to <code>16000</code> and <code>160000</code> respectively. Use <em>brackets</em> to dynamically allocate an array.†</p>

<p>After that, you subscript (<em>way</em>) out of bounds, leading to <a href=""http://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior"">undefined behavior</a>. (Any subscript past zero in your case is undefined behavior; more generally, subscripting past array bounds is undefined behavior.)</p>

<p>To answer the question, there is no limit, language-wise. It depends on your running environment.</p>

<hr>

<p>†Of course, you should never use <code>new[]</code>. Use <code>std::vector</code> instead.</p>
"
"<p>I am trying to learn a little c++ and I have a silly question. Consider this code:</p>

<pre><code>TCHAR tempPath[255];
GetTempPath(255, tempPath);
</code></pre>

<p>Why does windows need the size of the var tempPath? I see that the <code>GetTempPath</code> is declared something like:</p>

<pre><code>GetTempPath(dword size, buf LPTSTR);
</code></pre>

<p>How can windows change the buf value without the <code>&amp;</code> operator? Should not the function be like that?</p>

<pre><code>GetTempPath(buf &amp;LPTSTR);
</code></pre>

<p>Can somebody provide a simple <code>GetTempPath</code> implementation sample so I can see how <code>size</code> is used?</p>

<p><strong>EDIT:</strong></p>

<p>Thanks for all your answers, they are all correct and I gave you all +1. But what I meant by ""Can somebody provide a simple <code>GetTempPath</code> implementation) is that i have tried to code a function similar to the one windows uses, as follow: </p>

<pre><code>void MyGetTempPath(int size, char* buf) 
{
 buf = ""C:\\test\\"";
}

int main(int argc, char *argv[])
{
    char* tempPath = new TCHAR[255];
    GetTempPathA(255, tempPath);
    MessageBoxA(0, tempPath, ""test"", MB_OK);
    return EXIT_SUCCESS;
}
</code></pre>

<p>But it does not work. MessageBox displays a ""##$' string. How should MyGetTempPath be coded to work properly?</p>
","87234","","<p>An array cannot be passed into functions by-value. Instead, it's converted to a pointer to the first element, and that's passed to the function. Having a (non-const) pointer to data allows modification:</p>

<pre><code>void foo(int* i)
{
    if (i) (don't dereference null)
        *i = 5; // dereference pointer, modify int
}
</code></pre>

<p>Likewise, the function now has a pointer to a <code>TCHAR</code> it can write to. It takes the size, then, so it knows exactly how many <code>TCHAR</code>'s exist after that initial one. Otherwise it wouldn't know how large the array is.</p>
"
"<p>This causes problems due to extra whitespace:</p>

<pre><code>std::string t(""3.14 "");
double d = boost::lexical_cast&lt;double&gt; (t); 
</code></pre>

<p>So, I wrote this</p>

<pre><code>template&lt;typename T&gt; 
T string_convert(const std::string&amp; given)
{
  T output;
  std::stringstream(given) &gt;&gt; output;
  return output;
}

double d = string_convert&lt;double&gt; (t); 
</code></pre>

<p>What can be the problems with this? Is there a better way? Much prefer to use lexical cast</p>
","87234","","<p>Note that your code isn't always correct. If you do <code>string_convert&lt;double&gt;(""a"")</code>, for example, the read will fail and you'll return <code>output</code> uninitialized, leading to undefined behavior.</p>

<p>You can do this:</p>

<pre><code>template&lt;typename T&gt; 
T string_convert(const std::string&amp; given)
{
  T output;
  if (!(std::stringstream(given) &gt;&gt; output))
    throw std::invalid_argument(); // check that extraction succeeded

  return output;
}
</code></pre>

<p>Note the only difference between the above code and Boost's is that Boost also checks to make sure nothing is left in the stream. What you should do, though, is just trim your string first:</p>

<pre><code>#include &lt;boost/algorithm/string/trim.hpp&gt;

std::string t(""3.14 "");
boost::algorithm::trim(t); // get rid of surrounding whitespace

double d = boost::lexical_cast&lt;double&gt;(t); 
</code></pre>
"
"<p>Is there a way of copying a string into a new string without knowing the size that the new array has to be at compile time? As far as I am aware, you can't have variable array lengths in C.</p>

<p>For example:</p>

<pre><code>void myFunction(char *string)
{
   char newString[????];

   strcopy(newString, string);
}
</code></pre>
","87234","","<p>In C99, variable-length arrays are an option:</p>

<pre><code>void myFunction(char *string)
{
   char newString[strlen(string) + 1];

    // note: strcpy, not strcopy
   strcpy(newString, string);
}
</code></pre>

<p>However, you'll run into problems if the string is large; it'll exhaust your stack space and kaboom! (Also, the array ceases to exist at the end of its scope, like any local variable, so you can't return it.)</p>

<p>So unless you know the string is small, you're probably better off just dynamically allocating:</p>

<pre><code>void myFunction(char *string)
{
   char *newString = strdup(string);
   if (!newString) /* error */

   /* ... */

   free(newString);
}
</code></pre>
"
"<p>as asked in the question.<br>
std::string myVar; the maximum character it can hold is dictated by stack or heap?  </p>

<p>Thank you</p>
","87234","","<p>By default, the memory allocated for <code>std::string</code> is allocated dynamically.</p>

<p>Note that <code>std::string</code> has a <code>max_size()</code> function returning the maximum number of character supported by the implementation. The usefulness of this is questionable, though, as it's a implementation maximum, and doesn't take into consideration other resources, like memory. Your real limit is much lower. (Try allocating 4GB of contiguous memory, or take into account memory exhaustion elsewhere.)</p>
"
"<p>I'm using the QT framework so if there is something like this implemented in that, I would use it, but I couldn't find it.</p>

<p>I would like to get random color values for variable length strings.</p>
","87234","","<p>If you include <a href=""http://doc.qt.nokia.com/latest/qhash.html""><code>&lt;QHash&gt;</code></a>, then you get <a href=""http://doc.qt.nokia.com/latest/qhash.html#qHashx"">overloads of the function <code>qHash()</code></a>, one of which is:</p>

<pre><code>uint qHash(const QString &amp; key)
</code></pre>
"
"<p>I see questions on SO every so often about overloading the comma operator in C++ (mainly unrelated to the overloading itself, but things like the notion of sequence points), and it makes me wonder:</p>

<p>When <em>should</em> you overload the comma? What are some examples of its practical uses?</p>

<p>I just can't think of any examples off the top of my head where I've seen or needed to something like</p>

<pre><code>foo, bar;
</code></pre>

<p>in real-world code, so I'm curious as to when (if ever) this is actually used.</p>
","87234","","<p><a href=""http://www.boost.org/doc/libs/1_46_1/libs/assign/doc/index.html"">Boost.Assign</a> uses it, to let you do things like:</p>

<pre><code>vector&lt;int&gt; v; 
v += 1,2,3,4,5,6,7,8,9;
</code></pre>

<p>And I've seen it used for quirky language hacks, I'll see if I can find some.</p>

<hr>

<p>Aha, I do remember one of those quirky uses: <a href=""http://stackoverflow.com/questions/2419650/c-c-macro-template-blackmagic-to-generate-unique-name/2419715#2419715"">collecting multiple expressions</a>. (Warning, dark magic.)</p>
"
"<p>Value of a pointer is address of a variable. Why value of an <code>int pointer</code> increased by 4-bytes after the int pointer increased by 1.</p>

<p>In my opinion, I think value of pointer(address of variable) only increase by 1-byte after pointer increment.</p>

<p>Test code:</p>

<pre><code>int a = 1, *ptr;
ptr = &amp;a;
printf(""0x%X\n"", ptr);
ptr++;
printf(""0x%X\n"", ptr);
</code></pre>

<p>Expected output:</p>

<pre><code>0xBF8D63B8
0xBF8D63B9
</code></pre>

<p>Actually output:</p>

<pre><code>0xBF8D63B8
0xBF8D63BC
</code></pre>

<p><strong>EDIT</strong>:</p>

<p>Another question - How to visit the 4 bytes an <code>int</code> occupies one by one?</p>
","87234","","<p>When you increment a <code>T*</code>, it moves <code>sizeof(T)</code> bytes.<sup>†</sup> This is because it doesn't make sense to move any other value: if I'm pointing at an <code>int</code> that's 4 bytes in size, for example, what would incrementing less than 4 leave me with? A partial <code>int</code> mixed with some other data: nonsensical.</p>

<hr>

<p>Consider this in memory:</p>

<pre><code>    [↓      ]
[...|0 1 2 3|0 1 2 3|...]
[...|int    |int    |...]
</code></pre>

<p>Which makes more sense when I increment that pointer? This:</p>

<pre><code>            [↓      ]
[...|0 1 2 3|0 1 2 3|...]
[...|int    |int    |...]
</code></pre>

<p>Or this:</p>

<pre><code>      [↓      ]
[...|0 1 2 3|0 1 2 3|...]
[...|int    |int    |...]
</code></pre>

<p>The last doesn't actually point an any sort of <code>int</code>. (Technically, then, using that pointer is <a href=""http://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior"">UB</a>.)</p>

<p>If you <em>really</em> want to move one byte, increment a <code>char*</code>: the size of of <code>char</code> is always one:</p>

<pre><code>int i = 0;
int* p = &amp;i;

char* c = (char*)p;
char x = c[1]; // one byte into an int
</code></pre>

<hr>

<p>†A corollary of this is that you cannot increment <code>void*</code>, because <code>void</code> is an incomplete type.</p>
"
"<p>i have a class which has a template by other purposes:</p>

<pre><code>template&lt;class t&gt;
class MyClass {
    public: //of course public...
    t foo;
    std::string text;
}
</code></pre>

<p>and i have another class which method get all kind of these class through the arguments, and want to store the pointer in an array. The class dont want to access the specific (tempalted) parts of the classes only the common attributes/methods.</p>

<pre><code>class Container {
    public: //of course public...
    MyClass* array; //this is allocated with some magic.
    void bar(MyClass&amp; m) {
      and want to store the class in a MyClass* array.
    }
}
</code></pre>

<p>here is the error that <strong>argument list for template missing</strong></p>

<p>how can i solve this?  </p>
","87234","","<p>The simplest method would be to make that function a template as well:</p>

<pre><code>template &lt;class t&gt;
void bar(MyClass&lt;t&gt;&amp; m) {
    // ...
}
</code></pre>

<p>Note that that should probably be <code>const MyClass&lt;t&gt;&amp;</code>, because you don't need to modify it.</p>

<hr>

<p>Your new code is meaningless. There is no such that as an object of type <code>MyClass</code>, because <code>MyClass</code> is a <em>template</em>. If you want to operate on these classes irrespective of their template argument, then you need to factor out the non-template portions as a base class:</p>

<pre><code>class MyClassBase
{
public:
    // polymorphic base classes should always have virtual destructors
    ~MyClassBase() {}

    virtual void some_function() = 0;
};

template &lt;typename T&gt;
class MyClass : public MyClassBase
{
public:
    // implement abstract functions
    void some_function()
    {
        // template argument T is available here
    }
};
</code></pre>

<p>Then you can refer to that base, and when you call a virtual function it will dynamically dispatch:</p>

<pre><code>class Container
{
public:
    // no magic: use a std::vector for dynamic arrays
    std::vector&lt;MyClassBase*&gt; array; // not by value! avoid slicing

    void bar(MyClassBase&amp; m)
    {
        array.push_back(&amp;m);
    }

    void baz()
    {
        array[0]-&gt;some_function(); // for example
    }
};
</code></pre>
"
"<p>Is it somehow possible? I want that to enable compile-time passing of arguments. Suppose it's only for user convenience, as one could always type out the real type with <code>template&lt;class T, T X&gt;</code>, but for some types, i.e. pointer-to-member-functions, it's pretty tedious, even with <code>decltype</code> as a shortcut. Consider the following code:</p>

<pre><code>struct Foo{
  template&lt;class T, T X&gt;
  void bar(){
    // do something with X, compile-time passed
  }
};

struct Baz{
  void bang(){
  }
};

int main(){
  Foo f;
  f.bar&lt;int,5&gt;();
  f.bar&lt;decltype(&amp;Baz::bang),&amp;Baz::bang&gt;();
}
</code></pre>

<p>Would it be somehow possible to convert it to the following?</p>

<pre><code>struct Foo{
  template&lt;auto X&gt;
  void bar(){
    // do something with X, compile-time passed
  }
};

struct Baz{
  void bang(){
  }
};

int main(){
  Foo f;
  f.bar&lt;5&gt;();
  f.bar&lt;&amp;Baz::bang&gt;();
}
</code></pre>
","87234","","<p>After your update: no. There is no such functionality in C++. The closest is macros:</p>

<pre><code>#define AUTO_ARG(x) decltype(x), x

f.bar&lt;AUTO_ARG(5)&gt;();
f.bar&lt;AUTO_ARG(&amp;Baz::bang)&gt;();
</code></pre>

<hr>

<p>Sounds like you want a generator:</p>

<pre><code>template &lt;typename T&gt;
struct foo
{
    foo(const T&amp;) {} // do whatever
};

template &lt;typename T&gt;
foo&lt;T&gt; make_foo(const T&amp; x)
{
    return foo&lt;T&gt;(x);
}
</code></pre>

<p>Now instead of spelling out:</p>

<pre><code>foo&lt;int&gt;(5);
</code></pre>

<p>You can do:</p>

<pre><code>make_foo(5);
</code></pre>

<p>To deduce the argument.</p>
"
"<p><code>int *pt = 0;<br>
long i = reinterpret_cast&lt;long&gt;(pt);</code></p>

<p>Is i guaranteed to be 0? Is this well defined or implementation-defined?
I checked the c++ standard, but it only states that</p>

<blockquote>
  <p>A pointer to a data object or to a function (but not a pointer to member) can be converted to any integer type large enough to contain it. </p>
</blockquote>

<p>In this case, pt doesn't point to any data object. Does the rule apply to this case?</p>
","87234","","<p><strong>No</strong>, <code>i</code> is not necessarily any value. The result is implementation-defined.<sup>†</sup></p>

<p>The representation of pointers, in C++, is implementation-defined, including the representation of a null pointer. When you assign an integer value of zero to a pointer, you set that pointer to the <em>implementation-defined</em> null pointer value, which is not necessarily all-bits-zero. The result of casting that value to an integer is, by transitivity, implementation-defined.</p>

<p>Even more troublesome, though, is that the mapping done by <code>reinterpret_cast</code>  is implementation-defined anyway. So even if the null pointer value was all-bits-zero, an implementation is free to make the result whatever it wants. You're only guaranteed that you'll get the original value when you cast back.</p>

<p>That all said, the next sentence after your quote includes the note:</p>

<blockquote>
  <p>[ Note: It is intended to be unsurprising to those who know the addressing structure
  of the underlying machine. —end note ]</p>
</blockquote>

<p>So even though specific mappings are not required, pragmatically you can take an educated guess.</p>

<hr>

<p><sup>†</sup> Assuming <code>long</code> is large enough. In C++0x use <code>uintptr_t</code>, optionally defined in <code>&lt;cstddef&gt;</code>.</p>
"
"<p>The base class is :</p>

<pre><code>#include &lt;memory&gt;

namespace cb{

template&lt; typename R, typename ... Args &gt;
class CallbackBase
{
public:
    typedef std::shared_ptr&lt; CallbackBase&lt; R, Args... &gt; &gt;
            CallbackPtr;

    virtual ~CallbackBase()
    {
    }
    virtual R Call(  Args ... args) = 0;
};
} // namespace cb
</code></pre>

<p>Derived class is this :</p>

<pre><code>namespace cb{
template&lt; typename R, typename ... Args &gt;
class FunctionCallback : public CallbackBase&lt; R, Args... &gt;
{
public:
    typedef R (*funccb)(Args...);

    FunctionCallback( funccb cb_ ) : 
        CallbackBase&lt; R, Args... &gt;(),
        cb( cb_ )
    {
    }
    virtual ~FunctionCallback()
    {
    }
    virtual R Call(Args... args)
    {
      return cb( args... );
    }
private:
  funccb cb;
};
} // namespace cb
</code></pre>

<p>Function to create :</p>

<pre><code>namespace cb{
template &lt; typename R, typename ...Args &gt;
typename CallbackBase&lt; R, Args... &gt;::CallbackBasePtr
    MakeCallback( typename FunctionCallback&lt; R, Args... &gt;::funccb cb )
{
    typename CallbackBase&lt; R, Args... &gt;::CallbackBasePtr
        p( new FunctionCallback&lt; R, Args... &gt;( cb )
);
    return p;
}
} // namespace cb
</code></pre>

<p>And the example :</p>

<pre><code>bool Foo_1args( const int &amp; t)
{
    return true;
}
int main()
{
    auto cbObj = cb::MakeCallback( &amp; Foo_1args );
}
</code></pre>

<p>I keep getting this error :</p>

<pre><code>error: no matching function for call to ‘MakeCallback(bool (*)(const int&amp;))’
error: unable to deduce ‘auto’ from ‘&lt;expression error&gt;’
</code></pre>

<p>I tried to change it, but I couldn't figure out how to fix.</p>

<p>So, what is wrong? And how to fix this example?</p>
","87234","","<p>The problem might make sense with a simpler example. Try identifying the problem here:</p>

<pre><code>template &lt;typename T&gt;
struct id { typedef T type; };

template &lt;typename T&gt;
void foo(typename id&lt;T&gt;::type x);

foo(5); // error
</code></pre>

<p>The problem is that the compiler cannot deduce what <code>T</code> should be; it's not directly used anywhere. You'd have to explicitly provide it: <code>foo&lt;int&gt;(5)</code>, or let it deduce it in some other way:</p>

<pre><code>template &lt;typename T&gt;
void foo(typename id&lt;T&gt;::type x, T y);

foo(5, 7); // okay, T is int because 7 is int
</code></pre>

<p>This makes sense: how could the compiler figure out which <code>T</code>'s, supplied to <code>id</code>, result in <code>id&lt;T&gt;::type</code> matching? There could be specializations, and the entire thing would be costly anyway, if possible.</p>

<hr>

<p>Likewise, there's nothing the compiler has available to deduce <code>R</code> and <code>Args</code>. Instead, you should do this:</p>

<pre><code>template &lt; typename R, typename ...Args &gt;
typename CallbackBase&lt; R, Args... &gt;::CallbackBasePtr
    MakeCallback( R cb(Args...) )
{
    typename CallbackBase&lt; R, Args... &gt;::CallbackBasePtr
        p( new FunctionCallback&lt; R, Args... &gt;( cb ));

    return p;
}
</code></pre>

<p>Finally, you have other minor issues that need fixing, <a href=""http://stackoverflow.com/questions/5656691/what-is-wrong-with-this-variadic-templates-example/5656901#5656901"">which Xeo has outlined</a>.</p>
"
"<p><code>TextItem</code> is a subclass of <code>XObject</code>.</p>

<p>I am trying to figure out why the following works:</p>

<pre><code>  TextItem *textItem = new TextItem();
  XObject *xItem = textItem;
  delete textItem;
</code></pre>

<p>But this does not:</p>

<pre><code>  TextItem *textItem = new TextItem();
  XObject *xItem = textItem;
  delete xItem;
</code></pre>

<p>The second example fails on <code>delete</code>, with an assertion failure (<code>_BLOCK_TYPE_IS_VALID</code>).</p>
","87234","","<p>Make sure that <code>XObject</code> has a <code>virtual</code> destructor, or your second snippet has <a href=""http://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior"">undefined behavior</a>:</p>

<pre><code>struct XObject
{
    // now deleting derived classes
    // through this base class is okay
    virtual ~XObject() {}
};

struct TextItem : XObject {};
</code></pre>
"
"<p>Let's say I have some <code>typedef struct {int b;} some_t;</code> and a pointer <code>a</code> to such a struct. Then why is </p>

<pre><code>(*a).b = 5;
</code></pre>

<p>not the same as</p>

<pre><code>some_t c = *a;
c.b = 5;
</code></pre>

<p>?</p>
","87234","","<p>In the second, <code>c</code> is a <em>copy</em> of <code>*a</code>, and <code>c.b</code> is a copy of <code>(*a).b</code>.</p>

<p><code>c.b = 5</code> modifies the copy, not the original.</p>
"
"<p>In the beautiful answer to the <a href=""http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom#3279550"">copy-and-swap-idiom</a> there is a piece of code I need a bit of help:</p>

<pre><code>class dumb_array
{
public:
    // ...
    friend void swap(dumb_array&amp; first, dumb_array&amp; second) // nothrow
    {
        using std::swap; 
        swap(first.mSize, second.mSize); 
        swap(first.mArray, second.mArray);
    }
    // ...
};
</code></pre>

<p>and he adds a note</p>

<blockquote>
  <p>There are other claims that we should specialize std::swap for our type, provide an in-class swap along-side a free-function swap, etc. But this is all unnecessary: any proper use of swap will be through an unqualified call, and our function will be found through ADL. One function will do.</p>
</blockquote>

<p>With <code>friend</code> I am a bit on ""unfriendly"" terms, I must admit. So, my main questions are:</p>

<ul>
<li><strong>looks like a free function</strong>, but its inside the class body?</li>
<li><strong>why isn't this <code>swap</code> static</strong>? It obviously doesn't use any member variables.</li>
<li><strong>""Any proper use of swap will find out swap via ADL""</strong>? ADL will search the namespaces, right? But does it also look inside classes? Or is here where <code>friend</code> comes in?</li>
</ul>

<p>Side-questions:</p>

<ul>
<li>With C++11, should I mark my <code>swap</code>s with <strong><code>noexcept</code></strong>?</li>
<li>With C++11 and its <strong>range-for</strong>, should I place <code>friend iter begin()</code> and <code>friend iter end()</code> the same way inside the class? I think the <code>friend</code> is not needed here, right?</li>
</ul>
","87234","","<p>There are several ways to write <code>swap</code>, some better than others. Over time, though, it was found a single definition works best. Let's consider how we might think about writing a <code>swap</code> function.</p>

<hr>

<p>We first see that containers like <code>std::vector&lt;&gt;</code> have a single-argument member function <code>swap</code>, such as:</p>

<pre><code>struct vector
{
    void swap(vector&amp;) { /* swap members */ }
};
</code></pre>

<p>Naturally, then, our class should too, right? Well, not really. The standard library has <a href=""http://www.gotw.ca/gotw/084.htm"">all sorts of unnecessary things</a>, and a member <code>swap</code> is one of them. Why? Let's go on.</p>

<hr>

<p>What we should do is identify what's canonical, and what our class <em>needs</em> to do to work with it. And the canonical method of swapping is with <code>std::swap</code>. This is why member functions aren't useful: they aren't how we should swap things, in general, and have no bearing on the behavior of <code>std::swap</code>.</p>

<p>Well then, to make <code>std::swap</code> work we should provide (and <code>std::vector&lt;&gt;</code> should have provided) a specialization of <code>std::swap</code>, right?</p>

<pre><code>namespace std
{
    template &lt;&gt; // important! specialization in std is OK, overloading is UB
    void swap(myclass&amp;, myclass&amp;)
    {
        // swap
    }
}
</code></pre>

<p>Well that would certainly work in this case, but it has a glaring problem: specializations cannot be partial. That is, we cannot specialize template classes with this, only particular instantiations:</p>

<pre><code>namespace std
{
    template &lt;typename T&gt;
    void swap&lt;T&gt;(myclass&lt;T&gt;&amp;, myclass&lt;T&gt;&amp;) // error! no partial specialization
    {
        // swap
    }
}
</code></pre>

<p>This method works some of the time, but not all of the time. There must be a better way.</p>

<hr>

<p>There is! We can use a <code>friend</code> function, and find it through ADL:</p>

<pre><code>namespace xyz
{
    struct myclass
    {
        friend void swap(myclass&amp;, myclass&amp;);
    };
}
</code></pre>

<p>When we want to swap something, we associate<sup>†</sup> <code>std::swap</code> and then make an unqualified call:</p>

<pre><code>using std::swap; // allow use of std::swap...
swap(x, y); // ...but select overloads, first

// that is, if swap(x, y) finds a better match, via ADL, it
// will use that instead; otherwise it falls back to std::swap
</code></pre>

<p>What is a <code>friend</code> function? There is confusion around this area.</p>

<p>Before C++ was standardized, <code>friend</code> functions did something called ""friend name injection"", where the code behaved <em>as if</em> if the function had been written in the surrounding namespace. For example, these were equivalent pre-standard:</p>

<pre><code>struct foo
{
    friend void bar()
    {
        // baz
    }
};

// turned into, pre-standard:    

struct foo
{
    friend void bar();
};

void bar()
{
    // baz
}
</code></pre>

<p>However, when ADL was invented this was removed. The <code>friend</code> function could then <em>only</em> be found via ADL; if you wanted it as a free function, it needed to be declared as so (<a href=""http://stackoverflow.com/questions/4027604/c-c-automatically-cast-void-pointer-into-type-pointer-in-c-in-define-in-cas/4027734#4027734"">see this</a>, for example). But lo! There was a problem.</p>

<p>If you just use <code>std::swap(x, y)</code>, your overload will <em>never</em> be found, because you've explicitly said ""look in <code>std</code>, and nowhere else""! This is why some people suggested writing two functions: one as a function to be found via ADL, and the other to handle explicit <code>std::</code> qualifications.</p>

<p>But like we saw, this can't work in all cases, and we end up with an ugly mess. Instead, idiomatic swapping went the other route: instead of making it the classes job to provide <code>std::swap</code>, it's the swappers job to make sure they don't use qualified <code>swap</code>, like above. And this tends to work pretty well, as long as people know about it. But therein lies the problem: it's unintuitive to need to use an unqualified call!</p>

<p>To make this easier, some library's like Boost provided the function <code>boost::swap</code>, which just does an unqualified call to <code>swap</code>, with <code>std::swap</code> as an associated namespace. This helps make things succinct again, but it's still a bummer.</p>

<p>Note that there is no change in C++11 to the behavior of <code>std::swap</code>, which I and others mistakenly thought would be the case. If you were bit by this, <a href=""http://stackoverflow.com/q/9170247/87234"">read here</a>.</p>

<hr>

<p>In short: the member function is just noise, the specialization is ugly and incomplete, but the <code>friend</code> function is complete and works. And when you swap, either use <code>boost::swap</code> or an unqualified <code>swap</code> with <code>std::swap</code> associated.</p>

<hr>

<p>†Informally, a name is <em>associated</em> if it will be considered during a function call. For the details, read §3.4.2. In this case, <code>std::swap</code> normally isn't considered; but we can <em>associate</em> it (add it to the set of overloads considered by unqualified <code>swap</code>), allowing it to be found.</p>
"
"<blockquote>
  <p><strong>Possible Duplicates:</strong><br>
  <a href=""http://stackoverflow.com/questions/5116541/difference-between-creating-object-with-or-without"">Difference between creating object with () or without</a><br>
  <a href=""http://stackoverflow.com/questions/877523/error-request-for-member-in-which-is-of-non-class-type"">error: request for member &hellip; in &hellip; which is of non-class type &hellip;</a>  </p>
</blockquote>



<p>I was working through some homework in my C++ class for college, and I ran into an interesting error. </p>

<p>birthdayInfo.cpp:43: error: request for member ‘setName’ in ‘myperson’, which is of non-class type ‘Person()’</p>

<p>Looking at line 43, I thought the object initializer was correct,</p>

<pre><code>Person myperson();
</code></pre>

<p>However when I removed the ()'s after the object declaration it compiled. Why does C++ refuse to init an ""empty"" object with parenthesis after the declaration? Is this a standard error thrown by the language or just g++?</p>
","87234","","<p>That's a function declaration.</p>
"
"<p>I'm reviewing a piece of code and see a class where an <code>std::vector</code> is stored as a member variable and the size of that <code>std::vector</code> is stored as a separate member variable. Both <code>std::vector</code> and its ""stored copy"" of size are never change during the containing object lifetime and the comments say size is stored separately ""for convenience and for <strong><em>cases when an implementation computes the size each time</em></strong>"".</p>

<p>My first reaction was ""WT*? Should't it be always trivial to extract <code>std::vector</code>s size?""</p>

<p>Now I've carefully read 23.2.4 of C++ Standard and can't see anything saying whether such implementations are allowed in the first place and I can't imagine why it would be necessary to implement <code>std::vector</code> in such way that its current size needs non-trivial computations.</p>

<p>Is such implementation that <code>std::vector::size()</code> requires some non-trivial actions allowed? When would having such implementation make sense?</p>
","87234","","<p>C++03 says in Table 65, found in §23.1, that <code>size()</code> should have a constant complexity. (In C++0x, this is required for all containers.) You'd be hard-pressed to find a <code>std::vector&lt;&gt;</code> where it's not.</p>

<p>Typically, as Steve says, this is just the difference between two pointers, a simple operation.</p>
"
"<p>Ive look everywhere and whatever algorithm I find (if any lol) for insertion sort on a vector in c++, it wont work so im assuming it has something to do with my code. Can anyone help me find a way I can pass a vector into a method as an argument and then do an insertion sort on it? At the moment it waits for a few seconds and shows all the values unsorted :(</p>

<p>Insertion Sort Code</p>

<pre><code>void insertionSort (vector&lt;int&gt; data, int n) 
{
int i, j, tmp;

 for (i=1; i&lt;n; i++)
 {
     j=i;
     tmp=data[i];
     while (j&gt;0 &amp;&amp; tmp&lt;data[j-1])
     {
           data[j]=data[j-1];
           j--;
     }
     data[j]=tmp;
 }
</code></pre>

<p>The important part of the code</p>

<pre><code>        cout &lt;&lt; ""insertion sort"" &lt;&lt; endl;
        system(""pause"");
        insertionSort(numberVectors, i);
</code></pre>

<p>let me know if you dont think theres anything wrong with that code and you want me to show you more, should just be this bit though, the other stuff is irrelavent i think</p>

<p>thanks</p>
","87234","","<p>Your function accepts its argument by value; this means it gets a <em>copy</em>. You sort the copy, in vain.</p>

<p>Change it to a reference instead:</p>

<pre><code>void insertionSort (vector&lt;int&gt;&amp; data, int n) 
</code></pre>
"
"<p>I have written a function template for serialization of enums to/from our stream class (Yes, I know boost::serialization, but it is not an option in my situation). Enums by convention in our company are serialized as <code>int</code>:</p>

<pre><code>template&lt;typename T&gt;
Stream&amp; operator&lt;&lt;( Stream&amp; s, T const&amp; value )
{
    s &lt;&lt; ( int ) value;
}

template&lt;typename T&gt;
Stream&amp; operator&gt;&gt;( Stream&amp; s, T &amp; value )
{
    int v;
    s &gt;&gt; v;
    value = (T) v;
}
</code></pre>

<p>These are simple templates, and they work nicely also in my function templates for (de)serializing a vector of enumeration items. I'm worried though that they are overly generic, i.e. that they get applied also for types <code>T</code> that are not <code>enums</code> but can be cast to/from an <code>int</code>. Can I improve the enum-serialization templates (or maybe the vector-serialization templates) to make sure they only apply to vectors of <code>enum</code>s? </p>
","87234","","<p>There are two improvements to be made here: not always serializing as <code>int</code> (not all enums are), but as whatever the underlying type is. And, as your request, to only accept enums.</p>

<p>The latter is easily solved with <code>std::enable_if</code> and <code>std::is_enum</code>:</p>

<pre><code>typename std::enable_if&lt;std::is_enum&lt;T&gt;::value, Stream&amp;&gt;::type
    operator&lt;&lt;( Stream&amp; s, T const&amp; value )

// and likewise for operator&gt;&gt;
</code></pre>

<p>And for the former, do the following inside the function:</p>

<pre><code>Stream&amp; operator&lt;&lt;( Stream&amp; s, T const&amp; value )
{
    typedef typename std::underlying_type&lt;T&gt;::type safe_type;
    s &lt;&lt; static_cast&lt;safe_type&gt;(value);
}

// and likewise for operator&gt;&gt;
</code></pre>

<p>This requires C++0x.</p>

<p>If that's not an option, both <code>enable_if</code> and <code>is_enum</code> can be found within Boost. However, I think you'll <a href=""http://stackoverflow.com/questions/1528374/how-can-i-extend-a-lexical-cast-to-support-enumerated-types"">need to make <code>underlying_type</code> yourself</a>. (And of course, in the worse case you can do all three yourself, though <code>is_enum</code> can be a pain, if I recall correctly.)</p>
"
"<p>I had a multi-thread program which execute from dos prompt, there are some prints and outputs dump to dos console using std::cout, but when thread1 and thread2 finished it jobs and then join() to main app, some printouts and outputs were overlapped and not aligned (no newline,running into each other). </p>

<p>Sometime they are ok. If you have some advises, I am really appreciate for your helps. </p>

<p>Andrew</p>
","87234","","<p>Well, it's simple. Output has no concurrency control, you're getting data races. You need to have your threads lock a mutex before they use output, then release it when they're done.</p>
"
"<p>I recently stumbles across some problem with initializer lists. Consider a program that stores map-like data</p>

<pre><code>struct MyMapLike {
  MyMapLike(std::map&lt;std::string, int&gt; data)
    :data(std::move(data))
  { }

private:
  std::map&lt;std::string, int&gt; data;
};
</code></pre>

<p>That looks straight forward. But when initializing it, it becomes ugly. I want to let it look like</p>

<pre><code>MyMapLike maps = { { ""One"", 1 }, { ""Two"", 2 } };
</code></pre>

<p>But the compiler doesn't want to accept this, because the above means that it should look for a two-parameter constructor that can accept <code>{ ""One"", 1 }</code> and <code>{ ""Two"", 2 }</code> respectively. I need to add extra braces, to make it look like a single-parameter constructor accepting the <code>{ { ... }, { ... } }</code></p>

<pre><code>MyMapLike maps = { { { ""One"", 1 }, { ""Two"", 2 } } };
</code></pre>

<p>I would not like to write it like that. Since I have a map-like class, and the initializer has the abstract value of a mapping-list, I would like to use the former version, and be independent of any such implementation details like level of nesting of constructors. </p>

<p>One work around is to declare an initializer-list constructor</p>

<pre><code>struct MyMapLike {
  MyMapLike(std::initializer_list&lt; 
    std::map&lt;std::string, int&gt;::value_type
    &gt; vals)
    :data(vals.begin(), vals.end())
  { }

  MyMapLike(std::map&lt;std::string, int&gt; data)
    :data(std::move(data))
  { }

private:
  std::map&lt;std::string, int&gt; data;
};
</code></pre>

<p>Now I can use the former, because when I have an initializer-list constructor, the whole initializer list is treated as one element instead of being splitted into elements. But I think this separate need of the constructor is dead ugly. </p>

<p>I'm looking for guidance:</p>

<ul>
<li>What do you think about the former and latter form of initialization? Does it make sense to be required to have extra braces in this case?</li>
<li>Do you consider the requirement for addition of an initializer list constructor in this case bad?</li>
</ul>

<p>If you agree with me on that the former way of initialization is nicer, what solutions can you think of?</p>
","87234","","<blockquote>
  <p>Since I have a map-like class, and the initializer has the abstract value of a mapping-list, I would like to use the former version</p>
</blockquote>

<p>And herin lies the problem: it's up to <em>you</em> to supply the constructors that allow <em>your</em> class to be treated like a map. You called your solution a work-around, but there's nothing to work around. :)</p>

<blockquote>
  <p>But I think this separate need of the constructor is dead ugly.</p>
</blockquote>

<p>It is, but unfortunately since it's your class, you have to specify how the initializer lists work.</p>
"
"<p>The following code</p>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

std::string const&amp; at(std::vector&lt;std::string&gt; const&amp; n, int i)
{
    return n[i];
}

std::vector&lt;std::string&gt; mkvec()
{
    std::vector&lt;std::string&gt; n;
    n.push_back(""kagami"");
    n.push_back(""misao"");
    return n;
}

int main()
{
    std::string const&amp; s = at(mkvec(), 0);
    std::cout &lt;&lt; s &lt;&lt; std::endl; // D'oh!
    return 0;
}
</code></pre>

<p>may lead to crash because the original vector is already destructed there. In C++ 2011 (c++0x) after rvalue-reference is introduced in, a <strong>deleted function</strong> declaration can be used to completely forbid calls to <code>at</code> if the vector argument is an rvalue</p>

<pre><code>std::string const&amp; at(std::vector&lt;std::string&gt;&amp;&amp;, int) = delete;
</code></pre>

<p>That looks good, but the following code still cause crash</p>

<pre><code>int main()
{
    std::string const&amp; s = mkvec()[0];
    std::cout &lt;&lt; s &lt;&lt; std::endl; // D'oh!
    return 0;
}
</code></pre>

<p>because calls to member function <code>operator [] (size_type) const</code> of an rvalue object is still allowed. Is there any way can I forbid this kind of calls?</p>

<p>FIX:</p>

<p>The examples above is not what I did in real projects. I just wonder if C++ 2011 support any member function qualifying like</p>

<pre><code>class A {
    void func() rvalue; // Then a call on an rvalue object goes to this overload
    void func() const;
};
</code></pre>

<p>FIX:</p>

<p>It's great, but I think C++ standard goes too far at this feature. Anyway, I have following code compiled on clang++ 2.9</p>

<pre><code>#include &lt;cstdio&gt;

struct A {
    A() {}

    void func() &amp;
    {
        puts(""a"");
    }

    void func() &amp;&amp;
    {
        puts(""b"");
    }

    void func() const &amp;
    {
        puts(""c"");
    }
};

int main()
{
    A().func();
    A a;
    a.func();
    A const b;
    b.func();
    return 0;
}
</code></pre>

<p>Thanks a lot!</p>
","87234","","<p>No, and you shouldn't. How am I to do <code>std::cout &lt;&lt; at(mkvec(), 0) &lt;&lt; std::endl;</code>, a perfectly reasonable thing, if you've banned me from using <code>at()</code> on temporaries?</p>

<p>Storing references to temporaries is just a problem C++ programmers have to deal with, unfortunately.</p>

<hr>

<p>To answer your new question, yes, you can do this:</p>

<pre><code>class A {
    void func() &amp;; // lvalues go to this one
    void func() &amp;&amp;; // rvalues go to this one
};

A a;
a.func(); // first overload

A().func(); // second overload
</code></pre>
"
"<p>Is there a data type like vector or queue where you can easily add items, but when they get added, they are automatically inserted in the right order?</p>

<p>Also is there an easy way to delete an item from a vector or queue if you know what it is, without having to actually search through and find it?</p>
","87234","","<p>Sounds like you want <code>std::set</code> or <code>std::multi_set</code>.</p>
"
"<p>I came across on a strange behavior of the following code, while playing around with initialization of ints using g++ 4.4.3. </p>

<pre><code>  int main()

    {

        int x(int());

        int y = int();

        cout &lt;&lt; x &lt;&lt; ""  "" &lt;&lt; y &lt;&lt;  endl;
    }
</code></pre>

<p>the result is: </p>

<p>1 0</p>

<p>The value of ""y"" is 0 as expected, but the value of x is strangely ""1""! </p>

<p>On VS2008 yields the following link error (a function declaration, but without definition):</p>

<pre><code>unresolved external symbol ""int __cdecl x(int (__cdecl*)(void))""
</code></pre>

<p>Can anyone explain this strange behavior of g++? </p>
","87234","","<p><code>int x(int());</code> is parsed as function declaration.</p>

<p>It declares a function named <code>x</code>, returning an <code>int</code> and accepting one parameter, which has the type of a function returning an <code>int</code> and accepting no arguments.</p>

<p>This is known as the most vexing parse.</p>
"
"<p>This is a follow up question to this question: <a href=""http://stackoverflow.com/questions/3321283/c0x-lambda-how-can-i-pass-as-a-parameter"">Lambda how can I pass as a parameter</a></p>

<p>MSDN supposedly has marked the item as fixed. I took a look at the specifications, but I'm having trouble converting their specifications into what the syntax should be.</p>

<p>So for example:</p>

<pre><code>void printOut(int(*eval)(int))
{
    for(int x = 0; x &lt; 4; ++x)
    {
        std::cout &lt;&lt; eval(x) &lt;&lt; std::endl;
    }
}
</code></pre>

<p>Now say I have the lambda:</p>

<pre><code>auto lambda1 = [](int x)-&gt;int{return x;};
</code></pre>

<p>What is the syntax to convert <code>lambda1</code> into the functional pointer equivalent so it can be passed to <code>printOut</code>?</p>

<p>Also, what about lambdas which actually have something in the brackets? For example:</p>

<pre><code>int y = 5;
auto lambda2 = [y](void)-&gt;int{return y;};
</code></pre>

<p>If this kind of lambda can't be converted to a function pointer, is there an alternative method for passing this type of lambda expression to <code>printOut</code> (or even a modified version of <code>printOut</code>, if so what's the syntax)?</p>
","87234","","<p>There is no syntax per se, it's an implicit conversion. Simply cast it (explicitly or implicitly) and you'll get your function pointer. However, this was fixed after Visual Studio 2010 was released, so is not present.<sup>†</sup></p>

<hr>

<p>You cannot make a capture-full lambda into a function pointer ever, as you noted, so it's the function <code>printOut</code> that'll have to change. You can either generalize the function itself:</p>

<pre><code>// anything callable
template &lt;typename Func&gt;
void printOut(Func eval) 
{
    // ...
}
</code></pre>

<p>Or generalize the function type in particular:</p>

<pre><code>// any function-like thing that fits the int(int) requirement
void printOut(std::function&lt;int(int)&gt; eval) 
{
    // ...
}
</code></pre>

<p>Each has their own trade-off.</p>

<hr>

<p>†As far as I know, it's unknown of we'll get it in a service pack, or if we need to wait until a new release.</p>
"
"<p>If I do not define a default constructor in a class in C++ , or any other constructors, I have read that the compiler creates a default constructor for you. But I created a test class, compiled it to assembly code and checked to find that nothing of the sort is created.<br>
Can someone clarify how the code for default constructor is created, or if it is created in the first place?</p>
","87234","","<p>C++ != Assembly.</p>

<p>Assembly is (one possible) output for a compiled C++ program, which may or may not have included certain optimizations which could have elided the call to a possibly empty constructor.</p>

<p>In other words, the language says there's a default constructor all right, but it only describes behavior, not implementation. If an implementation feels like it doesn't need to generate code, it doesn't have to.</p>
"
"<p>I understand the need for virtual inheritance when using multiple inheritance -- it solves the Dreaded Diamond Problem.</p>

<p>But what if I'm not using multiple inheritance?  <strong>Is there a need for virtual inheritance at all?</strong></p>

<p>I seem to recall hearing that it was important for exceptions (throw a derived class, catch by base class reference).  But shouldn't virtual destructors be sufficient for that?</p>

<p>I've tried searching for the reference page I once saw on this, but I can't seem to find it.</p>
","87234","","<p>You're probably thinking about this <a href=""http://www.boost.org/doc/libs/1_46_1/libs/exception/doc/using_virtual_inheritance_in_exception_types.html"" rel=""nofollow"">Boost.Exception guideline</a>, which I'll copy here for completeness:</p>

<hr>

<h2>Using Virtual Inheritance in Exception Types</h2>

<p>Exception types should use virtual inheritance when deriving from other exception types. This insight is due to Andrew Koenig. Using virtual inheritance prevents ambiguity problems in the exception handler:</p>

<pre><code>#include &lt;iostream&gt;
struct my_exc1 : std::exception { char const* what() const throw(); };
struct my_exc2 : std::exception { char const* what() const throw(); };
struct your_exc3 : my_exc1, my_exc2 {};

int
main()
    {
    try { throw your_exc3(); }
    catch(std::exception const&amp; e) {}
    catch(...) { std::cout &lt;&lt; ""whoops!"" &lt;&lt; std::endl; }
    }
</code></pre>

<p>The program above outputs ""whoops!"" because the conversion to std::exception is ambiguous.</p>

<p>The overhead introduced by virtual inheritance is always negligible in the context of exception handling. Note that virtual bases are initialized directly by the constructor of the most-derived-type (the type passed to the throw statement, in case of exceptions.) However, typically this detail is of no concern when boost::<a href=""http://www.boost.org/doc/libs/1_46_1/libs/exception/doc/exception.html"" rel=""nofollow"">exception</a> is used, because it enables exception types to be trivial structs with no members (there's nothing to initialize.) <a href=""http://www.boost.org/doc/libs/1_46_1/libs/exception/doc/exception_types_as_simple_semantic_tags.html"" rel=""nofollow"">See Exception Types as Simple Semantic Tags</a>.</p>
"
"<pre><code>//THIS IS JUST A FRAGMENT OF A static_numeric_limits.h for the purpose of this example   
 #include &lt;limits.h&gt;

    template&lt;class T&gt;
    struct static_numeric_limits;

    template&lt;&gt;
    struct static_numeric_limits&lt;signed char&gt;
    {/*min was outside of range for enum*/
        static const signed char min = SCHAR_MIN,
                                 max = SCHAR_MAX;
    };

    /*This ""surplus"" template is here for the reason that char is threated differently from signed char */
    template&lt;&gt;
    struct static_numeric_limits&lt;char&gt;
    {/*min was outside of range for enum*/
        static const char min = SCHAR_MIN,
                          max = SCHAR_MAX;
    };

    template&lt;&gt;
    struct static_numeric_limits&lt;unsigned char&gt;
    {
        static const unsigned char min = 0x0,
                             max = UCHAR_MAX;
    };
 ///REAL PROBLEM STARTS FROM HERE      
     template&lt;class IntType,IntType low_range = static_numeric_limits&lt;IntType&gt;::min&gt;
    struct Int
    {
        Int():value_(IntType())
        {}
        Int(const IntType&amp; pattern)
        {
            value_ = (pattern);
        }
        constexpr inline IntType getValue()const
        {
            return value_;
        }
    private:
        IntType value_;
    };

    template&lt;class IntType,class IntType_1&gt;
    auto operator+
        (Int&lt;IntType&gt;&amp; lhs, Int&lt;IntType_1&gt;&amp; rhs)
        -&gt; Int&lt;decltype(lhs.getValue() + rhs.getValue())&gt;//HERE IS THE PROBLEM
    {
        return lhs.getValue() + rhs.getValue();
    }
</code></pre>

<p><strong>Error</strong> (from VS2010) 
<code>error C2027: use of undefined type 'static_numeric_limits&lt;T&gt;'</code><br>
<strong>Error</strong> (from gcc 4.6)<br>
<code>error: 'decltype ((lhs-&gt;getValue() + rhs-&gt;getValue()))' is not a valid type for a template constant parameter</code>  </p>

<p>Why doesn't this work as I thought it would?</p>
","87234","","<p>The error here is what type <code>decltype</code> is deducing from your expression; unfortunately the error messages aren't clear about it, and it's actually a bit of a tricky problem.</p>

<p>Consider the type of the expression <code>0 + 0</code>. It's an <code>int</code>, yes, but more importantly it's an <em>rvalue</em> (informally, it's a temporary). This means that <code>decltype(0 + 0)</code> is not <code>int</code>, but <code>int&amp;&amp;</code>. Now consider that your code isn't any different, in this regard: you still have an rvalue.</p>

<p>The problem is that template non-type parameters cannot be rvalue references, so you cannot have <code>Int&lt;int&amp;&amp;&gt;</code>, because of the second parameter's type . What you can do, though is this:</p>

<pre><code>#include &lt;type_traits&gt;

// ...

template &lt;class IntType, class IntType_1&gt;
auto operator+(const Int&lt;IntType&gt;&amp; lhs, // be const-correct!
                const Int&lt;IntType_1&gt;&amp; rhs)
                -&gt; Int&lt;typename std::remove_reference&lt;
                        decltype(lhs.getValue() + rhs.getValue())&gt;::type&gt;
{
    return lhs.getValue() + rhs.getValue();
}
</code></pre>

<p>This takes the reference off <code>int&amp;&amp;</code>, giving you the bare <code>int</code> type. Hopefully gcc's error message makes a bit more sense: it's trying to tell you that you can't use <code>int&amp;&amp;</code> for your non-type parameter.</p>

<hr>

<p>Another problem, though probably a non-issue, is that integer arithmetic undergoes what's called the <a href=""http://stackoverflow.com/questions/4814668/addition-of-two-chars-produces-int/4814901#4814901""><em>usual arithmetic conversions</em></a>. So the result of adding the values of two <code>Int&lt;char&gt;</code>'s is actually going to be an <code>int</code>, so your return type should be <code>Int&lt;int&gt;</code> (and is, with the fixed code).</p>

<p>The problem, then, is that you haven't defined <code>static_numeric_limits&lt;int&gt;</code>. But like I said, I suspect this is a non-issue and you do actually have it defined, just not displayed in your question.</p>
"
"<p>I am trying to figure out why I keep getting the compiler error </p>

<p><strong>IntelliSense: no operator "">>"" matches these operands</strong></p>

<p>with the code below. Would appreciate any help given. Thanks </p>

<pre><code>#include ""stdafx.h""
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;

 int main(void)
 {
      int n;//number of resources we will  be dealing with 
      cout &lt;&lt;""What is number of resources to be shared?""&lt;&lt;
      cin &gt;&gt; n;
      return 0;
 }
</code></pre>
","87234","","<p>Hint:</p>

<pre><code>cout &lt;&lt;""What is number of resources to be shared?""&lt;&lt;
cin &gt;&gt; n;
</code></pre>

<p>Is the same as:</p>

<pre><code>cout &lt;&lt;""What is number of resources to be shared?""&lt;&lt; cin &gt;&gt; n;
</code></pre>

<hr>

<p>Perhaps <code>&lt;&lt;</code> should be followed by something like <code>std::endl;</code>, just or changed to a <code>;</code>.</p>
"
"<p>I was wondering whether the following is undefined behavior</p>

<pre><code>// Case 1:
int *p = 0;
int const *q = *const_cast&lt;int const* const*&gt;(&amp;p);

// Case 2: (I think this is the same)
int *p = 0;
int const *const *pp = &amp;p;
int const *q = *pp;
</code></pre>

<p>Is this undefined behavior by reading a <code>int*</code> as if it were a <code>int const*</code>? I think it is undefined behavior, but I previously thought that only adding <code>const</code> in general is safe, so I'm unsure. </p>
","87234","","<p>Qualification-wise, it's fine. With each expression split into a statement:</p>

<pre><code>int *p = 0; // ok
int **addrp = &amp;p; // ok
int const *const *caddrq = addrp; // ok, qualification conv. according to §4.4/4
int const *q = *caddrq; // ok
</code></pre>

<p>Note that the rules of <code>const_cast</code> (§5.2.11/3) are identical to those of qualification conversion, but without the requirement of being monotonically increasing in qualification. In your case, because you're only ever adding qualifications the <code>const_cast</code> is unnecessary.</p>

<hr>

<p>Concerning aliasing, I don't think it's an issue, here, or at least it's not intended to be.</p>

<p>Like you mentioned, there's a new bullet in the C++0x list of allowed access methods (§3.10) that allows similar types (""similar"" being types arising from qualification conversions). In C++03 that bullet is missing, but I suspect that the bullet about allowing more cv-qualified access was meant to cover that, but it technically isn't so (that is, the commitee overlooked this).</p>
"
"<p>A <code>std::map</code> must satisfy the requirements of an associative container specified in paragraph 23.1.2/2:</p>

<blockquote>
  <p>Each associative container is
  parameterized on Key and an ordering
  relation Compare that induces a strict
  weak ordering (25.3) on elements of
  Key. In addition, map and multimap
  associate an arbitrary type T with the
  Key. The object of type Compare is
  called the comparison object of a
  container. This comparison object may
  be a <strong>pointer to function</strong> or an object
  of a type with an appropriate function
  call operator.</p>
</blockquote>

<p>But then in paragraph 23.3.1/2 the <code>std::map</code> template is specified as:</p>

<pre><code>template &lt;class Key, class T, class Compare = less&lt;Key&gt;,
          class Allocator = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
class map;
</code></pre>

<p>which seems to explicitly prohibit the use of a function pointer as <code>Compare</code>. Is this a contradiction or am I not understanding the standard correctly?</p>

<p><strong>EDIT:</strong> Yes, the problem I was really having was why code like GMan's example:</p>

<pre><code>struct foo
{
    int x;
};

bool compare_foo(const foo&amp; x, const foo&amp; y)
{
    return x.x &lt; y.x;
}

std::map&lt;foo, bool, compare_foo&gt; fooMap;
</code></pre>

<p>wouldn't compile (yeah, I stupidly mixed up the type and value of the <code>Compare</code> parameter).</p>
","87234","","<p>Specify it like this:</p>

<pre><code>struct foo
{
    int x;
};

bool compare_foo(foo x, foo y)
{
    return x.x &lt; y.x;
}

//                  vvvvvvvvvvvvvvvvv function pointer type
std::map&lt;foo, bool, bool(*)(foo, foo)&gt; fooMap(compare_foo);
//                     function pointer value ^^^^^^^^^^^
</code></pre>
"
"<p>Consider the following classes:</p>

<pre><code>class Coord
{
public:
    double _x, _y;

    Coord(double x, double y)
    {
        _x = x;
        _y = y;
    }
};

class NamedPoint : public Coord
{
public:
    int _id;

    NamedPoint(int id, double x, double y) :
        Coord(x,y),
        _id(id)
    {
    }
};
</code></pre>

<p>I'd like to create a member function of NamedPoint -- coord() -- that returns a reference of type Coord corresponding to the NamedPoint.</p>

<p>For example, I'd like to something like:</p>

<pre><code>const Coord&amp; NamedPoint::coord()
{
    return ((Coord)*this);
}
</code></pre>

<p>But I get a warning about temporary variables and I'm not crazy about it.</p>

<p>Of course, the following works:</p>

<pre><code>Coord coord()
{
    Coord c = *this;
    return c;
}
</code></pre>

<p>But I'd rather return a reference.</p>

<p>Does anyone know if this is possible using inherited classes?</p>

<p>Sorry for not explaining the point of the function.  I'm overloading the == operator differently for Coord and NamedPoint.  Coord would simply check {x,y} and NamedPoint would check {id,x,y}.  If I forget to cast a NamedPoint to a Coord before this == test, I'll use the wrong version.  </p>

<p>So, while I realize that </p>

<pre><code>(Coord)np1 == (Coord)np2 
</code></pre>

<p>would give me what I want, I'd rather use something like </p>

<pre><code>np1.coord() == np2.coord()
</code></pre>

<p>which I think is more clear as to what is going on.</p>
","87234","","<p>What's the point of the function? <code>NamedPoint</code> is implicitly convertible to <code>Coord</code> anyway:</p>

<pre><code>void foo(Coord&amp; c)
{
    c._x = 5;
}

NamedCoord nc(0, 1, 2);
foo(nc); // c references the Coord part of nc
</code></pre>

<p>Anyway, your function should simply use this conversion:</p>

<pre><code>const Coord&amp; NamedPoint::coord()
{
    // Bad: takes the value of *this and slices off
    // the derived bits, leaving a temporary Coord.
    /* return ((Coord)*this); */

    // Good: takes the value of *this and refers
    // to the base bits, no temporaries.
    return *this;

    // (Same as:)
    /* return ((Coord&amp;)*this); */
}
</code></pre>
"
"<p>I have a map which represents a configuration.  It's a map of <code>std::string</code> and <code>boost::any</code>.  </p>

<p>This map is initialized at the start and I'd like the user to be able to override these options on the command line.</p>

<p>What I'd love to do is build the program options from this map using the <code>options_description::add_option()</code> method.  However, it takes a template argument <code>po::value&lt;&gt;</code> whereas all I have is <code>boost::any</code>.</p>

<p>So far, I just have the shell of the code.  <code>m_Config</code> represents my configuration class, and <code>getTuples()</code> returns a <code>std::map&lt;std::string, Tuple&gt;</code>.  <code>TuplePair</code> is a typedef of <code>std::pair&lt;std::string, Tuple&gt;</code> and the Tuple contains the <code>boost::any</code> I am interested in.</p>

<pre><code>    po::options_description desc;
    std::for_each(m_Config.getTuples().begin(),
                  m_Config.getTuples().end(),
                  [&amp;desc](const TuplePair&amp; _pair)
    {
            // what goes here? :)
            // desc.add_options() ( _pair.first, po::value&lt;???&gt;, """");
    });
</code></pre>

<p>Is there a way to build it this way, or do I need to resort to doing it myself?</p>

<p>Thanks in advance!</p>
","87234","","<p><code>boost::any</code> is not applicable to your problem. It performs the most basic form of type erasure: storage and (type-safe) retrieval, and that's it. As you've seen, no other operations can be performed. As jhasse points out, you could just test every type you want to support, but this is a maintenance nightmare.</p>

<p>Better would be to expand upon the idea <code>boost::any</code> uses. Unfortunately this requires a bit of boiler-plate code. If you'd like to try it, there's a new Boost library being discussed right now on the mailing list (titled ""[boost] RFC: type erasure"") that is essentially a generalized type erasure utility: you define the operations you'd like your erased type to support, and it generates the proper utility type. (It can simulate <code>boost::any</code>, for example, by requiring the erased type be copy-constructible and type-safe, and can simulate <code>boost::function&lt;&gt;</code> by additionally requiring the type be callable.)</p>

<p>Aside from that, though, your best option is probably to write such a type yourself. I'll do it for you:</p>

<pre><code>#include &lt;boost/program_options.hpp&gt;
#include &lt;typeinfo&gt;
#include &lt;stdexcept&gt;

namespace po = boost::program_options;

class any_option
{
public: 
    any_option() :
    mContent(0) // no content
    {}

    template &lt;typename T&gt;
    any_option(const T&amp; value) :
    mContent(new holder&lt;T&gt;(value))
    {
        // above is where the erasure happens,
        // holder&lt;T&gt; inherits from our non-template
        // base class, which will make virtual calls
        // to the actual implementation; see below
    }

    any_option(const any_option&amp; other) :
    mContent(other.empty() ? 0 : other.mContent-&gt;clone())
    {
        // note we need an explicit clone method to copy,
        // since with an erased type it's impossible
    }

    any_option&amp; operator=(any_option other)
    {
        // copy-and-swap idiom is short and sweet
        swap(*this, other);

        return *this;
    }

    ~any_option()
    {
        // delete our content when we're done
        delete mContent;
    }

    bool empty() const
    {
        return !mContent;
    }

    friend void swap(any_option&amp; first, any_option&amp; second)
    {
        std::swap(first.mContent, second.mContent);
    }

    // now we define the interface we'd like to support through erasure:

    // getting the data out if we know the type will be useful,
    // just like boost::any. (defined as friend free-function)
    template &lt;typename T&gt;
    friend T* any_option_cast(any_option*);

    // and the ability to query the type
    const std::type_info&amp; type() const
    {
        return mContent-&gt;type(); // call actual function
    }

    // we also want to be able to call options_description::add_option(),
    // so we add a function that will do so (through a virtual call)
    void add_option(po::options_description desc, const char* name)
    {
        mContent-&gt;add_option(desc, name); // call actual function
    }

private:
    // done with the interface, now we define the non-template base class,
    // which has virtual functions where we need type-erased functionality
    class placeholder
    {
    public:
        virtual ~placeholder()
        {
            // allow deletion through base with virtual destructor
        }

        // the interface needed to support any_option operations:

        // need to be able to clone the stored value
        virtual placeholder* clone() const = 0;

        // need to be able to test the stored type, for safe casts
        virtual const std::type_info&amp; type() const = 0;

        // and need to be able to perform add_option with type info
        virtual void add_option(po::options_description desc,
                                    const char* name) = 0;
    };

    // and the template derived class, which will support the interface
    template &lt;typename T&gt;
    class holder : public placeholder
    {
    public:
        holder(const T&amp; value) :
        mValue(value)
        {}

        // implement the required interface:
        placeholder* clone() const
        {
            return new holder&lt;T&gt;(mValue);
        }

        const std::type_info&amp; type() const
        {
            return typeid(mValue);
        }

        void add_option(po::options_description desc, const char* name)
        {
            desc.add_options()(name, po::value&lt;T&gt;(), """");
        }

        // finally, we have a direct value accessor
        T&amp; value()
        {
            return mValue;
        }

    private:
        T mValue;

        // noncopyable, use cloning interface
        holder(const holder&amp;);
        holder&amp; operator=(const holder&amp;);
    };

    // finally, we store a pointer to the base class
    placeholder* mContent;
};

class bad_any_option_cast :
    public std::bad_cast
{
public:
    const char* what() const throw()
    {
        return ""bad_any_option_cast: failed conversion"";
    }
};

template &lt;typename T&gt;
T* any_option_cast(any_option* anyOption)
{
    typedef any_option::holder&lt;T&gt; holder;

    return anyOption.type() == typeid(T) ? 
            &amp;static_cast&lt;holder*&gt;(anyOption.mContent)-&gt;value() : 0; 
}

template &lt;typename T&gt;
const T* any_option_cast(const any_option* anyOption)
{
    // none of the operations in non-const any_option_cast
    // are mutating, so this is safe and simple (constness
    // is restored to the return value automatically)
    return any_option_cast&lt;T&gt;(const_cast&lt;any_option*&gt;(anyOption));
}

template &lt;typename T&gt;
T&amp; any_option_cast(any_option&amp; anyOption)
{
    T* result = any_option_cast(&amp;anyOption);
    if (!result)
        throw bad_any_option_cast();

    return *result;
}

template &lt;typename T&gt;
const T&amp; any_option_cast(const any_option&amp; anyOption)
{
    return any_option_cast&lt;T&gt;(const_cast&lt;any_option&amp;&gt;(anyOption));
}

// NOTE: My casting operator has slightly different use than
// that of boost::any. Namely, it automatically returns a reference
// to the stored value, so you don't need to (and cannot) specify it.
// If you liked the old way, feel free to peek into their source.

#include &lt;boost/foreach.hpp&gt;
#include &lt;map&gt;

int main()
{
    // (it's a good exercise to step through this with
    //  a debugger to see how it all comes together)
    typedef std::map&lt;std::string, any_option&gt; map_type;
    typedef map_type::value_type pair_type;

    map_type m;

    m.insert(std::make_pair(""int"", any_option(5)));
    m.insert(std::make_pair(""double"", any_option(3.14)));

    po::options_description desc;

    BOOST_FOREACH(pair_type&amp; pair, m)
    {
        pair.second.add_option(desc, pair.first.c_str());
    }

    // etc.
}
</code></pre>

<p>Let me know if something is unclear. :)</p>
"
"<pre><code>struct A
{
    A(int a);
};

struct B
{
    B();
    void b(std::shared_ptr&lt;A&gt; a);
};

int main()
{
    A a(1);
    B b;
    b.b(&amp;a);
}
</code></pre>

<p>So I got this error, sorry guys it's my frist time with the smart pointers!!</p>

<p>Error:</p>

<blockquote>
  <p>no suitable constructor exists to convert from <code>""A *""</code> to <code>""std::tr1::shared_ptr&lt;A&gt;""</code></p>
</blockquote>

<p>How do I fix this problem!?</p>
","87234","","<p>The entire point of a smart pointer is to have ownership. That is, <em>it's</em> responsible for the deallocation of whatever it's pointing it. It simply doesn't make sense to try to tell it to manage something that's already being managed by a completely different system.</p>

<p>In your case, <code>a</code> is already being automatically managed, why would you want to <em>also</em> be managed by a smart pointer? Even if that worked, you'd just be setting yourself for deleting it twice, which is UB.</p>

<p><em>Either</em> give it something to own, like <code>new A(1)</code>, or change <code>b</code> to operate on something it doesn't own.</p>
"
"<p>The Boost.Thread library specification for the move constructor states for </p>

<p>Move Constructor:</p>

<blockquote>
  <p>Effects: Transfers ownership of the
  thread managed by other (if any) to
  the newly constructed boost::thread
  instance.</p>
</blockquote>

<p>whereas for Move Assignment : </p>

<blockquote>
  <p>Transfers ownership of the thread
  managed by other (if any) to *this. 
  If there was a thread previously
  associated with *this then that thread
  is detached.</p>
</blockquote>

<p>Clearly, for move assignment it is explicitly stated that previous thread object becomes detached.</p>

<p>Since the copying of boost::thread object has not been defined, and only moving of ownership is possible, does this mean that with Move Constructor, the previous owner thread does not become detached?</p>

<p>Or is this simply a documentation oversight?</p>
","87234","","<p>You're misunderstanding. Label your thread objects A and B, and the actual thread T.</p>

<p>If B owns T, move constructing A from B means A now owns T, and B owns nothing.<br>
If B owns T, move assigning A from B means A now owns T, and B owns nothing, <em>and whatever A had previously owned is not owned by anything</em> (aka, detached). </p>
"
"<p>I have the following classes:</p>

<pre><code>class A {};

class B { vector&lt;A&gt; vect; };
</code></pre>

<p>I can access an arbitrary A like this:</p>

<pre><code>A a = b.vect[0];
// A *a_ptr = &amp;a;
</code></pre>

<p>But how can I get directly to *a_ptr?</p>

<pre><code>A *a_ptr = &amp;b.vet[0];
</code></pre>

<p>compiles and doesn't give runtime errors, but it points to a wrong memory location.</p>

<p><strong>EDIT:</strong></p>

<p>my real world example: <a href=""http://ideone.com/kP8NK"" rel=""nofollow"">http://ideone.com/kP8NK</a></p>

<p>While Ideone gives the expected ""<code>You are now at 0, 0, 0</code>"", MS VisualStudio compiler yields ""<code>You are now at 6624656, -33686019, -1414812757</code>""</p>
","87234","","<p>It's not ""wrong"", you just missed the difference. Namely:</p>

<pre><code>A a = b.vect[0]; // Makes `a` a *copy* of the vector element
A *a_ptr = &amp;a; // Address of the copy

A *a_ptr2 = &amp;b.vect[0]; // Address of the element, not a copy
</code></pre>

<p>To get the equivalence, you should change your first one to:</p>

<pre><code>A&amp; a = b.vect[0]; // Makes `a` a reference to the vector element
A *a_ptr = &amp;a; // Address of the element, not a copy
</code></pre>

<p>If you're still not getting what you expect after observing this difference, then you'll need to show us your exact example along with how you're determining what ""right"" and ""wrong"" outcomes are.</p>

<hr>

<p>The problem is that <code>std::vector&lt;&gt;::push_back</code> will invalidate references, pointers, and iterators to elements when <code>size() == capacity()</code>, because it needs to allocate a new chunk of memory. Using an invalidated pointer (et al.) leads to undefined behavior, so your results are unknown.</p>

<p>You should store indices instead, and do a trivial look-up to get the actual element. (Note <code>vector</code> remains ordered, so even though your rooms may move in memory, their index is the same.)</p>
"
"<p>When you access elements of an array using array[i], I thought that C++ would take the starting position of the array in memory and add i*sizeof(one array element) and then dereference that address (or do something equivalent to what I just described). However, it seems to me that if you have an array of strings (std::string), each element could be a different size based on the number of characters in the string, so there must be something else going on.</p>

<p>Also, to my understanding, array elements are stored in contiguous memory. If you had strings stored in contiguous memory and then appended more characters to one of them, all of the succeeding strings would have to be moved over.</p>

<p>Can someone explain to me how this works?</p>
","87234","","<p>The string size is constant, but it (at some level) has a <em>pointer</em> to some non-constant-sized data.</p>

<p>The pointer size is constant, the pointee size is not.</p>
"
"<p>The question basically says it all. I'm a noob so make it gentle.</p>
","87234","","<p>Think of a function as some unit that does work. You may <em>call</em> it (ask it to do its work), and it may require some <em>function arguments</em> (values from you that it needs to do its job.) When that work is finished, it might <em>return</em> something back to you.</p>

<p>For example, a vending machine. The machine is a function: you give it some money, it returns a soda. To you, you ""called"" the vending machine with some arguments (money), and it gave you a return value. To the machine, it was a function that was called with some arguments (which is saved in its bank), and then used a <em>return statement</em> (the crux of your question) to give the caller (you) your return value.</p>
"
"<p>I'm trying to get familiar with C++ templates. I need to write a template of function that concatenates 2 arrays:</p>

<pre><code>template&lt;typename T, int Size&gt;
class Array
{
public:
    void push(int i, const T&amp; t) { _elem[i] = t; }
private:
    T _elem[Size];
};
</code></pre>

<p>For example I have 2 arrays:</p>

<pre><code>Array&lt;int,3&gt; a1;
Array&lt;int,4&gt; a2;
</code></pre>

<p>I don't know how to write this function, that will return </p>

<pre><code>Array&lt;int,7&gt;. 
</code></pre>

<p>How should header of this function look like?</p>
","87234","","<p>You could do it like this, as a free-function outside the class:</p>

<pre><code>template &lt;typename T, int SizeA, int SizeB&gt;
Array&lt;T, SizeA + SizeB&gt; join(const Array&lt;T, SizeA&gt;&amp; first,
                                const Array&lt;T, SizeB&gt;&amp; second)
{
    /* ... */
}
</code></pre>

<p>For what it's worth, you should probably use <code>std::size_t</code> from <code>&lt;cstddef&gt;</code> instead of <code>int</code>.</p>
"
"<p>I'm using Boost.Filesystem to create a listing of files in a directory. I use <code>boost::filesystem::recursive_directory_iterator</code> and <code>std::copy</code> to put each path into a std::vector as a <code>boost::filesystem::directory_entry</code> object. I wish to output to the file as std::strings though, so I did the following (\n to avoid the use of &lt;&lt;):</p>

<pre><code>std::vector&lt;boost::filesystem::directory_entry&gt; buffer; //filled with paths
...
std::vector&lt;std::string&gt; buffer_native(buffer.size());
//transform directory_entry into std::string, and add a \n, so output is formatted without use of &lt;&lt;
std::transform(buffer.begin(),buffer.end(),buffer_native.begin(), [](boost::filesystem::directory_entry de)-&gt;std::string
    {
        std::string temp=de.path().string();
        temp+=""\n"";
        return temp;
    }
    buffer.clear();
    std::copy(buffer_native.begin(),buffer_native.end(),std::ostream_iterator&lt;std::string&gt;(out_file));
</code></pre>

<p>However the problem with this is it creates two vectors, the original of which is immediately cleared because it is not needed. This sounds like a perfect place for move semantics, but n3242 only provides the same two overloads of transform as in C++98. Is it possible to implement move semantics with <code>std::transform</code>? If it is not, would writing a custom loop be better?</p>

<p>I'm using GCC 4.5.2 (MinGW) on Windows XP.</p>
","87234","","<p>This looks like a job for <code>make_move_iterator</code>:</p>

<pre><code>std::transform(make_move_iterator(buffer.begin()),
                make_move_iterator(buffer.end()), buffer_native.begin(),
                [](boost::filesystem::directory_entry&amp;&amp; de) -&gt; std::string
{
    // still makes copy :/ perhaps native() would work better, I don't know
    std::string temp = de.path().string();
    temp += ""\n"";

    return temp;
}
</code></pre>

<p>A move iterator is simply an iterator which moves its dereference result. Note that the class needs to support move semantics for this to even make a difference; I don't know if Boost FS does.</p>

<hr>

<p>Note if your goal is to output them on separate lines, you're doing it wrong. Formatted printing shouldn't require the input data be in a certain format, that defeats the purpose. Adding newlines to your data just to format it to have newlines is nasty. It's handled for you by <code>ostream_iterator</code> anyway:</p>

<pre><code>std::copy(buffer.begin(), buffer.end(), //               vvvv
            std::ostream_iterator&lt;std::string&gt;(out_file, ""\n""));
</code></pre>

<p>Anything more complex, make a lambda in for printing; don't modify your data beforehand.</p>
"
"<p>Is this behavior well-defined?</p>

<pre><code>class Foo
{
    int A, B;

    public:

    Foo(int Bar): B(Bar), A(B + 123)
    {
    }
};

int main()
{
    Foo MyFoo(0);
    return 0;
}
</code></pre>
","87234","","<p>No, it's undefined. <code>A</code> will be initialized first (it's first in the class definition), and it uses uninitialized <code>B</code>.</p>

<p>Class members are initialized in the order they appear in the class definition, irrespective of their order in the initialization list. Indeed, it is bad practice to mismatch the member definition order with the initialization list order.</p>

<p>If your instance of <code>Foo</code> happened to have static duration, like in <code>Foo f(0); int main(){}</code>, the behavior is well-defined. Objects with static duration are zero-initialized before any other initialization takes place; in that case, <code>A</code> and <code>B</code> will be 0 when the constructor is run. After that, though, the behavior is the same: first <code>A</code> then <code>B</code>, giving <code>A</code> a value of 123 and <code>B</code> a value of <code>Bar</code> (still ugly).</p>
"
"<p>I am working on a game engine in C++ using Lua to define NPCs.</p>

<p>I can define a prototypic NPC like this:</p>

<pre><code>orc =
{
    name = ""Generic Orc"",
    health = 100
}

function orc:onIdle()
    print(""Orc idles..."")
end
</code></pre>

<p>and then spawn an instance of ""Orc"" with <code>entitySpawn(orc)</code>. This is a C++ function that reads values like health and name from the given table, creates an Entity object in C++ with the given values and in addition creates a Lua table for the specific NPC.</p>

<p>Now, I would like to have a direct connection between the <code>orc.health</code> variable in Lua and the <code>mHealth</code> member variable of the corresponding Entity object in C++, so I could assign a value in Lua and instantly use it in C++ and vice versa.</p>

<p>Is this even possible? Or do I have to make use of setter / getter functions? I have taken a look at light userdata and got to the point of storing a pointer to the C++ variable in Lua, but could not assign a value.</p>
","87234","","<p>I don't have time to give you any code, but keep in mind <code>orc.health</code> is the same as <code>orc[""health""]</code>; that is, <code>orc</code> is a table and <code>""health""</code> is an element.</p>

<p>With that in mind, you can change the <code>index</code> and <code>newindex</code> <a href=""http://www.lua.org/manual/5.1/manual.html#2.8"" rel=""nofollow"">metamethods</a> of your table to have your own specific behavior. Store your ""real"" orc instance as some private metadata, then use it to update.</p>
"
"<p>I have a routine that gets passed a void* to a structure.  In the
routine I cast it to the correct type, e.g.</p>

<pre><code>SomeFunc(void* pMsg) {
  printf(""Event = %d\n"", static_cast&lt;struct MyEventMsg*&gt;(pMsg)-&gt;Event);
}
</code></pre>

<p>If I am accessing many members of the structure the code looks pretty
messy.  I can create a new pointer of the correct type and assign it
the cast void*, but it seems like it shouldn't be necessary to create
a temporary variable just for this purpose.  Is there some way to cast
the parameter pMsg to the correct type?</p>

<p>Thanks
Doug</p>
","87234","","<blockquote>
  <p>but it seems like it shouldn't be necessary to create a temporary variable just for this purpose</p>
</blockquote>

<p>Um, it's not: like you said, you can do a cast in-place.</p>

<p>Make your choice: cast every time (messy) or cast once into a variable of the correct type (clean).</p>
"
"<p>I am trying to understand how the pointers are moving.
Following is the program and I am aware that
if </p>

<pre><code>int cs={1,2,3};  
</code></pre>

<p>then  <code>cs</code> points to <code>cs[0]</code>
what I am not clear is what is *cs pointing to.</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
        int array[] = { 1, 2, 3, 4, 5 };
        int *arrptr1 = array;
        int *arrptr = array;
        int i;
        for (i = 0; i &lt; sizeof(array) / sizeof(int); i++) {
                printf(""%d, %d, %d\n"", array[i], *arrptr1++, *arrptr + i);
        }
}
</code></pre>

<p>the output of above program is </p>

<pre><code>1, 1, 1
2, 2, 2
3, 3, 3
4, 4, 4
5, 5, 5
</code></pre>

<p>then my understanding <code>*arrptr</code> should increase the value stored at</p>

<pre><code>*arrptr
</code></pre>

<p>should get incremented by 1.
Where as what I observe is the pointer is moving to next location.So just want to know what is wrong in my understanding?</p>

<p><strong>UPDATE</strong><br>
As per the replies below I understand that </p>

<pre><code>print(""%d"", *arrptr1++);
</code></pre>

<p>in such a statement evaluation of operators is from right to left.
Hence in <code>*arrptr1++</code>  the <code>++</code> will get evaluated first and then <code>arrptr</code> and then <code>*</code>
So to confirm the same I wrote another program</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
        int array[] = { 10, 20, 30, 40, 50 };
        int *q1 = array;
        printf(""q1 = %p\n"",q1);
      printf(""*q1++ = %d\n"",*q1++);
        printf(""q1 = %p\n"",q1);
      printf(""*q1++ = %d\n"",*q1);
}
</code></pre>

<p>The output of above program is different than the expected operator precedence by above logic.
The output  I got is </p>

<pre><code>q1 = 0x7ffffcff02e0
*q1++ = 10
q1 = 0x7ffffcff02e4
*q1++ = 20
</code></pre>

<p>So I was expecting in the 2nd line of output instead of <code>*q1++ = 10</code> following <code>*q1++ = 20</code>
so did the operator precedence not happened right to left?</p>
","87234","","<p><code>*arrptr1++</code> is parsed as <code>*(arrptr1++)</code>, not <code>(*arrptr1)++</code>.</p>
"
"<p>I did a search for this question thinking that somebody must have asked it before. I did not turn up any results, so if it has been, please post the link and feel free to close the question.</p>

<p>I ran across this code in <a href=""https://github.com/paulhodge/EASTL"" rel=""nofollow"">EASTL</a>:</p>

<pre><code>enum : size_type {   // size_type = size_t                   
                npos     = (size_type)-1,
                kMaxSize = (size_type)-2
            };
</code></pre>

<p>I have never encountered an <code>enum</code> declaration like that. What does the <code>:</code> do in this case?</p>
","87234","","<p>In C++0x, you can specify the underlying type for the enum. In this case, it will be <code>size_type</code>.</p>

<p>(And it may be supported as an extension in other places prior to C++0x, obviously.)</p>
"
"<p>Suppose I am a user of a Certain Template Library (<code>CTL</code>) which defines a template, named, say, <code>Hector</code></p>

<pre><code>template &lt;class T&gt;
class Hector {...};
</code></pre>

<p>And in its documentation it gives many guarantees about <code>Hector</code> template behavior. 
But then it also defines a specialization for a certain type <code>Cool</code></p>

<pre><code>template &lt;&gt;
class Hector&lt;Cool&gt; {....};
</code></pre>

<p>The purpose of the specialization is a more optimized implementation of <code>Hector</code>, but unfortunately  because of this optimization many guarantees of <code>Hector</code> are violated. </p>

<p>Currently I really don't need the optimization, I'd rather preserve all the guarantees of <code>Hector</code>. Is there any way I could, without changing the library code (<code>CTL</code> is a highly respectable library, you know), circumvent the specialization? Any way at all? Maybe write some sort of wrapper? Anything? I just want to the compiler to generate code for <code>Hector&lt;Cool&gt;</code> in a normal, non-optimized way, with all the guarantees.  </p>
","87234","","<p>No. And even if it can be done in some esoteric fashion, don't. Circumventing language features should set off an alarm.</p>

<p>You have to wrap the value or use a different type like <code>char</code> instead of <code>bool</code> (they behave similarly), giving <code>std::vector&lt;char&gt;</code> instead of <code>std::vector&lt;bool&gt;</code>.</p>
"
"<p>With curiosity, I was trying an alternate implementation of <a href=""http://stackoverflow.com/questions/6540948/c-templates-how-to-determine-if-a-type-is-suitable-for-subclassing?answertab=votes#tab-top"">is_class</a> construct using the <code>sizeof()</code> trick. Following is the code:</p>

<pre><code>template&lt;typename T&gt;
struct is_class
{
  typedef char (&amp;yes)[7];
  typedef char (&amp;no)[3];

  static yes check (int T::*);
  static no check (...);

  enum { value = (sizeof(check(0)) == sizeof(yes)) };
};
</code></pre>

<p>Problem is when I instantiate <code>is_class&lt;int&gt;</code>, it gives compile error:</p>

<pre><code>error: creating pointer to member of non-class type ‘int’
</code></pre>

<p>Now, my question is, if <code>int T::*</code> is not applicable for <code>int</code> (or <code>void*</code> etc.) then why <strong>doesn't substitution fail</strong> for <code>yes check</code>. Shouldn't compiler select the <code>no check</code> ?</p>
","87234","","<p><code>yes</code> and <code>no</code> are not templates, SFINAE cannot possibly apply to them. You need to do this:</p>

<pre><code>template&lt;typename T&gt;
struct is_class
{
  typedef char (&amp;yes)[7];
  typedef char (&amp;no)[3];

  template &lt;typename U&gt;
  static yes check (int U::*);

  template &lt;typename&gt;
  static no check (...);

  enum { value = (sizeof(check&lt;T&gt;(0)) == sizeof(yes)) };
};
</code></pre>

<p>Now SFINAE can kick in.</p>
"
"<p>I am designing a template class Policy which needs to be able to handle pointers to other classes.</p>

<pre><code>template &lt;class P&gt;
class Policy
{
  private:   
    const P *state;
  public:
    Policy (P const* s) : state(s){};
};
</code></pre>

<p>This works fine.
Now I want to inherit from the above template class and create new subclasses:</p>

<pre><code>class Greedy : public Policy&lt;???&gt;
{
  public:
    template &lt;typename P&gt; Greedy (P const* s) : Policy(s) {}:
};

class Explora : public Policy&lt;???&gt;
{ 
  public:
    template &lt;typename P&gt; Explora (P const* s) : Policy(s) {}:
};
</code></pre>

<p>Problem is that when defining those classes I do not know what type they will be using for the base template class. Is this even possible to do ?
I want the type obtained from the inherited class constructor (probably templated), and then pass it to the base class construtor.
Can I do that ? If yes, how ? typedefining enums ?
I have seen <a href=""http://stackoverflow.com/questions/5927648/inheriting-from-a-template-class-using-a-type-defined-in-the-derived-class"">this question</a> but it doesn't in my opinion really answer the question.</p>
","87234","","<p>Make them template classes:</p>

<pre><code>template &lt;typename P&gt;
class Greedy : public Policy&lt;P&gt;
{
    // now you know
};
</code></pre>
"
"<p>If I have a constructor with n parameters such that any argument to that can be an rvalue and lvalue. Is it possible to do support this with move semantics for the rvalues without writing 2^n constructors for each possible rvalue/lvalue combination?</p>
","87234","","<p>You take each one by value, like this:</p>

<pre><code>struct foo
{
    foo(std::string s, bar b, qux q) :
    mS(std::move(s)),
    mB(std::move(b)),
    mQ(std::move(q))
    {}

    std::string mS;
    bar mB;
    qux mQ;
};
</code></pre>

<p>The initialization of the function parameters by the argument will either be a copy-constructor or move-constructor. From there, you just move the function parameter values into your member variables.</p>

<p>Remember: <em>copy- and move-semantics are a service provided by the class, not by you</em>. In C++0x, you no longer need to worry about how to get your own ""copy"" of the data; just ask for it and let the class do it:</p>

<pre><code>foo f(""temporary string is never copied"", bar(), quz()); // no copies, only moves
foo ff(f.mS, f.mB, f.mQ); // copies needed, will copy
foo fff(""another temp"", f.mB, f.mQ); // move string, copy others
</code></pre>

<p>Note: your constructor only takes in values, those values will figure out how to construct themselves. From there, of course, it's up to you to move them where you want them.</p>

<p>This applies everywhere. Have a function that needs a copy? Make it in the parameter list:</p>

<pre><code>void mutates_copy(std::string s)
{
    s[0] = 'A'; // modify copy
}

mutates_copy(""no copies, only moves!"");

std::string myValue = ""don't modify me"";
mutates_copy(myValue); // makes copy as needed
mutates_copy(std::move(myValue)); // move it, i'm done with it
</code></pre>

<hr>

<p>In C++03, you could emulate it fairly well, but it wasn't common (in my experience):</p>

<pre><code>struct foo
{
    foo(std::string s, bar b, qux q)
    // have to pay for default construction
    {
        using std::swap; // swaps should be cheap in any sane program

        swap(s, mS); // this is effectively what
        swap(b, mB); // move-constructors do now,
        swap(q, mQ); // so a reasonable emulation
    }

    std::string mS;
    bar mB;
    qux mQ;
};
</code></pre>
"
"<p>Why does this crash after catching std::bad_exception ? (I'm using VC7)</p>

<pre><code>#include ""stdafx.h""
#include &lt;exception&gt;

int validateInt (int x) throw (int,std::bad_exception) {
    if ( 0 == x ) {
        throw std::bad_exception(""x"");
    }
    return x;
}

class C {  
    int i;    
public:  
    C(int);  
};  

C::C(int ii)  
try : i( validateInt(ii) ) {  
    std::cout &lt;&lt; ""I'm in constructor function body\n"";
} catch (std::exception&amp; e) {  
    std::cout &lt;&lt; ""I caught an exception...\n"";
}

int _tmain(int argc, _TCHAR* argv[]) {
    C a(0);
    return 0;
}
</code></pre>
","87234","","<p>Because you cannot stop exceptions from leaving the constructor initialization list. After you catch it, it's rethrown automatically. (It then crashes because you have an unhanded exception.)</p>

<p>This is a good thing: if your members cannot be properly initialized, your class cannot properly exist.</p>
"
"<p>For example, in the following pseudo code, Class B need to call A::Action() through B::m_cb member.<br><br>
The objective is, how to make a general, non-template Callback class, so ""B"" does not have to be a template, and the ""CallBack"" can hold any kind of function signature.<br>
<br>I ever use such code before, but now I can not find that implementation. All I remember is:<br>
- the ""CallBack"" itself is not a template, but it contains member template<br>
- the helper function template make_callback will instantiate CallBack object<br></p>

<p>Can anyone give a poiinter?</p>

<pre><code>Class A
{
public:
   void Action(){//...};
};

class CallBack
{
   //...
   // CallBack it self it is a NOT a template
   // It can wrap member template though
};

class B
{
public:
   void SetCallback(CallBack to){
      m_cb = to;
   }
   void do_something()
   {
      //...
      m_cb.Execute();
      //...
   }

private:
   CallBack m_cb;

};

int main()
{
   A obj1;
   CallBack cb = make_callback(&amp;obj1, &amp;A::Action);
   B obj2;
   obj2.SetCallback(cb);
   //....
   obj2.do_something();
}
</code></pre>

<p>Here is the sample code I got from this same website. 
I tried to improved it a little bit, so it can tolerate arbitrary call back function's return type. But it still can not handle arbitrary number of arguments, like in line 18. Also, , T is the pointer to member function, which should be depend on C. I don't know how to enforce this.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

// INTERNAL CLASSES

class CallbackSpecBase
{
  public:
    virtual ~CallbackSpecBase() {}
    virtual void operator()(...) const = 0;
};

template&lt;class C, class T&gt;
class CallbackSpec : public CallbackSpecBase
{
  public:
    CallbackSpec(C&amp; o, T m) : obj(o), method(m) {}
/*line 18*/    void operator()(...) const { (&amp;obj-&gt;*method)(); } // how to pass ""..."" into method(...)

  private:
    C&amp; obj;
    T method;
};

// PUBLIC API

class Callback
{
  public:
    Callback() {}

    void operator()() { (*spec)(); }

    template&lt;class C, class T&gt;
      void set(C&amp; o, T m) { spec.reset(new CallbackSpec&lt;C, T&gt;(o, m)); }

  private:
    std::auto_ptr&lt;CallbackSpecBase&gt; spec;
};

// TEST CODE

class Test
{
  public:
    void foo() { std::cout &lt;&lt; ""Working"" &lt;&lt; std::endl; }
    void bar() { std::cout &lt;&lt; ""Like a charm"" &lt;&lt; std::endl; }
};

int main()
{
  Test t;
  Callback c;
  c.set(t, &amp;Test::foo);
  c();
  c.set(t, &amp;Test::bar);
  c();
}
</code></pre>
","87234","","<p>What you're looking for is <code>std::function</code> (C++0x) /<code>boost::function</code>. These use type-erasure to make functions act like first-class objects. You can do something like this:</p>

<pre><code>class A
{
public:
    void Action() {//...};
};

class B
{
public:
    template &lt;typename Func&gt;
    void SetCallback(Func func) {
        m_cb = func;
    }

    void do_something() {
        m_cb(); // whatever function
    }

private:
    std::function&lt;void()&gt; m_cb; // anything callable with no arguments
};

int main()
{
    A obj1;
    B obj2;

    obj2.SetCallback(make_callback(&amp;obj1, &amp;A::Action));
    // or:
    obj2.SetCallback(std::bind(&amp;obj1, &amp;A::Action)); // or boost::bind

    obj2.do_something();
}
</code></pre>
"
"<p>Given:</p>

<pre><code>class Hokey
{
public:
    explicit C(int i): i_(i) { }

    template&lt;typename T&gt;
    T&amp; render(T&amp; t) { t = static_cast&lt;T&gt;(i_); return t; }
private:
    unsigned i_;
};
</code></pre>

<p>If I try:</p>

<pre><code>Hokey h(1);
string s;
h.render(s);
</code></pre>

<p><a href=""http://codepad.org/RYv7U02r"" rel=""nofollow"">Codepad</a> gives me an error on the static cast: </p>

<pre><code>t.cpp: In member function 'T&amp; Hokey::render(T&amp;) [with T = std::string]':
t.cpp:21:   instantiated from here
Line 11: error: no matching function for call to 'std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string(unsigned int&amp;)'
</code></pre>

<p>It seems like it should say that there is no <code>Hokey::render</code> to match.</p>

<p>Of course, if I supply a valid overload, everything works.
But given the code below, you uncomment the line, <a href=""http://codepad.org/BO5pok4I"" rel=""nofollow"">codepad chokes again</a>:</p>

<pre><code>string&amp; render(string&amp; s) const {
    ostringstream out;
    out &lt;&lt; i_;
//  s = out.str();
    return s;
}
</code></pre>

<p>Doesn't <a href=""http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error"" rel=""nofollow"">SFINAE</a> say that - in the first case - the problem within render should not be the error, rather the absence of a render that works should be the error?</p>
","87234","","<p>It's only not an error during overload resolution. In other words, it puts off giving you an error until it's sure the call definitely isn't going to work. After that, it's an error.</p>

<pre><code>struct example
{
    template &lt;typename T&gt;
    static void pass_test(typename T::inner_type); // A

    template &lt;typename T&gt;
    static void pass_test(T); // B

    template &lt;typename T&gt;
    static void fail_test(typename T::inner_type); // C
};

int main()
{
    // enumerates all the possible functions to call: A and B
    // tries A, fails with error; error withheld to try others
    // tries B, works without error; previous error ignored
    example::pass_test(5);

    // enumerates all the possible functions to call: C
    // tries C, fails with error; error withheld to try others
    // no other functions to try, call failed: emit error
    example::fail_test(5);
}
</code></pre>

<hr>

<p>It should also be noted that overload resolution (and therefore SFINAE) only looks at the function signature, <em>not the definition</em>. So this will always fail:</p>

<pre><code>struct example_two
{
    template &lt;typename T&gt;
    static int fail_test(T x)
    {
        return static_cast&lt;int&gt;(x);
    }

    template &lt;typename T&gt;
    static int fail_test(T x)
    {
        return boost::lexical_cast&lt;int&gt;(x);
    }
};

int main()
{
    example_two::fail_test(""string"");
}
</code></pre>

<p>There are no errors for either template substitution — for the function signatures — so both functions are okay to call, even though we know the first one will fail and the second won't. So this gives you an ambiguous function call error.</p>

<p>You can explicitly enable or disable functions with <code>boost::enable_if</code> (or <code>std::enable_if</code> in C++0x, equivalent to <code>boost::enable_if_c</code>). For example, you might fix the previous example with:</p>

<pre><code>struct example_two_fixed
{
    template &lt;typename T&gt;
    static boost::enable_if&lt;boost::is_convertible&lt;T, int&gt;, int&gt;
        pass_test(T x) // AA
    {
        return static_cast&lt;int&gt;(x);
    }

    template &lt;typename T&gt;
    static boost::disable_if&lt;boost::is_convertible&lt;T, int&gt;, int&gt;
        pass_test(T x) // BB
    {
        return boost::lexical_cast&lt;float&gt;(x);
    }
};

struct empty {} no_conversion;

int main()
{
    // okay, BB fails with SFINAE error because of disable_if, does AA
    example_two::pass_test(5);

    // okay, AA fails with SFINAE error because of enable_if, does BB
    example_two::pass_test(""string"");

    // error, AA fails with SFINAE, does BB, fails because cannot lexical_cast
    example_two::pass_test(no_conversion);
}
</code></pre>
"
"<p>I've been playing around with C++0x's <code>auto</code> keyword and tried the following.</p>

<pre><code>std::unique_ptr&lt;auto&gt; ptr(new int(0));
</code></pre>

<p>I tried compiling it with g++ 4.4.5 and got</p>

<pre><code>error: invalid use of auto
</code></pre>

<p>Judging by eye, <code>auto</code> can easily be inferred to <code>int</code>.</p>

<p>My guess is the type inference and the template engine don't talk to each other. Otherwise, the template engine would know to instantiate the template class with <code>int</code> as the type parameter.</p>

<p>Another guess is from the standard, I see this.</p>

<pre><code>A member shall not be declared with auto, extern or register storage class.
</code></pre>

<p>But I thought that was the <code>auto</code> as in local variables, not as in <code>auto</code> used to deduce types.</p>

<p>And my last guess is that the compiler thinks this is an <code>auto</code> storage class, not <code>auto</code> for type deduction.</p>

<p>Is there a reason behind this stated in the standard?</p>
","87234","","<p>Just want to add that a solution already exists for most cases:</p>

<pre><code>template &lt;typename T&gt;
std::unique_ptr&lt;T&gt; unique_ptr_auto(T* ptr)
{
    // fails to handle std::unique_ptr&lt;T[]&gt;, not deducible from pointer
    return std::unique_ptr&lt;T&gt;(ptr);
}

auto ptr = unique_ptr_auto(new int(0));
</code></pre>

<p>A bit more verbose, obviously, but you get the idea. These ""generator functions"" are quite common.</p>
"
"<p>In C++ can I reset the function pointer for an operator?</p>

<p>In particular I want to set the member function operator[] to use (or not use) bounds checking. I tried this with no luck:</p>

<p>Is this even possible? If so, Can anyone correct the syntax?</p>

<p>in MyArrayClass.h: </p>

<pre><code>class MyArrayClass {
public:
    bool CheckArrayBounds;
    float BoundsCheck(int i) {
        if (i&lt;_size) 
            return _data[i]; 
        return TCpx(_INVALID); 
    }
    float NoBoundsCheck(int i) {
        return _data[i]; 
    }
    void UseBoundsCheck(bool State) {
        if (State) {
            float (operator[]) = &amp;MyArrayClass::BoundsCheck;
        } else {
            float (operator[]) = &amp;MyArrayClass::NoBoundsCheck;
        }
        CheckArrayBounds = State;
    }
    float operator[](int i) { return _data[i]; };
};
</code></pre>
","87234","","<p>C++ isn't the right kind of language for this, unfortunately. You need a much more powerful type system.</p>

<p>Note that even if you could, <strong>you'd probably slow your program down</strong>: a integer comparison is much more expensive that a function call through a pointer. Especially since your CPU can branch predict: it'll start running code as if it passed the check, and if it ends up failing it can ditch whatever it was doing.</p>

<p>But note your compiler is smart. For example, if we have this:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

void process(std::vector&lt;int&gt;&amp; data)
{
    for (unsigned i = 0; i &lt; data.size(); ++i)
    {
        int v = data.at(i);
        std::cout &lt;&lt; v &lt;&lt; std::endl;
    }
}

int main()
{
    try
    {
        std::vector&lt;int&gt; data;
        std::generate_n(std::back_inserter(data), std::rand() + 1, std::rand);

        process(data);
    }
    catch (...)
    {
        std::cerr &lt;&lt; ""nope.avi"" &lt;&lt; std::endl;
    }
}
</code></pre>

<p>And if we compile with <code>g++ -O3</code>, there is <strong>no bounds checking code</strong>. Indeed, the compiler has deduced that the check inside <code>at()</code> will never pass (which then throws), so it stripped away that code. So you can leave the bounds checking in and your compiler can still strip it away. Note, though, that any more complex cases may make it too hard for the compiler to prove, so you'll pay for it.</p>

<p>These are the kind of optimizations you could guarantee with a more expressive type system, but the compiler can do them anyway. I don't know about MSVC; it tends not to be as smart, but you can check.</p>

<p>Your best bet is to go the <code>std::vector&lt;&gt;</code> route: provide an unchecked <code>operator[]</code> and a checked <code>at()</code>. Let the user of your class decide if they need checks or not.</p>
"
"<p>I'm about to write something myself since I didn't find what I was looking for, but figured I should ask the crowd before diving in.</p>

<ul>
<li>Is there a boost or stl random access container type that allows passing in of prefilled buffer?</li>
</ul>

<p>The imaginary(?) container type would operate something like this:</p>

<pre><code>  const int blobSize = unpackBlobSize( msg );
  int *     blob     = unpackBlobData( msg );

  SpecialVector&lt;int&gt; mySpecialIntVector( blob, blobSize );
</code></pre>

<p>Basically I'm interfacing an old library with c-style raw pointers-to-buffers, but would like to use C++ style container semantics without requiring a copy step. What I would hope to have is std::vector plus preallocated &amp; prefilled buffer constructor and, minus resize.</p>

<p>Libeigen has this sort of functionality with their Eigen::Map which allows things like the following:</p>

<pre><code>  int array[9];
  for(int i = 0; i &lt; 9; ++i) 
      array[i] = i;
  stl::cout &lt;&lt; Eigen::Map&lt;Eigen::Matrix3i&gt;(array) &lt;&lt; stl::endl;
</code></pre>

<p>Anyone know of a boost or stl template that covers these constraints?</p>
","87234","","<p>There's nothing like you want, this is just a shortcoming of the language. If you were satisfied with having the allocator statically guess a good expected maximum element count, you could just embed a normal C array inside an allocator and defer to it as long as possible; this is usually called an auto buffer.</p>

<hr>

<p>Old Answer:</p>

<p>All of the standard library containers allow you to specify an allocator. You can make a buffer allocator.</p>
"
"<p>Is there a way to overload, say the <code>&gt;&gt;</code> operator for function composition? The operator should work seamlessly on lambdas as well as <code>std::function</code>?</p>

<p>Requirements:</p>

<ul>
<li>The solution should not include nested <code>bind</code> calls,</li>
<li>the left operand can be of a functional type with an arbitrary number of parameters, and</li>
<li>no more than one function object instance should be created.</li>
</ul>

<p>Here is a quick and dirty example that illustrates the desired behaviour:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;functional&gt;

using namespace std;

// An example of a quick and dirty function composition.
// Note that instead of 'std::function' this operator should accept
// any functional/callable type (just like 'bind').
template&lt;typename R1, typename R2, typename... ArgTypes1&gt;
function&lt;R2(ArgTypes1...)&gt; operator &gt;&gt; (
                const function&lt;R1(ArgTypes1...)&gt;&amp; f1,
                const function&lt;R2(R1)&gt;&amp; f2) {
    return [=](ArgTypes1... args){ return f2(f1(args...)); };
}

int main(int argc, char **args) {
    auto l1 = [](int i, int j) {return i + j;};
    auto l2 = [](int i) {return i * i;};

    function&lt;int(int, int)&gt; f1 = l1;
    function&lt;int(int)&gt; f2 = l2;

    cout &lt;&lt; ""Function composition: "" &lt;&lt; (f1 &gt;&gt; f2)(3, 5) &lt;&lt; endl;

    // The following is desired, but it doesn't compile as it is:
    cout &lt;&lt; ""Function composition: "" &lt;&lt; (l1 &gt;&gt; l2)(3, 5) &lt;&lt; endl;

    return 0;
}
</code></pre>
","87234","","<p><code>(l1 &gt;&gt; l2)</code> can never work.</p>

<p>They are function objects made by the compiler and don't include that operator, so unless you plan on modifying the compiler to be non-conforming that's how it's always going to be. :)</p>

<p>You can, however, introduce a ""keyword"" (utility class) which is arguably a good thing, but it's hefty:</p>

<pre><code>// https://ideone.com/MS2E3

#include &lt;iostream&gt;
#include &lt;functional&gt;

namespace detail
{
    template &lt;typename R, typename... Args&gt;
    class composed_function;

    // utility stuff
    template &lt;typename... Args&gt;
    struct variadic_typedef;

    template &lt;typename Func&gt;
    struct callable_type_info :
        callable_type_info&lt;decltype(&amp;Func::operator())&gt;
    {};

    template &lt;typename Func&gt;
    struct callable_type_info&lt;Func*&gt; :
        callable_type_info&lt;Func&gt;
    {};

    template &lt;typename DeducedR, typename... DeducedArgs&gt;
    struct callable_type_info&lt;DeducedR(DeducedArgs...)&gt;
    {
        typedef DeducedR return_type;
        typedef variadic_typedef&lt;DeducedArgs...&gt; args_type;
    };

    template &lt;typename O, typename DeducedR, typename... DeducedArgs&gt;
    struct callable_type_info&lt;DeducedR (O::*)(DeducedArgs...) const&gt;
    {
        typedef DeducedR return_type;
        typedef variadic_typedef&lt;DeducedArgs...&gt; args_type;
    };

    template &lt;typename DeducedR, typename... DeducedArgs&gt;
    struct callable_type_info&lt;std::function&lt;DeducedR(DeducedArgs...)&gt;&gt;
    {
        typedef DeducedR return_type;
        typedef variadic_typedef&lt;DeducedArgs...&gt; args_type;
    };

    template &lt;typename Func&gt;
    struct return_type
    {
        typedef typename callable_type_info&lt;Func&gt;::return_type type;
    };

    template &lt;typename Func&gt;
    struct args_type
    {
        typedef typename callable_type_info&lt;Func&gt;::args_type type;
    };

    template &lt;typename FuncR, typename... FuncArgs&gt;
    struct composed_function_type
    {
        typedef composed_function&lt;FuncR, FuncArgs...&gt; type;
    };

    template &lt;typename FuncR, typename... FuncArgs&gt;
    struct composed_function_type&lt;FuncR, variadic_typedef&lt;FuncArgs...&gt;&gt; :
        composed_function_type&lt;FuncR, FuncArgs...&gt;
    {};

    template &lt;typename R, typename... Args&gt;
    class composed_function
    {
    public:
        composed_function(std::function&lt;R(Args...)&gt; func) :
        mFunction(std::move(func))
        {}

        template &lt;typename... CallArgs&gt;
        R operator()(CallArgs&amp;&amp;... args)
        {
            return mFunction(std::forward&lt;CallArgs&gt;(args)...);
        }

        template &lt;typename Func&gt;
        typename composed_function_type&lt;
                    typename return_type&lt;Func&gt;::type, Args...&gt;::type
             operator&gt;&gt;(Func func) /* &amp;&amp; */ // rvalues only (unsupported for now)
        {
            std::function&lt;R(Args...)&gt; thisFunc = std::move(mFunction);

            return typename composed_function_type&lt;
                                typename return_type&lt;Func&gt;::type, Args...&gt;::type(
                                        [=](Args... args)
                                        {
                                            return func(thisFunc(args...));
                                        });
        }

    private:    
        std::function&lt;R(Args...)&gt; mFunction;
    };
}

template &lt;typename Func&gt;
typename detail::composed_function_type&lt;
            typename detail::return_type&lt;Func&gt;::type,
                typename detail::args_type&lt;Func&gt;::type&gt;::type
    compose(Func func)
{
    return typename detail::composed_function_type&lt;
                        typename detail::return_type&lt;Func&gt;::type,
                            typename detail::args_type&lt;Func&gt;::type&gt;::type(func);
}

int main()
{
    using namespace std;

    auto l1 = [](int i, int j) {return i + j;};
    auto l2 = [](int i) {return i * i;};

    std:function&lt;int(int, int)&gt; f1 = l1;
    function&lt;int(int)&gt; f2 = l2;

    cout &lt;&lt; ""Function composition: "" &lt;&lt; (compose(f1) &gt;&gt; f2)(3, 5) &lt;&lt; endl;
    cout &lt;&lt; ""Function composition: "" &lt;&lt; (compose(l1) &gt;&gt; l2)(3, 5) &lt;&lt; endl;
    cout &lt;&lt; ""Function composition: "" &lt;&lt; (compose(f1) &gt;&gt; l2)(3, 5) &lt;&lt; endl;
    cout &lt;&lt; ""Function composition: "" &lt;&lt; (compose(l1) &gt;&gt; f2)(3, 5) &lt;&lt; endl;

    return 0;
</code></pre>

<p>That's a quite a bit of code! Unfortunately I don't see how it can be reduced any.</p>

<p>You can go another route and just make it so to use lambdas in your scheme, you just have to explicitly make them <code>std::function&lt;&gt;</code>s, but it's less uniform. Some of the machinery above could be used to make some sort of <code>to_function()</code> function for making lambda functions into <code>std::function&lt;&gt;</code>s.</p>
"
"<p>From the <a href=""http://en.wikipedia.org/wiki/C++0x#Lambda_functions_and_expressions"">wikipedia</a> article about <em>Lambda functions and expressions</em>:</p>

<blockquote>
  <p>users will often wish to define predicate functions near the place
  where they make the algorithm function call. The language has only one
  mechanism for this: the ability to define a class inside of a
  function. ... <em>classes defined in functions do not permit them to be used in templates</em></p>
</blockquote>

<p>Does this mean that use of nested structure inside function is silently deprecated after C++0x lambda are in place ?</p>

<p>Additionally, what is the meaning of last line in above paragraph ? I know that nested classes cannot be <code>template</code>; but that line doesn't mean that.</p>
","87234","","<p>I'm not sure I understand your confusion, but I'll just state all the facts and let you sort it out. :)</p>

<p>In C++03, this was legal:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    struct func
    {
        void operator()(int x) const
        {
            std::cout &lt;&lt; x &lt;&lt; std::endl;
        }
    };

    func f; // okay
    f(-1); // okay

    for (std::size_t i = 0; i &lt; 10; ++i)
        f(i) ; // okay
}
</code></pre>

<p>But if we tried doing this, it wasn't:</p>

<pre><code>template &lt;typename Func&gt;
void exec(Func f)
{
    f(1337);
}

int main()
{
    // ...

    exec(func); // not okay, local classes not usable as template argument
}
</code></pre>

<p>That left us with an issue: we want to define predicates to use for this function, but we can't put it <em>in</em> the function. So we had to move it to whatever outer scope there was and use it there. Not only did that clutters that scope with stuff nobody else needed to know about, but it moved the predicate away from where it's used, making it tougher to read the code.</p>

<p>It could still be useful, for the occasional reused chunk of code <em>within</em> the function (for example, in the loop above; you could have the function predicate to some complex thing with its argument), but most of the time we wanted to use them in templates.</p>

<p>C++0x changes the rules to allow the above code to work. They additionally added lambdas: syntax for creating function objects as expressions, like so:</p>

<pre><code>int main()
{
    // same function as above, more succinct
    auto func = [](int x){ std::cout &lt;&lt; x &lt;&lt; std::endl; };

    // ...
}
</code></pre>

<p>This is exactly like above, but simpler. So do we still have any use for ""real"" local classes? Sure. Lambda's fall short of full functionality, after all:</p>

<pre><code>#include &lt;iostream&gt;

template &lt;typename Func&gt;
void exec(Func func)
{
    func(1337);
}

int main()
{
    struct func
    {
        // note: not possible in C++0x lambdas
        void operator()(const char* str) const
        {
            std::cout &lt;&lt; str &lt;&lt; std::endl;
        }

        void operator()(int val) const
        {
            std::cout &lt;&lt; val &lt;&lt; std::endl;
        }
    };

    func f; // okay
    f(""a string, ints next""); // okay

    for (std::size_t i = 0; i &lt; 10; ++i)
        f(i) ; // okay

    exec(f); // okay
}
</code></pre>

<p>That said, with lambda's you probably won't see local classes any more than before, but for completely different reasons: one is nearly useless, the other is nearly superseded.</p>
"
"<p>How would you write the following code with a for loop?  i.e. how do you use a for loop to check if <em>any</em> of the conditions that occur in the loop have been fulfilled?  I know there must be a way and I'm sure someone has probably asked this on SO but I wasn't quite sure how to phrase it.  So if there is a duplicate, maybe you can point me in the right direction.</p>

<pre><code>  string topping;
  cout &lt;&lt; ""Enter a topping "";
  cin &gt;&gt; topping;
  string toppings_offered[5] = {""onions"", ""bell peppers"", ""olives"", ""spinach"", ""tomatoes""};

  if ( (topping == toppings_offered[0]) || (topping == toppings_offered[1]) || (topping == toppings_offered[2]) || (topping == toppings_offered[3]) || (topping == toppings_offered[4]))
           cout &lt;&lt; ""yes"";
</code></pre>
","87234","","<p>In C++0x:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

bool is_offered(const std::string&amp; s)
{
    // look up table
    static const std::string toppingsOffered[] =
                                {""onions"", ""bell peppers"", /* etc */ };

    const auto toppingsBegin = std::begin(toppingsOffered);
    const auto toppingsEnd = std::end(toppingsOffered);

    return std::find(toppingsBegin, toppingsEnd, s) != toppingsEnd;
}

if (is_offered())
    std::cout &lt;&lt; ""yes"";    
</code></pre>

<p>In C++03:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;string&gt;

bool is_offered(const std::string&amp; s)
{
    // look up table
    static const std::string toppingsOffered[] =
                                {""onions"", ""bell peppers"", /* etc */ };

    const std::string* toppingsBegin = &amp;toppingsOffered[0];
    const std::string* toppingsEnd =
                            toppingsBegin +
                                sizeof(toppingsOffered) / sizeof(std::string);

    return std::find(toppingsBegin, toppingsEnd, s) != toppingsEnd;
}

if (is_offered(topping))
    std::cout &lt;&lt; ""yes"";
</code></pre>

<p>In C++03 with utilities:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;cstddef&gt;
#include &lt;string&gt;

template &lt;typename T, std::size_t N&gt;
T* begin(T (&amp;array)[N])
{
    return *array[0];
}

template &lt;typename T, std::size_t N&gt;
T* end(T (&amp;array)[N])
{
    return begin(array) + N;
}


bool is_offered(const std::string&amp; s)
{
    // look up table
    static const std::string toppingsOffered[] =
                                {""onions"", ""bell peppers"", /* etc */ };

    const std::string* toppingsBegin = begin(toppingsOffered);
    const std::string* toppingsEnd = end(toppingsOffered);

    return std::find(toppingsBegin, toppingsEnd, s) != toppingsEnd;
}

if (is_offered(topping))
    std::cout &lt;&lt; ""yes"";
</code></pre>
"
"<p>I would like to know if you think it is reasonable to use a pattern similar to RAII to manage GUI state in Qt. By GUI state I mean the following: I've some widgets (including the mouse cursor state) I want to go (not) visible/enabled/changed after I leave some method, and I don't want to put everything I do in a giant try catch in this way:</p>

<pre><code>widget1-&gt;show();
...
widgetN-&gt;show();

try {
   ...
}
catch(...) {
   widget1-&gt;hide();
   ... 
   widgetN-&gt;hide();

   throw;
}

widget1-&gt;hide();
... 
widgetN-&gt;hide();
</code></pre>

<p>If I create an object that allows me to associate the hide/setEnabled/setCursor function (maybe a boost functor) on its constructor and that calls this associated function on its destructor (provided that all exceptions this function can throw are eaten/lost in the destructor) I can have a much cleaner code. Is this reasonable? what I'm not seeing?</p>

<p>Any comment/suggestion will be really welcomed.</p>

<p>Thanks in advance,</p>

<p>Federico</p>
","87234","","<p>It's completely reasonable. The technique you're after is called ScopeGuard, called ScopeExit in Boost. </p>

<p>The idea is that you define some code you want to run at the end of the scope when you first make your changes, and the rest is handled. You can ""dismiss"" the code if desired.</p>

<p>I'd type an example but I'm on my phone.</p>
"
"<p>In my following program I'm currently using <code>unordered_map</code> just because I wanted O(1) search/insert time. But now I wanted the items to be ordered. Sorting it every time is very inefficient. What are my alternatives ? I read that <code>hash_map</code> does the job but the articles i read are very confusing or rather complicated for me to understand. What is the complexity of insert/search for <code>hash_map</code> and is it really ordered ? If so, is it defined in C++0x and how can I implement it ? If not what else can I use ? Thanks.</p>

<pre><code>include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;

using namespace std;


template &lt;class T&gt;
inline void hash_combine(std::size_t &amp; seed, const T &amp; v)
{
  std::hash&lt;T&gt; hasher;
  seed ^= hasher(v) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);
}

template &lt;typename C&gt; struct ContainerHasher
{
  typedef typename C::value_type value_type;
  inline size_t operator()(const C &amp; c) const
  {
    size_t seed = 0;
    for (typename C::const_iterator it = c.begin(), end = c.end(); it != end; ++it)
    {
      hash_combine&lt;value_type&gt;(seed, *it);
    }
    return seed;
  }
};


typedef std::set&lt;int&gt; my_set;
typedef std::vector&lt;int&gt; my_vector;
typedef std::unordered_map&lt;my_set, my_vector, ContainerHasher&lt;std::set&lt;int&gt;&gt;&gt; my_map;
typedef my_map::iterator m_it;

void print(my_map&amp; data)
{
        for( m_it it(data.begin()) ; it!=data.end(); ++it)
        {
                cout &lt;&lt; ""Key : "";
                copy(it-&gt;first.begin(), it-&gt;first.end(), ostream_iterator&lt;int&gt;(cout, "" ""));
                cout &lt;&lt; "" =&gt; Value: "";
                copy (it-&gt;second.begin(),it-&gt;second.end(),ostream_iterator&lt;int&gt;(cout,"" ""));
                cout &lt;&lt; endl;
        }
        cout &lt;&lt; ""---------------------------------------------------------------\n"";
}

int main()
{
   my_vector v1,v2,v3;
  for(int i = 1; i&lt;=10; ++i)
   {
      v1.push_back(i);
      v2.push_back(i+10);
      v3.push_back(i+20);
   }

   my_set s1(v3.begin(),v3.begin()+3);
   my_set s2(v1.begin(),v1.begin()+3);
   my_set s3(v2.begin(),v2.begin()+3);

   my_map m1;

   m1.insert(make_pair(s1,v1));
   m1.insert(make_pair(s2,v2));
   m1.insert(make_pair(s3,v3));

   print(m1);
   my_set s4(v3.begin(),v3.begin()+3);

   m_it it = m1.find(s4);

   if(it != m1.end())
   {
      cout &lt;&lt; endl &lt;&lt; ""found"" &lt;&lt; endl;
   }
   else
   {
      cout &lt;&lt; endl &lt;&lt; ""Not found"" &lt;&lt; endl;
   }
}
</code></pre>

<p>EDIT:</p>

<p>I was using <code>std::map</code> before but I have large number of items (in millions). So even if the number of items are so large do you all recommend <code>map</code> if I want it ordered ? </p>
","87234","","<p>Just use a regular <code>std::map</code>. Note this means you need ordering instead of hashing.</p>

<p>An <code>unordered_map</code> <em>is</em> a <code>hash_map</code>, by the way. ""Unordered"" just captures the conceptual difference rather than the implementation difference, so it's a better name.</p>
"
"<p>I know I need to project the vertices of my polyhedra on a whole bunch of axes, i've read these axes are the normals to each of the faces of one polyhedra (or is it both?). I've also read i use the cross product of each edge of one collidable with each edge of the other collidable. So lets say i have 2 polyhedra each with 8 faces and 12 edges. Therefore there would be 8 + (12*12) = 152 axes to project and then subsequently test? Is that correct?</p>

<p>Also since i dont know whether my faces are CW or CCW, my normals could be pointing inside or outside, does this matter? For example lets say i project onto an axis that is a normal from one of the shapes facing inwards, as long as both polyhedra are projected using this same normal, will this effect the algorithm?</p>

<p>Thanks for any input!</p>
","87234","","<p>In short, the only planes you need to check are those that are defined by the faces of your objects; that is, the normal of the faces is the normal of the planes to check. The direction of the normal doesn't matter, since you're just projecting the vertices anyway.</p>

<p>Also note that this only works for convex meshes, and isn't necessarily the quickest way to do these kinds of checks. You might want to look into XenoCollide or GJK instead; those are becoming standard.</p>
"
"<p>I've looked through the mess that is lexical_cast.hpp and this continues to escape me.</p>

<p>How is lexical_cast, whose 'base definition' takes both a template source and destination, able to accept grammar such as <code>lexical_cast&lt;int&gt;(""7"")</code>? I don't see how it can only need a templated return type and not need you to give the type of the parameter without doing something illegal like partial template specialization. </p>

<p>Note: I understand how you could do this with a single template type and overloads for different parameters, but I fail to understand how lexical_cast's is based off of a template function requiring both source and destination template types.</p>
","87234","","<p>Template arguments can be deduced from the function arguments:</p>

<pre><code>template &lt;typename T&gt;
void foo(const T&amp; x)
{
    // T is the type of X
}

foo(5); // T is be int
foo(""hello""); //T is const char[6]
</code></pre>
"
"<p>Is it legal for a C++0x compiler to optimize</p>

<pre><code>int func(int&amp;&amp; a){
    a = 3;
    return a;
}
</code></pre>

<p>to</p>

<pre><code>int func(int&amp;&amp; a){
    return 3;
}
</code></pre>

<p>?
(or for another POD)</p>
","87234","","<p>Not like that <em>per se</em>, because the function must modify the variable <code>a</code> to be equivalent. That said, after inlining and a bit of trivial optimization the result will be the same:</p>

<pre><code>int x = func(5);

// pseudo-inlined:
int __temp = 5; // the temporary created by binding 5 to int&amp;&amp;
__temp = 3; // a = 3;
int x = __temp; // return a;

// constant propagation:
int __temp = 5;
__temp = 3;
int x = 3;

// dead-code elimination:
int x = 3;
</code></pre>

<p>Note the result is the same as if you used the second definition of <code>func</code> and inlined, only because the temporary variable wasn't used. This shows that the two functions aren't equivalent in general:</p>

<pre><code>int modifyme = 100;
int x = func(std::move(modifyme));

// modifyme must be 3, second function definition wouldn't do that
</code></pre>
"
"<p>5.15 Logical OR operator in the standard says the following:</p>

<blockquote>
  <p>Unlike |, || guarantees left-to-right evaluation;</p>
</blockquote>

<p>Does this mean somewhere I cannot locate in the standard, <code>|</code> is defined to evaluate right-to-left, or that it is implementation-defined? Does this vary when the operator is overloaded? I wrote a quick program to test this and both MSVC++ and GCC seem to evaluate <em>right-to-left</em>.</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

int foo = 7;

class Bar {
public:
    Bar&amp; operator|(Bar&amp; other) {
        return *this;
    }
    Bar&amp; operator++() {
        foo += 2;
        return *this;
    }
    Bar&amp; operator--() {
        foo *= 2;
        return *this;
    }
};

int main(int argc, char** argv) {
    Bar a;
    Bar b;
    Bar c = ++a | --b;
    cout &lt;&lt; foo;
}
</code></pre>

<p>This outputs <code>16</code>.
If <code>++a</code> and <code>--b</code> are switched it outputs <code>19</code>.</p>

<p>I've also considered that I may be running into the multiple changes between sequence points rule (and thus undefined behavior), but I'm unsure how/if that applies with two separate instances as operands.</p>
","87234","","<p>Ignore that operator for now, and just take note of this:</p>

<pre><code>(x + y) * (z + 1)
</code></pre>

<p>Here, both operands must be evaluated before the multiplication can take place (otherwise we wouldn't know what to multiply). In C++, the order in which this is done is <em>unspecified</em>: it could be <code>(x + y)</code> first, or <code>(z + 1)</code> first, whatever the compiler feels is better.†</p>

<p>The same is true for the operator <code>|</code>. However, operator <code>||</code> must <em>short-circuit</em>, and in order to do that, it must evaluate strictly left to right. (And if the left evaluation yields <code>true</code>, the evaluation ends without evaluating the right operand.) That's what the sentence means.</p>

<p>†Note that it may have no preference one way or another, and just evaluate in the order it's listed. This is why you get the output you do, though you cannot rely on it at the language level.</p>
"
"<p>I read in C book that for an array <code>num[7]</code> term <code>num</code> is equivalent to <code>&amp;num[0]</code>. This concept was working fine for me but when i wrote this progarm shown below i again got confused.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
int main()
{
    int num[]={21,22,23,24,25,26,27};
    int *x,*y,*z;
    x=&amp;num;
    y=num;
    z=&amp;num[0];
    printf(""%d   %d   %d\n"",sizeof(x),sizeof(y),sizeof(z));
    printf(""%d  %d  %d\n"",sizeof(&amp;num),sizeof(num),sizeof(&amp;num[0]));
    printf(""%d   %d   %d"",*(&amp;num),*(num),*(&amp;num[0]));
    getch();
    return 0;  
}
</code></pre>

<p>output is:</p>

<pre><code>      4    4    4
      4    28   4
      2293536   21   21
</code></pre>

<p>Now my question is if <code>num</code> is identical to <code>&amp;num[0]</code> then why there is a difference in there size? And what is this third type of term <code>&amp;num</code> I know it is showing garbage value But do this type of term makes any sense? <code>z=&amp;num[0]</code> I already understand. The compiler shows warning for the assignment <code>x=&amp;num</code> But for  <code>y=num;</code> compiler dont have any problems.  If <code>num</code> has size <code>28</code> then why it got assigned to an integer pointer <code>y</code> without a typecast?</p>

<p>Then I tried on 2-d array this way:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
int main ()
{
    int s[4][2]={{1234,56},{1235,57},{1236,58},{1237,59}};
    int i
    printf (""\n%d %d %d %d %d"",sizeof(s[i]),sizeof(&amp;s[i]),sizeof(s),
        sizeof(s[0][0]),sizeof(&amp;s));
    getch();
    return 0;
}
</code></pre>

<p>Now the output is </p>

<pre><code>8  4  32  4   4
</code></pre>

<p>Here <code>sizeof(s[i])</code> is <code>8</code>. because <code>s[i]</code> is a 1-D array and it has two elements so its fine. But what the terms <code>&amp;s[i]</code> and <code>&amp;s</code> means i dont have any clue. And i am again able to see that <code>s</code> is not identical to <code>s[0][0]</code> . I have used Dev C++ 4.9.9.2 version to run all the programs. I want to be clear in these three type of terms.</p>
","87234","","<p>Your contradictions are valid. It is <strong>not</strong> the case that <code>num</code> is equivalent to <code>&amp;num[0]</code>. That's simply false. Arrays are a distinct type from pointers, and <code>num</code> refers to an object with the type <code>int[7]</code>, not <code>int*</code>. That's why the size is different, for example, because one is a contiguous collection of seven integers.</p>

<p>Note that if the need be, <code>num</code> may be converted to an <code>int*</code>, with the value <code>&amp;num[0]</code>. A conversion is not the same as equivalence, of course. You'll find this confusion between arrays and pointers oddly prominent, because people keep repeating the falsity that arrays are pointers. They aren't.</p>
"
"<p>This C++ program is a CGI script, I have no desire to deal with exceptions. I'd rather get a marginal performance boost and let the OS (Linux) handle cleanup after the process dies.</p>

<p>I am using the Standard C++ Library, and want any function to <code>die</code> like in Perl: <strong>Whenever it throws an exception.</strong> Without unwinding, <em>or running any further code</em> in my process.</p>

<p>How does -fno-exceptions work? If I have no catch at all in my code, and basically pretend like exceptions do no exist. but I <strong>do</strong> use std:: c++ library which <strong>can</strong> throw()?</p>
","87234","","<p><a href=""http://gcc.gnu.org/onlinedocs/libstdc++/manual/using_exceptions.html""><code>-fno-exceptions</code> turns all standard library throw's into a call to <code>std::abort()</code></a>. That handles the part you can't modify directly, the rest is to not use them at all in your code.</p>

<p>Of course, I really doubt your justification in doing this. You only ""lose"" performance when you actually throw, and you're throwing out a significant and helpful bit of the language.</p>
"
"<p>using Visual Studio 2010 SP1</p>

<p>so i have a std::for_each iterating on lots of files using the boost::filesystem library.
since those iterations dont mess with each other i was trying to get multi threading working on it, so im trying to use VS 2010 library PPL.</p>

<p>old: <code>for_each(directory_iterator(path), directory_iterator(), &lt;lambda function&gt;);</code>
new: <code>parallel_for_each(directory_iterator(path), directory_iterator(), &lt;lambda function&gt;);</code></p>

<p>thing is, the parallel_for_each one doesnt compile because it asks for a random access iterator or a forward access iterator which i assume directory_iterator is not.
is there a way i can make directory_iterator work in this case? maybe with a diferent iterator that i dont know about or maybe some kind of cast?</p>

<p>tried searching for an answer on the web, but PPL with boost isnt really that much talked yet.</p>

<p>thanks in advance.</p>
","87234","","<p>If most of your time is spent loading files, you're only slowing yourself down by trying to load multiple files. That said, if your work is processing-bound, you could do something like this:</p>

<pre><code>for each file // serial
{
    load file into memory
    spawn task to process file // concurrent
}

wait until tasks to complete
</code></pre>

<p>For that, you'll want to use the <a href=""http://msdn.microsoft.com/en-us/library/dd492427.aspx"" rel=""nofollow"">tasks</a>.</p>
"
"<p>Normally when you write a template class and have a specialization of a function in that class, you need to put the specialization in the .cpp file since it is a concrete definition (rather than a template definition).  If you only have one tiny function to specialize though this is a little annoying and sometimes you may forget to look in that .cpp file for that one last definition which can cause confusion.</p>

<p>In a situation like this it would be nice to include that one specialization in the header file with the rest of the template definition.  Is there any trick that would allow this to be achieved?</p>
","87234","","<p>Use the <code>inline</code> keyword:</p>

<pre><code>template &lt;unsigned N&gt;
unsigned get_const()
{
    return N;
}

template &lt;&gt;
inline unsigned get_const&lt;42&gt;()
{
    throw ""meaning of life"";
}
</code></pre>

<p>The keyword indicates that multiple definitions should assumed to be the same, and therefore not an error. (This is orthogonal to <code>static</code>, which keeps repeat definitions in their own translation unit.)</p>

<p>Note that this works with all functions, not just templates or specializations.</p>
"
"<p>Is it a feature of unordered_map::find() to insert the key that we lookup with 0 value automatically?
Let me make this clear</p>

<pre><code>    unordered_map&lt;int, int&gt; tempMap;
    //some code
    if(tempMap.find(1) == tempMap.end()){
      //do something but not insert the 1 with a corresponding value into the tempMap
    }
</code></pre>

<p>so if I lookup 1 again, will it be there in the tempMap having 0 as corresponding value.
Is that a feature of unordered_map?</p>
","87234","","<p>No, <code>find</code> only searches and returns an iterator.</p>

<p>That said, <code>std::unordered_map</code> (and <code>std::map</code>) both overload <code>operator[]</code> which <em>will</em> insert a default if needed:</p>

<pre><code>// if element with a key value one exists, return that. otherwise, insert
// a default initialized element (zero in this case), and return that
auto&amp; val = tempMap[1]; 
</code></pre>
"
"<p>Can someone explain the output of the following code?</p>

<pre><code>#include &lt;iostream&gt;

template &lt;class T&gt;
void assign(T&amp; t1, T&amp; t2){
    std::cout &lt;&lt; ""First method""&lt;&lt; std::endl;
    t1 = t2;
}

template &lt;class T&gt;
void assign(T&amp; t1, const T&amp; t2) {
    std::cout &lt;&lt; ""Second method""&lt;&lt; std::endl;
    t1 = t2;
}

class A
{
public:
    A(int a) : _a(a) {};

private:
    friend A operator+(const A&amp; l, const A&amp; r);

    int _a;
};

A operator+(const A&amp; l, const A&amp; r) 
{
    return A(l._a + r._a);
}

int main ()
{
    A a = 1;
    const A b = 2;

    assign(a, a);
    assign(a, b);
    assign(a, a + b);
}
</code></pre>

<p>The output is </p>

<pre><code>First method

Second method

Second method
</code></pre>

<p>I don't see why. Shouldn't the last call to assign activate the first version, since (a+b) doesn't return a const A object?</p>
","87234","","<p><code>(a + b)</code> returns a temporary object, though, and can therefore only be bound to a constant reference.</p>
"
"<p>Is the following safe? I know, strictly speaking, dereferencing a pointer before the thing to which it points has been properly constructed seems dangerous, but I imagine the compiler will just provide a pointer without actually doing any dereferencing. Well, I assume.</p>

<p>(Note: gInst doesn't actually use the reference until much later.)</p>

<p>TU 1</p>

<pre><code>Sys::System::System::System(const sf::VideoMode&amp; rVM, const std::string&amp; rSTR, unsigned long settings) :
    win(rVM, rSTR, settings),
    gInst(*this)
{

}
</code></pre>

<p>Header A</p>

<pre><code>namespace Sys
{
    namespace System
    {
        struct System;
    }

    namespace UI
    {
        struct GUI
        {
            System::System&amp; topl;
            MenuBar menu;

            GUI(System::System&amp;);

            private:

            GUI();
            GUI(const GUI&amp;);
            GUI&amp; operator=(const GUI&amp;);
        };
    }
}
</code></pre>

<p>Header B</p>

<pre><code>namespace Sys
{
    namespace System
    {
        struct System
        {
            sf::RenderWindow win;
            Sys::UI::GUI gInst;
            Sys::Editor::Editor eInst;

            System(const sf::VideoMode&amp;, const std::string&amp;, unsigned long);

            private:

            System();
            System(const System&amp;);
            System&amp; operator=(const System&amp;);
        };

        void start();
    }
}
</code></pre>
","87234","","<blockquote>
  <p>(Note: gInst doesn't actually use the reference until much later.)</p>
</blockquote>

<p>Then it's completely safe. (Taking note you say ""the reference"", not ""the value"".)</p>

<p>Compilers will just warn about it for the reason you've stated, but there's nothing undefined about it, just ""risky"". Note that you can often trump compiler warnings (if they bother you) with something like this:</p>

<pre><code>struct foo
{
    foo() : b(self())
    {}

private:
    foo&amp; self() { return *this; }

    bar b;
};
</code></pre>
"
"<pre><code>void * intptr = new int;
delete (int *) intptr;
</code></pre>

<p>Is the <code>(int *)</code> type cast required?</p>
","87234","","<p>Yes.</p>

<p>The type must match that which was new'd. The only time it doesn't have to match is deletion of a derived type through a base pointer, where the base type has a virtual destructor.</p>
"
"<p>I just started learning C++ and have a question about vectors.
The book I'm reading states that if I want to extract the size of a vector of type double (for example), I should do something like:</p>

<pre><code>vector&lt;double&gt;::size_type vector_size;
vector_size = myVector.size();
</code></pre>

<p>Whereas in Java I might do</p>

<pre><code>int vector_size;
vector_size = myVector.size();
</code></pre>

<p>My question is, why is there a type named vector::size_type? Why doesn't C++ just use int? </p>
","87234","","<p>Java does not have unsigned integer types, so they have to go with <code>int</code>.</p>

<p>Contrarily, C++ does and uses them where appropriate (where negative values are nonsensical), the canonical example being the length of something like an array.</p>
"
"<p>I'm using <code>boost::any</code> in combination with <code>boost::any_cast&lt;&gt;</code> to write some framework code which should take a set of arguments, almost like a function call, and convert them into an array of <code>boost::any</code> types.</p>

<p>So far everything has been working great, except in places where it is hard to predict if the number the caller gives me is going to be signed or unsigned.  A lot of code in our existing product (windows based) uses <code>DWORD</code> and <code>BYTE</code> data types for local variables so if one of those variables is used, I get unsigned type.  However if a constant is hardcoded, the most likely it'll be a simple number in which case it will be signed.</p>

<p>Since I can't predict if I should do <code>any_cast&lt;int&gt;</code> or <code>any_cast&lt;unsigned int&gt;</code>, 50% of the time my code that reads the <code>boost::any</code> array will fail.</p>

<p>Does anyone know if there's a way to just a number out of <code>boost::any</code> regardless if original type was signed or unsigned?</p>
","87234","","<p>There isn't a way; <code>boost::any</code> does the simplest form of type-erasure, where the type must match exactly. You can write your own <code>boost::any</code>-like class that supports the additional features you want. I've <a href=""http://stackoverflow.com/questions/6122094/building-boostoptions-from-a-string-boostany-map/6123962#6123962"">previously demonstrated</a> how this can be done.</p>

<p>Failing that, you can:</p>

<ol>
<li>Have two code paths, one for each sign. (Switch to signed path if <code>any_cast&lt;unsigned T&gt;</code> throws.)</li>
<li>Try unsigned, and if that throws, try signed and cast, use a single code path.</li>
<li>Just let the unsigned <code>any_cast</code> throw if it's signed, and force the user to cope.</li>
</ol>

<p>However, each of these isn't really that good. Do you really need <code>boost::any</code>? Perhaps you want <code>boost::variant</code> instead, if you're expecting a certain list of types.</p>
"
"<pre><code> if(y-- &gt; 0 &amp;&amp; matriz[x][y--]!=9 &amp;&amp; matriz[x][y--]!=0)
</code></pre>

<p>When i'm doing this, my variable <strong>y</strong> is not decremented, right? And i can do this comparison <strong>y-- > 0</strong>?</p>

<p>Imagine that i have y=0, i want to compare if -1 > 0.</p>

<p>Thanks</p>
","87234","","<p><em>Assuming all tests pass</em>, your code is effectively equivalent to this:</p>

<pre><code>if (y &gt; 0)
{
    y--; // post-decrement

    if (matriz[x][y] != 9)
    {
        y--; // post-decrement

        if (matriz[x][y] != 0)
        {
            y--; // post-decrement

            // all true
        }
    }
}
</code></pre>

<p>If any fail, you still decrement (equivalence would be in an else-clause), but I'm omitting that for brevity.</p>

<p>Hopefully this is enough to clarify. I find it quite unwieldy, and if <code>y &lt; 2</code> at the start you'll end up with a negative index, which is probably a bad thing.</p>
"
"<p>Quick question. Let's say I declare a vector of size 20. And then I want to add a few integers to it using push_back.</p>

<pre><code>vector&lt;int&gt; myVector(20);
myVector.push_back(5);
myVector.push_back(14);
</code></pre>

<p>Is the capacity of my vector now 22, or is it still 20? Were 5 and 14 added to indices [19] and [20], respectively? Or are they at [0] and [1]?</p>
","87234","","<p>After those statements its capacity is implementation-defined. (Please note that is different from its size.)</p>

<hr>

<pre><code>vector&lt;int&gt; myVector(20);
</code></pre>

<p>This creates a vector filled with twenty 0's. Its size is twenty, exactly, and its capacity is at least twenty. Whether or not it's exactly twenty is implementation-defined; it may have more (probably not, in practice).</p>

<pre><code>myVector.push_back(5);
</code></pre>

<p>After this, the twenty-first element of the array is 5, and the capacity is once again implementation-defined. (If the capacity had been exactly twenty before, it is now increased in an unspecified manner.)</p>

<pre><code>myVector.push_back(14);
</code></pre>

<p>Likewise, now the twenty-second element of the array is 14, and the capacity is implementation-defined.</p>

<hr>

<p>If you want to reserve space, but not insert elements, you'd do it like this:</p>

<pre><code>vector&lt;int&gt; myVector;
myVector.reserve(20); // capacity is at least twenty, guaranteed not
                      // to reallocate until after twenty elements are pushed

myVector.push_back(5); // at index zero, capacity at least twenty.
myVector.push_back(14); // at index one, capacity at least twenty.
</code></pre>
"
"<p>Let's say you have defined a (global or local) pointer variable such as this:</p>

<pre><code>    void *this_is_a_pointer;
</code></pre>

<p>without giving it the value "" = NULL; ""</p>

<p>Would this automatically give you a NULL ptr (a pointer that points to NULL)?</p>

<p><strong>*</strong> Also, what does it mean for a null pointer to point to NULL? Is that saying that it could point to literally <em>anywhere</em>? (basically, what really is the ""address location of <em>NULL</em>""?)</p>
","87234","","<blockquote>
  <p>(global or local)</p>
</blockquote>

<p>This is actually what makes the difference.</p>

<p>In general, if you didn't initialize a variable, it's not initialized and reading from it is undefined behavior. But if the variable has <em>static storage duration</em>, then it's automatically initialized to zero (null for pointers).</p>

<pre><code>// foo.cpp

void* this_is_null;

void whatever(void)
{
    static int* and_so_is_this;
}

void not_whatever(void)
{
    float* but_this_local_is_uninitialized;
}
</code></pre>
"
"<p>I've been exploring the possibilities of <a href=""http://msdn.microsoft.com/en-us/library/dd293665.aspx"">Move Constructors</a> in C++, and I was wondering what are some ways of taking advantage of this feature in an example such as below. Consider this code:</p>

<pre><code>template&lt;unsigned int N&gt;
class Foo {
public:
    Foo() {
        for (int i = 0; i &lt; N; ++i) _nums[i] = 0;
    }

    Foo(const Foo&lt;N&gt;&amp; other) {
        for (int i = 0; i &lt; N; ++i) _nums[i] = other._nums[i];
    }

    Foo(Foo&lt;N&gt;&amp;&amp; other) {
        // ??? How can we take advantage of move constructors here?
    }

    // ... other methods and members

    virtual ~Foo() { /* no action required */ }

private:
    int _nums[N];
};

Foo&lt;5&gt; bar() {
    Foo&lt;5&gt; result;
    // Do stuff with 'result'
    return result;
}

int main() {
    Foo&lt;5&gt; foo(bar());
    // ...
    return 0;
}
</code></pre>

<p>In this above example, if we trace the program (with MSVC++ 2011), we see that <code>Foo&lt;N&gt;::Foo(Foo&lt;N&gt;&amp;&amp;)</code> is called when constructing <code>foo</code>, which is the desired behaviour. However, if we didn't have <code>Foo&lt;N&gt;::Foo(Foo&lt;N&gt;&amp;&amp;)</code>, <code>Foo&lt;N&gt;::Foo(const Foo&lt;N&gt;&amp;)</code> would be called instead, which would do a redundant copy operation.</p>

<p>My question is, as noted in the code, with this specific example which is using a statically-allocated simple array, is there any way to utilize the move constructor to avoid this redundant copy?</p>
","87234","","<p>In this case it's not useful because <code>int</code> has no move-constructors.</p>

<p>However, it could be useful if those were strings instead, for example:</p>

<pre><code>template&lt;unsigned int N&gt;
class Foo {
public:
    // [snip]

    Foo(Foo&lt;N&gt;&amp;&amp; other) {
        // move each element from other._nums to _nums
        std::move(std::begin(other._nums), std::end(other._nums), &amp;_nums[0]);
    }

    // [snip]

private:
    std::string _nums[N];
};
</code></pre>

<p>Now you avoid copying strings where a move will do. I'm not sure if a conforming C++11 compiler will generate equivalent code if you omit all the copy-/move-constructors completely, sorry.</p>

<p>(In other words, I'm not sure if <code>std::move</code> is specially defined to do an element-wise move for arrays.)</p>
"
"<p>Writing a program that should be portable in Linux and Windows enviroments I have found a issue with the STL sort function, when compiling with Visual studio and gcc.
In order to sort a vector of complex data structures I have written an int conversion operator for the structures in that form:</p>

<pre><code>struct result
{ 
public :
  int Gene_a;
  int Gene_b;
  std::vector&lt;int&gt; score;
  float total_score;
  operator int() {return total_score;}
}
</code></pre>

<p>In that case I have no problem in visual studio using the standard sort algorithm for integers:</p>

<pre><code>sort(results.rbegin(),results.rend());
</code></pre>

<p>But when trying to compile that using GCC ( actually g++ ) that lead to funny errors.
To avoid that seems that I have to write an ordering function:</p>

<pre><code> inline bool better (result a, result b)
 {
   return a.total_score &gt; b.total_score;
 }
</code></pre>

<p>and invoke sort in the form:</p>

<pre><code>sort(results.begin(),results.end(),better);
</code></pre>

<p>Was I using something out of the standard C++ or is a lack of the g++ STL implementation ?
Is it possible to let g++ understand that the vector of struct is equivalent to a vector of int ?</p>

<p>Here is a short main to illustrate the error:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;
int main(int argc, char* argv[]) 
{
  vector&lt;result&gt; r;           // define a vector of struct
  for (int i=0;i&lt;10;i++)      // fill up with data
  {
    result a;
    a.Gene_a=i;
    a.Gene_b=2*i;
    for(int j=0;j&lt;i;j++)
      a.score.push_back(i); // fill the int vector in the struct
    a.total_score=i;
    r.push_back(a);
  }
  // sort(r.rbegin(),r.rend()); // this line will fail in g++
  sort(r.rbegin(),r.rend(),better);
  for (int i=0;i&lt;10;i++)      // demonstrate that the int operator works
    cout &lt;&lt; (int)r[i] &lt;&lt; endl;
}// End main
</code></pre>
","87234","","<p>The only meaningful difference I see between the two comparison methods is that the second will work when the element is <code>const</code>. The first should probably be:</p>

<pre><code>//             vvvvv
operator int() const
</code></pre>

<p>Even though you're modifying the container, your comparison still has the requirement that it work on <code>const</code> objects. In your case, the implementation used that assumption and the error arose.</p>

<p><strike>But this shouldn't matter, since to sort the container and its elements needs to be modifiable...</strike></p>
"
"<p>Say I have a <code>struct</code> like the following:</p>

<pre><code>struct ParentStruct
{
   virtual void XYZ()
   {
      getSize(sizeof(*this));
   }
   int memberX;
}
</code></pre>

<p>And another <code>struct</code> which inherits the parent struct:</p>

<pre><code>struct ChildStruct : public ParentStruct
{
    int memberY;
    int memberZ;
}
</code></pre>

<p>Assuming <code>sizeof(int) == 4</code>, is it possible to have a value of <em>12</em> passed to the function <code>getSize()</code> when called from the child struct (I am currently getting a value of <em>4</em>)? </p>

<p>I would prefer not to have to overwrite <code>XYZ()</code> in all the sub-structs, as I will have many of them.</p>
","87234","","<p>Type type of <code>this</code> is always the static class type, so <code>sizeof(*this)</code> is always <code>sizeof(ParentStruct)</code>.
(Consider: how would <code>sizeof</code> remain a constant expression if the type of <code>this</code> was not static?)</p>

<p>If you tel us what you're trying to do, we can suggest more maintainable alternatives.</p>
"
"<p>Using C++ with Visual Studio 2010.  I'm in the process of converting my <code>NULL</code>'s to <code>nullptr</code>'s.  With my code this is fine.  However if I make a call to an win api such as:</p>

<p><code>__checkReturn WINOLEAPI OleInitialize(IN LPVOID pvReserved);</code></p>

<p>normally I would have called this like:</p>

<p><code>::OleInitialize(NULL);</code></p>

<p>Can I safely use nullptr where I would have used NULL in a call such as this?</p>

<p>That is, can I do this:</p>

<p><code>::OleInitialize(nullptr);</code></p>

<p>Also same with MFC api:</p>

<p><code>CFileDialog fileDlg(TRUE, "".txt"", NULL, 0, strFilter);</code></p>

<p>Can I replace </p>

<p><code>CFileDialog fileDlg(TRUE, "".txt"", nullptr, 0, strFilter);</code></p>

<p>I'm guessing I can but I just want to make sure there are no gotchas.</p>

<p><strong>UPDATE</strong></p>

<p>So I went through and replaces all my NULL's with nullptr and it seems to work most everywhere however I am getting the below error on the following line:</p>

<pre><code>propertyItem = new CMFCPropertyGridProperty(_T(""SomeName""),
""SomeValue"", ""SomeDescription"", nullptr, nullptr, nullptr, nullptr);

8&gt;c:\something\something.cpp(118): error C2664: 
'CMFCPropertyGridProperty::CMFCPropertyGridProperty(const CString &amp;,const COleVariant
 &amp;,LPCTSTR,DWORD_PTR,LPCTSTR,LPCTSTR,LPCTSTR)' : 
cannot convert parameter 4 from 'nullptr' to 'DWORD_PTR'
8&gt;          A native nullptr can only be converted to bool or, using 
reinterpret_cast, to an integral type
</code></pre>

<p>(Note CMFCPropertyGridProperty is a Microsoft MFC class) So what does that mean?</p>
","87234","","<p>Yes, you can safely use <code>nullptr</code> anywhere you use <code>NULL</code>.</p>

<p><code>NULL</code> expanded to an integer constant expression with the value zero, which could then be converted to a null pointer value of any type. <code>nullptr</code> is ""pointer literal"" that does the exact same thing: it converts to a null pointer value of any type.</p>

<p>More information <a href=""http://stackoverflow.com/questions/1282295/what-exactly-is-nullptr-in-c0x"">here</a>.</p>
"
"<p>I know 2 ways for desiging an event in C++:</p>

<h1>1: Using callbacks:</h1>

<pre><code>typedef void (*callback_type)(void);

class my_class
{
  public:

    my_class(callback_type c)
    {
       m_callback = c;
    }

    void raise_event()
    {
       m_callback();
    }

  private:

    callback_type m_callback;
};
</code></pre>

<h1>2: Using <code>virtual</code> methods:</h1>

<pre><code>class my_class
{
   public:

   virtual void my_event() = 0;

   void raise_event()
   {
      my_event();
   }
};

class main_class : public my_class
{
   public:

   virtual void my_event()
   {
      // Handle EVENT.
   }
};
</code></pre>

<p>Is there any other way or other idea for designing events?</p>

<p>and</p>

<p><strong>What is the best pattern for designing events in ISO C++?</strong></p>
","87234","","<p>You should use Boost.Signals or Boost.Signals2.<br>
To emulate those, you can use a collection of Boost.Function's/<code>std::function</code>'s.<br>
To emulate those, you use type erasure (so the virtual function route) for flexibility.</p>

<p>Note that none of that is too trivial, so you should really try to use an existing solution if possible.</p>
"
"<p>I have fixed length char array used to store my decoded data. Once finish decoding, I want to copy content of the char array to a char vector for later use. When debugging to the line of ""std:copy(...)"" an error occurred. What's wrong with my std::copy usage?</p>

<p>Thank you!</p>

<pre><code>std::vector&lt;char&gt; m_cCalibrationID;
char cCalibrationID[5];
memcpy(cCalibrationID, pszData, 4);
cCalibrationID[4] = 0;

// Copy to vector
std::copy ( cCalibrationID, cCalibrationID + 4, m_cCalibrationID.begin() );
</code></pre>
","87234","","<p>Ignoring that you named them the same thing and pretending you didn't, you need to allocate space for your vector first:</p>

<pre><code>char arr[5];
memcpy(arr, pszData, 4);
arr[4] = 0;

std::vector&lt;char&gt; vec(5); // contains five usable elements
std::copy(arr, arr + 5, vec.begin());
//                 ^^^  should be + 5, not + 4, to get null terminator
</code></pre>

<p>Or you can use <code>std::back_inserter</code>:</p>

<pre><code>char arr[5];
memcpy(arr, pszData, 4);
arr[4] = 0;

std::vector&lt;char&gt; vec; // contains zero usable elements
vec.reserve(5); // reserve space ahead of time
std::copy(arr, arr + 5, std::back_inserter(vec));
</code></pre>

<p>That will <code>push_back</code> each copied element. That said, why not skip the middleman?</p>

<pre><code>std::vector&lt;char&gt; vec(5);
std::copy(pszData, pszData + 4, vec.begin());
// vec[4] already initialized to zero
</code></pre>
"
"<p>I have a class set up like this:</p>

<pre><code>class Foo {
  Foo();    

  private:
     Bar m_bar;
}
</code></pre>

<p>That is the class definition in  it's own header file, and now in the source file to go with it I have the constructor and I tried doing this:</p>

<pre><code>Foo::Foo() {
  m_bar(""parameters for the Bar constructor"");
}
</code></pre>

<p>However this doesn't work and gives me an error. I can make m_bar a pointer and then in Foo's constructor do this:</p>

<pre><code>m_bar = new Bar(""parameters here"");
</code></pre>

<p>However that makes m_bar a pointer and I don't want that.</p>

<p>I'm not the best with C++ classes and pointers, so could something either explain a way for me to have m_bar defined in the Foo class but constructor somewhere else or if it is better to make m_bar a pointer in this situation explain why? While I would rather not make it a pointer(because I don't understand pointers extremely well), if that is the best way to do it then I would rather do it that way, but I'd still like someone to explain why that is the best way to do it(if it is).</p>
","87234","","<p>You need to use initialization lists:</p>

<pre><code>Foo::Foo() :
m_bar(""and you ought to check out a good C++ book :)"")
{
    // Book list: http://tinyurl.com/so-cxxbooks
}
</code></pre>
"
"<p>Following <a href=""http://stackoverflow.com/questions/4726768/returning-functions-in-c/4730655#4730655"">this answer</a> I'm now wondering what the rules are for the lifetime of lambdas and how the relate to the lifetime of function pointers which are created by automatic conversion. There are several questions about the lifetime of lambdas (e.g. <a href=""http://stackoverflow.com/questions/7941562/what-is-the-lifetime-of-a-c-lambda-expression"">here</a> and <a href=""http://stackoverflow.com/questions/5207467/what-is-lifetime-of-lambda-derived-implicit-functors-in-c"">here</a>), in which case the answers are ""they behave exactly like you wrote the full functor object yourself"", however neither address the conversion to function pointer which could quite sensibly be a special case.</p>

<p>I put together this small working example that illustrates my concern:</p>

<pre><code>#include &lt;iostream&gt;

typedef int (*func_t)(int);

// first case
func_t retFun1() {
  static auto lambda = [](int) { return 1; };
  // automatically converted to func_t
  return lambda;
}

// second case
func_t retFun2() {
  // no static
  auto lambda = [](int) { return 2; };
  // automatically converted to func_t and 
  // the local variable lambda reaches the end of its life
  return lambda;
}

int main() {
  const int a = retFun1()(0);
  const int b = retFun2()(0);
  std::cout &lt;&lt; a &lt;&lt; "","" &lt;&lt; b &lt;&lt; std::endl;
  return 0;
}
</code></pre>

<p>Is this well defined for both cases? Or only for <code>retFun1()</code>? The question is: ""is the function that the function pointer points required to be calling the functor object itself, or reimplementing the body in a separate function?"" Either one would make sense, but the fact that the conversion to function pointer specifically requires a capture-less lambda suggests that it may actually be the latter.</p>

<hr>

<p>Put another way - I can see at least two sensible ways a compiler might want to implement such lambdas. One possible, legal implementation might be for a compiler to synthesize code like:</p>

<pre><code>func_t retFun3() {
  struct __voodoo_magic_lambda_implementation {
    int operator()(int) const {
      return 3;
    }
    static int plainfunction(int) {
      return 3;
    }
    operator func_t() const {
      return plainfunction;
    }
  } lambda;
  return lambda;
}
</code></pre>

<p>in which case both the <code>static</code> and non-<code>static</code> variants of <code>retFun</code> would be fine. If however it's also legal for a compiler to implement the lambda like:</p>

<pre><code>static int __voodoo_impl_function(int x);
static struct __voodoo_maigc_impl2 {
  int operator()(int) const {
    return 4;
  }
  operator func_t() const {
    return __voodoo_impl_function;
  }
} *__magic_functor_ptr;
static int __voodoo_impl_function(int x) {
  return (*__magic_functor_ptr)(x);
}

func_t retFun4() {
  __voodoo_maigc_impl2 lambda;
  // non-static, local lifetime
  __magic_functor_ptr = &amp;lambda; //Or do the equivalent of this in the ctor
  return lambda;
}
</code></pre>

<p>then <code>retFun2()</code> is undefined behaviour.</p>
","87234","","<p>§5.1.2/6 says:</p>

<blockquote>
  <p>The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type’s function call operator. The value returned by this conversion function <em>shall be the address of a function</em> that, when invoked, has the same effect as invoking the closure type’s function call operator.</p>
</blockquote>

<p>Emphasis mine.</p>

<p>In other words: because it's an address of a function, and functions have no lifetime, you are free to call that function whenever you'd like. Everything you have is well-defined.</p>

<p>It's a bit as if you'd done:</p>

<pre><code>func_t retFun2()
{
    int __lambda0(int)
    {
        return 2;
    }

    struct
    {
        int operator(int __arg0) const
        {
            return __lambda0(__arg0);
        }

        operator decltype(__lambda0)() const
        {
            return __lambda0;
        }
    } lambda;

    return lambda; // just the address of a regular ol' function
}
</code></pre>
"
"<p>From this reference:</p>

<blockquote>
  <p>(8.3.3/3) A pointer to member shall not point to a static member of a
  class (9.4), a member with reference type, or ""<em>cv</em> void.""</p>
</blockquote>

<p>Why a pointer cannot point to a static member of a class?</p>

<pre><code>struct S {
     static int f() { /*...*/ };

};

int main()
{
     int (S::*s)() = &amp;S::f; // why?
}
</code></pre>
","87234","","<p>Whenever you do <code>T::*</code>, you're saying ""this thing requires an instance of <code>T</code> to use."" That statement does not hold for <code>static</code> functions, which are callable without any instances of the class.</p>
"
"<p>I understand no copy or assign for IO objects, so that we have to have reference sign <code>&amp;</code> for istream/ostream objects. But why <code>ifstream/ofstream</code> or <code>istringstream/ostringstream</code> doesn't require a <code>&amp;</code> to initialize an object? .</p>

<pre><code>istream&amp; input=cin;
ifstream infile;
infile(""in"");
</code></pre>

<p>istream needs a &amp; and ifstream doesn't need a &amp; to declare the variable.</p>
","87234","","<p>Those two aren't <em>really</em> comparable; one has an initializer and the other doesn't.</p>

<p>But <code>std::istream input = cin</code> doesn't work because streams are not copyable. If you tried to initialize <code>infile</code> with an existing <code>ifstream</code>, you'd get the same error. Obviously, a reference entails no copying and so it works, aliasing the existing value.</p>

<p>Going the opposite way, if you leave out the initializer, then you <em>can't</em> have a reference because a reference requires an initializer. Instead, your stream will just default construct.</p>
"
"<p>The two overloaded function in std::string got my attention:</p>

<pre><code>string&amp; append(const string&amp; str, size_t pos, size_t n);
string&amp; append(const char* s, size_t n);
</code></pre>

<p>I'm curious that why the char* version of string::append() doesn't provide an additional parameter <code>size_t pos</code>, as the one below:</p>

<pre><code>string&amp; append(const char* s, size_t pos, size_t n);
</code></pre>

<p>For the other two functions, the situation is also the same:</p>

<pre><code>int compare(size_t pos1, size_t n1, const string&amp; str, size_t pos2, size_t n2) const;
int compare(size_t pos1, size_t n1, const char* s, size_t n2) const;

string&amp; replace(size_t pos1, size_t n1, const string&amp; str, size_t pos2, size_t n2);
string&amp; replace(size_t pos1, size_t n1, const char* s, size_t n2);
</code></pre>

<p>The char* version of these functions lack the parameter <code>size_t pos2</code>, which is not as flexible as their string&amp; counterpart. My question is the following:</p>

<ol>
<li>Why does std::string design its interface like this?</li>
<li>Why doesn't the char* version function has <code>size_t pos</code> as well?</li>
<li>What's the consideration(s) behind this?</li>
</ol>

<p>Thank you for reading!</p>
","87234","","<p>Because you can just add <code>pos</code> to <code>s</code>:</p>

<pre><code>str.append(ptr + pos, len);
</code></pre>

<p>That isn't to say it wouldn't be a nice shorthand to have, but they (generally) only want to minimally add the necessary functions, not the trivial wrapper kind.</p>
"
"<p>Why might my compiler see the following GetLength function pointer as ambiguous<br>
pseudo-code:</p>

<pre><code>size_t GetLength(char*);
size_t GetLength(wchar_t*);
struct ITEM { };
double GetLength(ITEM*);

CString GetInfo(ITEM * item, std::function&lt;double (ITEM*)&gt; fn)
{
  ... omitted for clarity
}

ITEM * item = new ITEM;
cout &lt;&lt; GetInfo(item, GetLength);  // &lt;- ambiguous error
</code></pre>

<p>GetInfo only allows something of the double return + ITEM* argument pattern.  So why is it considering (and not discarding) the two string based variations of GetLength?</p>
","87234","","<p>The constructor for <code>std::function&lt;...&gt;</code> is <em>templated</em> because it has to be able to support any function-like input type. There's no single type to try to deduce to, so your overloads are all possible to construct with; it wouldn't be until later into compilation later that an error arose for a type mismatch.</p>

<p>You could do this:</p>

<pre><code>GetInfo(item, static_cast&lt;double(*)(ITEM*)&gt;(GetLength));
</code></pre>

<p>To explicitly discard the other overloads.</p>

<hr>

<p>In other words, it's the same reason this won't work:</p>

<pre><code>void foo(int);
void foo(void*);

struct bar
{
    template &lt;typename T&gt;
    bar(T f)
    {
        f(5);
    }
};

bar b(foo);
</code></pre>

<p>Even though the constructor body for <code>bar</code> will only work with <code>void foo(int)</code>,
it wants to support any function where <code>f(5)</code> will work so the argument type is templated. This allows any function to work in that place, which means the compiler cannot deduce a single best overload to use.</p>

<hr>

<p>I think that one language-level solution is for an overload set to actually be a functor itself. That is, given:</p>

<pre><code>void foo(int);
void foo(void*);

template &lt;typename T&gt;
double foo(int, T);
</code></pre>

<p>Naming <code>foo</code> (as in <code>bar(foo)</code> or even just <code>foo(5)</code>) results in an instance of this type:</p>

<pre><code>struct __foo_overload_set // internal
{
    // forwarders
    void operator()(int __arg0) const
    {
        // where __foo0 is the zeroth overload, etc...
        return __foo0(__arg0);
    }

    void operator()(void* __arg0) const
    {
        return __foo1(__arg0);
    }

    template &lt;typename __Arg1&gt;
    double operator()(int __arg0, __Arg1&amp;&amp; __arg1) const
    {
        return __foo2(__arg0, std::forward&lt;__Arg1&gt;(__arg1));
    }

    // converters
    typedef void(*__foo0_type)(int);

    operator __foo0_type() const
    {
        return __foo0;
    }

    typedef void(*__foo1_type)(void*);

    operator __foo1_type() const
    {
        return __foo1;
    }

    template &lt;typename T&gt;
    struct __foo2_type
    {
        typedef void(*type)(int, T);
    };

    template &lt;typename T&gt;
    operator typename __foo2_type&lt;T&gt;::type() const
    {
        return __foo2;
    }
};
</code></pre>

<p>Which, being callable itself, <em>will</em> compile in the context we want. (AFAIK, it does not introduce any ambiguities that don't already exist, though it's completely untested.)</p>
"
"<p>I have the following code:</p>

<pre><code>template&lt;int k&gt;
void foo()
{
}
int main(int argc, char* argv[])
{
    int k = 1000;
    foo&lt;k&gt;();
    return 0;
}
</code></pre>

<p>which doesn't compile, but if I declare <code>k</code> as <code>const</code>, it does:</p>

<pre><code>template&lt;int k&gt;
void foo()
{
}
int main(int argc, char* argv[])
{
    const int k = 1000;
    foo&lt;k&gt;();
    return 0;
}
</code></pre>

<p>Now, I see the logic behind why in the first case it doesn't compile and in the second it does, but is this specified by the standard?</p>

<p>The error I'm getting is:</p>

<pre><code>Error   1   error C2971: 'foo' : template parameter 'k' : 'k' : a local variable cannot be used as a non-type argument
</code></pre>

<p>which isn't exactly clear, since <code>k</code> is a local variable also in the case it's <code>const</code>... right?</p>
","87234","","<p>§14.3.2.1 says [abridged]:</p>

<blockquote>
  <p>A template-argument for a non-type, non-template template-parameter shall be one of:<br>
  — an integral <em>constant-expression</em> of integral or enumeration type;</p>
</blockquote>

<p>And §5.19.1 says [abridged, emphasis mine]:</p>

<blockquote>
  <p>An <em>integral constant-expression</em> can involve only literals, enumerators, <strong>const variables or static data members of integral or enumeration types initialized with constant expressions</strong>...</p>
</blockquote>

<p>Your second definition of <code>k</code> satisfies this, so it's allowed to be used as an ICE for the template argument.</p>

<p>The error is slightly misleading in that ""a local variable cannot be used as a non-type argument"" is true <em>in general</em>, but with certain restrictions it's perfectly fine.</p>
"
"<p>Consider a type <code>T</code> and a pointer to <code>T</code>, <code>T*</code>.</p>

<p>Is there a way to place a copy of <code>T*</code> at a given address <code>x</code>, without using <code>memcpy()</code> and in a portable way?</p>

<p>Edit:</p>

<p>Just to be clear, I don't want to construct <code>T</code> at address <code>x</code>. I want to copy the value of the pointer to <code>T</code>, <code>T*</code>, at address <code>x</code>, as in</p>

<pre><code>char* p = new char[s];
memcpy(&amp;p[0], t, sizeof(T*)); // t is T*
</code></pre>
","87234","","<p><strong>If you want to construct an object at a specific address</strong>, you use placement-new:</p>

<pre><code>#include &lt;new&gt;

T oldT = /* .. */;
T* newT = new (x) T(oldT); // copy-constructed at address x
</code></pre>

<p>It's just like <code>new T()</code>, except you specify the buffer. (So take care that it's aligned and lives long enough.)</p>

<hr>

<p><strong>If you want to copy a value pointed to by a pointer</strong>, just dereference the pointer:</p>

<pre><code>T* x = /* .. */;
T copyT = *x; // dereference x, make copy
</code></pre>

<hr>

<p>In both cases, replace <code>T</code> with your type (be that <code>U</code> or <code>U*</code>, etc.).</p>
"
"<p>For a fixed array,</p>

<pre><code>  // will initialize the missing elements to 0 as well
   A[max_row][max_col] = {0,} 
</code></pre>

<p>Can we achieve this in dynamic arrays (multidimensional, in particular)?</p>

<p><strong>Side question</strong>:  if we can't, and we are forced to use nested loop, then how does the initialization time of the trick above compared to nested loop initialization? </p>

<hr>

<p>I don't want to vector, otherwise this question is meaningless. Thanks for the advise :) </p>
","87234","","<p>If you do this: <code>new int[N]() /* note parenthesis */</code>, then they are all zero initialized.</p>

<p>You should really use a <code>std::vector</code>, though.</p>
"
"<p>Is it bad practice to declare a typedef at class scope? Is it better to declare them for every function to make sure no one includes that file and then creates something with the same name?</p>

<p>For example</p>

<pre><code>typedef std::vector&lt;int&gt;::size_type vec_int;
</code></pre>

<p>Would be useful in some of my headers as in some classes there are many functions that use this type, but on the other hand I would have to put it in the header, wouldn't I? Or could I put it at the top of the source file?</p>
","87234","","<p>I'd say just keep the scope to a minimum; with that, do whatever is cleanest.</p>

<p>If you use it for one function, keep it in that function's scope. If you use it for several functions, make it a private typedef. And if you expect others to use it (out of utility, perhaps), make it public.</p>

<p>In code:</p>

<pre><code>namespace detail
{
    // By convention, you aren't suppose to use things from
    // this namespace, so this is effectively private to me.

    typedef int* my_private_type;
}

void some_func()
{
    // I am allowed to go inside detail:
    detail::my_private_type x = 0;

    /* ... */
}

void some_other_func()
{
    // I only need the typedef for this function,
    // so I put it at this scope:
    typedef really::long::type&lt;int&gt;::why_so_long short_type;

    short_type x;

    /* ... */
}

typedef int integer_type; // intended for public use, not hidden

integer_type more_func()
{
    return 5;
}

class some_class
{
public:
    // public, intended for client use
    typedef std::vector&lt;int&gt; int_vector; 

    int_vector get_vec() const;

private:
    // private, only for use in this class
    typedef int* int_ptr;
};
</code></pre>

<p>Hopefully that gives you an idea of what I mean.</p>
"
"<p>Is there a better way to do the following?</p>

<pre><code>#include &lt;iostream&gt;

template &lt;typename T&gt;
T Bar();

template &lt;&gt;
int Bar&lt;int&gt;() { return 3; }

// Potentially other specialisations

int main()
{
    std::cout &lt;&lt; Bar&lt;int&gt;() &lt;&lt; std::endl; // This should work
    std::cout &lt;&lt; Bar&lt;float&gt;() &lt;&lt; std::endl; // This should fail
}
</code></pre>

<p>The problem with this solution is that it fails at (understandably) link time with ""undefined reference to float <code>Bar&lt;float&gt;()</code>"" or the like. This can be confusing for other developers as they may suspect an implementation file is not being linked.</p>

<p>I do know another potential solution:</p>

<pre><code>template &lt;typename T&gt;
T Bar() { BOOST_STATIC_ASSERT(sizeof(T) == 0); }
</code></pre>

<p>This causes a compiler error when <code>Bar&lt;float&gt;()</code> is requested, exactly what I want. However, I'm concerned that technically a compiler may reject this just as gcc rejects <code>BOOST_STATIC_ASSERT(false)</code> because it knows that it will fail regardless of the template parameter, since <code>sizeof(T)</code> can <em>never</em> be zero.</p>

<p>In summary, I want to know whether:</p>

<ol>
<li>There is another way to do this.</li>
<li>I'm mistaken and <code>BOOST_STATIC_ASSERT(sizeof(T))</code> actually can't fail without instantiation.</li>
<li>The only way is to let this be a linker error as above.</li>
</ol>
","87234","","<p><code>BOOST_STATIC_ASSERT(sizeof(T) == 0);</code> isn't allowed to fail until the template is instantiated, so I would just do that one. You are correct that <code>BOOST_STATIC_ASSERT(false);</code> triggers each time.</p>

<hr>

<p>The reason for this has to do with two-phase name lookup. This is, essentially, the following: when a template is compiled, it's compiled twice. The first time a compielr sees a template it compiles <em>everything</em> except the expressions dependent on template parameters, and the second compilation happens once the template parameter is known, compiling the instantiation fully.</p>

<p>This is why <code>BOOST_STATIC_ASSERT(false);</code> will fail always: nothing here is dependent and the assert is processed immediately, as if the function weren't a template at all. (Note that MSVC does not implement two-phase look-up, so this fails at instantiation, incorrectly.) Contrarily, because <code>T</code> is dependent (§14.6.2.1), <code>BOOST_STATIC_ASSERT(sizeof(T) == 0);</code> is dependent, and is not allowed to be checked until the template is instantiated. (Where upon it will always fail.)</p>

<p>If a compiler tries to be thoughtful and fail it ahead of time, it would be non-conforming. You're suppose to be able to rely on this stuff. That said, if fear gets the best of you it's trivial to <em>really</em> make it wait:</p>

<pre><code>BOOST_STATIC_ASSERT(sizeof(typename T::please_use_specializations) == 0);
</code></pre>

<p>This is both guaranteed to fail, and impossible for a compiler to correctly ""smartly"" fail ahead of time.</p>
"
"<p>The question is simple.  Why does this compile:</p>

<pre><code>bool b(true);
if (b) { /* */ }
</code></pre>

<p>And this compile:</p>

<pre><code>if (bool b = true) { /* */ }
</code></pre>

<p>But not this:</p>

<pre><code>if (bool b(true)) { /* */ }
</code></pre>

<p>In my real code, I need to construct an object and test it, while also having it destroyed when the if-block ends.  Basically, I'm looking for something like this:</p>

<pre><code>{
    Dingus dingus(another_dingus);
    if (dingus) {
        // ...
    }
}
</code></pre>

<p>Of course, this would work:</p>

<pre><code>if (Dingus dingus = another_dingus) { /* */ }
</code></pre>

<p>But then I'm constructing a <code>Dingus</code> and calling <code>operator=</code> on it.  It seems logical to me that I would be able to construct the object using whatever constructor I please.</p>

<p>But I'm baffled why this isn't grammatically correct.  I've tested with G++ and MSVC++ and they both complain about this construct, so I'm sure it's part of the spec but I'm curious as to the reasoning for this and what non-ugly workarounds there may be.</p>
","87234","","<p>It's a bit technical. There's no reason why what you want couldn't be allowed, it just isn't. It's the grammar.</p>

<p>An <code>if</code> statement is a selection statement, and it takes the grammatical form:</p>

<pre><code>if (condition) statement
</code></pre>

<p>Here, <code>condition</code> can be either:</p>

<ul>
<li><code>expression</code> or</li>
<li><code>type-specifier-seq declarator = assignment-expression</code></li>
</ul>

<p>And there you have it. Allowing a declaration in a condition is a special case, and it must follow <em>that</em> form or your program is ill-formed. They could have probably allow direct-initialization instead of copy-initialization, but there isn't really any motivation to do so now. <a href=""http://stackoverflow.com/a/8332693/87234"">As Johannes Schaub points out</a>, this change would break existing code, so it's pretty much never going to happen.</p>

<p>Let_Me_Be notes that C++11 added a third form (I'm ignoring attributes here):</p>

<pre><code>decl-specifier-seq declarator braced-init-list
</code></pre>

<p>So <code>if (bool b{true})</code> is fine. (This can't possibly break any valid existing code.)</p>

<hr>

<p>Note your question seems to do with efficiency: don't worry. The compiler will elide the temporary value and just construct the left-hand side directly. This, however, requires your type be copyable (or movable in C++11).</p>
"
"<p>The <code>new</code> expression in the <code>try</code> block throws a <code>bad_alloc</code>exception in my computer.</p>

<p>Note that the catch clause receives an exception object by value, not by reference. How come <code>e.what()</code> prints <code>""bad allocation""</code> ?  I thought it would be sliced.</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    try
    {
        int* p = new int[0x1F000000];
    }
    catch(std::exception e)
    {
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}
</code></pre>
","87234","","<p>Visual Studio (Dinkumware?) uses an implementation of <code>std::exception</code> that contains internal storage† for the message. (Complete with a non-standard constructor that accepts a string.)</p>

<p>Because of this, no virtual dispatch is actually needed to get the error message, it survives any slicing.</p>

<p>A more orthodox implementation would indeed print a generic exception message, because the derived object was sliced off. (Effectively, MS has made <code>std::exception</code> and <code>std::runtime_error</code> equivalent. There's nothing wrong with this, since the return value of <code>std::exception::what</code> is implementation-defined, but it explains your results.)</p>

<hr>

<p>†Internal storage here is used loosely. It doesn't have an internal <em>buffer</em>, but it has a <code>const char*</code> and a <code>bool</code>. The <code>const char*</code> points to the message (the return value of <code>what()</code>), and the <code>bool</code> is a flag determining if the buffer should be deleted.</p>

<p>It's like this:</p>

<pre><code>class msvc_exception // for exposition
{
public:
    msvc_exception(const char* msg) :
    mMsg(msg),
    mDoDelete(false)
    {}

    msvc_exception(const std::string&amp; msg) :
    mMsg(copy_string(msg)),
    mDoDelete(true)
    {}

    virtual ~msvc_exception()
    {
        if (mDoDelete)
            delete [] mMsg;
    }

    virtual const char* what() const throw()
    {
        return mMsg ? mMsg : ""unknown"";
    }

private:
    const char* copy_string(const std::string&amp; str)
    {
        const char* result = new char[str.size() + 1];

        std::copy(str.begin(), str.end(), result);
        result[str.size()] = 0; // null-terminate

        return result;
    }
};
</code></pre>

<p>You see now that <code>bad_alloc</code> works like this:</p>

<pre><code>    class msvc_bad_alloc : // for exposition
        public msvc_exception
    {
    public:
        msvc_bad_alloc() :
        msvc_exception(""bad_alloc"") // note: a static string, no dynamic storage
        {}
    };
</code></pre>

<p>Slicing doesn't affect the message because the message ""exists"" in the base class.</p>

<p>Other compilers, like GCC and LLVM, implement it a bit more straight-forwardly:</p>

<pre><code>class orthodox_exception
{
public:
    orthodox_exception(){}
    virtual ~orthodox_exception() {}

    virtual const char* what() const throw()
    {
        return ""orthodox_exception"";
    }
};

class orthodox_bad_alloc :
    public orthodox_exception
{
public:
    const char* what() const throw()
    {
        return ""orthodox_bad_alloc"";
    }
};
</code></pre>

<p>Here, slicing would affect your outcome. (That said, after all this: always catch by reference.)</p>
"
"<p>With the advent of <code>std::unique_ptr</code>, the blemished <code>std::auto_ptr</code> can finally be put to rest.  So for the last several days, I have been changing my code to use smart pointers and to eliminate all <code>delete</code> from my code.</p>

<p>Although valgrind says my code is memory-clean, the semantic richness of smart pointers will make for cleaner and easier-to-understand code.</p>

<p>In most of the code, the translation is simple: use <code>std::unique_ptr</code> for in place of the raw pointers held by the owning objects, throw out <code>delete</code>, and carefully sprinkle <code>get()</code>, <code>reset()</code> and <code>move()</code> calls, as needed, to interface well with the rest of the code.</p>

<p>I am at the point where I am translating <strong>non-owning raw pointers</strong> to smart pointers now.</p>

<p>Since I was careful with the lifetimes of my objects (I ensure my modules only depend in one direction), valgrind tells me that I don't have any uninitialized reads, dangling pointers, or leaks.  So, technically, I could just leave those <strong>non-owning raw pointers</strong> alone now.</p>

<p>However, one option is to change those <strong>non-owning raw pointers</strong> to <code>std::shared_ptr</code> because I know they are acyclic.  Or, would it be better to leave them as raw pointers?</p>

<p><em>I need some advice from veteran users of smart pointers as to what rules of thumb you use to decide whether to keep <strong>non-owning raw pointers</strong> as-is, or to translate them into <code>std::shared_ptr</code>,</em> keeping in mind that I constantly unit-test and valgrind my code.</p>

<p>EDIT:  I might be misunderstanding the use of <code>std::shared_ptr</code> - can they be used in conjunction with <code>std::unique_ptr</code>, or is it the case that if I use <code>std::shared_ptr</code>, all handles should also be <code>std::shared_ptr</code>?</p>
","87234","","<p>Use a <code>shared_ptr</code> when you require multiple things own a resource (and those owning things may go in and out of scope at ""random""), use a <code>unique_ptr</code> when a single thing owns the resource, and use a raw pointer when you just need to refer to it and not own it (and expect this referral to not last longer than the resource exists).</p>

<p>There is a fourth type, a sort of raw-pointer-for-<code>shared_ptr</code>'s, called <code>weak_ptr</code>. You use that to refer to a <code>shared_ptr</code> without actually owning it; you can then check if the object is still there and use it.</p>
"
"<p>This is my code:</p>

<pre><code>class Base
{
    friend class SubClass;
    int n;
    virtual int getN()
    {
        return n;
    }
};

class SubClass: public Base
{
public:
    SubClass() {}
    SubClass(const SubClass&amp; s) {}


};

int _tmain(int argc, _TCHAR* argv[])
{
    SubClass s;
    int x = s.getN();

    return 0;
}


error C2248: 'Base::getN' : cannot access private member declared in class 'Base'
</code></pre>

<p>What more do I have to do to access my private members from Base ?</p>
","87234","","<p>Your <code>friend</code> declaration means that <code>SubClass</code> gets to access it <em>in the scope of <code>SubClass</code></em>.</p>

<p>If you want users of a class to access something, at some point you need to a write <code>public:</code> function:</p>

<pre><code>class SubClass : public Base
{
public:
    int getN()
    {
        return Base::getN();
    }
};
</code></pre>

<p>You can write a using declaration to bring a base class function into the current class:</p>

<pre><code>class SubClass : public Base
{
public:
    // getN is considered declared at this point now (in public)
    using Base::getN(); 
};
</code></pre>
"
"<p>Why is the following code valid:</p>

<pre><code>template&lt;typename T1&gt;
void foo(T1 &amp;&amp;arg) { bar(std::forward&lt;T1&gt;(arg)); }

std::string str = ""Hello World"";
foo(str); // Valid even though str is an lvalue
foo(std::string(""Hello World"")); // Valid because literal is rvalue
</code></pre>

<p>But not:</p>

<pre><code>void foo(std::string &amp;&amp;arg) { bar(std::forward&lt;std::string&gt;(arg)); }

std::string str = ""Hello World"";
foo(str); // Invalid, str is not convertible to an rvalue
foo(std::string(""Hello World"")); // Valid
</code></pre>

<p>Why doesn't the lvalue in example 2 get resolved in the same manner that it does in example 1?</p>

<p>Also, why does the standard feel it important to need to provide the argument type in std::forward versus simple deducing it? Simply calling forward is showing intention, regardless of the type.</p>

<p>If this isn't a standard thing and just my compiler, I am using msvc10, which would explain the crappy C++11 support.</p>

<p>Thanks</p>

<p>Edit 1: Changed the literal ""Hello World"" to be std::string(""Hello World"") to make an rvalue.</p>
","87234","","<p>First of all, <a href=""http://stackoverflow.com/questions/3582001/advantages-of-using-forward/3582313#3582313"">read this</a> to get a full idea of forwarding. (Yes, I'm delegating most of this answer elsewhere.)</p>

<p>To summarize, forwarding means that lvalues stay lvalues and rvalues stay rvalues. You can't do that with a single type, so you need two. So for each forwarded argument, you need two versions for that argument, which requires 2<sup>N</sup> combinations total for the function. You <em>could</em> code all the combinations of the function, but if you use templates then those various combinations are generated for you as needed.</p>

<hr>

<p>If you're trying to optimize copies and moves, such as in:</p>

<pre><code>struct foo
{
    foo(const T&amp; pX, const U&amp; pY, const V&amp; pZ) :
    x(pX),
    y(pY),
    z(pZ)
    {}

    foo(T&amp;&amp; pX, const U&amp; pY, const V&amp; pZ) :
    x(std::move(pX)),
    y(pY),
    z(pZ)
    {}

    // etc.? :(

    T x;
    U y;
    V z;
};
</code></pre>

<p>Then you should stop and do it this way:</p>

<pre><code>struct foo
{
    // these are either copy-constructed or move-constructed,
    // but after that they're all yours to move to wherever
    // (that is, either: copy-&gt;move, or move-&gt;move)
    foo(T pX, U pY, V pZ) :
    x(std::move(pX)),
    y(std::move(pY)),
    z(std::move(pZ))
    {}

    T x;
    U y;
    V z;
};
</code></pre>

<p>You only need one constructor. <strong>Guideline</strong>: if you need your own copy of the data, make that copy in the parameter list; this enables the decision to copy or move up to the caller and compiler.</p>
"
"<p>I tried this dummy code below to test unnamed namespace.</p>

<p>I have the following output</p>

<pre><code> ctor 1
 ctor 0
 3
 5
</code></pre>

<p>I am a bit confused about this.</p>

<ol>
<li>I was expecting an error from the compiler saying that it cannot resolve
an ambiguity regarding <code>a::m_a</code>. Instead it refers always to the
less nested. Is it always the case? What rules C++ is following?</li>
<li>It seems that the compiler creates variable CMyObj following the order
written on the file. Is this always the case?</li>
<li>is there any way to access the most nested <code>m_a</code> variable 
from <code>main()</code>?. </li>
</ol>



<pre><code>class CMyObj{     
    public:
    CMyObj(int a){std::cout  &lt;&lt; ""ctor "" &lt;&lt; a &lt;&lt; std::endl; }
 };
 namespace a{ 
      namespace{
           int m_a=4;
           int m_b=5;
           CMyObj m_obj(1);
      }  
 }
 namespace a{
      int m_a=3;
      CMyObj m_obj(0);
 }
 int main(){
      std::cout &lt;&lt; a::m_a &lt;&lt; std::endl; // which one?
      std::cout &lt;&lt; a::m_b &lt;&lt; std::endl; // how this is possible?
      return 0;
 }
</code></pre>
","87234","","<p>First look at this simplified code (and my simplified explanation, you can read §3.4.3.2 for the details):</p>

<pre><code>namespace a
{
    int x;
}

int main()
{
    int i = a::x;
}
</code></pre>

<p>Consider what happens when we say <code>a::x</code>. First the compiler enumerates all the declarations of <code>x</code> in <code>a</code>. If it finds an unambiguous <code>x</code>, it finishes successfully. Otherwise it recursively searches the namespaces declared by a using-directive. If it never finds a result, the program is ill-formed.</p>

<pre><code>namespace a
{
    int x;
}

namespace b
{
    using namespace a;
}

int main()
{
    int i = b::x;
}
</code></pre>

<p>Here, it doesn't find <code>x</code> in <code>b</code>, so it searches the namespace <code>a</code> (because of the using-directive) and finds it. It should now make sense why this isn't ambiguous:</p>

<pre><code>namespace a
{
    int x;
}

namespace b
{
    using namespace a;
    int x;
}

int main()
{
    int i = b::x;
}
</code></pre>

<p>Here it finds the <code>x</code> in <code>b</code> and never considers <code>a</code>. Now just consider that an unnamed namespace is actually just a namespace with a unique unknown name:</p>

<pre><code>namespace b
{
    namespace
    {
        int x;
    }

    // this is what an unnamed namespace expands to (in exposition)
    namespace __unique__ {}
    using namespace __unique__;

    namespace __unique__
    {
        int x;
    }

    int x;
}

int main()
{
    int i = b::x;
}
</code></pre>

<p>Like before, the <code>x</code> in <code>b</code> is found without considering the unnamed namespace. Your code is similar.</p>
"
"<p>I want to have a class behave identically to pointers, <em>but</em> also support the comparison operators, like <code>&lt;</code> and <code>&gt;</code>.</p>

<p>I am running into casting troubles:</p>

<pre><code>ptr_t&lt;foo&gt; x = new foo;
(bar*)x;              // cast should be allowed
static_cast&lt;bar*&gt;(x); // cast should fail
</code></pre>

<p>The above snippet should behave as if <code>ptr_t&lt;foo&gt;</code> was <code>foo*</code>. </p>

<p>Here is the cast operator:</p>

<pre><code>template &lt;typename cast_t&gt;
explicit inline operator cast_t() {
  return (cast_t)(ptr); // causes static_cast to use C-style, which is bad
}
</code></pre>

<p>If I use C-style in the definition then <code>static_cast</code> becomes unsafe. If I use <code>static_cast</code> then the C-style becomes less useful. How can I fix this?</p>
","87234","","<p>You can easily emulate <code>ptr_t&lt;foo&gt;</code> acting like <code>foo*</code> by overloading the arrow and dereference operators, whilst providing a <code>get</code> function. This is how all smart pointer operate (by convention), and it's much more natural to work with. Messing around with casts seems needlessly complicated and fragile. </p>

<pre><code>template &lt;typename T&gt;
struct ptr_t
{
    T* get() const;

    T* operator-&gt;() const
    {
        return get();
    }

    T&amp; operator*() const
    {
        return *get();
    }
};
</code></pre>

<hr>

<pre><code>struct foo
{
    void bar() const;
};

void baz(foo*);

ptr_t&lt;foo&gt; x = /* .. */;

x-&gt;bar();
(*x).bar();
baz(x.get());
</code></pre>
"
"<p>In <em>A brief Introduction to Rvalue References</em>, perfect forwarding is proposed as the ideal solution to forward rvalue 5 to a constructor with a non-const reference argument.</p>

<p>But:</p>

<pre><code>#include &lt;memory&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;

template &lt;class T, class A1&gt;
std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) {
   return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1)));
}

class X {
public:
    X(int&amp; i){
        std::cout&lt;&lt;""X(""&lt;&lt;i&lt;&lt;"")\n"";
    }
};


int main() {
    std::shared_ptr&lt;X&gt; p = factory&lt;X&gt;(5);
}
</code></pre>

<p>fails in XCode 4.2 ans G++ 4.6.1 with <code>no known conversion from int to int&amp;</code>, whereas:</p>

<pre><code>template &lt;class T, class A1&gt;
std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) {
   return std::shared_ptr&lt;T&gt;(new T(/*no forwarding*/a1));
}
</code></pre>

<p>compiles. What did I get wrong?</p>
","87234","","<p>Ignore rvalue-references for a second, and instead pretend this was allowed:</p>

<pre><code>void modify_int(int&amp; i)
{
    i = 1;
}

void foo(int&amp; x)
{
    modify_int(x); // okay, modify_int references x
}

int i = 7;
foo(i); // makes i = 1

// illegal in standard C++, cannot bind a temporary to a non-const reference
foo(5); // makes the temporary integer equal to 1
</code></pre>

<p>You can see that the temporary object gets modified, which is perfectly fine. However, this binding was made illegal in C++ because its usually not desired (it reads as if 5 was being changed to 1, after all).</p>

<p>All rvalue-references do is enable the binding of temporary values to references, but safely because we understand that we're dealing with a value that should be considered temporary:</p>

<pre><code>void modify_int(int&amp; i)
{
    i = 1;
}

void foo(int&amp;&amp; x)
{
    modify_int(x); // okay, modify_int references x
}

int i = 7;
foo(std::move(i)); // makes i = 1 (std::move makes it an rvalue)

// legal in C++11, temporary is bound to rvalue-reference
foo(5); // makes the temporary integer equal to 1
</code></pre>

<p>Note that in this version of <code>foo</code>, passing to <code>modify_int</code> is still perfectly fine. Once inside the function, the fact that it was an rvalue-reference instead of an lvalue-reference is irrelevant: we still have an object to refer to. <a href=""http://stackoverflow.com/questions/3582001/advantages-of-using-forward/3582313#3582313"">Forwarding is used in templates to preserve the value category</a>:</p>

<pre><code>void test(int&amp; i) {} // lvalue version of test
void test(int&amp;&amp; i) {} // rvalue version of test

template &lt;typename T&gt;
void foo(T&amp;&amp; x)
{
    // if x was an lvalue, forward does nothing;
    // if x was an rvalue, forward std::move's it 
    test(std::forward&lt;T&gt;(x)); 
}

int i = 7;
foo(i); // calls lvalue version of test

foo(5); // calls rvalue version of test
</code></pre>

<p>Your code without forwarding is similar to the second snippet in my answer. Once inside the <code>factory</code> function, <code>a1</code> is just a regular lvalue, and binds to the constructor reference just fine. But with forwarding, it turns back into an rvalue (because <code>factory(5)</code> calls it with an rvalue), which cannot bind to the lvalue-reference, resulting in an error.</p>
"
"<p>I'm reviewing code of a custom container and some portions of it create elements like this:</p>

<pre><code>::new( (void*)&amp;buffer[index] ) CStoredType( other );
</code></pre>

<p>and some do like this:</p>

<pre><code>::new( &amp;buffer[index] ) CStoredType( other );
</code></pre>

<p>So both use placement new to invoke a copy constructor to create an element by copying some other element, but in one case a pointer to the new element storage is passed as is and in another it is casted to <code>void*</code>.</p>

<p>Does this cast to <code>void*</code> have any effect?</p>
","87234","","<p>A compilable example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;new&gt;

void* operator new(std::size_t, int* x)
{
    std::cout &lt;&lt; ""a side effect!"" &lt;&lt; std::endl;

    return x;
}

int main()
{
    int buffer[1];

    new ((void*)&amp;buffer[0]) char;
    new (&amp;buffer[0]) char;
}
</code></pre>
"
"<p>Say I have some sort of type wrapping up a function, maybe a lambda function:</p>

<pre><code>template&lt;typename Function&gt;
  struct my_struct
{
  Function f;

  my_struct(const Function &amp;f) : f(f) {}
};
</code></pre>

<p>What happens when an instance of this type is assigned? My understanding is that lambdas are immutable, and have deleted assignment operators.</p>

<p>Yet, when I assign to an object this type in the code snippet below, no error is emitted:</p>

<pre><code>// a structure which contains a function;
// possibly a lambda function
template&lt;typename Function&gt;
  struct my_struct
{
  Function f;

  my_struct(const Function &amp;f) : f(f) {}

  // XXX adding this assignment operator causes an error
  //my_struct &amp;operator=(const my_struct &amp;other)
  //{
  //  f = other.f;
  //  return *this;
  //}
};

template&lt;typename Function&gt;
my_struct&lt;Function&gt; make_struct(const Function &amp;f)
{
  return my_struct&lt;Function&gt;(f);
}

int main()
{
  // create some lambda
  auto lambda = [](int x){return x;};

  // make a struct containing a copy of the lambda
  auto x = make_struct(lambda);

  // try to assign to the struct, which
  // presumably assigns to the enclosed lambda
  x = make_struct(lambda);

  return 0;
}
</code></pre>

<p>Adding the commented-out assignment operator yields an error, as expected:</p>

<pre><code>$ g++-4.6 -std=c++0x test.cpp
test.cpp: In member function ‘my_struct&lt;Function&gt;&amp; my_struct&lt;Function&gt;::operator=(const my_struct&lt;Function&gt;&amp;) [with Function = main()::&lt;lambda(int)&gt;, my_struct&lt;Function&gt; = my_struct&lt;main()::&lt;lambda(int)&gt; &gt;]’:
test.cpp:34:25:   instantiated from here
test.cpp:13:5: error: use of deleted function ‘main()::&lt;lambda(int)&gt;&amp; main()::&lt;lambda(int)&gt;::operator=(const main()::&lt;lambda(int)&gt;&amp;)’
test.cpp:27:18: error: a lambda closure type has a deleted copy assignment operator
</code></pre>

<p>So, is it possible to create assignable types with lambda member variables?  This seems like a reasonable thing to want to try.  Consider combining a lambda with <code>boost::transform_iterator</code>, for example.</p>
","87234","","<p>You're close. A lambda has an implicit copy-constructor and may have — depending on the captured values — an implicit move-constructor. It has a deleted copy-assignment operator.</p>

<p>In other words, you may construct it, but you may not assign it. If you're looking for a generic function object, you want to use <code>std::function&lt;&gt;</code>. It emulates functions as first-class values.</p>

<hr>

<p>Note that immutable is different from assignable.  When a lambda is called mutable, that means its function-call body can modify the members of the lambda (i.e., the function is not <code>const</code>):</p>

<pre><code>int i = 0;

auto okay = [=](int x) mutable { i += x; };
auto error = [=](int x) { i += x; };
</code></pre>

<p>Each of these is copy-constructable and non-assignable.</p>
"
"<p>Is there anyway in C++11 to have an input argument to a function be declared as invalid after the function returns?</p>

<p>For a simple example, consider that I have a rectangle object with a coordinate for the lower left corner and a coordinate for the upper right corner.  If I pass this rectangle object by non-const reference to the function, the function is free to side-effect the rectangle memory in place as it sees fit. What if that function needs to scale it and rather than copying to new memory just wants to work in place, how could we in C++11 declare that after the function returns, the contents of the rectangle passed in are no longer valid as they may have been modified by the function called?</p>

<p>I would not want to modify the rectangle class, but instead have some way in the declaration of the function call to indicate that the memory passed in by reference should be considered invalid upon return from the function and have the compiler give an error if the caller tries to use it subsequent to the function call returning. Is there some way to do this in C++11?</p>
","87234","","<p>You can get half-way there:</p>

<pre><code>void function(rectangle&amp;&amp; x) // r-value reference
{
    // ...
}

rectangle r;

function(r); // error
function(std::move(r)); // okay, explicitly made into an rvalue

// now (by convention) r shouldn't be used, because it's been moved
</code></pre>

<p>That said, the type-system is C++ is not strong enough to give you an error if you use it again.</p>

<p>I question your design, though. What's wrong with making a copy? Or why not make it clear in the function name that the argument is going to modified? (Like <code>std::swap</code>.)</p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/3926530/a-singleton-that-is-not-globally-accessible"">A Singleton that is not globally accessible</a>  </p>
</blockquote>



<p>Do you know a good design pattern that would make sure that only one instance of an object is created without making this object global in c++? 
That's what singleton do but I really need it NOT to be global for code access security reasons.</p>

<p>Thanks for your help!</p>
","87234","","<p>I think you want something like this (note: copy-pasted from <a href=""http://stackoverflow.com/a/3926915/87234"">an answer I already wrote and forgot about</a>):</p>

<pre><code>#include &lt;stdexcept&gt;

// inherit from this class (privately) to ensure only
// a single instance of the derived class is created
template &lt;typename D&gt; // CRTP (to give each instantiation its own flag)
class single_instance
{
protected: // protected constructors to ensure this is used as a mixin
    single_instance()
    {
        if (mConstructed)
            throw std::runtime_error(""already created"");

        mConstructed = true;
    }

    ~single_instance()
    {
        mConstructed = false;
    }

private:
    // private and not defined in order to
    // force the derived class be noncopyable
    single_instance(const single_instance&amp;);
    single_instance&amp; operator=(const single_instance&amp;);

    static bool mConstructed;
};

template &lt;typename T&gt;
bool single_instance&lt;T&gt;::mConstructed = false;
</code></pre>

<p>Now you get an exception if the class is constructed more than once:</p>

<pre><code>class my_class : private single_instance&lt;my_class&gt;
{
public:
    // usual interface (nonycopyable)
};

int main()
{
    my_class a; // okay
    my_class b; // exception
}
</code></pre>

<p>There's no way to enforce the single-instance policy at compile-time in C++, though.</p>

<hr>

<p>(Also good on you for noticing that singletons are dumb. Globally accessible and singly-creatable are two different concepts, and should only be combined by coincidence, not by design.)</p>
"
"<p>What is the difference between</p>

<pre><code>template &lt;class T&gt;
class why
{
public:
   why()
   {}
};
</code></pre>

<p>and </p>

<pre><code>template &lt;class T&gt;
class why
{
public:
   why&lt;T&gt;()
   {}
};
</code></pre>

<p>They both seem to work the same and compile.</p>

<p><strong>EDIT</strong></p>

<p>And, if they are truly the same, why is this functionality even in the C++ language?</p>
","87234","","<p>They're equivalent. In the former, <code>why</code> is an <em>injected</em> name that's defined to be the same as <code>why&lt;T&gt;</code> (where <code>T</code> is the actual template argument.) This exists for ease of typing.</p>

<hr>

<p>Note that this injection is into the class's scope, and not outside of it. Obvious, but given:</p>

<pre><code>template &lt;typename T&gt;
struct foo
{
    foo x(foo f);
};
</code></pre>

<p>A common mistake might be to try and define <code>x</code> like this:</p>

<pre><code>template &lt;typename T&gt;
foo foo&lt;T&gt;::x(foo f) { return f; }
</code></pre>

<p>But this would be an error, as <code>foo</code> in the return type needs template arguments. The <code>foo</code> in the parameter list is okay, though, because after <code>foo&lt;T&gt;::</code> we're in the class's scope, and <code>foo</code> is defined to be <code>foo&lt;T&gt;</code>. So the correct way to do this is either of these:</p>

<pre><code>template &lt;typename T&gt;
foo&lt;T&gt; foo&lt;T&gt;::x(foo f) { return f; }

template &lt;typename T&gt;
foo&lt;T&gt; foo&lt;T&gt;::x(foo&lt;T&gt; f) { return f; } // equivalent
</code></pre>
"
"<p>For an arbitrary class,</p>

<pre><code>template&lt;class T&gt;
struct S
{
    S()
    {
        cout &lt;&lt; ""hello moto\n"";
    }
};
</code></pre>

<p>it is possible to construct an temporary object that's destroyed immediately after its creation, but only inside <strong>functions</strong>, e.g.</p>

<pre><code>void f()
{
    S&lt;int&gt;();
}
</code></pre>

<p>Moving <code>S&lt;int&gt;();</code> outside in the global scope either does not compile in GCC, or is compiled as being a function declaration in VC++.</p>

<p>Is it even possible to create a global temporary object?</p>

<hr>

<h3>Edit</h3>

<p>Although the demo code is in the form of a template class, it does have to be for my question; a plain C struct would do. But with a class it is easy to see whether this temp is actually created or not so as to be be sure this clause is not interpreted as a function declaration instead by the compiler.</p>
","87234","","<p>To merely create? Sure:</p>

<pre><code>//         vvvvvvvv creates temporary
S&lt;int&gt; x = S&lt;int&gt;();
</code></pre>

<p>Or to save space on the global:</p>

<pre><code>char x = (S&lt;int&gt;(), 0); // uses comma operator
</code></pre>

<p>But this (ab)uses initialization. Your program starts at <code>main</code>, and you aren't meant to run arbitrary statements before then. You should embrace that, not try to work around it.</p>
"
"<p>In any C program, the command line argument <code>argv[0]</code> points to the name used to invoke the program. Is there any circumstance in which it will point to an empty string <code>""""</code>? </p>

<p>An example code snippet for such a case would be a good reference. </p>
","87234","","<p>It's implementation defined. §5.1.2.2.1 abridged:</p>

<blockquote>
  <ul>
  <li><p>If the value of <code>argc</code> is greater than zero, the array members <code>argv[0]</code> through
  <code>argv[argc-1]</code> inclusive shall contain pointers to strings, which are given
  implementation-defined values by the host environment prior to program startup. The
  intent is to supply to the program information determined prior to program startup
  from elsewhere in the hosted environment. [...]</p></li>
  <li><p>If the value of <code>argc</code> is greater than zero, the string pointed to by <code>argv[0]</code>
  represents the program name; <code>argv[0][0]</code> shall be the null character if the
  program name is not available from the host environment. [...]</p></li>
  </ul>
</blockquote>

<p>So if <code>argc</code> is greater than zero, it's quite the <em>intention</em> that <code>argv[0]</code> never be an empty string, but it could happen. (Note that with <code>argc</code> equal to <code>n</code>, <code>argv[0]</code> through <code>argv[n - 1]</code> are never null and always point to a string. The string itself may be empty, though. If <code>n</code> is zero, <code>argv[0]</code> is null.)</p>

<p>In practice, of course, you just need to make sure the platforms your targetting behave as needed.</p>
"
"<p>I apologise if this isn't considered a good enough question (since my own solution just works, so I don't actually have a problem), but here goes.<br>
I mean, I was brought up on C and I only learned C++ later, so maybe I'm biased, but still.</p>

<p>In this particular case, there is one library that returns a <code>const char*</code>, while another library needs a <code>void*</code> as input. So if I want to call the second library with the result of the first, I will need to write</p>

<pre><code>second(const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(first())));
</code></pre>

<p>Right? That's the only proper way, right?</p>
","87234","","<p>A <code>char*</code> can be implicitly converted to a <code>void*</code>, so your code can be simplified to this:</p>

<pre><code>second(const_cast&lt;char*&gt;(first()));
</code></pre>

<p>This is only safe if the definition of <code>second</code> operates <em>as if</em> its parameter had the type <code>const void*</code>.</p>
"
"<p>I´m getting this ""Cannot use typeid with -fno-rtti"" when I´m trying to compile my project, I´m using an opencv framework.
I googled the problem but, it seems the errors I found in internet does not have relation with my problem.
I don´t know if the problem is related with the includes, the code or the compiler.</p>

<p>Xcode is giving me the error a lot of times, but the first error is here:</p>

<pre><code>virtual const std::type_info&amp; type() { return typeid(T); }
</code></pre>
","87234","","<p>It's telling you the error right in the message: if you use the <code>no-rtti</code> flag on the compiler, then <code>typeid</code> is not going to be available. Just enable RTTI; it's part of C++ after all.</p>
"
"<p>What I know about C++ is that the order of the constructions (and destructions) of global instances should not be assumed.</p>

<p>While I'm writing code with a global instance which uses <code>std::cout</code> in the constructor &amp; destructor, I got a question.</p>

<p><code>std::cout</code> is also a global instance of iostream. Is <code>std::cout</code> guaranteed to be inizialized before any other global instances?</p>

<p>I wrote a simple test code and it works perfectly, but still I don't know why.</p>

<pre><code>#include &lt;iostream&gt;

struct test
{
    test() { std::cout &lt;&lt; ""test::ctor"" &lt;&lt; std::endl; }
    ~test() { std::cout &lt;&lt; ""test::dtor"" &lt;&lt; std::endl; }
};

test t;

int main()
{
    std::cout &lt;&lt; ""Hello world"" &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>It prints</p>

<pre><code>test::ctor
Hello world
test::dtor
</code></pre>

<p>Is there any possibility that the code doesn't run as expected?</p>
","87234","","<p>The answer differs depending on if you're using C++03 or C++11.</p>

<p>In C++11, your code is guaranteed to work, but in C++03 it's unspecified; your only guarantee is that by the time <code>main()</code> is entered, the standard streams had been initialized. (That said, all mainstream implementations initialize them prior to running any dynamic initialization, making them fine to use.)</p>

<p>You can force initialization by constructing an <code>std::ios_base::Init</code> object, like so:</p>

<pre><code>#include &lt;iostream&gt;

struct test
{
    test() { std::cout &lt;&lt; ""test::ctor"" &lt;&lt; std::endl; }
    ~test() { std::cout &lt;&lt; ""test::dtor"" &lt;&lt; std::endl; }

private:
    std::ios_base::Init mInitializer;
};

test t;

int main()
{
    std::cout &lt;&lt; ""Hello world"" &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>Now when <code>test</code> constructs, it initializes <code>mInitializer</code> and guarantees the streams are ready to use.</p>

<p>C++11 fixed this slightly annoying behavior by acting as if every instance of <code>#include &lt;iostream&gt;</code> where followed by <code>static std::ios_base::Init __unspecified_name__;</code>. This automatically guarantees the streams are ready to use.</p>
"
"<p>I'm aware of <a href=""http://stackoverflow.com/questions/6128293/boost-static-warning"">this question</a> which mentions Boost's ""STATIC WARNING"", but I'd like to ask again, specifically, how I could implement a <code>static_warning</code> which operates similarly to <code>static_assert</code> but only emits a <em>warning</em> at compile time rather than an aborting compilation error.</p>

<p>I'd like something similar to Alexandrescu's proposal for a static assert in pre-C++11 days which somehow managed to print some useful contextual information as part of the error.</p>

<p>It would be acceptable to require that the user enable certain standard compiler warnings in order for this construction to work (perhaps ""invalid pointer conversion"" or ""breaks strict aliasing rules"") -- any warning that should be part of a normal compilation anyway can be used.</p>

<p>In short, I want <code>static_warning(false, ""Hello world"");</code> to create a compiler warning that should somehow include the string ""hello world"" in the warning message. Is this possible, say in GCC and MSVC, and how?</p>

<p>I'd happily give out a small reward bounty for any particularly clever solution.</p>

<hr>

<p>As a bit of explanation: I got the idea when thinking about <a href=""http://stackoverflow.com/q/8935705/596781"">this question</a>: A static warning would be a useful way to trace through the compile-time process of complex template specializations, which are otherwise fairly hard to debug. A static warning could be used as a simple beacon for the compiler to emit ""I'm now compiling this part of the code.""</p>

<hr>

<p><strong>Update.</strong> Ideally, the warning would be triggered in the following setup:</p>

<pre><code>template &lt;typename T&gt; struct Foo
{
    static_warning(std::is_pointer&lt;T&gt;::value, ""Attempting to use pointer type."");
    // ...
};

int main() { Foo&lt;int&gt; a; Foo&lt;int*&gt; b; }
</code></pre>
","87234","","<p>Here's the best I've come up with so far. It's basic and doesn't quite fit your requirements, but instead goes the route of <code>BOOST_MPL_ASSERT_MSG</code> in that your message has to take the form of a valid identifier. (As far as I know, the only way you could get a string printed in the warning message is if the warning you used happened to also be one to do with strings, and printed its contents.)</p>

<p>It requires the warning for an unused variable be enabled. In g++ this is <code>-Wunused-variable</code> (enabled by <code>-Wall</code>), and in MSVC it's warning C4101 which is enabled at Warning Level 3.</p>

<p>It's obviously not very tested and could be enhanced in a few ways (use <code>__COUNTER__</code> instead of <code>__LINE__</code> on supported compilers, prettier message printing, use Boost to simplify, etc.), but seems to get the job done. Here's the boiler-plate:</p>

<pre><code>namespace detail
{
    template &lt;bool Condition&gt;
    struct static_warning;

    template &lt;&gt;
    struct static_warning&lt;true&gt;
    {
        template &lt;typename Message&gt;
        static void warn() {}
    };

    template &lt;&gt;
    struct static_warning&lt;false&gt;
    {
        // If you're here because of a warning, please see where the
        // template was instantiated for the source of the warning.
        template &lt;typename Message&gt;
        static void warn() { Message STATIC_WARNING_FAILED; }
    };
}

#define STATIC_WARNING_DETAIL_EX(cond, msg, line)                   \
        struct static_warning ## line                               \
        {                                                           \
            class msg {};                                           \
                                                                    \
            static_warning ## line()                                \
            {                                                       \
                ::detail::static_warning&lt;(cond)&gt;::                  \
                    warn&lt;void************ (msg::************)()&gt;(); \
            }                                                       \
        }

#define STATIC_WARNING_DETAIL(cond, msg, line) \
        STATIC_WARNING_DETAIL_EX(cond, msg, line)

// Use these:
#define STATIC_WARNING_MSG(cond, msg) \
        STATIC_WARNING_DETAIL(cond, msg, __LINE__)

#define STATIC_WARNING(cond) \
        STATIC_WARNING_DETAIL(cond, STATIC_WARNING_FAILED, __LINE__)
</code></pre>

<p>And a test:</p>

<pre><code>STATIC_WARNING(sizeof(int) == 2);

int main()
{
    STATIC_WARNING_MSG(sizeof(char) != 1, JUST_KIDDING_ALL_IS_WELL);
}
</code></pre>

<p>In MSVC this produces:</p>

<pre><code>&gt;main.cpp(19): warning C4101: 'STATIC_WARNING_FAILED' : unreferenced local variable
&gt;          main.cpp(45) : see reference to function template instantiation 'void detail::static_warning&lt;false&gt;::warn&lt;void************(__thiscall static_warning45::STATIC_WARNING_FAILED::* ***********)(void)&gt;(void)' being compiled
&gt;main.cpp(19): warning C4101: 'STATIC_WARNING_FAILED' : unreferenced local variable
&gt;          main.cpp(49) : see reference to function template instantiation 'void detail::static_warning&lt;false&gt;::warn&lt;void************(__thiscall main::static_warning49::JUST_KIDDING_ALL_IS_WELL::* ***********)(void)&gt;(void)' being compiled
</code></pre>

<p>And in GCC it produces:</p>

<pre><code>main.cpp: In static member function 'static void detail::static_warning&lt;false&gt;::warn() [with Message = void************ (static_warning39::STATIC_WARNING_FAILED::************)()]':
main.cpp:39:1:   instantiated from here
main.cpp:19:38: warning: unused variable 'STATIC_WARNING_FAILED'
main.cpp: In static member function 'static void detail::static_warning&lt;false&gt;::warn() [with Message = void************ (main()::static_warning43::JUST_KIDDING_ALL_IS_WELL::************)()]':
main.cpp:43:5:   instantiated from here
main.cpp:19:38: warning: unused variable 'STATIC_WARNING_FAILED'
</code></pre>
"
"<p>From what I know smart pointer should be equilvalent to ""raw"" pointer with the difference that it is safe. Ok, but if I have regular pointer:  </p>

<pre><code>int* p = new int[10];
fill(p, p + 10, 0);//this will work for regular pointer but not for smart one.  
</code></pre>

<p>Same with hand written loop:</p>

<pre><code>for(int i = 0; i &lt; 10; ++i)
{
*p[i] = 0;
}
</code></pre>

<p>This is not possible (I think) for smart poiner. So the question is, how can I initialized array to which pointer I have stored in one of smart pointers (let's assume shared_ptr)?</p>
","87234","","<p>First off, it might be easier just to use <code>std::vector&lt;int&gt;</code>. If your array has an unchanging size, though, then perhaps <code>std::vector&lt;int&gt;</code> is indeed better replaced with a smart pointer.</p>

<p>With that out of the way, your first choice should be a <code>std::unique_ptr</code>, specifically the array specialization: <code>std::unique_ptr&lt;int[]&gt;</code>. (If you don't, the smart pointer will use <code>delete</code> instead of <code>delete[]</code> on your pointer, leading to undefined behavior.) Your code would become:</p>

<pre><code>std::unique_ptr&lt;int[]&gt; p(new int[10]);
std::fill(p.get(), p.get() + 10, 0);
</code></pre>

<p>As you can see, smart pointers have a <code>get()</code> method that returns the underlying pointer.</p>

<p>From here, if you need to use a <code>std::shared_ptr</code>, things become a big dangerous (do to unfortunate oversight, as far as I know). That oversight is that <code>std::shared_ptr</code> has no array specialization:</p>

<pre><code>{
    std::shared_ptr&lt;int&gt; x(new int[10]);
} // oops! calls delete x.get(); instead of delete [] x.get(); ... UB!
</code></pre>

<p>However, <code>std::shared_ptr</code> can easily correct this like so:</p>

<pre><code>{
    std::shared_ptr&lt;int&gt; x(new int[10], std::default_delete&lt;int[]&gt;());
} // correctly uses delete [] x.get()
</code></pre>

<p>From this point, the code is the same:</p>

<pre><code>std::shared_ptr&lt;int&gt; p(new int[10], std::default_delete&lt;int[]&gt;());
std::fill(p.get(), p.get() + 10, 0);
</code></pre>

<hr>

<p>Note that <code>std::shared_ptr</code> provides a constructor to construct from a <code>std::unique_ptr</code>, which properly uses the deleter. So this is safe:</p>

<pre><code>std::unique_ptr&lt;int[]&gt; p(new int[10]);
std::shared_ptr&lt;int&gt; p2(std::move(p)); // okay, uses std::default_delete&lt;int[]&gt;()
</code></pre>
"
"<p>Currently, I am implementing a multi-thread project using <code>std::thread</code> in C++11. I use <code>std::condition_variable</code> to synchronize threads. In detail, one consumer function calls <code>wait()</code> member function of <code>std::condition_variable</code> to wait for task from a global task queue, another producer function generates and puts tasks into the queue. But I do not know the difference between <code>notify_all()</code> and <code>notify_one()</code> member functions of <code>std::condition_variable</code>. Which function should I use in the producer function? Thanks!</p>
","87234","","<p>If there are ten threads blocked on the condition variable, for example, <code>notify_one()</code> will unblock only one thread, while <code>notify_all()</code> will unblock them all. In your case, you'll want to use <code>notify_one()</code> so you don't wake up threads that don't have any work waiting for them.</p>
"
"<p>When I use the constant argument of a function as a array size in C++ it gives ""Constant expression required"" error:<br>
<img src=""http://i.stack.imgur.com/Oa3xG.jpg"" alt=""enter image description here""></p>

<p>So the compiler is not considering <code>m</code> as a constant object, this means I can change the value of <code>m</code> inside the function, but when I try to increment the value of <code>m</code> it gives ""cannot modify a const object"" error:<br>
<img src=""http://i.stack.imgur.com/yC2XJ.jpg"" alt=""enter image description here""></p>

<p>It is really ambiguous to me. Can anyone please explain what I'm getting wrong? </p>
","87234","","<p><code>const</code> doesn't actually mean ""this value is constant"", but, ""you cannot change this value.""</p>

<p>With this, it should be clear why the latter code fails to compile but the former cannot. Even though you give it a default of <code>5</code>, that doesn't <em>guarantee</em> it's five, and so you don't have a constant, so you can't make an array. But the type is still <code>const</code>, so you can't change it.</p>

<p>That said, since C99 you can have variable-length arrays so this would actually be fine. (It is not okay in C++.) Your compiler just seems to be too old to support C99. (I highly recommend using the latest GCC.)</p>
"
"<p>I was wondering if anyone knows what the limits are on the conversion/typecast operator?</p>

<p>So, for example, I can have the following override operators:</p>

<pre><code>class Test {
    operator int() { return 0; };
    operator int*() { return nullptr; };
}
</code></pre>

<p>For a regular function, I could also have a pointer to array type. E.g.</p>

<pre><code>int (*MyFunc())[4] { return nullptr; };
</code></pre>

<p>However, I don't know how to do the same for the conversion operator (or if it is even legal to do so). I have tried a few different variations and VS2010 and none work. (Such as:)</p>

<pre><code>operator int (*())[4] { return nullptr; };
operator int(*)[4]() { return nullptr; };
</code></pre>

<p>I'm not sure if this is a limitation in VS2010 or if there is a general limit on the types that can be used in the conversion operator. I tried looking for the standard online with no luck. Does anyone know? Before anyone asks ""why would you even want to do that"", it's for auto-generated code. Although I don't anticipate getting pointer to array input, I would like to be able to produce the code if it is legal in C++.</p>
","87234","","<p>Yes, there are restrictions. The limitation you've hit with arrays is due to the language grammar. The grammar specification for a conversion operator (and kin) is as follows:</p>

<pre>
§12.3.2
conversion-function-id:
    operator conversion-type-id
conversion-type-id:
    type-specifier-seq conversion-declarator[opt]
conversion-declarator:
    ptr-operator conversion-declarator[opt]

§7.1.6
type-specifier:
    trailing-type-specifier
    class-specifier
    enum-specifier
trailing-type-specifier:
    simple-type-specifier
    elaborated-type-specifier
    typename-specifier
    cv-qualifier
type-specifier-seq:
    type-specifier attribute-specifier-seq[opt]
    type-specifier type-specifier-seq
trailing-type-specifier-seq:
    trailing-type-specifier attribute-specifier-seq[opt]
    trailing-type-specifier trailing-type-specifier-seq
</pre>

<p>I leave it as an exercise for the reader to look at all those, but you can't specify an array as the type directly. (It is only specified in <em>declarations</em>.) Luckily, though, a typedef-name is allowed (through the typename-specifier), and because a typedef is a kind of declaration, arrays work there:</p>

<pre><code>struct Test {
    typedef int operator_type[4];

    operator operator_type*() { return nullptr; };
};
</code></pre>

<p>Long story short, use a typedef and you can use whatever type you'd like. </p>
"
"<h3>Background</h3>

<p>Consider for this question the following code:</p>

<pre><code>#include &lt;utility&gt;

namespace ns
{
    struct foo
    {
        foo() : i(0) {}
        int i;

    private:
        foo(const foo&amp;); // not defined,
        foo&amp; operator=(const foo&amp;); // non-copyable
    };

    void swap(foo&amp; lhs, foo&amp; rhs)
    {
        std::swap(lhs.i, rhs.i);
    }
}

template &lt;typename T&gt;
void do_swap(T&amp; lhs, T&amp; rhs); // implementation to be determined

int main()
{
    ns::foo a, b;
    do_swap(a, b);
}
</code></pre>

<p>In C++03, this implementation of <code>do_swap</code> would be considered ""broken"":</p>

<pre><code>template &lt;typename T&gt;
void do_swap(T&amp; lhs, T&amp; rhs)
{
    std::swap(lhs, rhs);
}
</code></pre>

<p>By explicitly specifying <code>std::</code>, it prohibits <code>ns::swap</code> from being found via argument-dependent lookup. (It then fails to compile because <code>std::swap</code> tries to copy a <code>foo</code>, which is not allowed.) Instead, we do this:</p>

<pre><code>template &lt;typename T&gt;
void do_swap(T&amp; lhs, T&amp; rhs)
{
    using std::swap; // allow std::swap as a backup if ADL fails to find a swap
    swap(lhs, rhs); // unqualified call to swap, allow ADL to operate
}
</code></pre>

<p>Now <code>ns::swap</code> is found and <code>std::swap</code>, being less specialized, is not used. It's uglier, but it works and is understandable in hind-sight. <code>boost::swap</code> wraps this up nicely for us (and provides array overloads):</p>

<pre><code>#include &lt;boost/swap.hpp&gt;

template &lt;typename T&gt;
void do_swap(T&amp; lhs, T&amp; rhs)
{
    boost::swap(lhs, rhs); // internally does what do_swap did above
}
</code></pre>

<h3>Question</h3>

<p><strong>My question is thus</strong>: does <code>std::swap</code> take on the behavior of <code>boost::swap</code> in C++11? If not, why?</p>

<p>To me it seems obvious that it ought to. Any code broken by the change was probably quite flimsy in the first place (algorithms and containers, like <code>std::sort</code> and <code>std::vector</code>, were underspecified; implementations were allowed to call ADL swap's or not indeterminately), so the change would be for the better. Additionally, <code>std::swap</code> is now defined for arrays, so change at all certainly isn't out of the question.</p>

<p>However, while §17.6.3.2 specifies that all calls to <code>swap</code> within the standard library must be done without <code>std::</code> qualification (fixing the problem with algorithms and containers noted above), it fails to touch on <code>std::swap</code> itself. It even gives examples of swapping values that include <code>using std::swap;</code>. Likewise §20.2.2 (where <code>std::swap</code> is specified) doesn't say a word on ADL.</p>

<p>Lastly, GCC does not enable ADL in their <code>std::swap</code> implementation (nor does MSVC, but that's not saying much). So I must be wrong that <code>std::swap</code> takes on the behavior of <code>boost::swap</code>, but I don't understand why the change wasn't made. :( <a href=""http://stackoverflow.com/a/6115281/87234"">And I'm not alone</a>!</p>
","87234","","<p>Here's a proof-of-concept implementation:</p>

<pre><code>#include &lt;utility&gt;

// exposition implementation
namespace std_
{
    namespace detail
    {
        // actual fallback implementation
        template &lt;typename T&gt;
        void swap(T&amp; lhs, T&amp; rhs)
        {
            T temp = std::move(lhs);
            lhs = std::move(rhs);
            rhs = std::move(temp);
        }
    }

    template &lt;typename T&gt;
    void swap(T&amp; lhs, T&amp; rhs)
    {
        using detail::swap; // shadows std_::swap, stops recursion
        swap(lhs, rhs); // unqualified call, allows ADL
    }
}

namespace ns
{
    struct foo
    {
        foo() : i(0) {}
        int i;

    private:
        foo(const foo&amp;); // not defined,
        foo&amp; operator=(const foo&amp;); // non-copyable
    };

    void swap(foo&amp; lhs, foo&amp; rhs)
    {
        std::swap(lhs.i, rhs.i);
    }
}


int main()
{
    int i = 0, j = 0;
    std_::swap(i, j);

    ns::foo a, b;
    std_::swap(a, b);
}
</code></pre>
"
"<p>I always thought that implicit constructor in C++ could only be a constructor with only one argument. For example:</p>

<pre><code>class Foo1
{
   Foo(int); // This could be an implicit constructor
};
</code></pre>

<p>But is the following code right:</p>

<pre><code>class Foo2
{
    Foo2(int, int=0);  // Would compiler use this as an implicit constructor?
}
</code></pre>

<p>I can do this:</p>

<pre><code>Foo1 obj;
...
obj = 5;
</code></pre>

<p>What about <code>Foo2</code>?</p>
","87234","","<p>First, <em>any</em> constructor can be marked <code>explicit</code>. How many arguments it has is irrelevant. </p>

<p>With that out of the way, you just now need to understand what <code>explicit</code> really means. It just means that the only way that constructor can be called is when you <em>explicitly</em> specify the class name:</p>

<pre><code>struct foo
{
    foo(int){}
    explicit foo(double){}
};

void bar(foo){}

bar(5); // okay, calls foo(int) to construct the foo
bar(3.14); // error, cannot call foo(double) because foo was not explicitly used
bar(foo(3.14)); // okay, calls foo(double) to construct the foo
</code></pre>

<p>The reason we don't mark multiple-argument constructors explicit is because it's useless. Given:</p>

<pre><code>struct baz
{
    baz(int, int, int);
};
</code></pre>

<p>How else can you call that constructor other than saying <code>baz</code> anyway? (As in <code>baz(1, 2, 3)</code>.)†</p>

<p>In your example, <code>explicit</code> would be sensible because you <em>could</em> call that constructor with only one argument. What you actually do only depends on if you feel it should be implicitly convertible or not.</p>

<hr>

<p>†This is disregarding C++11 initializer lists. In C++11, I think you could say:</p>

<pre><code>void qaz(baz) {}

qaz({1, 2, 3}); 
</code></pre>

<p>And manage to get an implicit conversion to a multiple-argument constructor, but I don't know enough about initializer-lists to make a meaningful comment except as a footnote.</p>
"
"<blockquote>
  <p>error: passing 'const QByteArray' as 'this' argument of 'QByteArray&amp; QByteArray::append(const QByteArray&amp;)' discards qualifiers [-fpermissive]</p>
</blockquote>

<p>since it is a convention to make objects const while passing as function arguments i have done it.
but now i am getting an error!!,
i dnt want to make the function constant as i have to convert data in qbyte array into short and then append it another array.</p>

<p>QByteArray ba((const char*)m_output.data(), sizeof(ushort));
    playbackBuffer.append(ba);</p>

<p>i really need to pass this array into playbackbuffer;</p>

<p>it is giving me an error on playbackBuffer.append(ba);</p>

<p>please help
thanks in advance</p>
","87234","","<p>Consider this:</p>

<pre><code>struct foo
{
    void bar();
};

const foo f;
f.bar();
</code></pre>

<p>Here, in the call to <code>bar()</code>, the <code>this</code> pointer is <code>&amp;f</code>. But <code>bar()</code> is not a const-function, so the type of <code>this</code> is <code>foo*</code>, which is incompatible with <code>const foo*</code>. (In other words, <code>bar()</code> says it might mutate the <code>foo</code>, but <code>f</code> says it's a non-mutable<code>foo</code>.)</p>

<p>Either <code>bar()</code> needs to be marked as <code>const</code> (if it can), or <code>f</code> needs to not be <code>const</code>.</p>

<p>In your case, I'm going to assume you're using Qt and so cannot modify <code>QByteArray</code> (nor should you, since <code>append</code> is necessarily a non-const function), and instead suggest you get rid of the <code>const</code> on the object, which is preventing you from using the function.</p>
"
"<p>Every definition I've seen of function <code>ios::setstate( iostate state )</code> shows that the function takes <strong>ONE</strong> and <strong>ONLY ONE</strong> parameter yet when I compile a program with the following function call, everything compiles and runs just fine: </p>

<pre><code>mystream.setstate( std::ios_base::badbit, true );
</code></pre>

<p>What exactly is the second parameter and why is there no documentation about it?</p>

<p>EDIT: I'm using the command line compiler of the latest version of Microsoft Visual Studio 2010.</p>
","87234","","<p>It's required to accept a single argument, as you've noted, but implementations <em>are</em> allowed to extend member functions via parameters with default values (§17.6.5.5). In other words, as long as this works:</p>

<pre><code>mystream.setstate( std::ios_base::badbit );
</code></pre>

<p>your compiler is conforming. Nothing says that your code <em>doesn't</em> have to work, though.</p>

<p>(Your library implementation has decided that a boolean parameter would be useful to have. You never notice it because it has a default value, but you can still get into implementation-specific territory and provide the argument yourself. Whether or not this is a good idea is obviously another question, but probably not.)</p>
"
"<p>Can someone explain to me the difference between:</p>

<p><code>shared_dynamic_cast</code> and <code>dynamic_pointer_cast</code> from the Boost library?</p>

<p>It appears to me that they may be equivalent.</p>
","87234","","<p>Given a <code>shared_ptr&lt;T&gt;</code>, the two functions are indeed equivalent.</p>

<p>The difference is that <code>shared_dynamic_cast</code> <em>only</em> works with <code>shared_ptr&lt;&gt;</code>'s, while <code>dynamic_pointer_cast</code> works with any kind of pointer (via overloading). This enables you to perform a dynamic cast on any pointer <em>concept</em>, regardless of how that pointer is actually composed:</p>

<pre><code>#include &lt;boost/pointer_cast.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;

struct foo {};
struct bar : foo { void f(){} };

template &lt;typename Ptr&gt;
void test(Ptr ptr)
{
    boost::dynamic_pointer_cast&lt;bar&gt;(ptr)-&gt;f();
}

int main()
{
    bar b;
    foo* pf = &amp;b;

    std::shared_ptr&lt;foo&gt; spf(new bar());

    test(pf); // turns into dynamic_cast&lt;bar*&gt;(pf)-&gt;f();
    test(spf); // turns into shared_dynamic_cast&lt;bar&gt;(pf)-&gt;f();
}
</code></pre>

<p>Because <code>dynamic_pointer_cast</code> has the capability of <code>shared_dynamic_cast</code> and more, <strong>the latter function is deprecated</strong>. (Likewise in C++11, there only exists <code>dynamic_pointer_cast</code>.)</p>

<p>(The idea is the same for the other cast variants too, of course.)</p>
"
"<p>Based on <a href=""http://rads.stackoverflow.com/amzn/click/0321133544"" rel=""nofollow"">pp. 8</a></p>

<blockquote>
  <p>Free Functions</p>

<pre><code>template&lt;typename T&gt; void swap(scoped_ptr&lt;T&gt;&amp; a,scoped_ptr&lt;T&gt;&amp; b)
</code></pre>
  
  <p>This function offers the preferred means by which to exchange the
  contents of two scoped pointers. It is preferable because
  swap(scoped1,scoped2) can be applied generically (in templated code)
  to many pointer types, including raw pointers and third-party smart
  pointers.[2] scoped1.swap(scoped2) only works on smart pointers, not
  on raw pointers, and only on those that define the operation.</p>
</blockquote>

<pre><code>int* pA = new int(10);
int *pB = new int(20);

boost::swap(pA, pB); // Error: could not deduce template argument for 'boost::scoped_ptr&lt;T&gt; &amp;' from 'int *'
</code></pre>

<p><strong>Question</strong>> How to swap raw pointers with <code>boost::swap</code>?</p>
","87234","","<p>I don't understand why the other answers are telling you not to use <code>boost::swap</code>. The <em>entire purpose</em> of <code>boost::swap</code> is to hide the <code>using std::swap; swap(x, y);</code> business. This works just fine:</p>

<pre><code>#include &lt;boost/swap.hpp&gt;

int main()
{
    int* pA = new int(10);
    int *pB = new int(20);

    boost::swap(pA, pB);

    delete pA;
    delete pB;
}
</code></pre>

<p>Obviously if you haven't included <code>boost/swap.hpp</code> this won't work. That's how you use <code>boost::swap</code> to swap two things. You should always prefer to swap two things in this form!</p>

<p>What you're reading is simply stating that <code>boost::scoped_ptr</code> also provides an overload of <code>swap</code> inside the <code>boost</code> namespace, so that this works too:</p>

<pre><code>#include &lt;boost/scoped_ptr.hpp&gt;

int main()
{    
    boost::scoped_ptr&lt;int&gt; pA(new int(20));
    boost::scoped_ptr&lt;int&gt; pB(new int(20));

    boost::swap(pA, pB);
}
</code></pre>

<p>But it should be clear that this won't work:</p>

<pre><code>#include &lt;boost/scoped_ptr.hpp&gt;

int main()
{
    int* pA = new int(10);
    int *pB = new int(20);

    boost::swap(pA, pB);

    delete pA;
    delete pB;
}
</code></pre>

<p>Because <code>boost/scoped_ptr.hpp</code> has not provided (and indeed doesn't have the responsibility to provide) a general implementation of <code>boost::swap</code>. If you want to use <code>boost::swap</code> <em>in general</em>, you must include <code>boost/swap.hpp</code>:</p>

<pre><code>#include &lt;boost/scoped_ptr.hpp&gt;
#include &lt;boost/swap.hpp&gt;

int main()
{
    int* pA = new int(10);
    int *pB = new int(20);

    boost::scoped_ptr&lt;int&gt; pC(new int(20));
    boost::scoped_ptr&lt;int&gt; pD(new int(20));

    boost::swap(pA, pB);
    boost::swap(pC, pD);

    delete pA;
    delete pB;
}
</code></pre>

<p>Like that. If you have Boost available to do, do not fall back to the using <code>std::swap</code> stuff.</p>
"
"<p>Can't understand what is a problem here:
I have got main.cpp file where I am including:</p>

<pre><code>#include ""lexan.h""
...
</code></pre>

<p>The lexan.h file:</p>

<pre><code>#ifndef _LEXAN_
#define _LEXAN_
enum Statements ...
//some function prototypes
...
struct TokensList {
    Statements statement;
    std::string value;
    struct TokensList *next;
};
struct TokensList *tokens = NULL;
#endif _LEXAN_
</code></pre>

<p>In lexan2.h:</p>

<pre><code>#include ""lexan.h""
// and some function prototypes
</code></pre>

<p>The problem is that I get the link error 2005:</p>

<pre><code>1&gt;lexan2.obj : error LNK2005: ""struct TokensList * tokens"" (?tokens@@3PAUTokensList@@A) already defined in lexan.obj
1&gt;main.obj : error LNK2005: ""struct TokensList * tokens"" (?tokens@@3PAUTokensList@@A) already defined in lexan.obj
</code></pre>

<p>Where is my mistake? I thought the </p>

<pre><code>#ifndef _LEXAN_
#define _LEXAN_
</code></pre>

<p>in the lexan.h file would protect me from such linking problems.</p>
","87234","","<p>Include guards only stop you from processing the same header twice <em>per translation unit</em> (source file).</p>

<p>Let's say you have a header, <code>X.h</code>, which has include guards:</p>

<pre><code>// x.h
#ifndef X_H
#define X_H

    // x.h stuff

#endif
</code></pre>

<p>You also have <code>A.h</code> and <code>B.h</code>, each of which include <code>X.h</code>:</p>

<pre><code>// a.h
#ifndef A_H
#define A_H

    #include ""x.h""

    // a.h stuff

#endif

// b.h
#ifndef B_H
#define B_H

    #include ""x.h""

    // b.h stuff

#endif
</code></pre>

<p>Then we have <code>j.cpp</code> and <code>k.cpp</code>:</p>

<pre><code>// j.cpp
#include ""a.h""
#include ""b.h""

    // j.cpp stuff

// k.cpp
#include ""a.h""
#include ""b.h""

    // k.cpp stuff
</code></pre>

<p>Here the include guards prevent <code>x.h</code> from being processed twice within <code>j.cpp</code>, likewise in <code>k.cpp</code>. <em>But <code>x.h</code> is still included twice, once for each translation unit.</em> So if <code>// x.h stuff</code> was this:</p>

<pre><code>int myGlobalInt; // x.h stuff
</code></pre>

<p>Although you prevent <code>j.cpp</code> (and <code>k.cpp</code>) from defining this variable twice, each still has defined it once. At link time, the linker finds them both and complains.</p>

<p>What you want — other than avoiding global variables, which you should try to do — is this:</p>

<pre><code>extern int myGlobalInt; // x.h stuff
</code></pre>

<p>Now each translation unit gets told ""there exists a <code>myGlobalInt</code> somewhere"", and you can explicit define it in a single translation unit of your choosing.</p>

<p>Also, don't use those kinds of header guards; names beginning with an underscore followed by a capital, as well as those beginning with two consecutive underscores <a href=""http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier"">are reserved</a>.</p>
"
"<p>Say I need to use <code>s</code>:</p>

<pre><code>typedef struct tagSOMESTRUCT   // Defined by someone else; C-compatible
{
    int count;
    int elements[256];
} SOMESTRUCT;

SOMESTRUCT s;
</code></pre>

<p>and say I have a function like:</p>

<pre><code>template&lt;typename RevFwdIt&gt;
std::pair&lt;RevFwdIt, RevFwdIt&gt; some_slice_rev(RevFwdIt rbegin, RevFwdIt rend)
{
    RevFwdIt it = basename_rev(rbegin, rend);
    RevFwdIt e = std::find(rbegin, it, 5);
    return std::make_pair(e == it ? rbegin : e, it);
}
</code></pre>

<p>In order to use this function, I need to say</p>

<pre><code>some_slice_rev(&amp;s.elements[s.count - 1], &amp;s.elements[-1]);
</code></pre>

<p>which (IMHO) is ugly and error-prone due to the off-by-one errors.</p>

<p>On the one hand, I cannot simply change <code>some_slice_rev</code> to <code>some_slice</code> to use the (much better)</p>

<pre><code>some_slice(&amp;s.elements[0], &amp;s.elements[s.count]);
</code></pre>

<p>because then <code>std::find</code> would search from the beginning instead of the end.</p>

<p>On the other hand, the code itself already looks broken to me, because I can't see how <code>std::find</code> would handle ""reverse iterators"" that are raw pointers.</p>

<p>What is the best way to fix the code in situations like this? Is there any way to work with reverse-iterators that are raw pointers? Or is there a standard refactoring mechanism for fixing this, <strong>other</strong> than changing <code>SOMESTRUCT</code>?</p>
","87234","","<p>I'm not quite sure I understand the question (that may be from the awkward mixing of iterator directions you seem to be trying to avoid), but I'll just direct your attention to <code>std::reverse_iterator</code>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iterator&gt;

// for example
template &lt;typename Iter&gt;
void print_it(Iter first, Iter last)
{
    std::cout &lt;&lt; '|';

    for (; first != last; ++first)
        std::cout &lt;&lt; ' ' &lt;&lt; *first &lt;&lt; "" |"";

    std::cout &lt;&lt; std::endl;
}

int main()
{
    int arr[10] = {1, 2, 3, 4};

    int *begin = arr, *end = arr + 4;

    print_it(begin, end);
    print_it(std::reverse_iterator&lt;int*&gt;(end),
                std::reverse_iterator&lt;int*&gt;(begin));
}
</code></pre>

<p>They work like bi-directional iterators, except <code>++</code> is internally <code>--</code>, and vice versa.</p>

<p>Note that it's a bit ugly. You might want some utility function:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iterator&gt;

// for example
template &lt;typename Iter&gt;
void print_it(Iter first, Iter last)
{
    std::cout &lt;&lt; '|';

    for (; first != last; ++first)
        std::cout &lt;&lt; ' ' &lt;&lt; *first &lt;&lt; "" |"";

    std::cout &lt;&lt; std::endl;
}

template &lt;typename Iter&gt;
std::reverse_iterator&lt;Iter&gt; make_reverse_iterator(Iter iter)
{
    return std::reverse_iterator&lt;Iter&gt;(iter);
}

int main()
{
    int arr[10] = {1, 2, 3, 4};

    int *begin = arr, *end = arr + 4;

    print_it(begin, end);
    print_it(make_reverse_iterator(end),
                make_reverse_iterator(begin));
}
</code></pre>

<hr>

<p>So I think you want this:</p>

<pre><code>template&lt;typename ForwardIterator &gt;
std::pair&lt;ForwardIterator, ForwardIterator&gt;
    some_slice(ForwardIterator begin, ForwardIterator end)
{
    typedef std::reverse_iterator&lt;ForwardIterator&gt; rev_iter;

    rev_iter it = basename(rev_iter(end), rev_iter(begin));
    rev_iter e = std::find(rev_iter(end), it, 5);

    return std::make_pair(it.base(), e.base());
}
</code></pre>

<hr>

<p>Relatively off-topic now, but note that <code>s.elements[s.count]</code> is undefined behavior if <code>s.count</code> is <code>256</code>, because <code>s.elements[s.count]</code> is <code>*(s.elements + s.count)</code>, which isn't a valid array element to dereference.</p>

<p>In practice, the full expression is fine because <code>&amp;*x</code> cancels out to <code>x</code>, but you still probably want to avoid it:</p>

<pre><code>some_slice(s.elements, s.elements + s.count);
</code></pre>

<p><code>s.elements[-1]</code> may also be undefined behavior, though I think strictly speaking it might be legal by accident, because you have an <code>int</code> member before the array.</p>
"
"<p>I'm trying to compile the code in Visual Studio (2008) and g++.<br>
In vs2008 it's successful, but in g++ it reported error.<br>
if add <code>const</code>,<br>
<code>test(const test &amp;source):a(source.a) {}</code><br>
g++ will compiled succeed.<br>
I kown that <code>test aa = 2;</code> will create a  temporary object and call copy-constructor.<br>
<strong>temporary object cannot bind to a non-const reference</strong><br>
so,why the vs2008 can compiled it succeed?</p>

<pre><code>class test{  
public:  
    test():a(1) {}  
    test(int num):a(num) {}
    test(test &amp;source):a(source.a) {}  
private:
    int a;
};

int main(){
    test aa = 2;
    return 0;
}
</code></pre>
","87234","","<p>VS has a non-standard extension that allows it, unfortunately.</p>

<p>There's a compiler flag to disable extensions, but last I checked it also makes it impossible to use the standard library. Your best bet is to keep the Warning Level on 4 (though this particular situation gets no warning), and check your compilations with multiple compilers when possible.</p>
"
"<p>How is it that in line below on the right side of equation one could use symbol 'fibs' although it is not yet definied:</p>

<pre><code>let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
</code></pre>
","87234","","<p>It won't actually try to call <code>fibs</code> in your definition until something else uses <code>fibs</code> later on in your program, <em>at which point <code>fibs</code> has been completely defined</em>.</p>

<p>You can do this in most other languages too:</p>

<pre><code>int foo(int x)
{
    if (x &lt;= 0) return 0;

    // will call foo when it gets there, at which point its been defined
    foo(x - 1); 
}
</code></pre>
"
"<p>I would like to create an STL map to find whether an item is close enough to another item in 3 dimensional space. So far, my ""less-than-functor"" has worked quite well, pasted to the following link.</p>

<p>Now this problem isn't quite the ""nearest neighbor"" problem. Rather it is a problem of ""is there a neighbor within some distance.""</p>

<p>My example just shows a single dimension. I've skipped the Y/Z dimensions for clarity.</p>

<p><a href=""http://pastebin.com/dKztPGM2"" rel=""nofollow"">My attempt so far</a> :</p>

<pre><code>class ApproximateLessFunctor {
 public:
  ApproximateLessFunctor( float fudgeFactor ) :
    mFudgeFactor( fudgeFactor ) {};

  bool operator()( float a, float b ) const {
    return (a &lt; (b - mFudgeFactor) );
  }

  float mFudgeFactor;
};

typedef map&lt;float, int, ApproximateLessFunctor&gt; XAxisMap;

class XAxis {
 public:
  XAxisMap vMap;

  XAxis(ApproximateLessFunctor functor, float x, int v)
  : vMap( functor )
  {
    vMap.insert(make_pair(x, v));
  }
};
</code></pre>

<p>On rare occasions, and I mean- really rare- the maps don't find a matching entry when positions overlap.</p>

<p>Is there something I can do better to implement this, still using STL containers?</p>
","87234","","<blockquote>
  <p>Now this problem isn't quite the ""nearest neighbor"" problem. Rather it is a problem of ""is there a neighbor within some distance.""</p>
</blockquote>

<p>The latter is phrased pretty simply in terms of the former, though. Find the nearest neighbor, then determine if it's close enough. This seems like a reasonable route to go considering the number of data structures available to you for the task.</p>

<p>Namely, a <a href=""http://en.wikipedia.org/wiki/K-d_tree"" rel=""nofollow"">kd-tree</a> is extremely common and not too hard to implement. Also relevant is an <a href=""http://en.wikipedia.org/wiki/R-tree"" rel=""nofollow"">R-tree</a>, though I haven't implemented that and cannot comment on its difficulty.</p>
"
"<p>I have a process which is running fine on x86 platforms.<br>
Now I compiled it to x64 and suddenly I cannot assign NULL to my pointers.<br>
If I do something like this:  </p>

<pre><code>void* pointy = NULL;
</code></pre>

<p>It will point to 0x0000000100000000<br>
What's going on?</p>
","87234","","<p>Null is not necessarily bit-wise zero. Its value is implementation-defined. </p>

<hr>

<p>That is to say, these are all the same:</p>

<pre><code>void* pointy = NULL;
void* pointy = 0;
void* pointy = nullptr;
</code></pre>

<p>They assign a <em>null-pointer value</em> to <code>pointy</code>. What this value is on a bit-level is completely unspecified, and is not necessarily all bits zero!</p>

<p>If your code is what you say it is, then either: your platform indeed uses that value for null, it doesn't and your compiler is broken, or it doesn't and you're reading the value incorrectly.</p>

<p>In any case, the C++ code is fine, and sets <code>pointy</code> to null. No need to worry about anything further.</p>
"
"<p>Our infamous litb has an interesting article on <a href=""http://bloglitb.blogspot.fr/2011/12/access-to-private-members-safer.html"" rel=""nofollow"">how to circumvent the access check</a>.</p>

<p>It is fully demonstrated by this simple code:</p>

<pre><code>#include &lt;iostream&gt;

template&lt;typename Tag, typename Tag::type M&gt;
struct Rob { 
  friend typename Tag::type get(Tag) {
    return M;
  }
};

// use
struct A {
  A(int a):a(a) { }
private:
  int a;
};

// tag used to access A::a
struct A_f { 
  typedef int A::*type;
  friend type get(A_f);
};

template struct Rob&lt;A_f, &amp;A::a&gt;;

int main() {
  A a(42);
  std::cout &lt;&lt; ""proof: "" &lt;&lt; a.*get(A_f()) &lt;&lt; std::endl;
}
</code></pre>

<p>Which compiles and runs (output <code>42</code>) with <a href=""http://ideone.com/LA724"" rel=""nofollow"">gcc 4.3.4</a>, <a href=""http://ideone.com/4sqlN"" rel=""nofollow"">gcc 4.5.1</a>, gcc 4.7.0 (see  user1131467's comment) and compiles with Clang 3.0 and Comeau C/C++ 4.3.10.1 in <strong>C++03 strict mode</strong> and MSVC 2005.</p>

<p>I was asked by Luchian on <a href=""http://stackoverflow.com/questions/9903718/friend-function-access-the-private-members-of-class-defined-in-static-library/9904241#comment12636611_9904241"">this answer</a> in which I used it to justify that it was actually legal. I agree with Luchian that it is weird, however both Clang and Comeau are close contenders for the most ""Standard"" compilers available (much more so than MSVC by default)...</p>

<p>And I could not find anything in the drafts of the Standards I have available (n3337 being the last version I got my hands on).</p>

<p>So... can anyone actually justifies that it is <strong>legal or not</strong> ?</p>
","87234","","<p><strong>Yes, it's legal</strong>. The relevant text is at §14.7.2/12, talking about explicit template instantiation:</p>

<blockquote>
  <p>12 The usual access checking rules <strong>do not apply to names used to specify explicit instantiations</strong>. [ <em>Note</em>: In particular, the template arguments and names used in the function declarator (including parameter types, return types and exception specifications) may be private types or objects which would normally not be accessible and the template may be a member template or member function which would not normally be
  accessible. — <em>end note</em> ]</p>
</blockquote>

<p>Emhpasis mine.</p>
"
"<p>This is trivial, probably silly, but I need to understand what state <em>cout</em> is left in after you try to print the contents of a character pointer initialized to '\0' (or 0). Take a look at the following snippet:</p>

<pre><code>const char* str;
str = 0; // or str = '\0';
cout &lt;&lt; str &lt;&lt; endl;
cout &lt;&lt; ""Welcome"" &lt;&lt; endl;
</code></pre>

<p>On the code snippet above, line 4 wont print ""Welcome"" to the console after the attempt to print <strong>str</strong> on line 3. Is there some behavior I should be aware of? If I substitute line 1-3 with <strong>cout &lt;&lt; '\0' &lt;&lt; endl;</strong> the message ""Welcome"" on the following line will be successfully printed to the console.</p>

<p>NOTE: Line 4 just silently fails to print. No warning or error message or anything (at least not using MinGW(g++) compiler). It spewed an exception when I compiled the same code using MS cl compiler.</p>

<p>EDIT: To dispel the notion that the code fails only when you assign <strong>str</strong> to '\0', I modified the code to assign to 0 - which was previously commented</p>
","87234","","<p>If you insert a <code>const char*</code> value to a standard stream (<code>basic_ostream&lt;&gt;</code>), it is <em>required</em> that it not be null. Since <code>str</code> is null you violate this requirement and the behavior is undefined.</p>

<p>The relevant paragraph in the standard is at §27.7.3.6.4/3.</p>

<p>The reason it works with <code>'\0'</code> directly is because <code>'\0'</code> is a <code>char</code>, so no requirements are broken. However, Potatoswatter has convinced me that <a href=""http://stackoverflow.com/a/9920686/87234"">printing this character out is effectively implementation-defined</a>, so what you see might not quite be what you want (that is, perform your own checks!).</p>
"
"<p>Durning the weekend I'm trying to refresh my c++ skills and learn some c++11, I've stumbled onto the following problem: I cannot force my container class to properly use move constructor:</p>

<p>I have a builder class,  which is defined as follows:</p>

<pre><code>class builder
{
   ...
   container build() const
   {
     std::vector&lt;items&gt; items;

     //... fill up the vector

     return container(items); //should move the vector right? wrong!
     //return container(std::move(items)); also doesn't work
   }
}
</code></pre>

<p>And classes item and container, defined as follows:</p>

<pre><code>class container
{
public:

    container(std:vector&lt;item&gt; items)
      : items_(items) // always invokes copy constructor on vector, never move
    { }

    container(container&amp;&amp; rhs)
    {
       ...
    }

    ...

private:
    std::vector&lt;item&gt; items_;

}

class item
{
public:
    //move .ctor
    item(item &amp;&amp; rhs);
    item&amp; operator=(item &amp;&amp; rhs);

    //copy .ctor
    item(const item&amp; rhs); //this gets called instead of move .ctor
    item&amp; operator=(const item&amp; rhs);

    ...
}
</code></pre>

<p>Now my code simply uses </p>

<pre><code>builder my_builder;
...
auto result = my_builder.build();
</code></pre>

<p>which causes every item to be first constructed and then copied...</p>

<p>How should I write following classess to not copy items? Should I just go back to using standard pointers? </p>
","87234","","<p>Your code should be changed to this:</p>

<pre><code>container(std:vector&lt;item2&gt; items) // may copy OR move
: items_(std::move(items)) // always moves
{}
</code></pre>

<p>In general: if you want your own copy of something then make that copy on that parameter list and move it to where it needs to be. Let the caller be the one that decides if they are going to copy or move the existing data. (In other words, you were halfway there. Now just move your data.)</p>

<p>Also: <code>return container(std::move(items));</code>. I didn't mention this before because I mistakenly thought all local variables were automatically moved in a return statement, but only the returned value is. (So this should actually work: <code>return items;</code>, because <code>container</code>'s constructor is not <code>explicit</code>.)</p>
"
"<p>Why is the destructor not invoked in this code?</p>

<pre><code>#include &lt;boost/scoped_ptr.hpp&gt;
#include &lt;iostream&gt;

class MyClass {
boost::scoped_ptr&lt;int&gt; ptr;
public:
MyClass() : ptr(new int) { *ptr = 0; throw; std::cout&lt;&lt;""MyClass Allocated\n""; }
~MyClass() { std::cout&lt;&lt;""MyClass De-allocated\n""; }
int increment() { return ++*ptr; }
};

int main()
{
    boost::scoped_ptr&lt;MyClass&gt; myinst(new MyClass);
    std::cout &lt;&lt; myinst-&gt;increment() &lt;&lt; '\n';
    std::cout &lt;&lt; myinst-&gt;increment() &lt;&lt; '\n';
}
</code></pre>

<p><strong>EDIT</strong></p>

<p>From the answers, In understand that when an exception happens in the constructor, destructor will not be invoked. But if the exception happens in the main(), ie after the MyClass object is fully instantiated, will the MyClass destructor be invoked? If not, then why it is a smart pointer?</p>

<p>Adding the code</p>

<pre><code>#include &lt;boost/scoped_ptr.hpp&gt;
#include &lt;iostream&gt;

class MyClass {
    boost::scoped_ptr&lt;int&gt; ptr;
    public:
    MyClass() : ptr(new int) { *ptr = 0; std::cout&lt;&lt;""MyClass Allocated\n""; }
    ~MyClass() { std::cout&lt;&lt;""MyClass De-allocated\n""; }
    int increment() { return ++*ptr; }
};

int main()
{
    boost::scoped_ptr&lt;MyClass&gt; myinst(new MyClass);
    throw 3;
    std::cout &lt;&lt; myinst-&gt;increment() &lt;&lt; '\n';
    std::cout &lt;&lt; myinst-&gt;increment() &lt;&lt; '\n';
}
</code></pre>

<p>Output:</p>

<pre><code>MyClass Allocated
terminate called after throwing an instance of 'int'
Aborted
</code></pre>
","87234","","<p>Because calling the destructor doesn't make sense in this case.</p>

<p>You only destruct things which are constructed, yet your object never fully constructs. Your class <em>members</em> have been constructed, though, and will have their destructors called.</p>
"
"<p>If I declare and object inside a for, and for example assign it's adress to a pointer, when that for ends, would that pointer be pointing to invalid memory? Like it happens at the end of a method with the objects that you declared in that method</p>
","87234","","<p>Yes.</p>

<p>A for-statement has the following grammar:</p>

<pre><code>for (init cond; expr) statement
</code></pre>

<p>And is equivalent to:</p>

<pre><code>{
    init
    while (cond)
    {
        statement
        expr;
    }
}
</code></pre>

<p>So <em>everything</em> that was defined within the for-loop ends its lifetime at the conclusion of the loop, both for the inner expression and full control structure. Pointing to something that is no longer alive is UB.</p>

<p>In general:</p>

<pre><code>void* p;

{
    T x;
    p = &amp;x;
} // x no longer exists

// p no longer holds a valid value
</code></pre>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/716762/c-stl-which-method-of-iteration-over-a-stl-container-is-better"">C++ STL: Which method of iteration over a STL container is better?</a><br>
  <a href=""http://stackoverflow.com/questions/9506018/efficiency-of-vector-index-access-vs-iterator-access"">Efficiency of vector index access vs iterator access</a>  </p>
</blockquote>



<p>Assuming an <code>std::vector&lt;int&gt;</code> named <code>numbers</code>, which of the following is faster?</p>

<pre><code>for (vector&lt;int&gt;::iterator i = numbers.begin(); i != numbers.end(); i++)
  cout &lt;&lt; *i;
</code></pre>

<p>or..</p>

<pre><code>for (int i = 0; i &lt; numbers.size(); i++)
  cout &lt;&lt; numbers.at(i);
</code></pre>

<p>Which one is faster? Is there any significant difference?</p>
","87234","","<p>Those two aren't even comparable. The former loops through each element, while the latter loops through while checking if the current index is valid (with <code>at()</code>). Take out the check and ask again:</p>

<pre><code>for (/* Not an int! Unsigned type: */ std::size_t i = 0; i &lt; numbers.size(); i++)
    cout &lt;&lt; numbers[i];
</code></pre>

<p>Now they do the same thing. And now the question is a duplicate (#<a href=""http://stackoverflow.com/questions/716762/c-stl-which-method-of-iteration-over-a-stl-container-is-better"">1</a> #<a href=""http://stackoverflow.com/questions/9506018/efficiency-of-vector-index-access-vs-iterator-access"">2</a>). To summarize: it doesn't matter.</p>
"
"<pre><code>#include &lt;iostream&gt;
#include &lt;exception&gt;
using namespace std;


class myexception: public exception
{
  virtual const char* what() const throw()
  {
    return ""My exception happened"";
  }
};

int main ()
{
  try
  {
    myexception myex;
    printf(""addr1:%x\n"",&amp;myex);
    throw myex;
  }
  catch (exception&amp; e)
  {
    printf(""addr2:%x\n"",&amp;e);
    cout &lt;&lt; e.what() &lt;&lt; endl;
  }
  return 0;
}
</code></pre>

<h1>output of this program:</h1>

<pre><code>addr1:6d78c020
addr2:20a1080
My exception happened
</code></pre>

<p>Question: Do you see addr1 and addr2 are different, any idea why?</p>
","87234","","<p>When an exception is thrown, a copy is made. You're viewing the address of that copy.</p>

<p>(How could the handler's exception have the same address? When you threw, you exited the block containing the exception, so it ceased to exist. You can't access something that doesn't exist.)</p>
"
"<p>Reading the Eigen library documentation, I noticed that <a href=""http://eigen.tuxfamily.org/dox/TopicPassingByValue.html"">some objects cannot be passed by value</a>.  Are there any developments in C++11 or planned developments that will make it safe to pass such objects by value?</p>

<p>Also, why is there no problem with returning such objects by value?</p>
","87234","","<p>They could do this in C++11:</p>

<pre><code>class alignas(16) Matrix4f
{
    // ...
};
</code></pre>

<p>Now the class will always be aligned on a 16-byte boundary.</p>

<p>Also, maybe I'm being silly but this shouldn't be an issue anyway. Given a class like this:</p>

<pre><code>class Matrix4f
{
public:
    // ...
private:
    // their data type (aligned however they decided in that library):
    aligned_data_type data;

    // or in C++11
    alignas(16) float data[16];
};
</code></pre>

<p>Compilers are now obligated to allocate a <code>Matrix4f</code> on a 16-byte boundary anyway, because that would break it; the class-level <code>alignas</code> should be redundant. But I've been known to be wrong in the past, somehow.</p>
"
"<p>If I have code such as</p>

<pre><code>class CString { int GetLength(); };

bool smaller(CString s1, std::string s2) {
    return s2.size() &gt; s1.GetLength();
}
</code></pre>

<p>What is the best thing for me to do?</p>

<ul>
<li><p>Change <code>s1.GetLength()</code> to <code>(size_t)c.GetLength()</code>?<br>
This would get help get rid of a compiler warning regarding ""signed-unsigned mismatch"", and communicate my intention to cast, and is by far the easiest route. But it's probably frowned upon. :(</p></li>
<li><p>Change <code>s1.GetLength()</code> to <code>static_cast&lt;size_t&gt;(c.GetLength())</code>?<br>
This would get help get rid of the warning, with ""The Correct"" kind of cast.</p></li>
<li><p>Change <code>s1.GetLength()</code> to <code>static_cast&lt;std::string::size_type&gt;(c.GetLength())</code>?<br>
It's extremely verbose... is there a practical benefit to this abstraction, or should I break it?</p></li>
<li><p>Leave it as is?<br>
This would help make the compiler do overflow-checking using the <strong><code>/RTCc</code> switch</strong> (my main concern here), at the expense of a warning.</p></li>
<li><p>Do something else?<br>
Should I make my own casting function? Use a macro? Should I check at run-time as well as compile-time? Any other ideas?</p></li>
</ul>

<h3>Edit:</h3>

<p>It seems like the example is being taken a little too literally...</p>

<p>I obviously didn't mean to talk <em>just</em> about <code>CString::GetLength()</code>. That particular method is certainly not a huge worry of mine. :) What I am worried about is the more <em>general</em> case, of when I'm getting an integer that's never <em>supposed</em> to be negative, but which <em>could</em> theoretically be, due to bugs.  </p>

<p>Heck, I might be <em>writing</em> a method that does this, in order to override another piece of code -- so I can't change the signature. And my code could certainly have bugs, even though I wouldn't expect it.</p>

<p>In such a case, what should I do?</p>
","87234","","<p>Can you change <code>GetLength()</code>? Fundamentally, the issue is that length is never negative, and an unsigned type reflects that the best. Length shouldn't be measured with an <code>int</code>.</p>

<p>But other than that, all three of your solutions are identical. <code>std::string::size_type</code> is always <code>std::size_t</code>, and while I would use a <code>static_cast</code>, the C-style cast performs the same cast, in this case. Because you know that the returned length is never negative (ensure this, by the way; you never know what weird things people might do), you're completely safe simply casting the type:</p>

<pre><code>return s2.size() &gt; static_cast&lt;std::size_t&gt;(s1.GetLength());
</code></pre>

<p>If <code>CString::GetLength</code> <em>can</em> be negative, for some reason, then it's up to you to decide how to make that conversion from negative to positive. Truncate? Magnitude (absolute value)? Whatever you need.</p>

<hr>

<p>If you're worried about bugs, either do an explicit check and throw an exception (depending on your domain, this may be too costly), or use <code>assert</code>. Generally, though, you should trust the documentation.</p>
"
"<p>Is there any function objects in the boost that are generic equivalents to the std::equal_to, std::greater etc. family of function objects?</p>

<p>Essentially, std::equal_to should become something like</p>

<pre><code>struct generic_equal_to
{
    template &lt;class T, class U&gt;
    bool operator()(const T&amp; t, const U&amp; u) const
    {
        return t == u;
    }
};
</code></pre>

<p>I can see how the generic versions of std::plus etc. might be trickier due to issues with the return type (though the <code>decltype</code> can solve that). I can't see any possible reason why the std::equal_to function object itself should require a template argument, though.</p>

<p>Surely somewhere in boost or in the STL these versions exist? They are, of course, trivial to write, but I very much dislike duplicating library code, especially for something as apparently trivial as this.</p>

<p><strong>EDIT</strong>:</p>

<p>As some context as to why I would want this instead of using lambdas, or another function-object generation method:</p>

<p>I was writing a generic <code>boost::fusion</code> sequence comparison function thusly:</p>

<pre><code>template &lt;class T&gt;
bool sequence_equal(const T&amp; left, const T&amp; right)
{
    return fusion::all(
        fusion::zip(left, right),
        fusion::fused&lt;generic_equal_to&gt;());
}
</code></pre>

<p>Note the <code>fusion::fused&lt;generic_equal_to&gt;</code> part, which leads to the isse that you can't practically specify a <code>boost::lambda</code> or <code>boost::phoenix</code> function-object by type. I guess one solution might be decltype:</p>

<pre><code>fusion::fused&lt;decltype(_1 == _2)&gt;()
</code></pre>

<p>That seems very awkward though, and might not even work, depending on how <code>boost::lambda</code> or <code>boost::phoenix</code> is implemented - I'm really not sure.</p>

<p>I know you can use <code>fusion::make_fused</code> to get around this whole issue, but then you have to instantiate the function object. The solution I thought of, then, would be a non-template <code>equal_to</code> struct - I called mine <code>generic_equal_to</code>.</p>

<p>I know it's a very trivial problem - after all, <code>make_fused(_1 == _2)</code> will probably inline down to much the same assembly as <code>fused&lt;generic_equal_to&gt;</code>. I just couldn't believe that there was no <code>generic_equal_to</code> function object in boost or in the STL anywhere, hence this question.</p>
","87234","","<p>I don't think there's anything quite as direct as you're asking for, but there are utilities that not only cover your use-cases, but go beyond. They are <a href=""http://www.boost.org/libs/lambda"" rel=""nofollow"">Boost.Lambda</a> and <a href=""http://www.boost.org/libs/spirit/phoenix/"" rel=""nofollow"">Boost.Phoenix</a> (the latter being a more generic successor to the lambda library).</p>

<p>Example using Boost.Lambda for generic equality:</p>

<pre><code>#include &lt;boost/lambda/lambda.hpp&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;

struct foo {};

bool operator==(foo, foo) { return true; }
bool operator==(foo, int) { return false; }

template &lt;typename T, typename U, typename Func&gt;
void f(const T&amp; x, const U&amp; y, Func func)
{
    std::cout &lt;&lt; func(x, y) &lt;&lt; std::endl;
}

int main()
{
    using namespace boost::lambda; // for placeholders
    std::cout &lt;&lt; std::boolalpha;

    foo a, b;
    int i = 0;

    f(a, b, _1 == _2);
    f(a, i, _1 == _2);
}
</code></pre>

<p>And the same, with Phoenix:</p>

<pre><code>#include &lt;boost/phoenix.hpp&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;

struct foo {};

bool operator==(foo, foo) { return true; }
bool operator==(foo, int) { return false; }

template &lt;typename T, typename U, typename Func&gt;
void f(const T&amp; x, const U&amp; y, Func func)
{
    std::cout &lt;&lt; func(x, y) &lt;&lt; std::endl;
}

int main()
{
    using namespace boost::phoenix::arg_names; // for placeholders
    std::cout &lt;&lt; std::boolalpha;

    foo a, b;
    int i = 0;

    f(a, b, arg1 == arg2);
    f(a, i, arg1 == arg2);
}
</code></pre>

<p>Each of these can be extended to support the other operators in the obvious way (and more generally, into other expressions). I would personally go with Phoenix, because if you find out you need more functionality than lambda offers you won't end up including both.</p>
"
"<p>I've heard it mentioned a couple of times that <code>std::vector</code> is not exception-safe when storing raw pointers and that one should use <code>unique_ptr</code> or <code>shared_ptr</code> instead.</p>

<p>My question is, why is <code>std::vector</code> not exception-safe and how do these classes fix that?</p>
","87234","","<p>It's not <code>std::vector</code> that's not exception safe, it's using raw pointers for memory management:</p>

<pre><code>int main()
{
    try
    {
        int* i = new int;

        throw ""oops, memory leak!"";
    }
    catch (...){}
}
</code></pre>

<p>That has nothing to do with vector's per se, it's just that doing this is the exact same problem:</p>

<pre><code>int main()
{
    try
    {
        std::vector&lt;int*&gt; vi;
        vi.push_back(new int);

        throw ""oops, memory leak!"";
    }
    catch (...){}
}
</code></pre>

<p>Both of these are fixed by using smart pointers:</p>

<pre><code>int main()
{
    try
    {
        std::unique_ptr&lt;int&gt; i(new int);

        std::vector&lt;std::unique_ptr&lt;int&gt;&gt; vi;
        vi.push_back(std::unique_ptr&lt;int&gt;(new int));
        vi.push_back(std::move(i));

        throw ""vector destroys unique_ptr's...which delete their memory"";
    }
    catch (...){}
}
</code></pre>

<p>(Or <code>shared_ptr</code>, which is more expensive. You may also use pointer containers, from Boost.)</p>
"
"<p>Is it true that C++ array is a const pointer in C++ ?</p>

<p><a href=""http://www.cplusplus.com/forum/articles/10/#msg1381"" rel=""nofollow"">http://www.cplusplus.com/forum/articles/10/#msg1381</a></p>

<p>So why is <code>x</code> and <code>&amp;x</code> the same if they are pointers?</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

int main() {
    int x[5];
    int *y = new int[5];

    cout &lt;&lt; ""&amp;x : "" &lt;&lt; &amp;x &lt;&lt; endl;
    cout &lt;&lt; ""x : "" &lt;&lt;  x &lt;&lt; endl;
    cout &lt;&lt; endl;
    cout &lt;&lt; ""&amp;y : "" &lt;&lt; &amp;y &lt;&lt; endl;
    cout &lt;&lt; ""y : "" &lt;&lt;  y &lt;&lt; endl;
    return 0; 
}
</code></pre>

<p>Output:</p>

<pre><code>&amp;x:  0xbfec4ccc
x :  0xbfec4ccc

&amp;y:  0xbfec4ce0
y :  0x8961008
</code></pre>

<p>Link to ideone of above code:
<a href=""http://ideone.com/3JRZd"" rel=""nofollow"">http://ideone.com/3JRZd</a></p>
","87234","","<p>Graham is wrong and doesn't know what he's talking about. Arrays and pointers are two different things.</p>
"
"<p>There are two threads (t1 and t2) pinned to two different cores. They both have a shared variable which is a raw pointer to some class type. t1 only reads the pointer and t2 reads/writes the pointer. Should I declare the pointer as just volatile or atomic or both? </p>

<p>When t2 updates this pointer, it is fine if t1 reads the old one or new one but it should not read any intermediate value as it will cause seg fault.</p>
","87234","","<p><code>volatile</code> is useless for multithreading, so that option is out. You indeed just want an atomic variable.</p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/1819114/when-can-typeid-return-different-type-info-instances-for-same-type"">When can typeid return different type_info instances for same type?</a>  </p>
</blockquote>



<p>If I change the <code>operand-&gt;type() == typeid(ValueType)</code> line below into <code>&amp;operand-&gt;type() == &amp;typeid(ValueType)</code>, the code still works with gcc and takes up less space in the executable (and did so for many years now), but does the C++11 standard give any guarantees, that this optimization should work across different compilers?</p>

<pre><code>template&lt;typename ValueType&gt;
ValueType * any_cast(any * operand)
{
    return operand &amp;&amp; 
#ifdef BOOST_AUX_ANY_TYPE_ID_NAME
        std::strcmp(operand-&gt;type().name(), typeid(ValueType).name()) == 0
#else
        operand-&gt;type() == typeid(ValueType)
#endif
        ? &amp;static_cast&lt;any::holder&lt;ValueType&gt; *&gt;(operand-&gt;content)-&gt;held
        : 0;
}
</code></pre>
","87234","","<p>No, it's not guaranteed. This assert may trigger:</p>

<pre><code>assert(&amp;typeid(int) == &amp;typeid(int));
</code></pre>

<p>While it would take a pretty stupid compiler to make that fire, it could happen. In practice, it will only fail when typeid's are being compared across dynamic library boundaries:</p>

<pre><code>assert(&amp;typeid_of_int_in_lib1() == &amp;typeid_of_int_in_lib2());
</code></pre>

<p>This will almost certainly trigger.</p>
"
"<p>The title is quite self-explanatory, input is given double value, and I want to add/substract the smallest amount possible.</p>
","87234","","<p>If your compiler implements C99's math functions/C++11, you can use the <code>nextafter</code>:</p>

<pre><code>#include &lt;cfloat&gt; // DBL_MAX
#include &lt;cmath&gt; // std::nextafter

double x = 0.1;

// next representable number after x in the direction of DBL_MAX
double xPlusSmallest = std::nextafter(x, DBL_MAX); 
</code></pre>

<p>Even if your compiler doesn't support it, it probably has an instrinsic for it. (MSVC has had <code>_nextafter</code> since 2005, for example. GCC probably implements it as standard.)</p>

<p>If your compiler doesn't support it but Boost is available to you, you can do this:</p>

<pre><code>#include &lt;boost/math/special_functions/next.hpp&gt; // boost::float_next

double x = 0.1;

// next representable number after x
double xPlusSmallest = boost::math::float_next(x); 
</code></pre>

<p>Which is equivalent to this (emulating C99):</p>

<pre><code>#include &lt;boost/math/special_functions/next.hpp&gt; // boost::nextafter
#include &lt;cfloat&gt; // DBL_MAX

double x = 0.1;

// next representable number after x in the direction of DBL_MAX
double xPlusSmallest = boost::math::nextafter(x, DBL_MAX); 
</code></pre>

<p>And if none of those work for you, you'll just have to crack open the Boost header and copy it.</p>
"
"<p>I have a namespace defined in one header file and used in another, but it cannot be found. Specifically, a namespace called ""players"" defined in ""players/Players.hpp"" and used in a file called ""players/Ownable.hpp"" cannot be found in a file called ""combat/Targetable.hpp""</p>

<p>The errors are</p>

<pre><code>...\source\combat\Targetable.hpp(7): 'players' : is not a class or namespace name
...\source\combat\Targetable.hpp(7): 'Ownable' : base class undefined
</code></pre>

<p>Obviously it's some syntax thing I don't understand. I've spent some time simplifying the code so it looks silly, but bear with me.</p>

<pre><code>// source/players/Players.hpp:
#ifndef PLAYERS_HPP
#define PLAYERS_HPP

#include ""../Headers.hpp""

namespace players {
  class Player{

// this class compiles fine.
// There used to be a ""Players.cpp"" but it's been simplified away

    public:
      int getID(){ return 0; }
      int getTeam(){ return 0; }
      string getName(){ return """"; }
      Vec3 getColor(){ return Vec3(0.0,0.0,0.0); }
  };
}
#endif
</code></pre>

<p>And players/Ownable.hpp, which is in the same folder as Player.hpp and also compiles fine:</p>

<pre><code>// source/players/Ownable.hpp:
#ifndef OWNABLE_HPP
#define OWNABLE_HPP

#include ""Players.hpp""

namespace players {
  class Ownable;
  typedef boost::shared_ptr&lt;Ownable&gt; OwnablePTR;
  typedef boost::weak_ptr&lt;Ownable&gt; OwnableWPTR;

  class Ownable {
    public:
      Ownable(){}
      Ownable(int playerID) : playerID(playerID){}
      bool isAlliedWith(OwnablePTR other){ return false; }

    private:
      int playerID;
  };
}

#endif
</code></pre>

<p>Here's where the fun starts. I have a file at ""source/combat/Targetable.hpp"", which is in a different directory than the other two. However, the file itself seems to include fine:</p>

<pre><code>// source/combat/Targetable.hpp:
#ifndef TARGETABLE_HPP
#define TARGETABLE_HPP

#include ""../players/Ownable.hpp""

namespace combat{
  class Targetable : public players::Ownable { // ERROR
    public:
      Targetable(int playerID){}
      //Targetable(players::Player player);

      virtual Vec2 getPosition(){
        return Vec2();
      }
      virtual Vec2 getVelocity(){
        return Vec2();
      }
  };
}

#endif
</code></pre>

<p>I'm really hoping this is some silly syntax thing that I'm missing. I've even tried</p>

<pre><code>using players::Ownable;
</code></pre>

<p>but that A) pollutes the files that include this one, and B) doesn't fix anything. Any help?</p>

<p>EDIT: GManNickG got it, it was a circular include in the Headers.hpp file. Thanks!</p>
","87234","","<p>You have a circular include.</p>

<p>First consider the purpose of include guards:</p>

<pre><code>// a.hpp
#ifndef A_HPP
#define A_HPP

// stuff

#endif
</code></pre>

<p> </p>

<pre><code>// b.hpp
#ifndef B_HPP
#define B_HPP

#include ""a.hpp""

// stuff

#endif
</code></pre>

<p> </p>

<pre><code>// c.hpp
#ifndef C_HPP
#define C_HPP

#include ""a.hpp""
#include ""b.hpp""

// stuff

#endif
</code></pre>

<p> </p>

<pre><code>// x.cpp
#include ""c.hpp""
</code></pre>

<p>The inclusion of <code>c.hpp</code> will end up include <code>a.hpp</code> twice. The first time, the guards are not defined and everything is okay, and the second time the guards prevent redefinitions. This is what we want.</p>

<p>This does not work when you have a loop, though. (It will prevent it, which is good, but it does ""too well"" because the guard is defined right after its tested, which means the contents of the header haven't actually yet been processed). Consider this instead:</p>

<pre><code>// a.hpp
#ifndef A_HPP
#define A_HPP

#include ""c.hpp""

// stuff

#endif
</code></pre>

<p> </p>

<pre><code>// b.hpp
#ifndef B_HPP
#define B_HPP

#include ""a.hpp""

// stuff

#endif
</code></pre>

<p> </p>

<pre><code>// c.hpp
#ifndef C_HPP
#define C_HPP

#include ""b.hpp""

// stuff

#endif
</code></pre>

<p> </p>

<pre><code>// x.cpp
#include ""c.hpp""
</code></pre>

<p>Which is similar to what you have. <code>x.cpp</code> includes <code>c.hpp</code>, which is the first time it's been included so it defines <code>C_HPP</code>. Then <code>c.hpp</code> includes <code>b.hpp</code>, which includes <code>a.hpp</code>. Then <code>a.hpp</code> includes <code>c.hpp</code> and <em>finds that <code>C_HPP</code> has already been defined</em>, so the include does nothing.</p>

<p>Assuming <code>a.hpp</code> still manages to compile (that is, <code>c.hpp</code> isn't actually needed), then <code>a.hpp</code> finishes, then <code>b.hpp</code> finishes, then <code>c.hpp</code> finally actually defines its contents before returning to <code>x.cpp</code>.</p>

<p>The solution is to minimize the amount of headers you include. Use forward declarations, and most of all: <em>do not use 'include everything' headers</em>! These are <em>terrible</em>. And I suspect that's what <code>Headers.hpp</code> is.</p>
"
"<p>I got following warning in my project (both Release and Debug mode):</p>

<pre><code>C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\concurrent_vector.h(1599): warning C4189: '_Array' : local variable is initialized but not referenced
      C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\concurrent_vector.h(1598) : while compiling class template member function 'void Concurrency::concurrent_vector&lt;_Ty&gt;::_Destroy_array(void *,Concurrency::concurrent_vector&lt;_Ty&gt;::size_type)'
      with
      [
          _Ty=Vector3i
      ]
      d:\Some_path\somefile.h(780) : see reference to class template instantiation 'Concurrency::concurrent_vector&lt;_Ty&gt;' being compiled
      with
      [
          _Ty=Vector3i
      ]
</code></pre>

<p>Where somefile.h is my file and line 780 has this code:</p>

<pre><code>Concurrency::concurrent_vector&lt;Vector3i&gt; m_ovColors;
</code></pre>

<p>Vector3i is something like this:</p>

<pre><code>template&lt;typename T&gt; class TVector3 {
public:
    T x, y, z;
}

typedef TVector3&lt;int&gt;           Vector3i;
</code></pre>

<p>Code around line 1598 in concurrent_vector.h is (line 1598 is just '{'):</p>

<pre><code>template&lt;typename _Ty, class _Ax&gt;
void concurrent_vector&lt;_Ty, _Ax&gt;::_Destroy_array( void* _Begin, size_type _N ) 
{
    _Ty* _Array = static_cast&lt;_Ty*&gt;(_Begin);
    for( size_type _J=_N; _J&gt;0; --_J )
        _Array[_J-1].~_Ty(); // destructors are supposed to not throw any exceptions
}
</code></pre>

<p>What could be a reason for this?
This somefile.h when included in other projects does not issue that kind of warning.</p>
","87234","","<p>The problem is that the code turns into this because of inlining:</p>

<pre><code>_Ty* _Array = static_cast&lt;_Ty*&gt;(_Begin);
for( size_type _J=_N; _J&gt;0; --_J )
    ; // destructor has no effect!
</code></pre>

<p>At this point, the compiler stops and checks that all initialized variables are used, and emits that warning.</p>

<p>(The code will then be optimized to an empty function:</p>

<pre><code>; // variable is unused
; // loop has no effect
</code></pre>

<p>but by this point the warnings have already been emitted.)</p>
"
"<p>After a huge amount of digging and searching I found the root of my problem. In essence this code is executed and, in its own project it causes the same error. I see that I cannot reset a smart pointer to a new string...but why? Also is there a simple way around this?</p>

<pre><code>scoped_array&lt;char&gt; sptr;
char* nptr = ""Hello"";

sptr.reset("""");
sptr.reset(nptr);
</code></pre>

<p>EDIT -</p>

<p>I think I've figured it out. While resetting, the smart pointer tries to delete and empty character array ("""") which, because the new operator was not used, was not allocated on the heap (ahem !!?!!?!???!?!). Therefore this program will break miserably when it tries to deallocate the memory. So correct me if I'm wrong but would the string itself be stored in the program's executable byte stream itself? If so, just for future reference, is there a way to force the allocation of a new string?</p>
","87234","","<p>You're correct in identifying the error. <code>scoped_array</code> will call <code>delete[]</code> on the object it's holding; that is, after all, the sole purpose of its existence. You can't <code>delete[]</code> something that wasn't <code>new[]'d</code>, or you get undefined behavior.</p>

<p>However, you should just use <code>std::string</code> if you want a dynamic string. Anything you try to create to allow <code>scoped_array&lt;char&gt;</code> to act like a string is just going to end up as a shoddy version of <code>std::string</code>. Then it's as simple as: <code>std::string s; s = """"; s = ""Hello""</code>.</p>
"
"<p>I want to use shared_ptr just like I'd use an actual pointer. I wanted to be able to do things like</p>

<pre><code>shared_ptr&lt;int&gt; a;
a = new int(5);
a = 0;
shared_ptr&lt;int&gt; foo()
    return 0;
</code></pre>

<p>but it is not implemented by default.</p>

<p>I changed the source code of the shared_ptr of the boost library by adding</p>

<pre><code>template&lt;class Y&gt; void operator=( int i )
{
    reset(i);
}
template&lt;class Y&gt; void reset(int i)
{
    this_type(i).swap(*this);
}
template&lt;class Y&gt; void operator=( Y * p )
{
    reset(p);
}
shared_ptr(int i): px(0), pn()
{
}
</code></pre>

<p>The only thing is that if I do a = -1; it will compile and give me a null pointer, which shouldn't be a problem because normally you can't assign an integer value to a pointer.</p>

<p>So my question is, is this a correct way to implement this or have I forgot cases that might crash the application? Because everywhere I looked, the only way I saw to get a nullpointer for a shared_ptr was to call the default constructor which isn't very elegant in code compared to: ptr = 0;.</p>
","87234","","<p>No. <strong>Do not change the source.</strong> It's like that for a reason and very smart people have decided that the way it's defined is better than whatever you're going to edit it to be.</p>

<p>What you have doesn't even make sense. You cannot assign an integer to a pointer, they are two different types, yet you've given it such semantics. You say: ""...which shouldn't be a problem because normally you can't assign an integer value to a pointer"", but you also said at the top of your question ""I want to use shared_ptr just like I'd use an actual pointer"". Well, which is it? Because assigning integers to pointers to set them to null is about as far from an actual pointer as you can get.</p>

<p>You need to take a step back and realize what you want isn't always the best thing to do. You should revert those changes and use the class properly. I don't want to be mean but this is seriously not the route you want to go; it's dangerous, has nonsensical semantics, and is all around unmaintainable.</p>
"
"<pre><code>/** converts 'WinMain' to the traditional 'main' entrypoint **/
#define PRO_MAIN(argc, argv)\
    int __main (int, LPWSTR*, HINSTANCE, int);\
    int WINAPI WinMain (HINSTANCE __hInstance, HINSTANCE __hPrevInstance, \
                       LPSTR __szCmdLine, int __nCmdShow)\
    {\
        int nArgs;\
        LPWSTR* szArgvW = CommandLineToArgvW (GetCommandLineW(), &amp;nArgs);\
        assert (szArgvW != NULL);\
        return __main (nArgs, szArgvW, __hInstance, __nCmdShow);\
    }\
    \
    int __main (int __argc, LPWSTR* __argv, HINSTANCE __hInstance, int __nCmdShow)
</code></pre>

<p>Now, when I use this code here:</p>

<pre><code>PRO_MAIN(argc, argv)
{
  ...
}
</code></pre>

<p>I get the error:</p>

<pre><code>error: conflicting types for '__main'
note: previous declaration of '__main' was here
</code></pre>

<p>What's the problem?</p>
","87234","","<p>You have broken the rules: <a href=""http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier"">double-underscores are reserved for implementation</a>! (Among other things.)</p>

<p>You simply cannot use <code>__main</code>, <code>main__</code>, <code>_Main</code>, etc. You should pick something else.</p>

<p>I would recommend you make this work:</p>

<pre><code>int main(int argc, char* argv[])
{
    // main like normal
}

// defines WinMain, eventually makes call to main()
PRO_MAIN;
</code></pre>

<p>Which has the added advantage that for non-Windows applications, <code>PRO_MAIN</code> can simply expand to nothing, and the program still compiles with the standard main function. This is what I do.</p>
"
"<p>I'd like to be able to ""somehow"" create a dynamic array that would still let me build its elements using the new operator.
Here's what I'd like to achieve:</p>

<pre><code>A* a = new A[3]; //or any equivalent syntax 
new (&amp;a[0]) A(myparams1); //placement new on first slot 
new (&amp;a[1]) A(myparams2, ...); //placement new on 2nd slot 
new (&amp;a[2]) A(myparams3, ...); //placement new on 3rd slot
delete[] a; //correct deletion of all elements
</code></pre>

<p>I'm aware  that this code would work (minus the 3 elements overwritten), but I'd like to avoid creating 3 default <code>a</code> elements in the first call to <code>new[]</code>. I am assuming here that I will <em>always</em> place 3 elements before calling <code>delete[]</code>.
I'm thinking such a thing can be achieved by using intelligent calls to <code>A::operator new[]</code> but I'm not sure how.
Does anyone have any idea? it's mostly for curiosity</p>
","87234","","<p>You just get raw memory instead:</p>

<pre><code>void* mem = ::operator new(capacity * sizeof(A));
</code></pre>

<p>This is required to be aligned for any type, including an array of <code>A</code>'s. Now you can construct in it:</p>

<pre><code>for (std::size_t i = 0; i &lt; capacity; ++i)
{
    void* addr = static_cast&lt;char*&gt;(mem) + i * sizeof(A);
    new (addr) A(x, y, z, ...);
}
</code></pre>

<p>Destruction requires you explicitly invoke it:</p>

<pre><code>for (std::size_t i = 0; i &lt; capacity; ++i)
{
    void* addr = static_cast&lt;char*&gt;(mem) + i * sizeof(A);
    static_cast&lt;A*&gt;(addr)-&gt;~A();
}
</code></pre>

<p>And now you can free the raw memory:</p>

<pre><code>::operator delete(mem);
</code></pre>

<p>Note that none of this is exception-safe. It's also what <code>std::vector&lt;A&gt;</code> does, check out the code.</p>
"
"<p>Example:</p>

<pre><code>enum SomeEnum
{
   DD,
   PP,
   NN
};

void someFunc(int a)
{
}

int main()
{
  SomeEnum e = DD;
   someFunc(a) // calls someFunc with value 0
  return 0;
}
</code></pre>

<p>This works in MSVC but is it non standard?</p>

<p>Thanks</p>
","87234","","<p>An <code>enum</code> has an underlying integer type (the type used to store the value of the <code>enum</code>), and the <code>enum</code> value can be implicitly converted to that integer type's value.</p>

<p>In your case the underlying type is <code>int</code>, and the value is 0. Everything is okay.</p>
"
"<pre><code>struct test_struct
{
    test_struct() {}
    ~test_struct() {}
};

#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;cstdio&gt;

int main()
{
    printf(""ctor begin\n"");
    {
        std::vector&lt;std::unique_ptr&lt;test_struct&gt;&gt; test_vec;
        const int count = 100000;

        for (auto i = 0; i &lt; count; i++) {
            test_vec.emplace_back(new test_struct);
        }
        printf(""dtor begin\n"");
    }
    printf(""dtor end\n"");
}
</code></pre>

<p>I'm using VS2010, and found some ridiculous performance issue. The code above works well both in debug and release build (ctrl+f5), but when debugger is attached(f5), dtor call for unique_ptr class is intolerably slow. The result machine code is fairly optimized, so I don't expect that it's compiler issue rather than debugger's, but I don't know how to deal with it. My question is</p>

<ul>
<li>Is this problem able to be reproduced on your machine?</li>
<li>What's the reason of this behaviour?</li>
<li>Is there any workaround?</li>
</ul>
","87234","","<p>The slowdown is caused by memory checking that occurs whenever memory is freed. However, this is a special system-/debugger-level heap, and isn't anything you can control from within your program.</p>

<p>There's a <a href=""http://preshing.com/20110717/the-windows-heap-is-slow-when-launched-from-the-debugger"">great article on the issue</a>. To summarize: you have to set an environment variable to disable it!</p>

<p>Luckily, you can set project-specific environment variables from the Debugging options in the Project Settings for your project, so that the environment variable is only applied to your program.</p>

<p>I used this simplified program to test:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;

int main()
{
    std::cout &lt;&lt; ""ctor begin"" &lt;&lt; std::endl;
    {
        std::vector&lt;std::unique_ptr&lt;int&gt;&gt; test_vec;

        for (unsigned i = 0; i &lt; 100000; i++)
            test_vec.emplace_back(new int);

        std::cout &lt;&lt; ""dtor begin"" &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; ""dtor end"" &lt;&lt; std::endl;
}
</code></pre>

<p>By setting <code>_NO_DEBUG_HEAP=1</code> as an environment variable (either system-wide, which I won't recommend, or through the Debugging options), the code runs in roughly the same amount of time irrespective of whether or not the debugger is attached.</p>
"
"<p>The STL uses the ""less than"" as the default comparator. An STL comparator call on an object wrapped with the reference_wrapper&lt;> <a href=""http://stackoverflow.com/q/9139748/1408646"">does not compile</a>, even if the underlying class has the ""&lt;"" operator defined.</p>

<p>It seems, this is because there is <a href=""http://stackoverflow.com/a/9139979/1408646"">no implicit conversion</a> performed on on the <em>LHS</em> of the <em>LHS.operator&lt;(RHS)</em> when it is a member function. I have verified that <a href=""http://stackoverflow.com/a/10717235/1408646"">using a free version</a> as the comparator works.</p>

<p>However, if the reference_wrapper provided the ""&lt;"" operator, which calls the ""&lt;"" on the underlying, the need to use the free function will be obviated. </p>

<p>I made the following addition in the code for the reference_wrapper (taken from VS11 Beta xrefwrap.h), and could use std::map with a class wrapped in my version of the reference_wrapper&lt;> which has the ""&lt;"" operator defined.</p>

<pre><code>    bool operator &lt;(reference_wrapper&lt;_Ty&gt; const rhs) const {
    return this-&gt;get() &lt; rhs.get();
}
</code></pre>

<p>Added later: If I understand correctly, reference_wrapper&lt;> provides copy/assign semantics associated with ptrs needed by many libraries, while hiding the ptr related syntax. This permits the use of reference type syntax, without the overhead of local copies. To compare it with examples using ptrs completely misses <strong><em>one</em></strong> of the point of the reference_wrappers: <em>you want to avoid the use of ptr type syntax.</em> </p>

<p>The way things stand right now, code which directly works on objects breaks when the objects are wrapped in reference_wrappers. Needless to say, ""&lt;"" being the default comparator, indeed makes it special; in a significant percentage of existing code, objects will define these to obviate the need for special comparators.</p>

<p>Added Later #2:
The history of this feature suggests that avoiding the use of ptr syntax was not the original intent. However, it has been a decade since this was first introduced in boost. With a large number of new programmers ""guided"" <a href=""http://stackoverflow.com/a/9149473/1408646"">to avoid ptr based syntax</a> (undoubtedly influenced by ptr free languages), this feature can become increasingly useful if it could work more seamlessly, especially when dealing with legacy code storing objects in STL containers, and value copies all over. </p>

<p><strong>Added Later #3: Improving Legacy Code with minimal code changes</strong>
Over time thin classes become heavy and the size of the objects in the containers increases. A quick way to improve performance is to avoid the copies, via wrapped objects. This will provide the ""C ptr"" type performance without the extra copies with minimal changes to the code.</p>

<pre><code>std::map&lt;const Object, string&gt; objTable;
// can be rewritten as to avoid object copies using the
// __myOwn::reference_wrapper which contains the '&lt;' operator
std::map&lt;__myOwn::reference_wrapper&lt;const Object&gt;, string&gt; rwTable_myOwn;

// which works with out any non-member free comparator functions
rwTable_myOwn[a]=""One""; // Compiles and works

// When using the table with the std::reference_wrapper
std::map&lt;std::reference_wrapper&lt;const Object&gt;, string&gt; rwTable_std;
//the map does not work
rwTable_std[a]=""One""; // Fails to compile it needs the custom non-member comparator
</code></pre>
","87234","","<p>No, it shouldn't. It isn't <code>reference_wrapper</code>'s job to do anything but wrap <em>a reference</em> as a value.</p>

<p>If you need to compare two <code>reference_wrapper&lt;T&gt;</code>'s (which is <em>not</em> a reference to <code>T</code>), then it's your job to make that work. For the same reason <code>std::set&lt;T*&gt;</code> doesn't default to defining comparison as <code>std::less&lt;T&gt;(*x, *y)</code>, neither should your case. The wrapper is just a non-null pointer.</p>

<p>Why stop at a single comparison operator or all the comparison operators? Why not overload reference wrapper for <em>all</em> of the standard functions? Because it's not worth it when the solution is so easy.</p>
"
"<p>I want to define a vector with some number of ints and populate it with the results from the function <code>get_a_value()</code>. It can be done through a loop this way:</p>

<pre><code>auto v = new std::vector&lt;int&gt;( 7 );
for ( int i = 0; i &lt; 7; i++ )
    v-&gt;at(i) = get_a_value();
</code></pre>

<p>But there's some redundancy that makes me uncomfortable. Can this be solved with some lambda magic in just the vector initialisation?</p>

<pre><code>auto v = new std::vector&lt;int&gt;( 7, /* something involving get_a_value() here */ );
</code></pre>

<p>The value of <code>get_a_value()</code> can be different in each call. And yes, I do need a pointer.</p>
","87234","","<p>In general, you want this:</p>

<pre><code>std::vector&lt;T&gt; v;
v.reserve(n); // reserve space only, no need to fill with default-constructed T's

std::generate_n(std::back_inserter(v), n, get_a_T_value); // fill with n values
</code></pre>

<p>This is simplest and most efficient. I leave it to you to adapt it to your homework.</p>
"
"<p>So when I have code like:</p>

<pre><code>shared_ptr&lt;Foo&gt; bar (my_normal_operator&lt;Foo&gt;(mumble));
</code></pre>

<p>Even though the type <code>Foo</code> is coming out of left field, it works as the return type is produced solely through an ""additive"" pattern to what is given:</p>

<pre><code>template &lt;typename Target, typename Source&gt;
shared_ptr&lt;Target&gt; my_normal_operator(Source src)
{
    /* ... whatever ... */
}
</code></pre>

<p>But what if the situation instead looked something like this:</p>

<pre><code>shared_ptr&lt;Foo&gt; bar (my_pointer_operator&lt;Foo*&gt;(mumble));
</code></pre>

<p>It needs some way to pull the pointer off the type.  I dug around and found <a href=""http://en.cppreference.com/w/cpp/types/remove_pointer"" rel=""nofollow"">std::remove_pointer</a>, but a naive application gives a ""type/value mismatch"":</p>

<pre><code>template &lt;typename Target, typename Source&gt;
shared_ptr&lt; std::remove_pointer&lt;Target&gt;::type &gt; my_pointer_operator(Source src)
{
    /* ... whatever ... */
}
</code></pre>

<p>I didn't actually expect it to work...but I'm putting it here as an expression of the what-I'm-looking for intent!</p>

<p><em>Sigh.  Every time I step into any new territory with templates and traits I feel like one of those <a href=""http://knowyourmeme.com/memes/i-have-no-idea-what-im-doing"" rel=""nofollow"">""I have no idea what I'm doing""</a> meme animals.  :-/</em></p>
","87234","","<p>You need <code>typename</code>:</p>

<pre><code>template &lt;typename Target, typename Source&gt;
shared_ptr&lt; typename std::remove_pointer&lt;Target&gt;::type &gt;
    my_pointer_operator(Source src)
{
    /* ... whatever ... */
}
</code></pre>

<p>Because the type of <code>std::remove_pointer&lt;Target&gt;::type</code> depends on a template argument.</p>

<p>Personally, I would leave <code>Target</code> as <code>Foo</code> and within the definition of <code>my_pointer_operator</code> use <code>typename std::add_pointer&lt;Target&gt;::type</code>, so the caller can specify the return value more directly. The function name gives away the difference in implementation.</p>
"
"<p>While I would assume that in VC++ this would be a no brainer, it's still worth asking.</p>

<p>When creating a getter method for a class that <em>only</em> returns the value of a protected/private member, does the compiler optimize this call so it's the equivalent of referencing that member without having to friend the class and without the overhead of a full method call?</p>
","87234","","<p>Yes. Both variants compile to the same thing:</p>

<pre><code>struct test
{
    int x;

    int get() const { return x; }
};

__declspec(noinline) int use_x(const test&amp; t)
{
    return t.x;
}

__declspec(noinline) int use_get(const test&amp; t)
{
    return t.get();
}

int main()
{
    test t = { 111605 };

    // pick one:
    return use_x(t);
    //return use_get(t);
}
</code></pre>

<p>Note that it's not as simple as always replacing <code>t.get()</code> with <code>t.x</code>, for the compiler. Consider something like this:</p>

<pre><code>t.get() += 5;
</code></pre>

<p>This shouldn't compile, because the result of the function call is an rvalue and <code>+=</code> (for primitives) requires an lvalue. The compiler will check for things like that.</p>
"
"<p>According to my understanding of the C++ specification (according to the draft standard online), a for-loop can be rewritten in terms of a while-loop and a block for initialization.  According to my understanding, the iteration statement of the for-loop occurs in the same scope as the body, so it should be able to use variables declared in the body of the for-loop.  Both gcc and clang reject the following (contrived) code, which is a simplification of my real code.</p>

<p>I can obviously fix the code by declaring j outside of the loop, but why is j out of scope below?</p>

<pre><code>int main() 
{
    for(int i=0; i&lt;10; i=j) int j=i+1;

    // // I must misunderstand the standard because I thought the above loop is 
    // // equivalent to the commented code below where j is clearly in scope.
    // {
    //     int i=0;
    //     while(i&lt;10) {
    //         int j=i+1;
    //         i=j;
    //     }
    // }

    return 0;
 }
</code></pre>

<p>According to clang (and gcc), this is invalid.</p>

<pre><code>test.cpp:3:26: error: use of undeclared identifier 'j'
    for(int i=0; i&lt;10; i=j) int j=i+1;
                         ^
1 error generated.
</code></pre>
","87234","","<p>For reference, the expansion is as follows (§6.5.3/1). The for-loop statement:</p>

<pre><code>for (init cond; expr) statement
</code></pre>

<p>is equivalent to:</p>

<pre><code>{
    init
    while (cond)
    {
        statement
        expr;
    }
}
</code></pre>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/5625600/what-is-the-meaning-of-token"">What is the meaning of &ldquo;&hellip; &hellip;&rdquo; token?</a>  </p>
</blockquote>



<p>There is a relatively new way to directly specify <strong>function types</strong> (at least, as template parameters). Don't know whether this is strictly C++11, but I've came across it while reading GCC 4.7's STL headers.</p>

<p>It's like this:</p>

<pre><code>std::function&lt;void(int, char**)&gt; f;
</code></pre>

<p>And now, in header file <code>&lt;functional&gt;</code>, I see the following:</p>

<pre><code>template &lt;typename R, typename... A&gt;
struct SomeStruct&lt;R(A...)&gt; { /* */ };
</code></pre>

<p>This is understandable: an explicit-specialization of <code>SomeStruct</code> for function types with return type <code>R</code> and arguments' types <code>A</code>.</p>

<p>But consider this declaration (on next line):</p>

<pre><code>template &lt;typename R, typename... A&gt;
struct SomeStruct&lt;R(A......)&gt; { /* */ };
</code></pre>

<p>What does that double-ellipsis mean?</p>
","87234","","<p>I personally find it unclear, but if you know that these are equivalent, it makes more sense:</p>

<pre><code>void example(int, char, ...); // C-style variadic arguments
void example(int, char...);   // equivalent: the comma before the ellipses is optional
</code></pre>

<p>So that specialization is just covering the case for when functions take the form:</p>

<pre><code>R(A..., ...)
</code></pre>

<p>Such as in <code>sprintf</code>: <code>R</code> is <code>int</code>, <code>A...</code> is <code>char*</code> and <code>const char*</code>, and it's C-style variadic.</p>
"
"<p>In a <a href=""http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html"" rel=""nofollow"">tutorial</a> on monads, in the section <strong>A more complex side effect: Random Numbers</strong>, the author provides the signature of the random function like so:</p>

<pre><code>random :: StdGen -&gt; (a,StdGen)
</code></pre>

<p>but then goes on to say that:</p>

<blockquote>
  <p>So a function that is conceptually a randomised function <code>a → b</code> can be
  written as a function <br>
  <code>a -&gt; StdGen -&gt; (b,StdGen)</code> <br>where <code>StdGen</code> is the
  type of the seed.</p>
</blockquote>

<p>Where does the extra <code>a</code> in the begining of the signature come from? Why is the type of that not simply <code>StdGen -&gt; (a, StdGen)</code> as before???</p>

<p>Thanks</p>
","87234","","<p>It's not the same because those are two different functions he's describing. :)</p>

<p>The first one takes a <code>StdGen</code> and returns a result of that random generator along with the new state. </p>

<p>He then says, ""so if we have a function that mutates an <code>a</code> randomly (into <code>b</code>), you'd get..."" and then the second signature.</p>
"
"<p>When I compile the following code, compiler gives me the warning: </p>

<pre><code>""Implicit conversion loses integer precision: 'std::streamsize' (aka 'long') to 'int'"". 
</code></pre>

<p>I'm a little bit confused about this warning since I just try to save the current value of the precision to set it back to the original value later.</p>

<pre><code>#include &lt;iomanip&gt;
#include &lt;iostream&gt;

int main() {
  std::streamsize prec = std::cout.precision();
  std::cout &lt;&lt; std::setprecision(prec);
}
</code></pre>

<p>What is the right way to save the precision value and set it back later in this case?</p>
","87234","","<p>It looks like it's just an oversight in the standard specification.</p>

<p><code>ios_base::precision</code> has two overloads, one that gets and one that sets the precision:</p>

<pre><code>// returns current precision
streamsize precision() const;

// sets current precision and returns old value
streamsize precision(streamsize prec) const;
</code></pre>

<p>So this code will not give you warnings:</p>

<pre><code>#include &lt;iostream&gt;

int main() {
  std::streamsize prec = std::cout.precision(); // gets
  std::cout.precision(prec); // sets
}
</code></pre>

<p>However, the <code>setprecision()</code> function simply takes a plain old <code>int</code>:</p>

<pre><code>unspecified-type setprecision(int n);
</code></pre>

<p>and returns an unspecified functor, which when consumed by a stream <code>str</code> has the effect of:</p>

<pre><code>str.precision(n);
</code></pre>

<p>In your case, <code>streamsize</code> is not an <code>int</code> (and does not have to be), hence the warning. The standard should probably be changed so that <code>setprecision</code>'s parameter is not <code>int</code>, but <code>streamsize</code>.</p>

<p>You can either just call <code>precison()</code> yourself, as above, or assume <code>int</code> is sufficient and cast.</p>

<pre><code>#include &lt;iomanip&gt;
#include &lt;iostream&gt;

int main() {
  std::streamsize prec = std::cout.precision();
  std::cout &lt;&lt; std::setprecision(static_cast&lt;int&gt;(prec));
}
</code></pre>

<p><em>Edit: <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1148"" rel=""nofollow"">Apparently it was submitted to be fixed and reached no concensus (closed as not-a-defect)</a>.</em></p>
"
"<pre><code>#include &lt;iostream&gt;
int main()
{
    ------- some statements ---------

    int(a)(1);

   -------- some other statments .......
    return 0;
}
</code></pre>

<p>I saw this statement in a C++ program. This did not result in a syntax error.  </p>

<p>What is <code>a</code> here? Is this valid C++ syntax?</p>
","87234","","<p>It is okay to put the name of the variable in parenthesis:</p>

<pre><code>int i;
int (i); // exact same
</code></pre>

<p>So in your case:</p>

<pre><code>int a(1); // initialized with 1
int (a)(1); // exact same
</code></pre>
"
"<p>I've spend quite some time on implementing move semantics for my class but now I'm dealing with functions that use it. </p>

<p>Ok, so I have this object which has a lot of data on the heap: <code>CLargeOb</code> for which I implemented the move semantics (constructor and operator =). It is ideally used like this:</p>

<pre><code>void OtherOb::Func(CLargeOb&amp;&amp; largeOb1, CLargeOb&amp;&amp; largeOb2)
{
    SomeOtherFunc(largeOb1); // use objects
    SomeOtherFunc(largeOb2); 
    m_largeOb1 = (CLargeOb&amp;&amp;)largeOb1; // save as members and trash the originals
    m_largeOb2 = (CLargeOb&amp;&amp;)largeOb2;
}
</code></pre>

<p>However it's not always possible to allow the objects to be moved/trashed, so I added these two functions:</p>

<pre><code>void OtherOb::Func(const CLargeOb&amp; largeOb1, CLargeOb&amp;&amp; largeOb2)
{
    SomeOtherFunc(largeOb1);
    SomeOtherFunc(largeOb2); 
    m_largeOb1 = largeOb1;
    m_largeOb2 = (CLargeOb&amp;&amp;)largeOb2;
}

void OtherOb::Func(CLargeOb&amp;&amp; largeOb1, const CLargeOb&amp; largeOb2)
{
    SomeOtherFunc(largeOb1);
    SomeOtherFunc(largeOb2); 
    m_largeOb1 = (CLargeOb&amp;&amp;)largeOb1;
    m_largeOb2 = largeOb2;
}
</code></pre>

<p>Although it works, you can already guess it will become a major pain in the *ss when I have a function which takes 3 or more of these objects as parameters... Isn't there a clever way to solve this using templates or maybe 'perfect forwarding'?</p>
","87234","","<p>As was the case in C++03, the guideline is: <strong>if you want a copy, make it in the parameter list</strong>.</p>

<p>This lets the caller deal with how you get the object, you just get an object regardless:</p>

<pre><code>void OtherOb::Func(CLargeOb largeOb1, CLargeOb largeOb2) 
{ 
    SomeOtherFunc(largeOb1); // use objects 
    SomeOtherFunc(largeOb2);  
    m_largeOb1 = std::move(largeOb1); // save as members and trash the originals 
    m_largeOb2 = std::move(largeOb2); // (you should use std::move, not cast)
} 
</code></pre>

<p>The caller:</p>

<pre><code>OtherOb o;

CLargeOb x, y;
const CLargeOb z;

o.Func(x, std::move(y)); // need x for later, done with y so move it
o.Func(std::move(x), z); // done with x, necessarily copy z
</code></pre>

<p>This is just as efficient as several specialized overloads. Why? <em>Because those already exist in the class as constructors</em>. Let the compiler figure out which to call at the call site for you, it already knows what to do.</p>
"
"<p>Here:</p>

<p><a href=""http://en.cppreference.com/w/cpp/utility/functional/function"" rel=""nofollow"">http://en.cppreference.com/w/cpp/utility/functional/function</a></p>

<p><code>operator bool</code> is described: ""Checks whether the stored callable object is valid"".</p>

<p>Presumably a default constructed <code>std::function</code> is not valid but is this the only case?</p>

<p>Also, how does it check whether it is valid?</p>

<p>Is the case where <code>operator()</code> raises <code>std::bad_function_call</code> exactly the case where the object is not valid?</p>
","87234","","<p>It's poorly written as is, your confusion is justified. By ""valid"" they mean ""has a target"".</p>

<p>A <code>std::function</code> ""has a target"" when it's been assigned a function:</p>

<pre><code>std::function&lt;void()&gt; x; // no target
std::function&lt;void()&gt; y = some_void_function; // has target

x = some_other_void_function; // has target
y = nullptr; // no target

x = y; // no target
</code></pre>

<p>They should have either defined ""valid"" before they used it, or simply stuck with the official wording.</p>
"
"<p>In C++ Primer fourth edition, by Stanley B.Lippman, Josee Lajoie and Barbara E. Moo it states:</p>

<blockquote>
  <p>Because vectors grow efficiently, it is usually best to let the vector
  grow by adding elements to it dynamically as the element values are
  known.</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>Readers accustomed to using c or java might expect that because vector
  elements are stored contiguously, it would be best to preallocate the
  vector at its expected size. In fact the contrary is the case...</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>Allthough we can preallocate a given number of elements in a vector,
  it is usually more efficient to define an empty vector and add
  elements to it.</p>
</blockquote>

<p>Assuming this is correct (the authors are as reputable as they come, one is a co-author of C++ itself) then can anyone give me a case that proves this statement, and explain why?</p>
","87234","","<p>It depends.</p>

<p>If you don't know what the final size will be, then let the vector allocate using its allocation scheme (usually doubles each time, or somewhere around there). This way you avoid reallocating for every single element:</p>

<pre><code>std::vector&lt;int&gt; v;

// good:
for (/* populate v */) // unknown number of iterations
{
    v.push_back(i); // possible reallocation, but not often
}

// bad:
for (/* populate v */) // unknown number of iterations
{
    v.reserve(v.size() + 1); // definite reallocation, every time
    v.push_back(i); // (no reallocation)
}
</code></pre>

<p>But if you know ahead of time you won't be reallocating, then preallocate:</p>

<pre><code>std::vector&lt;int&gt; v;

// good:
v.reserve(10); 
for (/* populate v */) // only 10 iterations (for example)
{
    v.push_back(i); // no reallocations
}

// not bad, but not the best:
for (/* populate v */) // only 10 iterations (for example)
{
    v.push_back(i); // possible reallocation, but not often (but more than needed!)
}
</code></pre>
"
"<p>Is it at all possible to use Type Erasure to create objects that encapsulate an arbitrary type, (let's call it <code>ErasedType</code>), and can be queried at runtime to tell whether another arbitrary type <code>T</code> is convertible to <code>ErasedType</code>?</p>

<p>After thinking about it, I don't think it's possible - even though it seems it <em>could</em> potentially be possible in theory.  The compiler would know which types <code>T</code> we're trying to compare with <code>ErasedType</code>, and so could generate the necessary code before runtime.  The problem is that, in practice, there doesn't seem to be <em>ANY</em> way to pass a template parameter type from a Base class instance to a Subclass instance.</p>

<p>For example:</p>

<pre><code>struct FooBase
{
    template &lt;class TestType&gt;
    bool is_convertible()
    {
        return call_derived();
    }

    protected:

    virtual bool call_derived() = 0;

    template &lt;class ErasedType&gt;
    void base_class_function() { }
};

template &lt;class ErasedType&gt;
struct Foo : public FooBase
{
    bool call_derived()
    {
        // Here we have access to the ErasedType but no access to TestType.
            //
        // We could pass ErasedType to a base class function by saying:
        //
        // this-&gt;base_class_function&lt;ErasedType&gt;();
        //
        // ...but that doesn't seem to help since we still don't have access to
        // TestType
    }
};
</code></pre>

<p><br>
<br>
So, the goal is to be able to say something like:</p>

<pre><code>FooBase* f = new Foo&lt;int&gt;();
bool res1 = f-&gt;is_convertible&lt;double&gt;(); // returns true
bool res2 = f-&gt;is_convertible&lt;long&gt;(); // returns true
bool res3 = f-&gt;is_convertible&lt;std::string&gt;(); // returns false
</code></pre>

<p>But, I can't see how the <code>FooBase::is_convertible</code> method could ever be implemented, since I see no way to make <code>TestType</code> and <code>ErasedType</code> accessible together, in the same function, so the compiler could compute the result of <code>std::is_convertible&lt;TestType, ErasedType&gt;::value</code></p>

<p>So, is this at all possible?</p>
","87234","","<p>It is indeed not possible in C++, <em>in general</em>. It takes quite a bit of meta-data to make arbitrary queries about types at runtime, and C++ tries to keep this minimal (sometimes to the point of being a bit annoying; a feature could be automatically opt-in ""on use"", so there's no unnecessary overhead, but I disgress).</p>

<p>As David has been alluding to, it's entirely possible to duplicate the compilers information up to a point, but never fully automatically. This limits the runtime type information to what you manually add.</p>

<p>Take a look at libraries like <a href=""http://en.wikipedia.org/wiki/Qt_%28toolkit%29"" rel=""nofollow"">Qt</a> that have an entire framework on top of C++ to provide this meta-data to see what kind of work is involved. Depending on the problem at hand, you may be able to get by without it.</p>
"
"<pre><code>printf(""%c"",""abcdefgh""[4]);
</code></pre>

<p>The output of the following program is <code>e</code>. But I don't know how it is? I searched a lot in google and here but didn't find the correct explanation for this code. The explanation I am getting for this code:</p>

<blockquote>
  <p>""This is for getting one <code>char</code> only. i.e, the 4th <code>char</code> starts from <code>0</code>. So the answer is <code>'e'</code>"".</p>
</blockquote>
","87234","","<p>String literals are arrays, and as such can be indexed into: <code>""abcdefgh""[0]</code> is <code>'a'</code>, for example.</p>
"
"<p>I have a vector and I would like to efficiently break out the second half of the vector into another vector using STL algorithms.  Here is one way I see to do this, but expect there are more efficient and succinct answers, or at the least, one that uses the stl algorithms:</p>

<pre><code>std::vector&lt;Entry&gt; &amp;entries = someFunction();
int numEntries = entries.size();

// Assume numEntries is greater than or equal to 2.

std::vector&lt;Entry&gt; secondEntries;
std::vector&lt;Entry&gt;::iterator halfway = entries.begin() + numEntries / 2;
std::vector&lt;Entry&gt;::iterator endItr  = entries.end() 

// Copy the second half of the first vector in the second vector:
secondEntries.insert(secondEntries.end(), halfway, endItr);

// Remove the copied entries from the first vector:
entries.erase(halfway, endItr);
</code></pre>
","87234","","<p>Taking a step back, keep in mind to make sure that you're working with iterators with your own algorithms, and not (necessarily) containers. So if you have this:</p>

<pre><code>void foo(const std::vector&lt;Entry&gt;&amp; v) { /* ... */ }
</code></pre>

<p>And now you're stuck in this situation:</p>

<pre><code>std::vector&lt;Entry&gt; entries = someFunction();

// have to split entries! make more containers? :(
foo(first_half(entries));
foo(second_half(entries));
</code></pre>

<p>Consider using iterators instead:</p>

<pre><code>// or a template, if it doesn't hurt
void foo(std::vector&lt;Entry&gt;::const_iterator first, 
         std::vector&lt;Entry&gt;::const_iterator second) { /* ... */ }
</code></pre>

<p>So now you denote ranges and not containers:</p>

<pre><code>std::vector&lt;Entry&gt; entries = someFunction();

// easy to split entries! :)
auto middle = entries.begin() + entries.size() / 2;
foo(entries.begin(), middle);
foo(middle + 1, entries.end());
</code></pre>

<p>This limits the number of unnecessary containers and allocations you make.</p>

<hr>

<p>With that out of the way, in C++11 you can do this (rest is the same):</p>

<pre><code>// *Move* the second half of the first vector in the second vector:           
secondEntries.insert(secondEntries.end(),
                        std::make_move_iterator(halfway),
                        std::make_move_iterator(endItr));
</code></pre>

<p>If <code>Entry</code> has a move constructor, the <code>move_iterator</code> adapter will ensure that it is used during the insertion (if it doesn't a normal copy is made). In C++03, what you have is probably best.</p>
"
"<p>Consider:</p>

<pre><code>#include &lt;iostream&gt;

template &lt;typename T&gt; T getArray( T &amp;arr ) {
    return *arr;
}

int main() {

    int a[] = {5, 3, 6};

    std::cout &lt;&lt; getArray(a);

}
</code></pre>

<p>It's suppose to print the first element in the array but it is not not working. Why is that?</p>

<p>It gives me the error:</p>

<pre><code>error: no matching function for call to 'getArray(int [3])'
</code></pre>
","87234","","<p>The type of <code>a</code> is <code>int[3]</code>, so the type of <code>T</code> is <code>int[3]</code>. <strong>Arrays cannot be returned from functions.</strong></p>

<p>In C++11, you can do this:</p>

<pre><code>template &lt;typename T&gt;
auto getArray(T &amp;arr) -&gt; decltype(*arr)
{ 
    return *arr; 
} 
</code></pre>

<p>Or this:</p>

<pre><code>// requires &lt;type_traits&gt;

template &lt;typename T&gt;
typename std::remove_extent&lt;T&gt;::type&amp; getArray(T &amp;arr)
{ 
    return *arr; 
} 
</code></pre>

<p>In C++03 you can do this, but it's not quite the same:</p>

<pre><code>template &lt;typename T&gt;
T getArray(T* arr /* not really an array */)
{ 
    return *arr; 
} 
</code></pre>

<p>Or:</p>

<pre><code>template &lt;typename T, std::size_t N&gt;
T getArray(T (&amp;arr)[N])
{ 
    return *arr; 
} 
</code></pre>
"
"<p>I wish to have some wrapper code be a header-only library. I was inspired by the boost libraries to keep them header only to uncomplicate the need for distributing .lib's and including compiling .cpp's. </p>

<p>In this example ""z.h"" is the wrapper and a.cpp has been refactored to move B() into it's own source file. Now it doesn't work.</p>

<p>z.h</p>

<pre><code>class Z
{
    public:
    void Foo(); // edited to match my code
};

Z::Foo() { } 
</code></pre>

<p>a.cpp</p>

<pre><code>#include ""z.h""
void A() { 
      Z z;
      z.Foo();
}
//void B(Z z) {
//     z.Foo();
//}
</code></pre>

<p>b.cpp</p>

<pre><code>#include ""z.h""
void B(Z z) {           
      z.Foo();
}
</code></pre>

<p>*error LNK2005: ""public: __cdecl void z::Foo()"" already defined in b.obj*</p>

<p>I know I can fix this by separating out z.h into z.h for declarations and z.cpp for definitions. </p>

<ul>
<li>But how can Boost libraries get away without .cpp files?</li>
<li>Does everything need to be a template?</li>
<li>What code can go in z.h?</li>
</ul>
","87234","","<p>For a moment, consider this header:</p>

<pre><code>// foo.hpp

void foo(int x)
{
    /* do something */
}
</code></pre>

<p>(Header guards aren't relevent here, they work per-translation-unit.) We now have two translation units:</p>

<pre><code>// a.cpp

#include ""foo.hpp""
</code></pre>

<p>And:</p>

<pre><code>// b.cpp

#include ""foo.hpp""
</code></pre>

<p>What this ends up doing is defining <code>foo(int x)</code> twice, one in each TU. Multiple definitions are not allowed, under the One Definition Rule (ODR), and though technically no diagnostic is required, it's trivial on the compilers part to do so, and hence you get your error.</p>

<p>Luckily, there is a keyword, <code>inline</code>, which changes this behavior:</p>

<pre><code>// foo.hpp

inline void foo(int x)
{
    /* do something */
}
</code></pre>

<p>This keyword tells the linker that, should it come across multiple definitions, it is free to pick a single definition and discard the rest. (It's up to you to make sure this is actually okay!) With this change, the previous ODR violation is solved and the program compiles.</p>

<p>Now, you've listed your header as:</p>

<pre><code>class Z      
{      
    public:      
    void Foo(){       
       //do stuff      
    }      
};     
</code></pre>

<p>This is equivalent to this:</p>

<pre><code>class Z      
{      
    public:      
    void Foo();
};    

inline void Z::Foo(){       
       //do stuff      
    }
</code></pre>

<p>because functions that are defined within the class are implicitly <code>inline</code>. (This allows you to include the definition in multiple translation units without error.) I suspect what you've written is not what is in your post, but something like this:</p>

<pre><code>class Z      
{      
    public:      
    void Foo();
};    

void Z::Foo(){       
       //do stuff      
    }
</code></pre>

<p>where <code>inline</code> is missing. The equivalence is lost, multiple definitions are created, and you violate the ODR.</p>

<p>The solution is to use <code>inline</code>, or implicitly use it by definition the function within the class definition. Personally, I find the latter much clearer (because you avoid repeating yourself), and much easier to maintain. Boost uses <code>inline</code> often to avoid the need for single definitions.</p>
"
"<p>I have a simple function that takes two variables by reference:</p>

<pre><code>void foo(int*&amp; it2,
         bit_reader&lt;big_endian_tag&gt;&amp; reader2)
{
    for(/* ... */)
    {
        *it2++ = boo(reader2.next());
        // it2++ =&gt; 0x14001d890 add qword ptr [r12], 0x4
    }
}
</code></pre>

<p>The problem here is that for <code>it2</code> and <code>reader2</code> the optimizer makes the computer write to memory instead of registers during the loop.</p>

<p>However, the following code puts the variables properly into registers during the loop, but has an extra overhead in the form of unnecessary copies, before and after the loop:</p>

<pre><code>void foo2(int*&amp; it2,
         bit_reader&lt;big_endian_tag&gt;&amp; reader2)
{
    auto reader = reader2;
    auto it     = it2;

    for(/* ... */)
    {
        *it++ = boo(reader.next());
        // it++ =&gt; 0x14001d890 add r15, 0x4
    }

    reader2 = reader;
    it2 = it;
}
</code></pre>

<p>e.g.</p>

<p>How can I make the first example generate the same code as the second example but without the extra copies?</p>
","87234","","<p>The problem is that the compiler cannot prove <code>it2</code> does not change within the function. (Well, it could, but that's vastly beyond the intended capabilities of a normal C++ compiler.)</p>

<p>How does it know <code>boo(reader2.next());</code> doesn't change the value? Consider:</p>

<pre><code>int* i = 0;

struct foo
{
    int myInt;
    int blah() { i = &amp;myInt; return 5; }
};

void bar(int*&amp; ptr, const foo&amp; f)
{
    *ptr = f.blah(); // changes value of ptr!
}

int otherInt;
i = &amp;otherInt;

bar(i, foo());
</code></pre>

<p>This does not assign anything to <code>otherInt</code>, whereas after your transformation it would:</p>

<pre><code>void bar(int*&amp; ptr, const foo&amp; f)
{
    int* ptrCopy = ptr;
    *ptrCopy = f.blah(); // changes ptr, but not ptrCopy
}
</code></pre>

<p>So unless the compiler can prove the behavior is the same, it cannot make the optimization.</p>

<p>C99 solves this problem with the <code>restrict</code> keyword, but C++ has no equivalent. There are extensions that exist in most C++ compilers though, such as <code>__restrict__</code> or <code>__restrict</code>.</p>

<p>To do it in standard C++, you just have to be explicit and make the copy yourself</p>
"
"<p>I have a piece of code and some errors and warnings, I could not understand why they occur. Could you give me your advice?   </p>

<p>The first:</p>

<pre><code>#pragma once

#include ""Vector3.h""
#include &lt;vector&gt;

#include &lt;GL/glew.h&gt;

class BoundingSphere
{
public:
    float radius;
    Vector3 center;
    BoundingSphere(float radius, Vector3 center) : radius(radius),center(center) {};
    BoundingSphere() {};
};

class TriangleFace;

class MeshVertex
{

private:
    Vector3 position; 
    std::vector&lt;TriangleFace *&gt; faces;
    Vector3 normal;
    bool normalUpdateNeeded;

public:

    unsigned int index;

    MeshVertex(void);
    MeshVertex(Vector3 position);
    ~MeshVertex(void);

    Vector3 &amp;getPos() {return position;};
    void addFace(TriangleFace *face);
    const std::vector&lt;TriangleFace*&gt;&amp; getFaces() {return faces;  };
    Vector3 getNormal();

    void setPos(Vector3 &amp; pos) {position = pos; }
    bool isSurfaceParticle() {return faces.size()&gt;0;}
    void updateNormal();
};

class TriangleFace
{
private:
    Vector3 normal;
    bool normalUpdateNeeded;

public:
    MeshVertex* particles[3];
    TriangleFace(void);
    TriangleFace(MeshVertex *p1, MeshVertex *p2, MeshVertex *p3);
    MeshVertex&amp; operator[](int i) {  return *(particles[i]); }
    Vector3 getNormal();
    ~TriangleFace(void);
    void updateNormal();
};

class TriangleMesh
{
protected:
    std::vector&lt;MeshVertex&gt; particles;
    std::vector&lt;TriangleFace&gt; faces;

public:
    TriangleMesh(string filename);
    ~TriangleMesh(void);

    void reserveNumberOfFaces(unsigned int n) { faces.reserve(n); };
    void addFace(TriangleFace &amp;f) {faces.push_back(f);};
    void addFace(MeshVertex *p1, MeshVertex *p2, MeshVertex *p3) {faces.push_back(TriangleFace(p1,p2,p3));};

    std::vector&lt;TriangleFace&gt;&amp; getFaces() {return faces;};
    std::vector&lt;MeshVertex&gt;&amp; getParticles() { return particles; };

    void updateNormals();

    BoundingSphere getBoundingSphere();
};


class RenderTriangleMesh
{
private: 
    TriangleMesh &amp;m;

    GLuint vboid[2];

    GLfloat *vertices;
    GLfloat *normals;

public:
    RenderTriangleMesh(TriangleMesh &amp;m);
    void draw();

private:
    void generateVBOs();
    void updateVBOs();

};
</code></pre>

<p>Errors:</p>

<blockquote>
  <p>error C2220: warning treated as error - no 'object' file generated</p>
  
  <p>warning C4512: 'RenderTriangleMesh' : assignment operator could not be generated</p>
</blockquote>

<p>And the other:</p>

<pre><code> virtual short SimpleAddOK(const GeneralMatrix* gm) { return 0; }
</code></pre>

<p>error :</p>

<blockquote>
  <p>error C2220: warning treated as error - no 'object' file generated</p>
  
  <p>warning C4100: 'gm' : unreferenced formal parameter</p>
</blockquote>
","87234","","<p>The first is saying that the compiler could not generate an assignment operator. This happens because of your reference member, as references cannot be reseated:</p>

<pre><code>struct foo
{
    int&amp; i;
};

int x, y;
foo f = { x };
foo g = { y };

f = g; // ??? 
</code></pre>

<p>You can silence the warning by explicitly disabling it yourself:</p>

<pre><code>struct foo
{
    int&amp; i;

private:
    foo&amp; operator=(const foo&amp;); // declared but never defined
};
</code></pre>

<p>That's an old trick to make the assignment operator unusable, but stops the compiler from generating it.</p>

<p>In C++11, you can do this:</p>

<pre><code>struct foo
{
    int&amp; i;

private:
    foo&amp; operator=(const foo&amp;) = delete;
};
</code></pre>

<p>which is more explicit and much less hacky.</p>

<hr>

<p>The other is because you never used your argument, which can often be an error in program logic. You should probably remove its name if you don't use it:</p>

<pre><code>virtual short SimpleAddOK(const GeneralMatrix* /* gm */) { return 0; } 
</code></pre>

<p>Personally I delete it completely. Others do this:</p>

<pre><code>virtual short SimpleAddOK(const GeneralMatrix* gm)
{
    (void)gm; // this ""uses"" gm

    return 0;
} 
</code></pre>

<p>It's sometimes wrapped in a macro called <code>USE</code>:</p>

<pre><code>#define USE(x) (void)x

virtual short SimpleAddOK(const GeneralMatrix* gm)
{
    USE(gm);

    return 0;
} 
</code></pre>

<p>I consider these inferior to simply deleting the name, because if the warning is actually correct (that is, you <em>do</em> have a flaw in your program and aren't seeing it), you're masking the warning, defeating the purpose.</p>

<p>Warnings should always be fixed, not silenced.</p>
"
"<p>What are the cases when  <code>std::forward</code> is not needed?  It is used to wrap inner function argument which is templated-rvalue (that is it can be lvalue or named-rvalue). Like in:</p>

<pre><code>template&lt;class T&gt;
void outer(T&amp;&amp; t) { 
    inner(std::forward&lt;T&gt;(t)); 
}
</code></pre>

<p>I am guessing one case is when inner function parameters are passed by value.   Are there other cases?  I've got this question when I was writing <code>std::begin(std::forward&lt;Ct&gt;(ct))</code> where Ct is templated-rvalue-ref. </p>
","87234","","<p>Perfect forwarding is possible when the template parameter type contains a value category. (If this sentence doesn't make sense, take a minute to <a href=""http://stackoverflow.com/questions/3582001/advantages-of-using-forward/3582313#3582313"">familiarize yourself with the problem at hand</a>.)</p>

<p>Given:</p>

<pre><code>template &lt;typename T&gt;
void foo(T&amp;&amp; x); 
</code></pre>

<p>Within the body of <code>foo</code>, <code>T</code> will either take the form of <code>U</code> or <code>U&amp;</code>. The former means we were passed an rvalue, the latter means we were passed an lvalue. We can <em>forward</em> this fact on like so:</p>

<pre><code>template &lt;typename T&gt;
void foo(T&amp;&amp; x)
{
    bar(std::forward&lt;T&gt;(x));
}
</code></pre>

<p>Pass an lvalue to <code>foo</code>, <code>bar</code> gets the same lvalue. Pass an rvalue to <code>foo</code>, <code>bar</code> gets the rvalue.</p>

<p>If you cannot distinguish a value category, then forwarding is of no use. It's only useful when you have a template parameter that's deduced in the same fashion as above. So yes, it has no use here:</p>

<pre><code>template &lt;typename T&gt;
void foo(const T&amp; x)
{
    // if this was called as foo(1), we're none the wiser
}
</code></pre>
"
"<p>The C++ program below should return a stricly positive value. However, it returns <code>0</code>.</p>

<p>What happens ? I suspect an int-double conversion, but I can't figure out why and how.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;
using namespace std;
int main()
{

    vector&lt;double&gt; coordinates;
    coordinates.push_back(0.5);
    coordinates.push_back(0.5);
    coordinates.push_back(0.5);

     cout&lt;&lt;inner_product(coordinates.begin(), coordinates.end(), coordinates.begin(), 0)&lt;&lt;endl;

    return 0;
}
</code></pre>
","87234","","<p>Because you've supplied an initial value of <code>0</code>, an <code>int</code>. Your code is internally equivalent to:</p>

<pre><code>int result = 0;

result = result + 0.5 * 0.5; // first iteration
result = result + 0.5 * 0.5; // second iteration
result = result + 0.5 * 0.5; // third iteration

return result;
</code></pre>

<p>While <code>result + 0.5 * 0.5</code> produces the correct value (<code>result</code> is promoted to <code>double</code> in this expression), when that value is assigned back into <code>result</code>, it's truncated (that expression is cast to <code>int</code>). You never get above <code>1</code>, so you see <code>0</code>.</p>

<p>Give it an initial value of <code>0.0</code> instead.</p>
"
"<p>I have a vector with type <code>const std::vector&lt;const Array*&gt; &amp;objects</code> which is passed as an argument to the method. </p>

<p>I want to const_cast but I can't do it for some reason. I have tried:</p>

<p><code>vector&lt;const Array*&gt; obj = const_cast&lt;const std::vector&lt;const Array*&gt; &gt;(objects);</code> </p>

<p>and some other ways but it keeps complaining. </p>

<p>Any ideas ?</p>
","87234","","<p>Firstly, <strong>don't</strong>. Change your function's signature to take a non-const reference, you risk UB by doing this:</p>

<pre><code>const std::vector&lt;const Array*&gt; myData = /* fill */;
yourFunction(myData); // try to modify my stuff and you get UB!
</code></pre>

<hr>

<p>Now if you are still convinced you have to, for whatever reason (like legacy API), it's done like this:</p>

<pre><code>vector&lt;const Array*&gt;&amp; obj = const_cast&lt;std::vector&lt;const Array*&gt;&amp;&gt;(objects);
</code></pre>

<p>Now <code>obj</code> and <code>objects</code> refer to the same object, but <code>obj</code> is not const-qualified. At this point, everything is well-defined; it's only modifying a const <em>object</em> that is UB, so be careful.</p>
"
"<p>I need to init socket in C++ (GNU GCC) without libraries. When I Googled it, it suggested to use WinSock Library or something like this. How to do this? Thank you for answers.</p>
","87234","","<p>You cannot. The C++ language as defined by the standard has no socket specification. To work with them, you necessarily have to use some implementation-specific libraries, like WinSock.</p>

<p>I would recommend you use Boost's ASIO library, which does all the hard and dirty work for you.</p>
"
"<p>I would like to do something like:</p>

<pre><code>class A {
  public:
    void f();
  private:
    void g() { };
};

class B {
  public:
    void f();
  private:
    void g() { };
};

template&lt;typename T&gt;
void T::f() {
    g();
}

int main() {
    A a;
    B b;
    a.f();
    b.f();
}
</code></pre>

<p>however T::f() does not compile.</p>

<p>Possible workarounds could be making f() non-member:</p>

<pre><code>template&lt;typename T&gt;
void f(T* t);
</code></pre>

<p>Or using CRTP: <a href=""http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"" rel=""nofollow"">http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern</a></p>

<p>But is there no C++ syntax to do as above?</p>

<p>EDIT: I have a big function f() whose code is shared by the 2 classes A and B. A and B have the same interface, which f() uses. However, because we are not using runtime polimorphism (i.e, virtual functions), the corpus of f() needs to be instantiated twice at compile time, once for A and once for B. Templates are made exactly for this purpose. The function f(), in my case, should be template function whose template type is the type of *this.</p>
","87234","","<p>Free function is the correct answer. You should prefer free functions over member functions anyway, for this exact reason: you extend the interface without intruding on the class.</p>

<p>In this case, a free function with an unconstrained template is a bit ugly, because you only need it to work for two cases, not all cases. You should do something like this:</p>

<pre><code>namespace detail
{
    template &lt;typename T&gt;
    void f(T* t)
    {
        // implement stuff
    }
}

void f(A* x)
{
    detail::f(x);
}

void f(B* x)
{
    detail::f(x);
}
</code></pre>

<p>Now you can restrict access to that function via overloading.</p>
"
"<p>This is a bit theoretical question, but although I have some basic understanding of the std::move Im still not certain if it provides some additional functionality to the language that theoretically couldnt be achieved with supersmart compilers. I know that code like :</p>

<pre><code>{
  std::string s1=""STL"";
  std::string s2(std::move(s1));
  std::cout &lt;&lt; s1 &lt;&lt;std::endl;
} 
</code></pre>

<p>is a new semantic behavior not just performance sugar. :D But tbh I guess nobody will use var x after doing std::move(x).
Also for movable only data (std::unique_ptr&lt;>, std::thread) couldnt compiler automatically do the move construction and clearing of the old variable if type is declared movable?
Again this would mean that more code would be generated behind programmers back(for example now you can count cpyctor and movector calls, with automagic std::moving you couldnt do that ). </p>
","87234","","<p>It depends on what you mean by ""what move does"". To satisfy your curiosity, I think what you're looking to be told about the existence of <a href=""http://en.wikipedia.org/wiki/Uniqueness_typing"" rel=""nofollow""><strong>Uniqueness Type Systems</strong></a> and <a href=""http://en.wikipedia.org/wiki/Linear_type_system"" rel=""nofollow""><strong>Linear Type Systems</strong></a>.</p>

<p>These are types systems that enforce, at compile-time (in the type system), that a value only be referenced by one location, or that no new references be made. <code>std::unique_ptr</code> is the best approximation C++ can provide, given its rather weak type system.</p>

<p>Let's say we had a new storage-class specifier called <code>uniqueref</code>. This is like <code>const</code>, and specifies that the value has a single unique reference; nobody else has the value. It would enable this:</p>

<pre><code>int main()
{
    int* uniqueref x(new int); // only x has this reference

    // unique type feature: error, would no longer be unique
    auto y = x; 

    // linear type feature: okay, x not longer usable, z is now the unique owner
    auto z = uniquemove(x);

    // linear type feature: error: x is no longer usable
    *x = 5;
}
</code></pre>

<p>(Also interesting to note the immense optimizations that can be taking, knowing a pointer value is really truly only referenced through that pointer. It's a bit like C99's <code>restrict</code> in that aspect.)</p>

<p>In terms of what you're asking, since we can now say that a type is uniquely referenced, we can guarantee that it's safe to move. That said, move operates are ultimately user-defined, and can do all sorts of weird stuff if desired, so implicitly doing this is a bad idea in current C++ anyway.</p>

<p>Everything above is obviously not formally thought-out and specified, but should give you an idea of what such a type system might look like. More generally, you probably want an <a href=""http://en.wikipedia.org/wiki/Effect_system"" rel=""nofollow""><strong>Effect Type System</strong></a>.</p>

<p>But yes, these ideas do exist and are formally researched. C++ is just too established to add them.</p>
"
"<p>I want to do some processing before calling the second constructor. For example:</p>

<pre><code>
class Foo {
    Foo(){ displayWindow(); }

    //This is possible
    Foo(int bar) : Foo() { windowSize = bar; }

    //But how do I do processing before calling the second constructor?
    Foo(int bar, int baz) {
        addLabel(baz); // prototype = void addLabel(int)
        Foo(bar);
    }
}</code></pre>

<p>How would I accomplish this (without using initialization functions)?</p>

<p>EDIT: I updated the example. It now shows that the default constructor HAS to occur last. If it doesnt, displayWindow wont take into account any of the updated variables.</p>
","87234","","<p>Like this:</p>

<pre><code>Foo(int bar, int baz) :
    Foo(initializeAnotherStaticLibrary(bar, baz) == -1 ? bar : baz)
{
}
</code></pre>

<p>(Note that delegating constructors is a feature supported only in C++11 onward.)</p>
"
"<p>I am trying to play with <code>__attribute__</code> to allow a function to be essentially compiled with different flags from the rest of the code. For example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

void MyNormalFunction();

void MyDebugabbleFunction() __attribute__((optimize(0)));

void MyNormalFunction()
{
  std::cout &lt;&lt; ""Test"" &lt;&lt; std::endl;

  std::vector&lt;int&gt; a;

  for(unsigned int i = 0; i &lt; 10; ++i)
  {
    a.push_back(i);
  }
}

void MyDebugabbleFunction()
{
  std::cout &lt;&lt; ""Test"" &lt;&lt; std::endl;

  std::vector&lt;int&gt; a;

  for(unsigned int i = 0; i &lt; 10; ++i)
  {
    a.push_back(i);
  }
}

int main()
{
  MyNormalFunction();
  MyDebugabbleFunction();
  return 0;
}
</code></pre>

<p>I am building with -g -O2, but I want to be able to sanely debug <code>MyDebugabbleFunction()</code> — so I used the <code>__attribute__((optimize(0)))</code> on its declaration. However, I can't really tell any difference when stepping through these two functions with a debugger. I would expect the ""seemingly erratic"" behavior that I usually see when trying to step through optimized code in <code>MyNormalFunction</code>, but the standard ""-g""-only debugger behavior in <code>MyDebuggableFunction</code>.</p>

<p>Is it that I have done something wrong with <code>__attribute__</code>? Or that I have used bad demo code (i.e. code that doesn't get ""optimized a lot"") inside the two functions? Or am I misinterpreting what the difference is supposed to be in the debugger?</p>

<p>I am using gcc 4.6.</p>

<hr>

<p>EDIT based on GManNickG's suggestion</p>

<p>I used this code instead, and built with -O2 -g:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int MyNormalFunction();

int MyDebugabbleFunction() __attribute__((optimize(0)));

int MyNormalFunction()
{
  int val = 0; // breakpoint here - debugger does NOT stop here
  val = 1;
  val = 2;
  return val;
} // debugger stops here instead

int MyDebugabbleFunction()
{
  int val = 0;  // breakpoint here - debugger stops here and steps through the next 3 lines as if it were built with only -g
  val = 1;
  val = 2;
  return val;
}

int main()
{
  int a = MyNormalFunction();
  std::cout &lt;&lt; a &lt;&lt; std::endl;

  int b = MyDebugabbleFunction();
  std::cout &lt;&lt; b &lt;&lt; std::endl;

  return 0;
}
</code></pre>
","87234","","<p>Try a test like this instead:</p>

<pre><code>int MyNormalFunction()
{
    int val = 0;
    val = 1;
    val = 2;

    // should optimize to return 2
    return val;
}

int MyDebuggableFunction() __attribute__((optimize(0)));
{
    int val = 0;
    val = 1;
    val = 2;

    // could optimize to return 2, but attribute blocks that
    return val;
}

int main()
{
    // we need to actually output the return values,
    // or main itself could be optimized to nothing
    std::cout &lt;&lt; MyNormalFunction() &lt;&lt; std::endl;
    std::cout &lt;&lt; MyDebuggableFunction() &lt;&lt; std::endl;
}
</code></pre>

<p>It'll make it much easier to follow.</p>

<hr>

<p>Note that you should start in <code>main</code>, when stepping through, because it most likely will be reduced to:</p>

<pre><code>int main()
{
    std::cout &lt;&lt; 2 &lt;&lt; std::endl;
    std::cout &lt;&lt; MyDebuggableFunction() &lt;&lt; std::endl;
}
</code></pre>

<p>If you're up for it, looking at the disassembly makes this task much easier.</p>
"
"<p>I don't really understand the difference between a shared_ptr and the new handle notation (^) in C++/CX. From what I've read they seem to do the same thing regarding reference counting and memory management. What am I missing? </p>

<pre><code>std::shared_ptr&lt;Type&gt;
//vs
Type^
</code></pre>
","87234","","<p>As far as I can tell, the latter lacks support for <strike>weak references and</strike> custom deallocation functions.</p>

<p>Note that the former, being more general, accepts any type (in principle), and for safety and cleanliness calls for the use of the helper function <code>make_shared</code>. The latter is supported at a language level. That means code like this is safe in C++/CX:</p>

<pre><code>some_function(ref new foo(), ref new bar());
</code></pre>

<p>While in C++, you need to do this:</p>

<pre><code>// bad: if foo is allocated but bar's allocation throws, you leak!
some_function(new foo(), new bar());

// good: both never make it anywhere but into a shared_ptr, no leaks
some_function(make_shared&lt;foo&gt;(), make_shared&lt;bar&gt;());
</code></pre>

<p>Other than that, sure, they implement the same concept. If you're in C++/CX land, use the latter syntax for simplicity and uniformity; if you're trying to stick to standard C++, or are wrapping an existing resource management scheme into a reference-counted scheme, then you'll want the former.</p>
"
"<p>I know that most aimbots work by detouring certain functions in memory in order to get access to certain structures, variables, even functions themselves. But the problem with this is there are many cheat detection methods for scanning memory and finding such software. Wouldn't it be easier to reverse engineer the packets sent by the game containing player data and modifying those before they are sent out? Or is it just easier  to reverse the cheat detection methods and nullify(?) those?</p>
","87234","","<p>One packet can do many things. You get a packet saying player was hit by an explosion. This might:</p>

<ul>
<li>Change the players health</li>
<li>Change the players position</li>
<li>Change the players velocity</li>
<li>Change the players orientation</li>
</ul>

<p>all at once. You could intercept the packet, update all these yourself by reverse engineering what each packet does and how it does it, and basically simulate your own model of the game.</p>

<p>Or you can let the game do it for you and just read the values it generates.</p>
"
"<p>I'm putting together a bitarray class for a GA thing I'm working on. I'm wondering if there's a better way to do the make my [] operator do assignments than what I came up with. Right now, I have the non-const version of the operator returning a secret 'bitsetter' class by value, which seems a bit excessive. I certainly can't return a bit by reference, but I'm wondering if there's a better (ie., more concise, efficient) way. Thanks in advance. Pardon my <code>throw 0</code>. Totally a placeholder ;)</p>

<pre><code>class bitsetter
{
public:
    short ind;
    unsigned char *l;

    bitsetter &amp; operator=(int val)
    {
        int vs = 1&lt;&lt;ind;
        if( val==0 ) {
            vs = ~vs;
            *l = *l &amp; vs;
        }
        else
        {
            *l = *l | vs;
        }
        return *this;
    }


    int value() const
    {
        return ((*l)&gt;&gt;ind)&amp;1;
    }

    friend std::ostream &amp; operator &lt;&lt; ( std::ostream &amp; out, bitsetter const &amp; b )
    {
        out &lt;&lt; b.value();
        return out;
    }

    operator int () { return value(); }
};

class bitarray
{
public:
    unsigned char *bits;
    int size;

    bitarray(size_t size)
    {
        this-&gt;size = size;
        int bsize = (size%8==0)?((size+8)&gt;&gt;3):(size&gt;&gt;3);
        bits = new unsigned char[bsize];
        for(int i=0; i&lt;size&gt;&gt;3; ++i)
            bits[i] = (unsigned char)0;        
    }

    ~bitarray()
    {
        delete [] bits;
    }

    int operator[](int ind) const
    {
        if( ind &gt;= 0 &amp;&amp; ind &lt; size )
            return (bits[ind/8] &gt;&gt; (ind%8))&amp;1;
        else
            return 0;
    }

    bitsetter operator[](int ind)
    {
        if( ind &gt;= 0 &amp;&amp; ind &lt; size )
        {
            bitsetter b;
            b.l = &amp;bits[ind/8];
            b.ind = ind%8;
            return b;
        }
        else
            throw 0;
    }
};
</code></pre>
","87234","","<p>This is the standard approach, it's called a <em>proxy</em>. Note that it's usually defined within the class itself:</p>

<pre><code>class bitfield
{
public:
    class bit
    { };
};
</code></pre>

<p>Additionally, it's kept a little more ""safe"":</p>

<pre><code>class bitfield
{
public:
    class bit
    {
    public:
        // your public stuff
    private:
        bit(short ind, unsigned char* l) :
        ind(ind), l(l)
        {}

        short ind;
        unsigned char* l;

        friend class bitfield;
    };

    bit operator[](int ind)
    {
        if (ind &gt;= 0 &amp;&amp; ind &lt; size)
        {
            return bit(&amp;bits[ind/8], ind % 8);
        }
        else
            throw std::out_of_range();
    }
};
</code></pre>

<p>So that people only get to see the public interface of bit, and cannot conjure up their own.</p>
"
"<p>On the example below, why <code>other.age</code> outputs 88 instead of 0?</p>

<pre><code>#include &lt;atlstr.h&gt;//CString for non-MFC
class A
{
public:
    A() : name(""Nobody""), age(0) {}
    ~A(){};


    A( CString name, unsigned age ) : name( name ), age( age ) {}
    A&amp; operator=( const A&amp; ref )
    {
        name = ref.name;
        age = 0;
    }

    CString name;
    unsigned int age;
};

int _tmain( int argc, _TCHAR* argv[] )
{

    A person( CString(""Michael""), 88 );
    A other = person;

    std::cout &lt;&lt; other.name &lt;&lt; std::endl &lt;&lt; other.age;
} 
</code></pre>
","87234","","<p>Because you're not using the assignment-operator, you're using copy-construction.</p>

<pre><code>A other = person;
</code></pre>

<p>is equivalent to†:</p>

<pre><code>A other(A(person));
</code></pre>

<p>and because you haven't explicitly specified your copy-constructor, the default one is used. This is a member-wise copy, leaving 88 as the value of <code>age</code>. This uses your operator:</p>

<pre><code>A other;
other = person;
</code></pre>

<hr>

<p>†Yes, that's a copy of a copy. Note that your compiler will, with optimizations turned on, turns this into:</p>

<pre><code>A other(person);
</code></pre>

<p>through copy-elison. In general, this:</p>

<pre><code>T x = y;
</code></pre>

<p>is equivalent to this:</p>

<pre><code>T x(T(y));
</code></pre>

<p>which will become this (after optimization):</p>

<pre><code>T x(y);
</code></pre>

<p>as long as <code>T</code> is copyable or moveable.</p>
"
"<p>For example:</p>

<pre><code>class Test
{
    /// This var contain Apple class
    void* something;
};
</code></pre>

<p>I know that ""something"" will be pointed to the object of Apple type. How can i force tell that to doxygen (for DOT graphs relations).</p>
","87234","","<p>Programming design aside, you can do this:</p>

<pre><code>class Test
{
    #ifdef DOXYGEN_RUNNING
        Apple* something;
    #else
        void* something;
    #endif
};
</code></pre>

<p>And then have Doxygen predefine <code>DOXYGEN_RUNNING</code>. (<a href=""http://www.doxygen.nl/preprocessing.html"" rel=""nofollow"">Manual for preprocessing</a>.)</p>

<hr>

<p>(But seriously: if it's gonna be an <code>Apple*</code> just write it that way.)</p>
"
"<p>I'm trying to store a lambda in an object system involving several layers of indirection. I'm using g++ 4.7.1.</p>

<p>Depending on how exactly I construct the (equivalent) objects, the lambda may or may not have the correct value. </p>

<p>Code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;functional&gt; // used for std::function

using namespace std; // TODO nope

typedef function&lt;int()&gt; intf;


struct SaveLambda {
    const intf func;
    SaveLambda(const intf&amp; _func) : func(_func) {}  
};


struct StoreSaved {
    const SaveLambda* child;
    StoreSaved(const SaveLambda&amp; _child) : child(&amp;_child) {
        cout &lt;&lt; ""Before returning parent: "" &lt;&lt;  child-&gt;func() &lt;&lt; endl;
    }
};


int main() {
    const int ten = 10;

    auto S = SaveLambda([ten](){return ten;});
    cout &lt;&lt; ""No indirection: "" &lt;&lt; S.func() &lt;&lt; endl &lt;&lt; endl;

    auto saved = StoreSaved(S);
    cout &lt;&lt; ""Indirection, saved: "" &lt;&lt; saved.child-&gt;func() &lt;&lt; endl &lt;&lt; endl;

    auto temps = StoreSaved ( SaveLambda([ten](){cout &lt;&lt; ""&amp;ten: ""&lt;&lt; &amp;ten &lt;&lt; endl; return ten;}) );
    cout &lt;&lt; ""***** what. *****"" &lt;&lt; endl;
    cout &lt;&lt; ""Indirection, unsaved: "" &lt;&lt; temps.child-&gt;func() &lt;&lt; endl;
    cout &lt;&lt; ""***** what. *****"" &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; ""ten still lives: "" &lt;&lt; ten &lt;&lt; endl;
}
</code></pre>

<p>Compile as <code>g++ -std=c++11 -Wall -o itest itest.cpp</code> and run: notice the one line of output with a different value.</p>

<p>What am I doing wrong? I assumed that capture-by-value would, well, capture by value. (Observe most disconcertingly that the print in StoreSaved (line 15) produces the <em>correct</em> value, unlike line 34, despite these both referring to the same object. The only difference is adding another layer of indirection.)</p>
","87234","","<p>This is wrong:</p>

<pre><code>auto temps = StoreSaved(
                /* This temporary value dies at the last semicolon! */
                SaveLambda([ten](){cout &lt;&lt; ""&amp;ten: ""&lt;&lt; &amp;ten &lt;&lt; endl; return ten;})
                );
</code></pre>

<p><code>StoreSaved</code> then has a pointer to a nonexistent object. Using it is UB.</p>
"
"<p>After upcasting a derived class's pointer, a virtual method of the derived class is still called, which seems to me wrong, as slicing should have happened.
Could you please comment what's wrong with this code?</p>

<pre><code>class Base
{
public:
    virtual void Hello() { cout &lt;&lt; ""Hello Base"" &lt;&lt; endl; }
};

class Derived: public Base
{
public:
    void Hello() { cout &lt;&lt; ""Hello Derived"" &lt;&lt; endl; }
};

int main()
{
    Derived* der = new Derived;
    Base* base = dynamic_cast&lt;Base*&gt; (der);
    if (base) base-&gt;Hello();
}
</code></pre>

<p>output: Hello Derived</p>
","87234","","<p>Slicing did not happen because you didn't work with any values of <code>Base</code>, just pointers to it.</p>

<p>This would cause slicing:</p>

<pre><code>Base base = *der;
</code></pre>

<p>But if you want to call a function and suppress dynamic dispatch, you can just do this:</p>

<pre><code>base-&gt;Base::Hello();
</code></pre>

<p>The function to call is specified statically. This works with <code>der</code> too, of course, avoiding the middle-man.</p>

<hr>

<p>Your <code>dynamic_cast</code> is not needed here. You can implicitly upcast, because this is trivially verifiable at compile-time. You can use <code>static_cast</code> to downcast, but it's up to you to make sure this is actually correct; <code>dynamic_cast</code> is just a checked version of that.</p>
"
"<p>What C and C++ standards says about whitespace character (or several characters) after backslash? Does it guarantees to join lines anyway or not?</p>

<pre><code>int main()
{
    // Comment \ 
    int foo;
}
</code></pre>

<p>MSVC and gcc works different in this case.</p>
","87234","","<p>For reference, the standard quote is (§2.2/1, abridged, emphasis mine):</p>

<blockquote>
  <h2>Phases of Translation</h2>
  
  <p>[...]<br>
  2. <strong>Each instance of a backslash character (<code>\</code>) immediately followed by a new-line character is deleted, splicing physical source lines to form logical source lines</strong>. Only the last backslash on any physical source line shall be eligible for being part of such a splice. If, as a result, a character sequence that matches the syntax of a universal-character-name is produced, the behavior is undefined. A source file that is not empty and that does not end in a new-line character, or that ends in a new-line character immediately preceded by a backslash character before any such splicing takes place, shall be processed as if an additional new-line character were appended to the file.<br>
  [...]  </p>
</blockquote>

<p>The implementation-defined part that other answers are mentioning is in the definition of ""new-line"".</p>

<p>(Note that comments are not replaced until phase 3, so that in this code:</p>

<pre><code>int main()
{
    int x = 0;

    // assuming the definition of new-line is as expected, this function
    // will return 0, not 5 (no whitespace after this backslash: ) \
    x = 5;

    return x;
}
</code></pre>

<p><code>x = 5;</code> will be appended to the end of the comment, then ultimately removed.)</p>
"
"<p>I saw the following example of enable_if for C++11:</p>

<pre><code>struct is_64_bit
{
    static const bool value = sizeof(void*) == 8;
};

enable_if&lt;is_64_bit::value, void&gt;::type
my_memcpy(void* target, const void* source, size_t n)
{
    cout &lt;&lt; ""64 bit memcpy"" &lt;&lt; endl;
}

enable_if&lt;!is_64_bit::value, void&gt;::type
my_memcpy(void* target, const void* source, size_t n)
{
    cout &lt;&lt; ""32 bit memcpy"" &lt;&lt; endl;
}
</code></pre>

<p>As I understand, depending on the system architecture, the ""my_memcpy"" function will be available either for 32 or 64 bit versions. But I'm getting the following error at compilation :</p>

<pre><code>error: ‘type’ in ‘struct std::enable_if&lt;false, void&gt;’ does not name a type
</code></pre>

<p>I'm a bit confused because I thought only the 32 version should be available (I'm using Linux Fedora 32 bits).</p>

<p>Maybe is something wrong with this example? or Am I missing something?</p>

<p>Thanks.   </p>
","87234","","<p>SFINAE is for templates. What you need is to use templates, as the other answers mentioned, or just have a compile-time branch, which IMO is the more appropriate solution (rather than introduce a needless template):</p>

<pre><code>struct is_64_bit :
    std::integral_constant&lt;bool, sizeof(void*) == 8&gt;
{};

namespace detail
{
    void my_memcpy(void* target, const void* source, std::size_t n, std::true_type)
    {
        std::cout &lt;&lt; ""64 bit memcpy"" &lt;&lt; std::endl;
    }


    void my_memcpy(void* target, const void* source, std::size_t n, std::false_type)
    {
        std::cout &lt;&lt; ""32 bit memcpy"" &lt;&lt; std::endl;
    }
}

void my_memcpy(void* target, const void* source, std::size_t n)
{
    my_memcpy(target, source, n, is_64_bit());
}
</code></pre>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/941832/is-it-safe-to-delete-a-void-pointer"">Is it safe to delete a void pointer?</a></p>
</blockquote>



<p>Say I have a <code>new</code> allocation to a class called <code>MyClass</code> and allocation is as simple as:</p>

<pre><code>MyClass *myClassPtr = new MyClass();
</code></pre>

<p>And I store reference to the list of <code>void*</code> where I simply say</p>

<pre><code>myListOfPointers.add(static_cast&lt;void*&gt;(myClassPtr)); // this has to be void*
</code></pre>

<p>And later I release memory so instead of doing:</p>

<pre><code>delete myClassPtr
</code></pre>

<p>I use:</p>

<pre><code>delete MyListOfPointer.get(0)
</code></pre>

<p>(Say myClassPtr reference is at zero-index.) Also, please note that it has to be <code>void*</code> since this list can store different types of pointers so I wouldn't know the type of pointer that I am deleting:</p>

<p><strong>So I can't do any thing like:</strong></p>

<pre><code>delete static_cast&lt;MyClass*&gt;(MyListOfPointer.get(0))
</code></pre>

<p>Is this way going to release the correct memory size? (<code>sizeof(MyClass)</code>)? </p>

<p><strong>Note:</strong><br>
I am not looking for any answer pointing to smart pointers.</p>
","87234","","<p>Deleting through a <code>void*</code> results in undefined behavior, so you are guaranteed nothing.</p>

<blockquote>
  <h3>5.3.5 Delete [expr.delete]</h3>
  
  <p>1 The delete-expression operator destroys a most derived object (1.8) or array created by a new-expression.<br>
  [...]<br>
  <strong>The operand shall have a pointer to object type, or a class type having a single non-explicit conversion function (12.3.2) to a pointer to object type</strong>. The result has type void.<sup>78</sup>  </p>
  
  <p>78) This implies that an object cannot be deleted using a pointer of type void* because void is not an object type.</p>
</blockquote>

<p>Emphasis mine.</p>

<hr>

<p>So even though you said not to say it, the answer is to create some form of smart pointer. It would need to use type-erasure to hide the type externally (allowing the heterogeneous list), but internally keep track of the type it was given and how to delete it. Something much like <code>boost::any</code>.</p>
"
"<p>I ran into this design problem. Here's the story: </p>

<p>I have a base class that defines a few methods like this:</p>

<pre><code>virtual double &amp; f(double x);
</code></pre>

<p>The base class will call one of them to ask for the reference to some data in subclass when answering some queries. The problem is, these f methods return an optional piece of data in subclass. In other words, depending on the subclass, what f is asking to return may not exist at all. The logic in the base class can guarantee that it will not call such f() on a subclass when it doesn't exist, so in principle this subclass doesn't need to implement this method, but I don't want to make the method pure virtual because the subclass needs to be instantiable regardless. Inconveniently the return type of f needs to be reference so I can't simply return some junk value.</p>

<p>So basically I'm looking for a ""elegant"" way to return a dummy reference, that will not be called anyway if the program works correctly, but ideally would help debugging by catching mistake calls. The signature of f is important for readability so ideally I don't want to change it.</p>

<p>I suppose I can declare a dummy static double DATA_NOT_EXIST variable in the class and return it, but it looks a bit ugly. Any better ideas? What's your favorite way to return a ""null"" reference when you have to?</p>

<p>Thanks in advance.</p>

<hr>

<p>Edit:</p>

<p>I want to keep these methods in base class, although they do seem better off declared in subclasses instead, because the base class is trying to handle some logic that's not applicable to all subclasses (is this itself a bad design?). Something like this: the base class represents a mouse, and the optional data in the subclasses represent left/middle/right buttons. Any particular subclass may not have certain buttons, but anyway the base class still handles button clicks, with the assumption that there may or may not be buttons.</p>

<hr>

<p>Edit:
Here's some source code to illustrate what I mean to do. In base class:</p>

<pre><code>#include &lt;cassert&gt;
struct Base
{
  double &amp; basef(int x)
  {
    assert(x &gt;= 0 &amp;&amp; x &lt; 20);
    if (x &lt; 10) return f1(x);
    else return f2(x);
  }
  virtual double &amp; f1(int x);
  virtual double &amp; f2(int x);
};

struct Sub1 : Base
{
  double &amp; f1(int x) { return a[x]; }
  double &amp; f2(int x) { return b[x - 10]; }
  double a[10];
  double b[10];
};

struct Sub2 : Base
{
  double &amp; f1(int x) { return a[x]; }
  double &amp; f2(int x) { /* nothing to return here! */ }
  double a[10];
};
</code></pre>
","87234","","<p>You have several options, none require you introduce undefined behavior into your program by dereferencing null pointers as has been suggested by two answers now.</p>

<p>1) Throw an exception. Take away the unpredictability and make it part of your design:</p>

<pre><code>// default implementation in base class
virtual double&amp; f2(int x)
{
    throw std::runtime_error(""No value defined"");
}
</code></pre>

<p>2) Use <code>boost::optional&lt;double&amp;&gt;</code>:</p>

<pre><code>// default implementation in base class
virtual boost::optional&lt;double&amp;&gt; f2(int x)
{
    return boost::optional&lt;double&amp;&gt;();
}

// call-site
auto value = x-&gt;f2(0);
if (value)
    do_something(*value);
</code></pre>

<p>3) Use <code>double*</code> (poor-man's <code>boost::optional</code>):</p>

<pre><code>// default implementation in base class
virtual double* f2(int x)
{
    return nullptr;
}

// same call-site as before
</code></pre>

<p>4) Fundamentally change the design to avoid the situation.</p>

<p>All of these are better solutions because they're reliable and predictable.</p>
"
"<p>I've been looking at some code I'm working on, and we have the equivalent of this:</p>

<pre><code>AutoPtr&lt;A&gt; x;
...
/// x gets initialized
...
B* y = new B(x.Detach());
</code></pre>

<p>Where AutoPtr is our version of auto_ptr, and Detach() returns the owned pointer and resets itself. Also, B() takes ownership of x.</p>

<p>Now, I realized that this will leak x if new throws an std::bad_alloc, so I changed the code to this:</p>

<pre><code>AutoPtr&lt;A&gt; x;
...
/// x gets initialized
...
B* y = new B(x.Get());
x.Detach();
</code></pre>

<p>But then I realized that if B() 'owns' the pointer, and an exception happens during its construction, it should take care of deleting the parameter itself (or should it?), so the x will get deleted twice, once by B(), and once by x's destructor.</p>

<p>Now, is there a C++ idiom that gets around this problem, for example, making code that calls constructors responsible for cleaning up parameters? Most code I've seen doesn't seem to do that...</p>
","87234","","<blockquote>
  <p>...it should take care of deleting the parameter itself (or should it?)</p>
</blockquote>

<p>No, it should not.</p>

<p><code>B</code> doesn't exist until the constructor completes, and if it doesn't exist it shouldn't claim ownership of anything (to a point; if the constructor itself did something, that needs to be safe as well).</p>

<p>The C++ idiom is to not use raw pointers for ownership (including for <code>y</code>)! <code>B</code> should accept the <code>AutoPtr</code> as an argument so the caller can give up ownership this way. This is the goal of <code>std::unique_ptr</code> and <code>std::move</code>:</p>

<pre><code>std::unique_ptr&lt;A&gt; x;

std::unique_ptr&lt;B&gt; y(new B(std::move(x)));
</code></pre>

<p>Also note that really <code>new</code> should not be used like this as well; instead use the <code>make_*</code> utilities:</p>

<pre><code>auto y = std::make_unique&lt;B&gt;(std::move(x));
</code></pre>

<p>But this is missing currently as oversight.</p>
"
"<p>Considering :</p>

<pre><code>double data; 
double array[10]; 
std::vector&lt;int&gt; vec(4, 100); 
MyClass myclass;   
</code></pre>

<p>Is there a difference between :</p>

<pre><code>sizeof(double);
sizeof(double[10]);
sizeof(std::vector&lt;int&gt;);
sizeof(MyClass);
</code></pre>

<p>and </p>

<pre><code>sizeof(data);
sizeof(array);
sizeof(vec);
sizeof(myclass);
</code></pre>

<p>Are the two syntaxes different or strictly equivalent ? Are all of them evaluated at compile-time ? If not, which one is evaluated at run-time ?</p>
","87234","","<p>The latter is defined in terms of the former.  Given an expression, it returns the size of the type of the expression. So <code>sizeof(vec)</code> translates to <code>sizeof(std::vector&lt;int&gt;)</code>.</p>

<p>Both are evaluated at compile-time; the only run-time <code>sizeof</code> is in C, not C++, with variable-length arrays. The operand to <code>sizeof</code> is unevaluated, so there isn't any real possibly the expression itself could generate code anyway.</p>

<p>I prefer to use expressions over types, because chances are stating the type is redundant in some fashion.</p>
"
"<p>The answer may be obvious for some of you, but as I can't find the answer, I need to ask it.
Oftenly, if a function has to return whether all was executed without problems, I use a boolean that track any failure.</p>

<pre><code>bool myFunction()
{
    bool ok = true;
    if (...) {
        if (...) {
            ok = ...;
        }
        ok = ok &amp;&amp; (...);
    }
    ok = ok &amp;&amp; (...);
    return ok;
}
</code></pre>

<p>As no <code>&amp;&amp;=</code> exists, I use a lot this syntax : <code>ok = ok &amp;&amp; (...)</code> (<code>(...)</code> can be a condition or a value). But I find this quite unelegant. Is there any C++ standard-compliant way to write this more concisely and elegantly ?</p>
","87234","","<p>Just return early, since no additional code executes if <code>ok</code> becomes <code>false</code>:</p>

<pre><code>bool myFunction()
{
    bool ok = true;
    if (...) {
        if (...) {
            if (!...) return false;
        }
        if (!...) return false;
    }

    return (...);
}
</code></pre>

<p>This is another reason why exceptions are better than error codes: if you don't handle them, you don't spaghettify code for normal code paths.</p>
"
"<p>I find myself typing</p>

<pre><code>double foo=1.0/sqrt(...);
</code></pre>

<p>a lot, and I've heard that modern processors have built-in inverse square root opcodes.</p>

<p>Is there a C or C++ standard library inverse square root function that</p>

<ol>
<li>uses double precision floating point?</li>
<li>is as accurate as <code>1.0/sqrt(...)</code>?</li>
<li>is just as fast or faster than the result of <code>1.0/sqrt(...)</code>?</li>
</ol>
","87234","","<p>If you find yourself writing the same thing over and over, you should think to yourself ""function!"":</p>

<pre><code>double invsqrt(const double x)
{
    return 1.0 / std::sqrt(x);
}
</code></pre>

<p>Now the code is more self-documenting: people don't have to <em>deduce</em> <code>1.0 / std::sqrt(x)</code> is the inverse square root, they <em>read</em> it. Additionally, you now get to plug in whatever implementation you want and each call-site automatically uses the updated definition.</p>

<p>To answer your question, no, there is no C(++) function for it, but now that you've made one if you find your performance is too lacking you can substitute your own definition.</p>
"
"<p>I want to write an x-macro that generates some code. The code depends on several headers and is intended to be generated inside namespaces. </p>

<p>The problem is that the xmacro's includes are being included inside the namespaces of the caller. Is there any way I can fix this?</p>

<p>Example:</p>

<p>xmacro.hpp:</p>

<pre><code>#include ""foo.hpp""
struct bar {
BODY
};
#undef BODY
</code></pre>

<p>main.hpp:</p>

<pre><code>namespace ns {
  #define BODY int func();
  #include ""xmacro.hpp"" // inserting foo.hpp inside namespace ns
}
</code></pre>
","87234","","<p>Unfortunately no, because X-macros, while being unique, are still ultimately just included files. This is no different from putting <code>#include &lt;iostream&gt;</code> into your own namespace.</p>

<p>X-macro includes should really not do anything but contain the target macro (which has a definition yet to be determined). If the use of your X-macro has prerequisites, I would do something like this:</p>

<p>xmacro_prelude.hpp:  </p>

<pre><code>#ifndef XMACRO_PRELUDE_INCLUDED
#define XMACRO_PRELUDE_INCLUDED

#include ""foo.hpp""

#endif
</code></pre>

<p>xmacro.hpp (usually suffixed with .def, by the way):</p>

<pre><code>#ifndef XMACRO_PRELUDE_INCLUDED
    #error ""You must include xmacro_prelude.hpp prior to using this X-macro.""
#endif

struct bar {
BODY
};

#undef BODY
</code></pre>

<p>main.hpp:</p>

<pre><code>#include ""xmacro_prelude.hpp""

namespace ns {
  #define BODY int func();
  #include ""xmacro.hpp""
}
</code></pre>
"
"<p>I came across a very strange behaviour using G++ (4.5.2) on different platforms; here's the code :</p>

<pre><code>class Class
{
private:
  std::string rString;

public:
  Class()
  {
    this-&gt;rString = ""random string"";
    std::cout &lt;&lt; ""Constructor of Class"" &lt;&lt; std::endl;
  }

  virtual ~Class()
  {
    std::cout &lt;&lt; ""Destructor of Class"" &lt;&lt; std::endl;
  }

  void          say() const
  {
    std::cout &lt;&lt; ""Just saying ..."" &lt;&lt; std::endl;
    if (this == NULL)
      std::cout &lt;&lt; ""Man that's really bad"" &lt;&lt; std::endl;
  }

  void          hello() const
  {
    std::cout &lt;&lt; ""Hello "" &lt;&lt; this-&gt;rString &lt;&lt; std::endl;
  }

};


int     main()
{
  Class *c = NULL;

  /* Dereferencing a NULL pointer results
     in a successful call to the non-static method say()
     without constructing Class */
  (*c).say(); // or c-&gt;say()

  /* Dereferencing a NULL pointer and accessing a random
     memory area results in a successful call to say()
     as well */
  c[42000].say();

  /* Dereferencing a NULL pointer and accessing a
     method which needs explicit construction of Class
     results in a Segmentation fault */
  c-&gt;hello();

  return (0);
}
</code></pre>

<p>The question is, why the two first statements in the main function don't crash the program?  Is this undefined behaviour, or the compiler is simply calling Class::say() as if it was static since it doesn't dereference ""this"" pointer inside the method?</p>
","87234","","<p>Yes, it's undefined behavior. <a href=""http://stackoverflow.com/questions/2474018/when-does-invoking-a-member-function-on-a-null-instance-result-in-undefined-beha/2474021#2474021"">You cannot call a member function with a null pointer</a>.</p>

<p>In practice, the first two indeed work because <code>this</code> is never dereferenced so your undefined behavior doesn't have to manifest like it does in the third, where memory is indeed wrongly accessed.</p>

<p>(In all cases, you die a little inside each time it's called, so don't do that.)</p>
"
"<p>I have a pointer that points to first byte of a shared memory which is 66 bytes long. I want to create another pointer that points to a certain byte in shared memory (I'm saying certain byte because I want to get this info from user as integer like:""which byte do you want to reach?""). Is there a way of reaching a certain byte via shared memory's pointer?</p>
","87234","","<p>The shared memory part is irrelevant: what you have is a pointer and you want to increment <em>n</em> bytes:</p>

<pre><code>T* p = /* pointer to whatever */;
char* nBytesIn = reinterpret_cast&lt;char*&gt;(p) + n;
</code></pre>

<p>Or in your case, more safely:</p>

<pre><code>char* byte_in_buffer(T* p, std::size_t n)
{
    if (n &gt;= 66)
        throw std::out_of_range(""Buffer is only 66 bytes!"");

    return reinterpret_cast&lt;char*&gt;(p) + n;
}
</code></pre>

<p>You need to cast to <code>char*</code> because pointer arithmetic dictates that <code>T* + n</code> increments <code>sizeof(T)</code>; we want to increment by bytes, and <code>char</code> is that type (with a size that's always 1).</p>

<p>(Aliasing a value through a <code>char*</code> is okay.)</p>
"
"<p>If I have a C++ function declaration:</p>

<pre><code>int func(const vector&lt;int&gt; a)
</code></pre>

<p>Would it always be beneficial to replace it with</p>

<pre><code>int func(const vector&lt;int&gt; &amp;a)
</code></pre>

<p>since the latter does not need to make a copy of <code>a</code> to pass into the function?</p>
","87234","","<p>In terms of efficiency like you're thinking, almost always yes. There are times where (purportedly) this may be slower, typically with types that are fundamental or small:</p>

<pre><code>// copy x? fits in register: fast
void foo(const int x);

// reference x? requires dereferencing on typical implementations: slow
void foo(const int&amp; x); 
</code></pre>

<p>But with inlining this doesn't matter anyway, plus you can just type it by-value yourself; this only matters with generic template functions.</p>

<p>However it's important to note that your transformation may not always be valid, namely because your function gets its own copy of the data. Consider this simpler example:</p>

<pre><code>void foo(const int x, int&amp; y)
{
    y += x;
    y += x;
}

int v = 1;
foo(v, v); // results in v == 3
</code></pre>

<p>Make your transformation and you get:</p>

<pre><code>void foo(const int&amp; x, int&amp; y)
{
    y += x;
    y += x;
}

int v = 1;
foo(v, v); // results in v == 4
</code></pre>

<p>Because even though you cannot write to <code>x</code>, it can be written to through other means. This is called aliasing. While probably not a concern with the example you've given (though global variables could still alias!), just be wary of the difference in principle.</p>

<p>Lastly, if you're going to make your own copy anyway, just do it in the parameter list; the compiler can optimize that for you, especially with C++11's rvalue references/move semantics.</p>
"
"<p>When functions take non-const refs as arguments, it can create hard-to-read code because at the calling site it is not obvious which inputs might be changed. This has lead some code conventions to enforce that pointers be used instead, for example</p>

<pre><code>void func(int input, int* output);

int input = 1, output = 0;
func(input, &amp;output);
</code></pre>

<p>instead of</p>

<pre><code>void func(int input, int&amp; output);

int input = 1, output = 0;
func(input, output);
</code></pre>

<p>Personally, I hate using pointers because of the need to check for null. This has lead me to wonder if boost::ref (or std::ref for C++11) can be used to signal intention, as follows:</p>

<pre><code>void func(int input, int&amp; output);

int input = 1, output = 0;
func(input, boost::ref(output));
</code></pre>

<p>This would be used as a company coding convention. <strong>My question is, are there any reasons why this would not be a good idea?</strong></p>
","87234","","<p>It's not a bad idea, but it's not really enforced (as PiotrNycz notes). It's effectively just a comment.</p>

<p>We can do better though:</p>

<pre><code>template &lt;typename T&gt;
class output_argument
{
public:
    template &lt;typename U&gt;
    friend output_argument&lt;U&gt; out(U&amp; ref);

    T&amp; get() const
    {
        return mRef;
    }

    operator T&amp;() const
    {
        return get();
    }

private:
    explicit output_argument(T&amp; ref) :
    mRef(ref)
    {}

    output_argument&amp; operator=(const output_argument&amp;); // not defined

    T&amp; mRef;
};

template &lt;typename U&gt;
output_argument&lt;U&gt; out(U&amp; ref)
{
    return output_argument&lt;U&gt;(ref);
}
</code></pre>

<p>Giving:</p>

<pre><code>void foo(int x, output_argument&lt;float&gt; f)
{
    int i = static_cast&lt;int&gt;(f);

    f.get() = static_cast&lt;float&gt;(i + x);
}

int main()
{
    float f = 5.0f;

    //fails: foo(1, f);
    foo(1, out(f));
}
</code></pre>

<p>But generally these kinds of utilities are not necessary, because the function name should convey what's happening to the arguments: <code>swap(x, y)</code> quite clearly modifies the arguments! And returning values should be done with a return type, further limiting the cases this utility can be used.</p>
"
"<p>(If you're a C++11 pro, skip to the bold paragraph.)</p>

<p>Let's say I want to write a template method which calls and returns the result of a passed object which type is the template parameter:</p>

<pre><code>template&lt;ReturnType, T&gt;
ReturnType doSomething(const T &amp; foo) {
    return foo.bar(); // EDIT: Might also be an expression introducing a temp val
}
</code></pre>

<p>So <code>T</code> has to have a method <code>ReturnType T::bar() const</code> in order to be used in a call like this:</p>

<pre><code>struct MyClass {
    ...
    int bar() const;
    ...
};
...
MyClass object;
int x = doSomething&lt;int, MyClass&gt;(object);
</code></pre>

<p>We don't have to write <code>MyClass</code> thanks to type deduction and the call becomes:</p>

<pre><code>int x = doSomething&lt;int&gt;(object);
</code></pre>

<p>But omitting <code>&lt;int&gt;</code> too results in a compilation error because the method doesn't require to return int in order to be assigned to <code>x</code> afterwards (it could return <code>char</code> for example).</p>

<p>In C++0x/11 we have the <code>auto</code> and <code>decltype</code> with which we can use to deduce the return type of a template method:</p>

<pre><code>template&lt;T&gt;
auto doSomething(const T &amp; foo) -&gt; decltype(foo.bar()) {
    return foo.bar(); // EDIT: Might also be an expression introducing a temp val
}
</code></pre>

<p>The compiler will now find out what the type of <code>foo.bar()</code> is and just uses this as the return type. With our concrete class <code>MyClass</code> this will be an <code>int</code> and the following would suffice:</p>

<pre><code>int x = doSomething(object);
</code></pre>

<p><strong>Now to my question:</strong></p>

<p>If MyClass defines <code>bar()</code> as returning an <code>int&amp;</code>, the return type of <code>doSomething(object)</code> will also be an <code>int&amp;</code> = <code>decltype(foo.bar())</code>. This is a problem, since as G++ now complies that I'm <em>returning reference to temporary</em>.</p>

<p>How can I fix this? Is there something like <code>remove_reference</code> which can be used like <code>remove_reference(decltype(foo.bar()))</code>?</p>

<p>I thought about just declaring a helper method which takes a <code>T&amp;</code> and returns a <code>T</code> and then define the return type of <code>doSomething</code> to be <code>decltype(helper(foo.bar()))</code>. But there has to be a better way, I'm feeling it.</p>
","87234","","<p>To remove a reference:</p>

<pre><code>#include &lt;type_traits&gt;

static_assert(std::is_same&lt;int, std::remove_reference&lt;int&amp;&gt;::type&gt;::value, ""wat"");
</code></pre>

<p>In your case:</p>

<pre><code>template &lt;typename T&gt;
auto doSomething(const T&amp; foo)
    -&gt; typename std::remove_reference&lt;decltype(foo.bar())&gt;::type
{
    return foo.bar();
}
</code></pre>

<hr>

<p>Just to be clear, note that as written returning a reference is just fine:</p>

<pre><code>#include &lt;type_traits&gt;

struct f
{
    int&amp; bar() const
    {
        static int i = 0;
        return i;
    } 
};

template &lt;typename T&gt;
auto doSomething(const T&amp; foo)
    -&gt; decltype(foo.bar())
{ 
    return foo.bar();
}

int main()
{
    f x;
    return doSomething(x);
}
</code></pre>

<p>The returned reference can simply be passed on without error. Your example in the comment is where it becomes important and useful:</p>

<pre><code>template &lt;typename T&gt;
auto doSomething(const T&amp; foo)
    -&gt; decltype(foo.bar())
{ 
    return foo.bar() + 1; // oops
}
</code></pre>
"
"<pre><code>#include &lt;iostream&gt;
int foo()
{
  return 0;
}

int main()
{
  const int&amp; a = foo();
  std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;
}
</code></pre>

<p>In this code, <code>a</code> binds to a rvalue. Is it legal to take its address? (And by legal I mean: in the code ill-formed? Am I causing an undefined behaviour?)</p>
","87234","","<p>This is fine. In C++11 you can even do this:</p>

<pre><code>int&amp;&amp; a = foo();
a = 123;
</code></pre>

<hr>

<p>You can kind of think about temporaries like this (conceptually and in general):</p>

<pre><code>x = func(); // translated as:

auto __temporary = func();
x = __temporary;
__destruct_value_now_and_not_later(__temporary);
</code></pre>

<p>Except if <code>x</code> is the definition of a reference type, the compiler notes that you're purposefully referring to the temporary value and extends its lifetime by removing the early destruction code, making it a normal variable.</p>
"
"<p>I'm writing a simple macro to show TRACE information.</p>

<p>This is what I'm using ,</p>

<pre><code>#ifdef __DEBUG__
#define TRACE  { PrintErrorMsg(""Trace exception at "" __FILE__  ""LineNo:""##(__LINE__) ""Function: "" __FUNCTION__ "" "" );}
#else 
#define TRACE 
#endif
</code></pre>

<p>This is working with <strong>FILE</strong>, but it doesn't seems to work with <strong>LINE</strong> , 
Any idea how could I deal with this. I already tried stringing operator too.Which is as
bellow.</p>

<pre><code>#ifdef __DEBUG__
#define TRACE  { PrintErrorMsg(""Trace exception at "" __FILE__  ""LineNo:""#(__LINE__) ""Function: "" __FUNCTION__ "" "" );}
#else 
#define TRACE 
#endif
</code></pre>

<p>and without parms and with double parms , ex - <code>__LINE__</code> or <code>((__LINE__))</code>
Any idea how could I deal with this problem?</p>

<p>And I come up with this,</p>

<pre><code>#ifdef __DEBUG__
#define ERROR_MSG_BUF_SIZE 1024
#define TRACE  { char * error_msg_buffer = new char[ERROR_MSG_BUF_SIZE]; \
                 sprintf(error_msg_buffer,""Trace Exception at file: %s ,Line : %d , Function %s \n"",__FILE__,__LINE__,__FUNCTION__);\
PrintErrorMsg(error_msg_buffer );\
delete[] error_msg_buffer;}
#else 
#define TRACE 
</code></pre>

<p>But I want to do it without using sprintf , just only by stringing and token pasting.
Any idea?</p>

<pre><code>#endif
</code></pre>

<p>--Thanks in advance--</p>
","87234","","<p>When you try to stringize something with <code>#x</code>, that <code>x</code> must be a macro parameter:</p>

<pre><code>#define FOO #__LINE__ /* this is not okay */
#define BAR(x) #x     /* this is okay */
</code></pre>

<p>But you cannot simply say <code>BAR(__LINE__)</code>, because this will pass the token <code>__LINE__</code> into <code>BAR</code>, where it is immediately turned into a string without expansion (this is by design), giving <code>""__LINE__""</code>. The same thing happens with the token-pasting operator <code>##</code>: expansion of their operands never happens.</p>

<p>The solution is to add indirection. You should always have these in your codebase somewhere:</p>

<pre><code>#define STRINGIZE(x) STRINGIZE_SIMPLE(x)
#define STRINGIZE_SIMPLE(x) #x

#define CONCAT(first, second) CONCAT_SIMPLE(first, second)
#define CONCAT_SIMPLE(first, second) first ## second
</code></pre>

<p>Now <code>STRINGIZE(__LINE__)</code> turns to <code>STRINGIZE_SIMPLE(__LINE__)</code> which gets fully expanded to (for example) <code>#123</code>, which results in ""123"". Phew! I leave <code>STRINGIZE_SIMPLE</code> around on the off chance I want the original behavior. So your code would be something like:</p>

<pre><code>#include &lt;iostream&gt;

#define STRINGIZE(x) STRINGIZE_SIMPLE(x)
#define STRINGIZE_SIMPLE(x) #x

#define TRACE()                                                 \
        PrintErrorMsg(""Trace exception in "" __FILE__            \
                      "" at line number "" STRINGIZE(__LINE__)    \
                      "" in function "" __FUNCTION__ ""."")

void PrintErrorMsg(const char* str)
{
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}

int main()
{
    TRACE();
}
</code></pre>
"
"<p>Code:</p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#define PI 3.14159

using namespace std;

int main(int argc, char** argv) {    
    cout&lt;&lt;""Address of PI:""&lt;&lt;&amp;PI&lt;&lt;endl;    
    return 0;
}
</code></pre>

<p>Here is the output:</p>

<p>main.cpp: In function <code>int main(int, char**)':
main.cpp:20: error: non-lvalue in unary</code>&amp;'
make[2]: <strong>* [build/Debug/Cygwin-Windows/main.o] Error 1
make[1]: <em></strong> [.build-conf] Error 2
make: *</em>* [.build-impl] Error 2</p>

<p>So why can't I see the memory address of PI here? </p>

<p>Thank you.</p>
","87234","","<p>You cannot take the address of a numeric literal. You could for a  variable, though:</p>

<pre><code>// #define PI 3.14159
static const double PI = 3.14159;
</code></pre>
"
"<p>I have a base class with a static pointer member. When I assign that static pointer member in a derived class, that static member appears NULL when referenced from the methods of the base class.</p>

<p>This is not the behavior I expect. Shouldn't the static pointer member still be assigned regardless of where it is accessed from? Am I wrong about the expected behavior?</p>

<p>The static member is a pointer to a base class. I realize that what I am trying to achieve is probably best accomplished by static polymorphism using templates ( <a href=""http://stackoverflow.com/questions/4557141/static-polymorphism-definition-and-implementation"">Static polymorphism definition and implementation</a> ) but I still do not understand why in this scenario the pointer member itself is NULL.</p>

<p>Edit: the behavior is NOT demonstrated in this SSCE. What bugs or common errors would cause the behavior I describe? My actual production scenario is significantly more complicated than this, but the structure is almost exactly the same. I am literally in the VS2010 debugger observing <code>Base::staticMember == not null</code>, then call to <code>Base::staticMethod()</code>, and inside <code>Base::staticMethod()</code>, <code>Base::staticMember</code> is null. I am baffled.</p>

<pre><code>#include &lt;iostream&gt;

class Base {
public:
    static Base *staticMember;

    static void baseMethod();
};

Base *Base::staticMember = NULL;

class Derived : public Base {
public:
    void derivedMethod();
};

void Base::baseMethod() {
    // here staticMember == NULL, the unexpected behavior
    if(staticMember == NULL) {
        std::cout &lt;&lt; ""NULL"";
    } else {
        std::cout &lt;&lt; ""NOT NULL"";
    }
};

void Derived::derivedMethod() {
    staticMember = new Derived();
}

int main(int argc, void *argv[]) {
    Derived *derived = new Derived();
    derived-&gt;derivedMethod();
    Base::baseMethod();
}
</code></pre>
","87234","","<p>No repro on a fixed up and simplified version of your code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

struct Base {
    static Base* staticMember;

    static void baseMethod();
};

Base* Base::staticMember;

void Base::baseMethod() {
    std::cout &lt;&lt; std::boolalpha &lt;&lt; (staticMember == nullptr) &lt;&lt; std::endl;
}

struct Derived : Base {
    void derivedMethod();
};

void Derived::derivedMethod() {
    staticMember = this;
}

int main() {
    Derived derived;
    derived.derivedMethod();

    Base::baseMethod();
}
</code></pre>

<p>Prints ""false"".</p>

<p><strong>Always give a <a href=""http://www.sscce.org/"" rel=""nofollow"">Short, Self Contained, Correct (Compilable), Example</a>, or your question is meaningless.</strong></p>
"
"<pre><code>struct vec3{
vec3(){x=y=z=0.0f;};
float x,y,z;
};

vec3 array[10];
char buffer[100];
memcpy(buffer, array, sizeof(array));
memcpy(array, buffer, sizeof(array));
</code></pre>

<p><strong>struct Vec3</strong> is not Plain Old Datatype (<strong>POD</strong> type).
Is it this code correct and/or is it exist some garantees about memory layout in C++2003?</p>
","87234","","<p>Not in C++03, but in C++11 this is fine.</p>

<p>They introduced a concept called <em>standard-layout</em>, which is really what POD should have been. I won't go into the standardese, but the new category is the recognition that your class is really just a POD with a new way of initializing it; the layout is still the same, hence the name ""standard layout"".</p>

<p>So most (all?) of those things that used to be POD only are now standard-layout only, so you're good to go.</p>

<p>In practice this works fine in C++03 compilers; you can view this as them supporting C++11 in some way.</p>
"
"<p>For example, <code>std::vector&lt;int&gt;::iterator it = --(myVec.end());</code>. This works in GCC 4.4 but I have heard a rumor that it's not portable. </p>
","87234","","<p>No that won't work in general.</p>

<p>In C++11 we have: <code>auto it = std::prev(myVec.end());</code>, which works reliably.</p>

<p>Boost has a similar function if you're in C++03, though it's trivial to write altogether:</p>

<pre><code>template &lt;typename BidirectionalIterator&gt;
BidirectionalIterator
    prev(BidirectionalIterator x,
         typename std::iterator_traits&lt;BidirectionalIterator&gt;::difference_type n = 1)
{
    std::advance(x, -n);
    return x;
}
</code></pre>

<p>Keep in mind you need at least one element in the range for this to make sense.</p>

<hr>

<p>Here's an example of how your method won't work in general, consider this stripped-down <code>std::vector&lt;&gt;</code>:</p>

<pre><code>#include &lt;iterator&gt;

namespace std_exposition
{
    template &lt;typename T&gt;
    struct vector
    {
        // this is compliant:
        typedef T* iterator;

        iterator end()
        {
            return std::end(data);
        }

        T data[4];
    };

    // manually implemented std::prev:
    template &lt;typename BidirectionalIterator&gt;
    BidirectionalIterator
        prev(BidirectionalIterator x,
             typename std::iterator_traits&lt;BidirectionalIterator&gt;::difference_type n = 1)
    {
        std::advance(x, -n);
        return x;
    }
}
</code></pre>

<p>Test program:</p>

<pre><code>int main()
{
    std_exposition::vector&lt;int&gt; myVec;

    // Won't compile (method in question):
    auto it0 = --(myVec.end());

    // Compiles
    auto it1 = std::prev(myVec.end());
    auto it2 = std_exposition::prev(myVec.end());
}
</code></pre>

<hr>

<p>There is a corresponding <code>std::next</code> as well, implemented here:</p>

<pre><code>template &lt;typename BidirectionalIterator&gt;
BidirectionalIterator
    next(BidirectionalIterator x,
         typename std::iterator_traits&lt;BidirectionalIterator&gt;::difference_type n = 1)
{
    std::advance(x, n);
    return x;
}
</code></pre>
"
"<p>In the Boost 1.5.1 source under <code>smart_ptr\detail\atomic_count_win32.hpp</code> is a neat little atomic reference counter <code>boost::detail::atomic_count</code>.</p>

<p>on line 48, they do a cast I'm curious about:</p>

<pre><code>class atomic_count
{
public:

// ...

operator long() const
{
    return static_cast&lt;long const volatile &amp;&gt;( value_ );
}

private:
long value_;
</code></pre>

<p>Why is the counter value cast to a-reference-to-a-volatile-constant-long (<code>long const volatile&amp;</code>)? </p>
","87234","","<p>MSVC provides a now-deprecated <a href=""http://msdn.microsoft.com/en-US/library/12a04hfd%28v=vs.110%29.aspx"" rel=""nofollow""><em>extension</em> on <code>volatile</code> variables</a>, giving them acquire and release semantics (memory ordering guarantees, with respect to multithreaded programming.)</p>

<p>This cast ""enables"" this extension on the variable, giving it read-acquire semantics (to match any release-writes that may also occur). Again, this is, <em>non-standard</em>. In C++11 code you should use <code>std::atomic&lt;&gt;</code>.</p>

<p>They need this because <code>boost::shared_ptr</code> gives guarantees of correctness for <code>shared_ptr&lt;T&gt;</code> in multithreaded (shared) use; this is their implementation of a <a href=""http://preshing.com/20120612/an-introduction-to-lock-free-programming"" rel=""nofollow"">lock-free</a> counter.</p>

<p>(Also, this is only half the story: while this extension may provide the needed ordering and visibility guarantees, it does not guarantee atomicity. On Win32 this is guaranteed implicitly by the platforms it runs on: aligned word-sized integer reads and writes are atomic per the platform.)</p>

<p>To nip it in the bud before it starts: without this extension <code>volatile</code> is not useful for multithreaded programming. Don't even try. This extension is deprecated, so you should really avoid it if you can.</p>
"
"<p>I came across a programming question of which I knew only a part of the answer. </p>

<pre><code>int f( char *p )
{
int n = 0 ;
while ( *p != 0 )
n = 10*n + *p++ - '0' ;
return n ;
}
</code></pre>

<p>This is what I think the program is doing.
p is a pointer and the while loop is DE-refrencing the values of the pointer until it equals 0. However I don't understand the n assignment line, what is '0' doing? I am assuming the value of p is initially negative, that is the only way it will reach 0 after the increment.</p>
","87234","","<p>It's poorly written, to say the least.</p>

<p>0) Use formatting!:</p>

<pre><code>int f(char* p)
{
    int n = 0;

    while (*p != 0)
        n = 10*n + *p++ - ‘0?;

    return n;
}
</code></pre>

<p>1) <code>?</code> there is syntactically invalid. It should probably be a <code>'</code> as noted by chris (and your existing <code>‘</code> is wrong too, but that's probably because you copied it from a website and not a source file), giving:</p>

<pre><code>int f(char* p)
{
    int n = 0;

    while (*p != 0)
        n = 10 * n + *p++ - '0';

    return n;
}
</code></pre>

<p>2) The parameter type isn't as contrained as it should be. Because <code>*p</code> is never modified (per our goals), we should enforce that to make sure we don't make any mistakes:</p>

<pre><code>int f(const char* p)
{
    int n = 0;

    while (*p != 0)
        n = 10 * n + *p++ - '0';

    return n;
}
</code></pre>

<p>3) The original programmer was obviously allergic to readable code. Let's split up our operations:</p>

<pre><code>int f(const char* p)
{
    int n = 0;

    for (; *p != 0; ++p)
    {
        const int digit = *p - '0';
        n = 10 * n + digit;
    }

    return n;
}
</code></pre>

<p>4) Now that the operations are a bit more visible, we can see some <em>independent</em> functionality embedded in this function; this should be factored out (this is called reactoring) into a separate function.</p>

<p>Namely, we see the operation of <a href=""http://stackoverflow.com/a/13694902/87234"">converting a character to a digit</a>:</p>

<pre><code>int todigit(const char c)
{
    // this works because the literals '0', '1', '2', etc. are
    // all guaranteed to be in order. Ergo '0' - '0' will be 0,
    // '1' - '0' will be 1, '2' - '0' will be 2, and so on.

    return c - '0';
}

int f(const char* p)
{
    int n = 0;

    for (; *p != 0; ++p)
        n = 10 * n + todigit(*p);

    return n;
}
</code></pre>

<p>5) So now it's clear the function reads a string character by character and generates a number digit by digit. This functionality already <a href=""http://stackoverflow.com/a/13694854/87234"">exists under the name <code>atoi</code>, and this function is an unsafe implementation</a>:</p>

<pre><code>int todigit(const char c)
{
    // this works because the literals '0', '1', '2', etc. are
    // all guaranteed to be in order. Ergo '0' - '0' will be 0,
    // '1' - '0' will be 1, '2' - '0' will be 2, and so on.

    return c - '0';
}

int atoi_unsafe(const char* p)
{
    int n = 0;

    for (; *p != 0; ++p)
        n = 10 * n + todigit(*p);

    return n;
}
</code></pre>

<p>It's left as an exercise to the read to check for overflow, invalid characters (those that aren't digits), and so on. But this should make it much clearer what's going on, and is how such a function should have been written in the first place.</p>
"
"<p>When I try to explain some simple code to my friends,something strange happens:</p>

<pre><code>#include &lt;stdio.h&gt;
int main() 
{
    int x;
    printf(""%x\n"",x);
}
</code></pre>

<p>I have tryed millions of times ,and the last 12 bits of x always turns out to be 0xff0.
I've disass the code,but still can't figure out what's going on here</p>

<p>My operating system is ubuntu10.10 ,compiler is gcc4.7.2</p>
","87234","","<p>Reading an uninitialized variable is undefined behavior. So you are guaranteed nothing.</p>

<p>This includes always being zero, always being even, always being different, and reformatting your hard drive.</p>
"
"<p>For containers such as <code>std::map&lt; std::string, std::unique_ptr&lt; Foo &gt;&gt;</code>, it looks like <code>emplace()</code> has yet to be implemented in stdc++ as of gcc 4.7.2.</p>

<p>Unfortunately, I can't store Foo directly by value as it is an abstract super-class. </p>

<p>As a simple, but inefficient, place-holder, I've just been using <code>std::map&lt; std::string, Foo* &gt;</code> in conjunction with a <code>std::vector&lt; std::unique_ptr&lt; Foo &gt;&gt;</code> for garbage collection.</p>

<p><em>Do you have a interim solution that is more efficient and more easily replaced once emplace() is available?</em></p>
","87234","","<p>What do you need <code>emplace()</code> for? Just move it in:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

struct Foo
{
    virtual ~Foo() = default;

    virtual std::string name() const = 0;
};

struct Bar : Foo
{
    std::string name() const { return ""Bar""; }
};

int main()
{
    std::map&lt;std::string, std::unique_ptr&lt;Foo&gt;&gt; m;

    std::unique_ptr&lt;Foo&gt; p(new Bar());
    m.insert(std::make_pair(""a"", std::move(p)));

    std::cout &lt;&lt; m[""a""]-&gt;name() &lt;&lt; std::endl;
}
</code></pre>

<p>In fact, <strong><a href=""http://stackoverflow.com/q/13172888/87234"">you should not use <code>emplace</code> with <code>unique_ptr</code>'s</a></strong>.</p>

<p>As noted in my comment there, I now consider the use of <code>new</code> in user code an error. It should be replaced with <code>make_unique</code>, so you know your resource cannot possibly leak:</p>

<pre><code>// will be in std:: someday
template &lt;typename T, typename... Args&gt;
std::unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args)
{
    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));
}

int main()
{
    std::map&lt;std::string, std::unique_ptr&lt;Foo&gt;&gt; m;

    m.insert(std::make_pair(""a"", make_unique&lt;Bar&gt;()));

    std::cout &lt;&lt; m[""a""]-&gt;name() &lt;&lt; std::endl;
}
</code></pre>
"
"<p>I have a following struct:</p>

<pre><code>struct Data
{
    std::string firstMember;
    std::string secondMember;
    std::string thirdMember;
};
</code></pre>

<p>I want to select one of the members by string name in <code>constexpr</code> manner, like</p>

<pre><code>Data instance;
auto&amp; member = getMember(instance, ""firstMember""); 
</code></pre>

<p>getMember is <code>constexpr</code> function/struct/macros/whatever in question and expression should be (I want it to be) optimized into simple <code>auto&amp; member = instance.firstMember;</code>. My desire here is to be able to call <code>getMember</code> from another <code>constexpr</code> function, which in turn are computing name of particular member --> some kind of compile time reflection.</p>

<p>I know, there is no reflection in C++, therefore it's OK to register somehow (partially specialize? use some macros magic?) names of members of struct in question, like:</p>

<pre><code>REGISTER_MEMBER(Data, ""firstMember"", firstMember);
</code></pre>

<p>All I want is to have that compile time optimization and do nothing in runtime. Is that possible in C++11 and how?</p>
","87234","","<p>As noted in the comments, first take a look at <code>BOOST_FUSION_ADAPT_STRUCT</code> (and friends):</p>

<pre><code>#include &lt;boost/fusion/include/adapt_struct.hpp&gt;
#include &lt;string&gt;

struct Data
{
    std::string firstMember;
    std::string secondMember;
    std::string thirdMember;
};

BOOST_FUSION_ADAPT_STRUCT(
    Data,
    (std::string, firstMember)
    (std::string, secondMember)
    (std::string, thirdMember)
    )
</code></pre>

<p>This turns your <code>Data</code> structure into a sequence usable by Fusion:</p>

<pre><code>#include &lt;boost/fusion/include/at_c.hpp&gt;

int main()
{
    Data d = { ""firstData"", ""secondData"", ""thirdData"" };

    std::cout &lt;&lt; boost::fusion::at_c&lt;0&gt;(d) &lt;&lt; std::endl;
}
</code></pre>

<p>This prints <code>""firstData""</code>. Change the index to refer to the members in order.</p>

<p>There, now we can refer to members at compile-time using a number. But you wanted a name. Also noted in the comments, processing strings is a runtime feature...almost. C++11 gives us <code>constexpr</code>.</p>

<p>It's a bit tricky, but ultimately it looks like this:</p>

<pre><code>#include &lt;boost/fusion/include/adapt_struct.hpp&gt;
#include &lt;boost/preprocessor/cat.hpp&gt;
#include &lt;boost/preprocessor/repetition/repeat.hpp&gt;
#include &lt;boost/preprocessor/seq.hpp&gt;
#include &lt;boost/preprocessor/tuple/elem.hpp&gt;
#include &lt;stdexcept&gt;

// and repeat for BOOST_FUSION_ADAPT_TPL_STRUCT, etc...
#define REFLECT_STRUCT(NAME, ATTRIBUTES)                                                \
        REFLECT_STRUCT_DETAIL(NAME,                                                     \
                              ATTRIBUTES,                                               \
                              BOOST_PP_SEQ_POP_FRONT(                                   \
                                BOOST_PP_CAT(                                           \
                                    /* warning: uses fusion implementation details: */  \
                                    BOOST_FUSION_ADAPT_STRUCT_FILLER_0(0,0)ATTRIBUTES,  \
                                    _END)))                                             \

#define REFLECT_STRUCT_DETAIL(NAME, ATTRIBUTES, WRAPPEDATTRIBUTES)                  \
        BOOST_FUSION_ADAPT_STRUCT(NAME, ATTRIBUTES)                                 \
                                                                                    \
        namespace detail                                                            \
        {                                                                           \
            namespace BOOST_PP_CAT(reflect_, NAME)                                  \
            {                                                                       \
                template &lt;int N&gt;                                                    \
                struct member_name;                                                 \
                                                                                    \
                BOOST_PP_SEQ_FOR_EACH_I(REFLECT_STRUCT_DETAIL_MEMBER_NAME,          \
                                        BOOST_PP_EMPTY,                             \
                                        WRAPPEDATTRIBUTES)                          \
                                                                                    \
                template &lt;int N&gt;                                                    \
                constexpr bool member_match_index(const std::size_t index,          \
                                                  const char* const str,            \
                                                  const std::size_t len)            \
                {                                                                   \
                    return index == len ||                                          \
                           (member_name&lt;N&gt;::value()[index] == str[index]            \
                            &amp;&amp; member_match_index&lt;N&gt;(index + 1, str, len));         \
                }                                                                   \
                                                                                    \
                template &lt;int N&gt;                                                    \
                constexpr bool member_match(const char* const str,                  \
                                            const std::size_t len)                  \
                {                                                                   \
                    return len == member_name&lt;N&gt;::value_length                      \
                           &amp;&amp; member_match_index&lt;N&gt;(0, str, len);                   \
                }                                                                   \
                                                                                    \
                constexpr int find_member(const char* const str,                    \
                                          const std::size_t len)                    \
                {                                                                   \
                    return BOOST_PP_REPEAT(BOOST_PP_SEQ_SIZE(WRAPPEDATTRIBUTES),    \
                                           REFLECT_STRUCT_DETAIL_MEMBER_NAME_TEST,  \
                                           BOOST_PP_EMPTY)                          \
                           throw std::runtime_error(""could not find ""               \
                                                    BOOST_PP_STRINGIZE(NAME)        \
                                                    "" member"");                     \
                }                                                                   \
            }                                                                       \
        }                                                                           \
                                                                                    \
        constexpr int BOOST_PP_CAT(indexof_, NAME)(const char* const str,           \
                                                   const std::size_t len)           \
        {                                                                           \
            return detail::BOOST_PP_CAT(reflect_, NAME)::find_member(str, len);     \
        }                                                                           \
                                                                                    \
        template &lt;std::size_t N&gt;                                                    \
        constexpr int BOOST_PP_CAT(indexof_, NAME)(const char (&amp;str)[N])            \
        {                                                                           \
            return detail::BOOST_PP_CAT(reflect_, NAME)::find_member(&amp;str[0], N);   \
        }

#define REFLECT_STRUCT_DETAIL_EXTRACT_NAME(pair) \
        BOOST_PP_STRINGIZE(BOOST_PP_TUPLE_ELEM(1, pair))

#define REFLECT_STRUCT_DETAIL_MEMBER_NAME(r, data, n, elem) \
        REFLECT_STRUCT_DETAIL_MEMBER_NAME_DETAIL(n, REFLECT_STRUCT_DETAIL_EXTRACT_NAME(elem))

#define REFLECT_STRUCT_DETAIL_MEMBER_NAME_DETAIL(n, name)               \
        template &lt;&gt;                                                     \
        struct member_name&lt;n&gt;                                           \
        {                                                               \
            static constexpr std::size_t value_length = sizeof(name);   \
            typedef const char value_type[value_length];                \
                                                                        \
            static constexpr const value_type&amp; value()                  \
            {                                                           \
                return name;                                            \
            }                                                           \
        };

#define REFLECT_STRUCT_DETAIL_MEMBER_NAME_TEST(z, n, text) \
        member_match&lt;n&gt;(str, len) ? n :
</code></pre>

<p>It looks scary but its readable if you take the time to pick it apart.</p>

<p>We have to introduce our own macros to give constant-expression access to the member names; most of the ugly comes from processing Boost.Preprocessor lists. Although Fusion does record the names during adaptation as well (see <code>boost::fusion::extension::struct_member_name</code>), they are not marked as <code>constexpr</code> so aren't usable to us, unfortunately.</p>

<p>This gives:</p>

<pre><code>#include &lt;boost/fusion/include/at_c.hpp&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

struct Data
{
    std::string firstMember;
    std::string secondMember;
    std::string thirdMember;
};

REFLECT_STRUCT(
    Data,
    (std::string, firstMember)
    (std::string, secondMember)
    (std::string, thirdMember)
    )

// your desired code:
// (note the use of at_c ensures this is evaluated at comple-time)
#define GETMEMBER(data, member) boost::fusion::at_c&lt;indexof_Data(member)&gt;(data)

int main()
{
    Data d = { ""firstData"", ""secondData"", ""thirdData"" };

    std::cout &lt;&lt; boost::fusion::at_c&lt;indexof_Data(""firstMember"")&gt;(d) &lt;&lt; std::endl;
    std::cout &lt;&lt; GETMEMBER(d, ""secondMember"") &lt;&lt; std::endl;
    std::cout &lt;&lt; GETMEMBER(d, ""thirdMember"") &lt;&lt; std::endl;
    /* causes error: std::cout &lt;&lt; GETMEMBER(d, ""nonexistent_member"") &lt;&lt; std::endl; */
}
</code></pre>

<p>Which I think is close to what you were after.</p>

<p>But keep in mind this may not all be necessary: Boost.Fusion may already have what you need. It lives in the area between pure compile-time stuff (Boost.MPL) and regular run-time stuff; adapt your struct and you can already do things like iterate over it (<code>boost::fusion::for_each</code>).</p>
"
"<p>Consider the following code:</p>

<pre><code>unordered_set&lt;T&gt; S = ...;

for (const auto&amp; x : S)
   if (...)
       S.insert(...);
</code></pre>

<p>This is broken correct?  If we insert something into S then the iterators may be invalidated (due to a rehash), which will break the range-for because under the hood it is using S.begin ... S.end.</p>

<p>Is there some pattern to deal with this?</p>

<p>One way is:</p>

<pre><code>unordered_set&lt;T&gt; S = ...;

vector&lt;T&gt; S2;

for (const auto&amp; x : S)
   if (...)
       S2.emplace_back(...);

for (auto&amp; x : S2)
    S.insert(move(x));
</code></pre>

<p>This seems clunky.  Is there a better way I'm missing?</p>

<p>(Specifically if I was using a hand-rolled hash table and I could block it from rehashing until the end of the loop, it would be safe to use the first version.)</p>

<p><strong>Update:</strong></p>

<p>From <a href=""http://en.cppreference.com/w/cpp/container/unordered_map/insert"">http://en.cppreference.com/w/cpp/container/unordered_map/insert</a></p>

<blockquote>
  <p>If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is higher than <code>max_load_factor() * bucket_count()</code>.</p>
</blockquote>

<p>Could you mess with <code>max_load_factor</code> somehow to prevent rehashing?</p>
","87234","","<blockquote>
  <p>Could you mess with max_load_factor somehow to prevent rehashing?</p>
</blockquote>

<p>Yes, you can set the <code>max_load_factor()</code> to infinity to ensure no rehashing occurs:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;unordered_set&gt;

int main()
{
    // initialize
    std::unordered_set&lt;int&gt; S;

    for (int i = 0; i &lt; 8; ++i)
        S.insert(i);

    std::cout &lt;&lt; ""buckets: "" &lt;&lt; S.bucket_count() &lt;&lt; std::endl;

    // infinite max load factor =&gt; never need to rehash
    const auto oldLoadFactor = S.max_load_factor();
    S.max_load_factor(std::numeric_limits&lt;float&gt;::infinity());

    for (const auto&amp; x : S)
    {
        if (x &gt; 2)
            S.insert(x * 2);
    }

    // restore load factor, verify same bucket count
    S.max_load_factor(oldLoadFactor);
    std::cout &lt;&lt; ""buckets: "" &lt;&lt; S.bucket_count() &lt;&lt; std::endl;

    // now force rehash
    S.rehash(0);
    std::cout &lt;&lt; ""buckets: "" &lt;&lt; S.bucket_count() &lt;&lt; std::endl;
}
</code></pre>

<p>Note that simply setting a new load factor does no rehashing, so those are cheap operations.</p>

<p>The <code>rehash(0)</code> bit works because it's a request that: 1) I get at least <em>n</em> buckets, and 2) I have enough buckets to satisfy my <code>max_load_factor()</code>. We just use zero to indicate we don't care for a minimum amount, we just want to rehash to satisfy our ""new"" factor, as if it was never changed to infinity.</p>

<p>Of course, this isn't exception-safe; if anything throws between the calls to <code>max_load_factor()</code>, our old factor is lost forever. Easily fixed with your favorite scope-guard utility or a utility class.</p>

<p><strong>Note that you get no guarantees if you'll iterate over the new elements.</strong> You will iterate over the existing elements, but you may or may not iterate over the new elements. If that is okay (which per our chat it should be), then this will work.</p>

<p>For example, consider you iterate over an unordered set of integer and for each even integer <code>x</code>, insert <code>x * 2</code>. If those always get inserted just after your currrent position (by chance of implementation-detail and container state), you will never terminate the loop except through exceptions.</p>

<p>If you do need some guarantees, you need to with an alternate storage solution.</p>
"
"<p>I searched and I'm surprised this hasn't been asked yet. I know how to do it with a simple loop, how about with vector iterators?</p>

<pre><code>for( std::vector&lt;int&gt;::iterator it = somevector.begin(); it != somevector.end(); ++it )
{
    //Conditions stating a certain vector has an even or odd index.
}
</code></pre>

<p>Sorry for not clarifying, I meant detecting whether the index of a vector is odd or even.</p>
","87234","","<p>I'm going to guess you meant you wanted to detect if the current index is even or odd:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; somevector;
    somevector.push_back(1);
    somevector.push_back(2);
    somevector.push_back(4);
    somevector.push_back(8);
    somevector.push_back(111605);

    for (auto it = somevector.begin(); it != somevector.end(); ++it)
    {
        // current index
        const auto index = std::distance(somevector.begin(), it);

        if ((index % 2) == 0) // even
        {
            std::cout &lt;&lt; ""Index "" &lt;&lt; index &lt;&lt; "" (even) is: "" &lt;&lt; *it;
        }
        else
        {
            std::cout &lt;&lt; ""Index "" &lt;&lt; index &lt;&lt; "" (odd) is: "" &lt;&lt; *it;
        }

        std::cout &lt;&lt; std::endl;
    }
}
</code></pre>

<p>You can get the distance between iterators with <code>std::distance</code>. (Index being distance from the start.)</p>
"
"<p>The answers to the question on <a href=""http://stackoverflow.com/q/14056000/1120273"">how to avoid undefined execution order for the constructors when using std::make_tuple</a> to a discussion during which I learned that the order of argument evaluation can be guaranteed for constructors: Using a <em>braced-init-list</em> the order is guaranteed to be left to right:</p>

<pre><code>T{ a, b, c }
</code></pre>

<p>The expressions <code>a</code>, <code>b</code>, and <code>c</code> are evaluated in the given order. This is the case, even if the type <code>T</code> just has a normal constructor defined.</p>

<p>Clearly, not everything called is a constructor and sometimes it would be nice to guarantee the order of evaluation when calling a function but there is no such thing as <em>brace-argument-list</em> to call function with a defined order of evaluation of their arguments. The question becomes: Can the guarantees to constructors be used to build a function call facility (""<code>function_apply()</code>"") with an ordering guarantee for the evaluation of arguments? It is acceptable to require a function object being called.</p>
","87234","","<p>First, I think if the order does matter it's probably best to explicitly construct those elements prior to the call, then pass them in. Much easier to read, but far less fun!</p>

<p>This is just expanding on Kerrek's answer:</p>

<pre><code>#include &lt;utility&gt;

namespace detail
{
    // the ultimate end result of the call;
    // replaceable with std::result_of? I do not know.
    template &lt;typename F, typename... Args&gt;
    static auto ordered_call_result(F&amp;&amp; f, Args&amp;&amp;... args)
        -&gt; decltype(std::forward&lt;F&gt;(f)
                    (std::forward&lt;Args&gt;(args)...)); // not defined

    template &lt;typename R&gt;
    class ordered_call_helper
    {
    public:
        template &lt;typename F, typename... Args&gt;
        ordered_call_helper(F&amp;&amp; f, Args&amp;&amp;... args) :
        mResult(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...))
        {}

        operator R()
        {
            return std::move(mResult);
        }

    private:
        R mResult;
    };

    template &lt;&gt;
    class ordered_call_helper&lt;void&gt;
    {
    public:
        template &lt;typename F, typename... Args&gt;
        ordered_call_helper(F&amp;&amp; f, Args&amp;&amp;... args)
        {
            std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...);
        }
    };

    // perform the call then coax out the result member via static_cast,
    // which also works nicely when the result type is void (doing nothing)
    #define ORDERED_CALL_DETAIL(r, f, ...) \
            static_cast&lt;r&gt;(detail::ordered_call_helper&lt;r&gt;{f, __VA_ARGS__})
};

// small level of indirection because we specify the result type twice
#define ORDERED_CALL(f, ...) \
        ORDERED_CALL_DETAIL(decltype(detail::ordered_call_result(f, __VA_ARGS__)), \
                            f, __VA_ARGS__)
</code></pre>

<p>And an example:</p>

<pre><code>#include &lt;iostream&gt;

int add(int x, int y, int z)
{
    return x + y + z;
}

void print(int x, int y, int z)
{
    std::cout &lt;&lt; ""x: "" &lt;&lt; x &lt;&lt; "" y: "" &lt;&lt; y &lt;&lt; "" z: "" &lt;&lt; z &lt;&lt; std::endl;
}

int get_x() { std::cout &lt;&lt; ""[x]""; return 11; }
int get_y() { std::cout &lt;&lt; ""[y]""; return 16; }
int get_z() { std::cout &lt;&lt; ""[z]""; return 12; }

int main()
{
    print(get_x(), get_y(), get_z());
    std::cout &lt;&lt; ""sum: "" &lt;&lt; add(get_x(), get_y(), get_z()) &lt;&lt; std::endl;

    std::cout &lt;&lt; std::endl;   

    ORDERED_CALL(print, get_x(), get_y(), get_z());
    std::cout &lt;&lt; ""sum: "" &lt;&lt; ORDERED_CALL(add, get_x(), get_y(), get_z()) &lt;&lt; std::endl;

    std::cout &lt;&lt; std::endl;

    int verify[] = { get_x(), get_y(), get_z() };
}
</code></pre>

<p>That last line is there to verify brace initializers do in fact have effect, normally.</p>

<p>Unfortunately as has been discovered from other answers/comments, GCC does not get it right so I cannot test my answer. Additionally, MSVC Nov2012CTP also does not get it right (and has a nasty bug that chokes on the <code>ordered_call_result</code>†). If someone wants to test this with clang, that would be swell.</p>

<p>†For this particular example, the trailing return type can be <code>decltype(f(0, 0, 0))</code> instead.</p>
"
"<p>After watching Herb Sutter's talk <a href=""http://isocpp.org/blog/2012/12/you-dont-know-const-and-mutable-herb-sutter"">You Don't Know const and mutable</a>, I wonder whether I should always define a mutex as mutable? If yes, I guess the same holds for any synchronized container (e.g., <code>tbb::concurrent_queue</code>)?</p>

<p>Some background: In his talk, he stated that const == mutable == thread-safe, and <code>std::mutex</code> is per definition thread-safe.</p>

<p>There is also related question about the talk, <a href=""http://stackoverflow.com/questions/14127379/does-const-mean-thread-safe-in-c11"">Does const mean thread-safe in C++11</a>.</p>

<p>Edit:</p>

<p><a href=""http://stackoverflow.com/questions/4127333/should-mutexes-be-mutable?rq=1"">Here</a>, I found a related question (possibly a duplicate). It was asked before C++11, though. Maybe that makes a difference.</p>
","87234","","<p>No. However, most of the time they will be.</p>

<p>While it's helpful to think of <code>const</code> as ""thread-safe"" and <code>mutable</code> as ""(already) thread-safe"", <code>const</code> is still fundamentally tied to the notion of promising ""I won't change this value"". It always will be.</p>

<p>I have a long-ish train of thought so bear with me.</p>

<p>In my own programming, I put <code>const</code> everywhere. If I have a value, it's a bad thing to change it unless I say I want to. If you try to purposefully modify a const-object, you get a compile-time error (easy to fix and no shippable result!). If you accidentally modify a non-const object, you get a runtime programming error, a bug in a compiled application, and a headache. So it's better to err on the former side and keep things <code>const</code>.</p>

<p>For example: </p>

<pre><code>bool is_even(const unsigned x)
{
    return (x % 2) == 0;
}

bool is_prime(const unsigned x)
{
    return /* left as an exercise for the reader */;
} 

template &lt;typename Iterator&gt;
void print_special_numbers(const Iterator first, const Iterator last)
{
    for (auto iter = first; iter != last; ++iter)
    {
        const auto&amp; x = *iter;
        const bool isEven = is_even(x);
        const bool isPrime = is_prime(x);

        if (isEven &amp;&amp; isPrime)
            std::cout &lt;&lt; ""Special number! "" &lt;&lt; x &lt;&lt; std::endl;
    }
}
</code></pre>

<p>Why are the parameter types for <code>is_even</code> and <code>is_prime</code> marked <code>const</code>? Because from an implementation point of view, changing the number I'm testing would be an error! Why <code>const auto&amp; x</code>? Because I don't intend on changing that value, and I want the compiler to yell at me if I do. Same with <code>isEven</code> and <code>isPrime</code>: the result of this test should not change, so enforce it.</p>

<p>Of course <code>const</code> member functions are merely a way to give <code>this</code> a type of the form <code>const T*</code>. It says ""it would be an error in implementation if I were to change some of my members"".  </p>

<p><code>mutable</code> says ""except me"". This is where the ""old"" notion of ""logically const"" comes from. Consider the common use-case he gave: a mutex member. You <em>need</em> to lock this mutex to ensure your program is correct, so you need to modify it. You don't want the function to be non-const, though, because it would be an error to modify any other member. So you make it <code>const</code> and mark the mutex as <code>mutable</code>.</p>

<p><em>None of this has to do with thread-safety.</em></p>

<p>I think it's one step too far to say the new definitions replace the old ideas given above; they merely compliment it from another view, that of thread-safety. </p>

<p>Now the point of view Herb gives that if you have <code>const</code> functions, they need to be thread-safe to be safely usable by the standard library. As a corollary of this, the only members you should really mark as <code>mutable</code> are those that are already thread-safe, because they are modifiable from a <code>const</code> function:</p>

<pre><code>struct foo
{
    void act() const
    {
        mNotThreadSafe = ""oh crap! const meant I would be thread-safe!"";
    }

    mutable std::string mNotThreadSafe;
};
</code></pre>

<p>Okay, so we know that thread-safe things <em>can</em> be marked as <code>mutable</code>, you ask: should they be?</p>

<p>I think we have to consider both view simultaneously. From Herb's new point of view, yes. They are thread safe so do not need to be bound by the const-ness of the function. But just because they <em>can</em> safely be excused from the constraints of <code>const</code> doesn't mean they have to be. I still need to consider: would it be an error in implementation if I did modify that member? If so, it needs to not be <code>mutable</code>!</p>

<p>There's a granularity issue here: some functions may need to modify the would-be <code>mutable</code> member while others don't. This is like wanting only some functions to have friend-like access, but we can only friend the entire class. (It's a language design issue.)</p>

<p>In this case, you should err on the side of <code>mutable</code>.</p>

<p>Herb spoke just slightly too loosely when he gave a <code>const_cast</code> example an declared it safe. Consider:</p>

<pre><code>struct foo
{
    void act() const
    {
        const_cast&lt;unsigned&amp;&gt;(counter)++;
    }

    unsigned counter;
};
</code></pre>

<p>This is safe under most circumstances, except when the <code>foo</code> object itself is <code>const</code>:</p>

<pre><code>foo x;
x.act(); // okay

const foo y;
y.act(); // UB!
</code></pre>

<p>This is covered elsewhere on SO, but <code>const foo</code>, implies the <code>counter</code> member is also <code>const</code>, and modifying a <code>const</code> object is undefined behavior.</p>

<p>This is why you should err on the side of <code>mutable</code>: <code>const_cast</code> does not quite give you the same guarantees. Had <code>counter</code> been marked <code>mutable</code>, it wouldn't have been a <code>const</code> object.</p>

<p>Okay, so if we need it <code>mutable</code> in one spot we need it everywhere, and we just need to be careful in the cases where we don't. Surely this means all thread-safe members should be marked <code>mutable</code> then?</p>

<p>Well no, because not all thread-safe members are there for internal synchronization. The most trivial example is some sort of wrapper class (not always best practice but they exist):</p>

<pre><code>struct threadsafe_container_wrapper
{
    void missing_function_I_really_want()
    {
        container.do_this();
        container.do_that();
    }

    const_container_view other_missing_function_I_really_want() const
    {
        return container.const_view();
    }

    threadsafe_container container;
};
</code></pre>

<p>Here we are wrapping <code>threadsafe_container</code> and providing another member function we want (would be better as a free function in practice). No need for <code>mutable</code> here, the correctness from the old point of view utterly trumps: in one function I'm modifying the container <em>and that's okay because I didn't say I wouldn't</em> (omitting <code>const</code>), and in the other I'm not modifying the container <em>and ensure I'm keeping that promise</em> (omitting <code>mutable</code>).</p>

<p>I think Herb is arguing the most cases where we'd use <code>mutable</code> we're also using some sort of internal (thread-safe) synchronization object, and I agree. Ergo his point of view works most of the time. But there exist cases where I simply <em>happen</em> to have a thread-safe object and merely treat it as yet another member; in this case we fall back on the old and fundamental use of <code>const</code>.</p>
"
"<p>Is it possible to construct the class below using macros?</p>

<pre><code>struct ModelName
{
public:
    typedef std::string type;

    static type get( const GameObject* obj )
    {
        return obj-&gt;getAttribute&lt; type &gt;( MODEL_NAME );
    }
};
</code></pre>

<p>In other words, I would like to generate the above code at compile time given the three parameters: <code>ModelName</code>, <code>MODEL_NAME</code>, and <code>std::string</code>. Is that possible?</p>

<p>EDIT: After typing it out, I realized I can achieve what I want using templates. For some reason I thought it wouldn't work. Thanks!</p>
","87234","","<p>Sure:</p>

<pre><code>#define DEFINE_ATTRIBUTE(classname, attributeName, attributeType)   \
        struct classname                                            \
        {                                                           \
            typedef attributeType type;                             \
                                                                    \
            static type get(const GameObject* const obj)            \
            {                                                       \
                return obj-&gt;getAttribute&lt;type&gt;(attributeName);      \
            }                                                       \
        }
</code></pre>

<p>(The missing semicolon is normal; it forces/allows the use of a semicolon after the macro.)</p>

<p>You may consider redesigning this as a template, if possible.</p>
"
"<p>Is it possible to <em>portably</em> hash a pointer in C++03, which does not have <code>std::hash</code> defined?</p>

<p>It seems really weird for hashables containing pointers to be impossible in C++, but I can't think of any way of making them.</p>

<p>The closest way I can think of is doing <code>reinterpret_cast&lt;uintptr_t&gt;(ptr)</code>, but <code>uintptr_t</code> is not required to be defined in C++03, and I'm not sure if the value could be legally manipulated even if it <em>was</em> defined... is this even possible?</p>
","87234","","<p>No, <em>in general</em>. In fact it's not even possible in general in C++11 without <code>std::hash</code>.</p>

<p>The reason why lies in the difference between <em>values</em> and <em>value representations</em>.</p>

<p>You may recall the very common example used to demonstrate the different between a value and its representation: the <em>null pointer value</em>. Many people mistakenly assume that the representation for this value is all bits zero. This is not guaranteed in any fashion. You are guaranteed behavior by its value only.</p>

<p>For another example, consider:</p>

<pre><code>int i;
int* x = &amp;i;
int* y = &amp;i;

x == y;  // this is true; the two pointer values are equal
</code></pre>

<p>Underneath that, though, the value representation for <code>x</code> and <code>y</code> <em>could</em> be different!</p>

<p>Let's play compiler. We'll implement the value representation for pointers. Let's say we need (for hypothetical architecture reasons) the pointers to be at least two bytes, but only one is used for the value.</p>

<p>I'll just jump ahead and say it could be something like this:</p>

<pre><code>struct __pointer_impl
{
    std::uint8_t byte1; // contains the address we're holding
    std::uint8_t byte2; // needed for architecture reasons, unused
    // (assume no padding; we are the compiler, after all)
};
</code></pre>

<p>Okay, this is our value representation, now lets implement the value semantics. First, equality:</p>

<pre><code>bool operator==(const __pointer_impl&amp; first, const __pointer_impl&amp; second)
{
    return first.byte1 == second.byte1;
}
</code></pre>

<p>Because the pointer's value is really only contained in the first byte (even though its representation has two bytes), that's all we have to compare. The second byte is irrelevant, <em>even if they differ</em>.</p>

<p>We need the address-of operator implementation, of course:</p>

<pre><code>__pointer_impl address_of(int&amp; i)
{
    __pointer_impl result;

    result.byte1 = /* hypothetical architecture magic */;

    return result;
}
</code></pre>

<p>This particular implementation overload gets us a pointer value representation for a given <code>int</code>. Note that the second byte is left uninitialized! That's okay: it's not important for the <em>value</em>.</p>

<p>This is really all we need to drive the point home. Pretend the rest of the implementation is done. :)</p>

<p>So now consider our first example again, ""compiler-ized"":</p>

<pre><code>int i;

/* int* x = &amp;i; */
__pointer_impl x = __address_of(i);

/* int* y = &amp;i; */
__pointer_impl y = __address_of(i);

x == y;  // this is true; the two pointer values are equal
</code></pre>

<p>For our tiny example on the hypothetical architecture, this sufficiently provides the guarantees required by the standard for pointer values. But note you are never guaranteed that <code>x == y</code> implies <code>memcmp(&amp;x, &amp;y, sizeof(__pointer_impl)) == 0</code>. There simply aren't requirements on the value representation to do so.</p>

<p>Now consider your question: how do we hash pointers? That is, we want to implement:</p>

<pre><code>template &lt;typename T&gt;
struct myhash;

template &lt;typename T&gt;
struct myhash&lt;T*&gt; :
    std::unary_function&lt;T*, std::size_t&gt;
{
    std::size_t operator()(T* const ptr) const
    {
        return /* ??? */;
    }
};
</code></pre>

<p>The most important requirement is that if <code>x == y</code>, then <code>myhash()(x) == myhash()(y)</code>. We also already know how to hash integers. What can we do?</p>

<p>The <em>only</em> thing we can do is try to is somehow convert the pointer to an integer. Well, C++11 gives us <code>std::uintptr_t</code>, so we can do this, right?</p>

<pre><code>return myhash&lt;std::uintptr_t&gt;()(reinterpret_cast&lt;std::uintptr_t&gt;(ptr));
</code></pre>

<p>Perhaps surprisingly, this is not correct. To understand why, imagine again we're implementing it:</p>

<pre><code>// okay because we assumed no padding:
typedef std::uint16_t __uintptr_t; // will be used for std::uintptr_t implementation

__uintptr_t __to_integer(const __pointer_impl&amp; ptr)
{
    __uintptr_t result;
    std::memcpy(&amp;result, &amp;ptr, sizeof(__uintptr_t));

    return result;
}

__pointer_impl __from_integer(const __uintptr_t&amp; ptrint)
{
    __pointer_impl result;
    std::memcpy(&amp;result, &amp;ptrint, sizeof(__pointer_impl));

    return result;
}
</code></pre>

<p>So when we <code>reinterpret_cast</code> a pointer to integer, we'll use <code>__to_integer</code>, and going back we'll use <code>__from_integer</code>. Note that the resulting integer will have a value depending upon the bits in the value representation of pointers. That is, two equal pointer values could end up with different integer representations...and this is allowed!</p>

<p>This is allowed because the result of <code>reinterpret_cast</code> is totally implementation-defined; you're only guaranteed the resulting of the opposite <code>reinterpret_cast</code> gives you back  the same result.</p>

<p>So there's the first issue: on <em>this</em> implementation, our hash could end up different for equal pointer values.</p>

<p>This idea is out. Maybe we can reach into the representation itself and hash the bytes together. But this obviously ends up with the same issue, which is what the comments on your question are alluding to. Those pesky unused representation bits are always in the way, and there's no way to figure out where they are so we can ignore them.</p>

<p>We're stuck! It's just not possible. <em>In general.</em></p>

<p>Remember, in practice we compile for certain implementations, and because the results of these operations are implementation-defined they <em>are</em> reliable if you take care to only use them properly. This is what <a href=""http://stackoverflow.com/a/14167738/87234"">Mats Petersson is saying</a>: find out the guarantees of the implementation and you'll be fine.</p>

<p>In fact, most consumer platforms you use will handle the <code>std::uintptr_t</code> attempt just fine. If it's not available on your system, or if you want an alternative approach, just combine the hashes of the individual bytes in the pointer. All this requires to work is that the unused representation bits always take on the same value. In fact, this is the approach MSVC2012 uses!</p>

<p>Had our hypothetical pointer implementation simply always initialized <code>byte2</code> to a constant, it would work there as well. But there just isn't any requirement for implementations to do so.</p>

<p>Hope this clarifies a few things.</p>
"
"<p>C++11 introduced strongly typed enums, with the syntax <code>enum class</code>. These are not compatible with integer types and require explicit casts to obtain their numeric value. C++11 also introduces the ability to specify the storage class for weakly typed enums with the form <code>enum name : type {}</code>. This is fine up to here.</p>

<p>But it looks like even if an weakly typed enum has a given storage class, the type of its items is still <code>int</code>. I tried with Visual Studio 2012, November CTP release. Consider the following code:</p>

<pre><code>enum charEnum : char { A = 'A' };
enum longEnum : long long { Tera = 1000000000000 };

void fct(char val) {}
void fct(int val) {}
void fct(long long val) {}

int main() 
{
    static_assert(sizeof(A) == sizeof(char), ""check charEnum size"");
    static_assert(sizeof(Tera) == sizeof(long long), ""check longEnum size"");
    fct('A');  // calls fct(char)
    fct(1);    // calls fct(int)
    fct(2ll);  // calls fct(long long)
    fct(A);    // calls fct(int) !
    fct(Tera); // calls fct(int), with truncation !
    fct((long long)Tera);  // calls fct(long long)
    return 0;
}
</code></pre>

<p>The overloaded function called for an enumeration value is always <code>fct(int)</code>, even if this results in a truncation of the value. Of course, with an explicit cast, we can call the overloaded function, but this was also possible in traditional C++03 syntax.</p>

<p>Am I missing something obvious? Why is that? Is there a better workaround than an explicit cast?</p>
","87234","","<p>It's a compiler bug. According to §7.2/9 and §4.5/4:</p>

<blockquote>
  <p>§7.2/9:<br>
  The value of an enumerator or an object of an unscoped enumeration type is converted to an integer by integral promotion (4.5)  </p>
  
  <p>§4.5/4:<br>
  A prvalue of an unscoped enumeration type whose underlying type is ﬁxed (7.2) can be converted to a prvalue of its underlying type. Moreover, if integral promotion can be applied to its underlying type, a prvalue of an unscoped enumeration type whose underlying type is ﬁxed can also be converted to a prvalue of the promoted underlying type. </p>
</blockquote>

<p>The last one should convert to <code>long long</code>, not <code>int</code>. <a href=""http://stackoverflow.com/questions/14206403/why-does-a-value-of-an-enum-with-a-fixed-underlying-type-of-char-resolve-to-fct"">The <code>char</code> case is a point of contention</a>. (!)</p>

<hr>

<p>Test program:</p>

<pre><code>#include &lt;iostream&gt;

enum charEnum : char      { A = 'A' };
enum longEnum : long long { Tera = 1000000000000 };

void fct(char val)      { std::cout &lt;&lt; ""fct(char)""      &lt;&lt; std::endl; }
void fct(int val)       { std::cout &lt;&lt; ""fct(int)""       &lt;&lt; std::endl; }
void fct(long long val) { std::cout &lt;&lt; ""fct(long long)"" &lt;&lt; std::endl; }

int main() 
{
    static_assert(sizeof(A)    == sizeof(char),      ""check charEnum size"");
    static_assert(sizeof(Tera) == sizeof(long long), ""check longEnum size"");

    fct('A');
    fct(1);
    fct(2ll);
    fct(A);
    fct(Tera);
    fct((long long)Tera);
}
</code></pre>

<p>MSVC2012NovCTP output:</p>

<blockquote>
  <p>fct(char)<br>
  fct(int)<br>
  fct(long long)<br>
  fct(int)<br>
  fct(int)<br>
  fct(long long)  </p>
</blockquote>

<p>g++ 4.7.1:</p>

<blockquote>
  <p>fct(char)<br>
  fct(int)<br>
  fct(long long)<br>
  fct(int)<br>
  fct(long long)<br>
  fct(long long)  </p>
</blockquote>
"
"<p>Is there a way to implement timeout in the std::async method, so I want this call to timeout and complete if the thread hasnt completed for the specified amount of time. How can I implement this functionality.</p>
","87234","","<p>There is no (standard) way to reach into a thread and kill it, and this is generally a bad idea anyway. The much cleaner option is to pass a starting time and max duration to the function and then (possibly multiple times as the calculation progresses) check if the current time minus the starting time is too long.</p>

<p>I would make something like this:</p>

<pre><code>#include &lt;chrono&gt;

template &lt;typename Clock = std::chrono::steady_clock&gt;
class timeout
{
public:
    typedef Clock clock_type;
    typedef typename clock_type::time_point time_point;
    typedef typename clock_type::duration duration;

    explicit timeout(duration maxDuration) :
    mStartTime(clock_type::now()),
    mMaxDuration(maxDuration)
    {}

    time_point start_time() const
    {
        return mStartTime;
    }

    duration max_duration() const
    {
        return mMaxDuration;
    }

    bool is_expired() const
    {
        const auto endTime = clock_type::now();

        return (endTime - start_time()) &gt; max_duration();
    }

    static timeout infinity()
    {
        return timeout(duration::max());
    }

private:
    time_point mStartTime;
    duration mMaxDuration;
};
</code></pre>

<p>This simple utility tracks the starting time and a max duration (and provides a way of specifying infinity), and allows the user to query simple facts, most importantly whether or not a timeout has occurred.</p>

<p>Test below; you can add fake delay by defining/undefining <code>FAKE_DELAY</code>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;future&gt;

#define FAKE_DELAY

void fake_delay()
{
    #ifdef FAKE_DELAY
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    #endif
}

void short_running_function(timeout&lt;&gt; timelimit)
{
    fake_delay();

    if (timelimit.is_expired())
        std::cout &lt;&lt; ""short running thread ran out of time"" &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; ""short running function finished"" &lt;&lt; std::endl;
}

void long_running_function(timeout&lt;&gt; timelimit)
{
    for (unsigned i = 0; i &lt; 10; ++i) {
        if (timelimit.is_expired())
        {
            std::cout &lt;&lt; ""long running thread ran out of time"" &lt;&lt; std::endl;
            return;
        }

        std::cout &lt;&lt; ""long running thread doing work"" &lt;&lt; std::endl;
        fake_delay();
    }

    std::cout &lt;&lt; ""long running function finished"" &lt;&lt; std::endl;
}

int main()
{
    std::async(short_running_function,
               timeout&lt;&gt;(std::chrono::milliseconds(500))).wait();

    std::async(short_running_function,
               timeout&lt;&gt;(std::chrono::milliseconds(5000))).wait();

    std::async(long_running_function,
               timeout&lt;&gt;(std::chrono::milliseconds(500))).wait();

    std::async(long_running_function,
               timeout&lt;&gt;(std::chrono::milliseconds(5000))).wait();

    std::async(long_running_function,
               timeout&lt;&gt;::infinity()).wait();
}
</code></pre>

<p>One possible output with <code>FAKE_DELAY</code> <strong>off</strong>:</p>

<blockquote>
  <p>short running function finished<br>
  short running function finished<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running function finished<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running function finished<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running function finished  </p>
</blockquote>

<p>One possible output with <code>FAKE_DELAY</code> <strong>on</strong>:</p>

<blockquote>
  <p>short running thread ran out of time<br>
  short running function finished<br>
  long running thread doing work<br>
  long running thread ran out of time<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread ran out of time<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running thread doing work<br>
  long running function finished  </p>
</blockquote>
"
"<p>After watching <a href=""http://channel9.msdn.com/posts/C-and-Beyond-2012-Herb-Sutter-You-dont-know-blank-and-blank"" rel=""nofollow"">You don't know const and mutable</a> I am kind of puzzled how to handle <code>mutable</code> properly in future.
While I think the case of <code>const</code> is pretty much safe, since one would assume physical read-only by default (minus the old <em>logic</em> exception), properly handling <code>mutable</code> puzzles me.
For example with the new threadsafe-condition the following seems wrong:</p>

<pre><code>int main() {
    int n;
    [=]() mutable {n = 10;}();
    return n;
}
</code></pre>

<p>I would assume, that in this case, <code>n</code> would have to be wrapped into a <code>std::atomic</code> or the copy of <code>n</code> be protected by concurrent writes in another way!?</p>
","87234","","<p>It may be clearer to you if we wrote the lambda out explicitly:</p>

<pre><code>struct mylambda
{
    mylambda(int n) : n(n) {}

    void operator()() /* const &lt;- lambda specified as mutable, operator not const */
    {
        n = 10;
    }

private:
    int n;
};

int main() {
    int n = 0;
    mylambda(n)();
    return n;
}
</code></pre>

<p>(Side note: you actually have undefined behavior in your example because when your lambda copies <code>n</code>, it's reading from an uninitialized variable. I've initialized it here to fix that small error.)</p>

<p>As you can see, you have no mutable members so nothing needs to be changed to be thread-safe (according to the talk). Just a regular member variable that can change through a <em>non-const</em> member function; non-const member functions are not assumed to be thread-safe.</p>

<p>I don't know if you can mark the lambda member as <code>mutable</code>; if you could, you could be in a position where thread safety is a concern (coupled with a const function call operator). But I don't think it's possible.</p>
"
"<p>My understanding is that when an asynchronous operation throws an exception, it will be propagated back to a thread that calls <code>std::future::get()</code>.  However, when such a thread calls <code>std::future::wait()</code>, the exception is not immediately propagated - it'll be thrown upon a subsequent call to <code>std::future::get()</code>.  </p>

<p>However, In such a scenario, what is supposed to happen to such an exception if the future object goes out of scope after a call to <code>std::future::wait()</code>, but prior to a call to <code>std::future::get()</code>?  </p>

<p>For those interested, here is a simple example.  In this case, the exception is silently handled by the thread/future package:</p>

<pre><code>#include ""stdafx.h""
#include &lt;thread&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;

int32_t DoWork( int32_t i )
{
    std::cout &lt;&lt; ""i ==  "" &lt;&lt; i &lt;&lt; std::endl;
    throw std::runtime_error( ""DoWork test exception"" );
    return 0;
}

int _tmain(int argc, _TCHAR* argv[])
{
    auto f = std::async( DoWork, 5 );
    try
    {
        //f.get();     // 1 - Exception does propagate.
        f.wait();      // 2 - Exception does NOT propagate.
    }
    catch( std::exception&amp; e )
    {
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        return -1;
    }
    return 0;
}
</code></pre>
","87234","","<p>It is ignored and discarded, just like if you <code>wait()</code> for a value but never <code>get()</code> it.</p>

<p><code>wait()</code> simply says ""block until the future is ready"", be that ready with a value or exception. It's up to the caller to actually <code>get()</code> the value (or exception). Usually you'll just use <code>get()</code>, which waits anyway.</p>
"
"<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""http://stackoverflow.com/questions/10828294/c-and-c-partial-initialization-of-automatic-structure"">C and C++ : Partial initialization of automatic structure</a>  </p>
</blockquote>



<p>For a long time I have been using</p>

<pre><code>char array[100] = {0};
</code></pre>

<p>to initialize all the elements of the array to 0.
However, I recently stumbled on a compiler (Code Composer Studio by Texas Instruments) where this didn't work. The statement had the effect of initializing only the first element to 0.</p>

<p>Could this behavior be a C vs C++ difference, a compiler difference, or is this a bug in the implementation?</p>
","87234","","<p>It's just a bug. In both C and C++, <code>array</code> should be filled with zeroes.</p>

<hr>

<p>Since this is a small answer, might as well go overboard:</p>

<p>C++11 §8.5.1/7:</p>

<blockquote>
  <p>If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from an empty initializer list (8.5.4). [Example:<br>
      <code>struct S { int a; const char* b; int c; };</code><br>
      <code>S ss = { 1, ""asdf"" };</code><br>
  initializes <code>ss.a</code> with <code>1</code>, <code>ss.b</code> with <code>""asdf""</code>, and <code>ss.c</code> with the value of an expression of the form <code>int()</code>, that is, <code>0</code>. —end example ] </p>
</blockquote>

<p>C99 §6.7.8/21 (sorry, don't have C11 off-hand):</p>

<blockquote>
  <p>If there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array,the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration.</p>
</blockquote>
"
"<p>I have a situation where I need to parse a lot of little <code>std::string</code>s out of a potentially large <code>std::string</code>(I'm stress-testing with a 20M <code>std::string</code>). I keep track of the index of the beginning of the <code>std::string</code> I want to parse out, and when I get to the end of the <code>std::string</code> I do a <code>substr</code> of the large <code>std::string</code>. I then use these <code>std::string</code>s that I have parsed out as keys for a <code>std::map</code>. </p>

<p>I'm looking to make this run faster by switching to <code>char*</code>. What I gather I would need to do is maintain the pointer to the beginning of the string I want to parse out, count the length of the string as I parse it, and then instantiate a new <code>char*</code> that holds the length of the parsed out string. I then <code>strncpy/memcpy</code> the string into the new <code>char*</code>. When I use this new <code>char*</code> as a key to a <code>std::map</code> I have to provide a comparison functor that will run a <code>strcmp</code>.</p>

<p>The way I have things now, it takes 290 ms total on average to parse through the string without inserting into the <code>std::map</code> (takes ~450 ms total with inserting). Will switching to <code>char*</code> give me significantly (anything 50 ms+) better results?</p>
","87234","","<p>Firstly, nobody knows the real answer without trying so you might as well try it yourself. But secondly, we can make an educated guess: probably not; that's all <code>std::string</code> is doing internally anyway. </p>

<p>What you should do is make a class that represents a range within an existing string (that is, store a pair of iterators), and use this class as an index to your map. This way you can avoid allocating a bunch of tiny strings, which is almost certainly where most of your performance hit will come from, at least during loading. Then you just keep your source string in memory so the iterators are still valid.</p>

<p>You may also consider <code>unordered_map</code> if you mostly perform lookups (you can cache the result of the hash, since you're now working with immutable strings), but again the only way to know if this will be faster is the same method for all performance problems: <em>testing and data</em>.</p>
"
"<p>I'm using Visual Studio 2008. This is my code:</p>

<pre><code>#include ""stdafx.h""
#include &lt;conio.h&gt;
#include &lt;hash_map&gt;
#include &lt;iostream&gt;

using namespace std;

hash_map &lt;int, int&gt; hm;

int main()
{
    return 0;
}
</code></pre>

<p>And here's my error:</p>

<pre><code>error C2143: syntax error : missing ';' before '&lt;'
error C4430: missing type specifier - int assumed. Note: C++ does not support default-int
</code></pre>
","87234","","<p>In the MSVC compiler, extensions to the standard library are placed in the <code>stdext</code> namespace:</p>

<pre><code>#include &lt;hash_map&gt;

stdext::hash_map&lt;int, int&gt; hm;

int main()
{
    return 0;
}
</code></pre>

<p><em>Disclaimer: I don't own VS2008 but this should work. :)</em></p>

<p>Note, though, that you should update to the latest compiler if possible and use the new standard unordered containers instead: <code>std::unordered_map</code> and <code>std::unordered_set</code>.</p>
"
"<p>Consider the following code:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    // the following is expected to not print 4000000000
    // because the result of an expression with two `int`
    // returns another `int` and the actual result 
    // doesn't fit into an `int` 
    cout &lt;&lt; 2 * 2000000000 &lt;&lt; endl; // prints -294967296

    // as such the following produces the correct result
    cout &lt;&lt; 2 * 2000000000U &lt;&lt; endl; // prints 4000000000
}
</code></pre>

<p>I played a bit around with casting the result to different integer types, and came accross some weird behavior. </p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    // unexpectedly this does print the correct result
    cout &lt;&lt; (unsigned int)(2 * 2000000000) &lt;&lt; endl; // prints 4000000000

    // this produces the same wrong result as the original statement
    cout &lt;&lt; (long long)(2 * 2000000000) &lt;&lt; endl; // prints -294967296
}
</code></pre>

<p>I expected both of the following statements to not produce the correct result, how come one did succeed and the other didn't?</p>
","87234","","<p>Way too much confusion going on in people trying to answer this question.</p>

<p>Let's examine:</p>

<p><code>2 * 2000000000</code></p>

<p>This is an <code>int</code> multiplied by an <code>int</code>. §5/4 tells us:</p>

<blockquote>
  <p>If during the evaluation of an expression, the result is not mathematically deﬁned or not in the range of representable values for its type, the behavior is undeﬁned.</p>
</blockquote>

<p>This result is mathematically defined, but is it in the range of representable values for <code>int</code>? </p>

<p>That depends. On many common architectures <code>int</code> has 32 bits to represent values, giving it a maximum value of 2,147,483,647. Since the mathematical result of this is 4,000,000,000, such an architecture would not be able to represent the value and the behavior is undefined. (This pretty much kills the question, because now the behavior of the entire program is undefined.) </p>

<p>But that's just dependent on the platform. If <code>int</code> was 64 bits wide instead (note: <code>long long</code> is guaranteed to have at least 64 bits to represent values), the result would fit just fine.</p>

<p>Let's just fix up the problem a bit though and go straight to this:</p>

<pre><code>int x = -294967296; // -294,967,296
</code></pre>

<p>And let's further say this fits within the range of <code>int</code> (which for 32 bit <code>int</code> it does).</p>

<p>Now let's cast this to an <code>unsigned int</code>:</p>

<pre><code>unsigned int y = static_cast&lt;unsigned int&gt;(x);
</code></pre>

<p>What is the value of <code>y</code>? <strong>It has nothing to do with the bit representation of <code>x</code></strong>.</p>

<p>There is no ""bit cast"" where the compiler simply treats the bits as an unsigned quantity. Conversions work with <em>values</em>. The <em>value</em> of a <code>signed int</code> converted to an <code>unsigned int</code> is defined in §4.7/2:</p>

<blockquote>
  <p>If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n is the number of bits used to represent the unsigned type). [Note: In a two’s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). —end note ]</p>
</blockquote>

<p>For us on our 32-bit (<code>unsigned</code>) <code>int</code> system, this means 4000000000. This works regardless of bits: two's-compliment, one's-compliment, magic's-compliment, etc. These are irrelevant.</p>

<p>The <em>reason</em> you see the value you wanted in the first palce (ignoring UB) is that on your two's-compliment machine, the difference between signed and unsigned integers is indeed a matter of viewing bits differently. So when you multiplied those two <code>int</code>'s, you were ""really"" multiplying two unsigned integers, ignoring the overflow, and viewing the result as a signed integer. Then the cast changes your view once more.</p>

<p>But the casting works independently of bits!</p>
"
"<p>On Artima article about C++ rvalue reference (<a href=""http://www.artima.com/cppsource/rvalue.html"" rel=""nofollow"">http://www.artima.com/cppsource/rvalue.html</a>) there is words: <em>That's why it is necessary to say move(x) instead of just x when passing down to the base class. This is a key safety feature of move semantics designed to prevent accidently moving twice from some named variable.</em></p>

<p>I can't think situation when such double move can perform. Can you give an example of this? In other words, what will go wrong if all members of <code>T&amp;&amp;</code> would be rvalue references and not just references?</p>
","87234","","<p>Consider this scenario:</p>

<pre><code>void foo(std::string x) {}
void bar(std::string y) {}

void test(std::string&amp;&amp; str)
{
    // to be determined
}
</code></pre>

<p>We want to call <code>foo</code> with <code>str</code>, then <code>bar</code> with <code>str</code>, both with the same value. The best way to do this is:</p>

<pre><code>foo(str); // copy str to x
bar(std::move(str)); // move str to y; we move it because we're done with it
</code></pre>

<p>It would be a mistake to do this:</p>

<pre><code>foo(std::move(str)); // move str to x
bar(std::move(str)); // move str to y...er, except now it's empty
</code></pre>

<p>Because after the first move the value of <code>str</code> is unspecified.</p>

<p>So in the design of rvalue references, this implicit move is not there. If it were, our best way above would not work because the first mention of <code>str</code> would be <code>std::move(str)</code> instead.</p>
"
"<p>local lvalue references-to-const and rvalue references can extend the lifetime of temporaries:</p>

<pre><code>const std::string&amp; a = std::string(""hello"");
std::string&amp;&amp; b = std::string(""world"");
</code></pre>

<p>Does that also work when the initializer is not a simple expression, but uses the conditional operator?</p>

<pre><code>std::string&amp;&amp; c = condition ? std::string(""hello"") : std::string(""world"");
</code></pre>

<p>What if one of the results is a temporary object, but the other one isn't?</p>

<pre><code>std::string d = ""hello"";
const std::string&amp; e = condition ? d : std::string(""world"");
</code></pre>

<p>Does C++ mandate the lifetime of the temporary be extended when the condition is false?</p>

<p>The question came up while answering <a href=""http://stackoverflow.com/q/14404904/252000"">this question</a> about non-copyable objects.</p>
","87234","","<p>Both of those are fine.</p>

<p>§5.16 says (extraordinarily abridged):</p>

<blockquote>
  <p>2 If either the second or the third operand has type void</p>
</blockquote>

<p>Nope.</p>

<blockquote>
  <p>3 Otherwise, if the second and third operand have diﬀerent types </p>
</blockquote>

<p>Nope.</p>

<blockquote>
  <p>4 If the second and third operands are glvalues of the same value category </p>
</blockquote>

<p>Nope. (In the first, both are prvalues and in the second one is a glvalue  and one is a prvalue.)</p>

<blockquote>
  <p>5 Otherwise, the result is a prvalue</p>
</blockquote>

<p>Okay, so both of these result in prvalues. So the binding is fine, but what's the binding to?</p>

<blockquote>
  <p>6  Lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are per- formed on the second and third operands.</p>
</blockquote>

<p>Okay, so both are now rvalues if they weren't already.</p>

<blockquote>
  <p>6 (continued)  After those conversions, one of the following shall hold:  </p>
  
  <p>The second and third operands have the same type; the result is of that type. If the operands have class type, the result is a prvalue temporary of the result type, which is copy-initialized from either the second operand or the third operand depending on the value of the ﬁrst operand.</p>
</blockquote>

<p>Okay, so it's either <code>std::string(first_operand)</code> or <code>std::string(second_operand)</code>.</p>

<p>Regardless, the result of the conditional expression is a new prvalue temporary, and it's that value that's extended by binding to your references.</p>
"
"<p>I am using <code>std::thread</code> and gcc as my compiler in implementing the parallel-merge as described in <a href=""http://rads.stackoverflow.com/amzn/click/0262033844"" rel=""nofollow"">Cormen's Introduction to Algorithms</a>.</p>

<p>I think I got the code to work.  It passes all randomly seeded arrays that are not too big.  However, when I try to merge two arrays that are large (1e6 elements each), I get the following termination:</p>

<pre><code>terminate called without an active exception
terminate called recursively
terminate called recursively
</code></pre>

<p>Using gdb doesn't help: it becomes corrupted during the run.</p>

<p>I am pretty certain that the run has failed due to too many threads spawned.</p>

<p><em>What can I do to confirm that this error is due to too many std::threads spawned?</em></p>

<p><strong>NOTES</strong></p>

<ol>
<li>Code works up to n=1e4, fails by n=1e5</li>
<li>#define DEBUG if you want to see output, but I don't recommend this except for small n like 10 or 50.</li>
<li>STRBUF_SIZE/use of fprintf is ugly, but iostream doesn't flush well in threads - this is hacky, but works (no need to focus here).</li>
<li>I tried following Barnes53's suggestion by using a try/catch block around the threads, but this didn't work, apparently.</li>
<li>I know that spawning a gazillion threads is a bad thing - at this point, I am just trying to implement what's in the book and to see if it works, and perhaps discover what its limitations are.</li>
</ol>

<p><strong>UPDATE</strong></p>

<ol>
<li><a href=""http://stackoverflow.com/a/14409088/975129"">GManNickG's answer below</a> helped: not every run, but during some runs of 1e5, I can see that, indeed, resources are gone.</li>
<li>I will probably look into some kind of k-way parallel sort, where I can control the number of threads spawned, if this algorithm is not salvageable.</li>
</ol>

<p><strong>CODE</strong></p>

<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;thread&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;

#define STRBUF_SIZE 1024

class Random
{
public:
    Random( unsigned int seed=::time(nullptr))
        : m_seed( seed )
    { }
    // between [ 0 .. n-1 ]
    unsigned int rand_uint( unsigned int n )
    {
        return static_cast&lt;unsigned int&gt;
                     (static_cast&lt;float&gt;(n) * rand_r( &amp;m_seed ) / RAND_MAX);
    }
    unsigned int getSeed() const { return m_seed; }
private:
    unsigned int m_seed;
};

template&lt;typename T&gt;
char* dump( char* line, T it1, T it2 )
{
    char buf[80];
    line[0] = '\0';
    for( T it=it1; it!=it2; ++it )
    {
        sprintf( buf, ""%u "", *it );
        strcat(  line, buf );
    }
    return line;
}

template&lt; typename T, class It &gt;
It binary_search_it( It beg, It end, const T&amp; value )
{
    auto low  = beg;
    auto high = std::max( beg, end );   // end+1
    while( low &lt; high )
    {
        auto mid = low + std::distance( low, high ) / 2;
        if ( value &lt;= *mid )
            high = mid;
        else
            low = mid + 1;
    }
    return high;
}

template&lt; class InputIt, class OutputIt &gt;
void p_merge( 
    char const*  msg, 
    unsigned     depth,
    unsigned     parent_lvl_id,
    unsigned     lr,
    InputIt  p1, InputIt  r1, 
    InputIt  p2, InputIt  r2, 
    OutputIt p3, OutputIt r3
    )
{
#ifdef DEBUG
    char buff[STRBUF_SIZE];
#endif
    unsigned sum_prev  = pow( 2, depth ) - 1;
    unsigned lvl_id    = 2*parent_lvl_id + lr;
    unsigned thread_no = sum_prev + lvl_id + 1;

    unsigned limit0    = sum_prev + 1;
    unsigned limit1    = pow( 2, depth+1 ) - 1;

#ifdef DEBUG
    char msg_dep[256];
    sprintf( msg_dep, ""%s [%2d] %-10d [%d,%d]"", msg, depth, thread_no, limit0, limit1 );
    fprintf( stderr, ""%s\n"", msg_dep );
#endif

    if ( thread_no&lt;limit0 || thread_no&gt;limit1 )
    {
        fprintf( stderr, ""OUT OF BOUNDS\n"" );
        exit( 1 );
    }

    auto n1 = std::distance( p1, r1 );
    auto n2 = std::distance( p2, r2 );
#ifdef DEBUG
    fprintf( stderr, ""%s dist[v1]=%2ld   : %s\n"", msg_dep, n1, dump( buff, p1, r1 ) );
    fprintf( stderr, ""%s dist[v2]=%2ld   : %s\n"", msg_dep, n2, dump( buff, p2, r2 ) );
#endif
    if ( n1&lt;n2 )
    {
        std::swap( p1, p2 );
        std::swap( r1, r2 );
        std::swap( n1, n2 );
#ifdef DEBUG
      fprintf( stderr, ""%s swapped[v1]   : %s\n"", msg_dep, dump( buff, p1, r1 ));
      fprintf( stderr, ""%s swapped[v2]   : %s\n"", msg_dep, dump( buff, p2, r2 ));
#endif
    }
    if ( n1==0 )
    {
#ifdef DEBUG
      fprintf( stderr, ""%s done              \n"", msg_dep );
#endif
        return;
    }
    auto q1 = p1 + n1 / 2;   // midpoint
    auto q2 = binary_search_it( p2, r2, *q1 );  // &lt;q1   q2[q1]   &gt;=q1
    auto q3 = p3 + std::distance( p1, q1 ) + std::distance( p2, q2 );
    *q3 = *q1;

#ifdef DEBUG
    fprintf( stderr, ""%s q1[median]=%u  : %s\n"", msg_dep, *q1, dump( buff, p1, r1 ));
    fprintf( stderr, ""%s q2[fulcrum]=%u : %s\n"", msg_dep, *q2, dump( buff, p2, r2 ));
    fprintf( stderr, ""%s q3(copied)=%u  : %s\n"", msg_dep, *q3, dump( buff, p3, r3 ));
#endif

#ifdef DEBUG
    auto d1 = std::distance( p1,   q1-1 );
    auto d2 = std::distance( q1+1, r1   );
    fprintf( stderr, ""%s q1[dist_L]=%ld  : %s\n"", msg_dep, d1, dump( buff, p1, r1 ));
    fprintf( stderr, ""%s q1[dist_M]=%ld  : %s\n"", msg_dep, d2, dump( buff, p1, r1 ));
#endif


    try {
        std::thread t1{ 
            [&amp;](){ p_merge( ""LESS"", depth+1, lvl_id, 0, p1, q1,   p2, q2,   p3, r3 ); } 
        };
        std::thread t2{ 
            [&amp;](){ p_merge( ""MORE"", depth+1, lvl_id, 1, q1+1, r1, q2, r2, q3+1, r3 ); } 
        };
        t1.join();
        t2.join();
    }
    catch( ... )
    {
        fprintf( stderr, ""OK - I am dying during a std::thread spawn\n"" );
        exit( 1 );
    }

#ifdef DEBUG
    fprintf( stderr, ""%s synchronized\n"", msg_dep );
#endif
}

int
main( int argv, char* argc[] )
{
    // ok up to 1e4, fails by 1e5
    unsigned n = 1e5; 
    Random   r;
    std::vector&lt;unsigned&gt; v1( n ), v2( n ), v3( 2 * n );

#ifdef DEBUG
    fprintf( stderr, ""SEED = %u\n"", r.getSeed() );
#endif

    std::generate( v1.begin(), v1.end(), [&amp;]() { return r.rand_uint(n); } );
    std::generate( v2.begin(), v2.end(), [&amp;]() { return r.rand_uint(n); } );

#ifdef DEBUG
    char buff[STRBUF_SIZE];
    fprintf( stderr, ""%s\n"", dump( buff, v1.begin(), v1.end() ));
    fprintf( stderr, ""%s\n"", dump( buff, v2.begin(), v2.end() ));
#endif

    std::sort( v1.begin(), v1.end() );
    std::sort( v2.begin(), v2.end() );

    p_merge( ""TOP "", 0, 0, 0,
        v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin(), v3.end() );

    assert( std::is_sorted( v3.begin(), v3.end() ));

#ifdef DEBUG
    fprintf( stderr, ""FINAL : %s\n"", dump( buff, v3.begin(), v3.end() ));
#endif
}
</code></pre>
","87234","","<p>You can catch <code>std::system_error</code> and check if the code is <code>resource_unavailable_try_again</code>:</p>

<pre><code>#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;system_error&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

class thread_collection
{
public:
    thread_collection() :
    mStop(false)
    {}

    ~thread_collection()
    {
        clear();
    }

    template &lt;typename Func, typename... Args&gt;
    bool add(Func&amp;&amp; func, Args&amp;&amp;... args)
    {
        try
        {
            mThreads.emplace_back(std::forward&lt;Func&gt;(func),
                                  std::cref(mStop),
                                  std::forward&lt;Args&gt;(args)...);
        }
        catch (const std::system_error&amp; e)
        {
            if (e.code().value() == std::errc::resource_unavailable_try_again)
                return false; // not possible to make more threads right now
            else
                throw; // something else
        }

        return true; // can keep going
    }

    void clear()
    {
        mStop = true;
        for (auto&amp; thread : mThreads)
        {
            if (thread.joinable())
                thread.join();
        }

        mThreads.clear();
        mStop = true;
    }

    std::size_t size() const
    {
        return mThreads.size();
    }

private:
    thread_collection(const thread_collection&amp;);
    thread_collection&amp; operator=(const thread_collection&amp;);

    std::atomic&lt;bool&gt; mStop;
    std::vector&lt;std::thread&gt; mThreads;
};

void worker(const std::atomic&lt;bool&gt;&amp; stop)
{
    while (!stop)
        std::this_thread::yield();
}

int main()
{
    thread_collection threads;

    try
    {
        while (threads.add(worker))
            continue;

        std::cout &lt;&lt; ""Exhausted thread resources!"" &lt;&lt; std::endl;
    }
    catch (const std::exception&amp; e)
    {
        std::cout &lt;&lt; ""Stopped for some other reason: "" &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; ""Made: "" &lt;&lt; threads.size() &lt;&lt; "" threads."" &lt;&lt; std::endl;
    threads.clear();
}
</code></pre>

<p><em>(Run this at your own risk!)</em></p>

<p>According §30.3.1.2/4, this is the error code used to indicate thread creation failure:</p>

<blockquote>
  <p>Error conditions:<br>
  resource_unavailable_try_again — the system lacked the necessary resources to create another thread, or the system-imposed limit on the number of threads in a process would be exceeded.</p>
</blockquote>

<p>Note this could be thrown by your own arguments being copied to the resulting thread. To guarantee against this, you need to pre-construct your arguments, then no-throw move them to your thread function.</p>

<p>That said, you're much better off putting a limit on thread creation anyway. There's no point in having more threads running than cores can execute. Use <code>std::thread::hardware_concurrency</code> to get that number.</p>
"
"<p>Consider a while loop in ANSI C whose only purpose is to delay execution:</p>

<pre><code>unsigned long counter = DELAY_COUNT;
while(counter--);
</code></pre>

<p>I've seen this used a lot to enforce delays on embedded systems, where eg. there is no <code>sleep</code> function and timers or interrupts are limited.</p>

<p>My reading of the ANSI C standard is that this can be completely removed by a conforming compiler. It has none of the side effects described in <strong>5.1.2.3</strong>:</p>

<blockquote>
  <p>Accessing a volatile object, modifying an object, modifying a file, or calling a function that does any of those operations are all side effects, which are changes in the state of the execution environment.</p>
</blockquote>

<p>...and this section also says:</p>

<blockquote>
  <p>An actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no needed side effects are produced (including any caused by calling a function or accessing a volatile object).</p>
</blockquote>

<p>Does this imply that the loop could be optimised out? Even if <code>counter</code> were <code>volatile</code>?</p>

<p>Notes:</p>

<ol>
<li>That this is not quite the same as <a href=""http://stackoverflow.com/questions/2178115/are-compilers-allowed-to-eliminate-infinite-loops"">Are compilers allowed to eliminate infinite loops?</a>, because that refers to <em>infinite</em> loops, and questions arise about when a program is allowed to terminate at all. In this case, the program will certainly proceed past this line at some point, optimisation or not.</li>
<li>I know what GCC does (removes the loop for <code>-O1</code> or higher, unless <code>counter</code> is <code>volatile</code>), but I want to know what the standard dictates.</li>
</ol>
","87234","","<blockquote>
  <p>Does this imply that the loop could be optimised out?</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>Even if counter were volatile?</p>
</blockquote>

<p>No. It would read and write a volatile variable, which has observable behavior, so it must occur.</p>
"
"<p>The error reads:</p>

<blockquote>
  <p>request for member 'begin', 'end' in 'arr' which is non class type int[5],
  unable to deduce from expression error.</p>
</blockquote>

<p>My code:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    int * mypointer;

    int arr[5] = {1,3,5,7,9};

    mypointer = arr;

    for(auto it = arr.begin(); it != arr.end(); ++it) {
        cout&lt;&lt;*mypointer&lt;&lt;endl;

        mypointer++;
    }

    return 0;
}
</code></pre>
","87234","","<p>Arrays have no member functions as they aren't a class type. This is what the error is saying.</p>

<p>You can use <code>std::begin(arr)</code> and <code>std::end(arr)</code> from the <code>&lt;iterator&gt;</code> header instead. This also works with types that <em>do</em> have <code>.begin()</code> and <code>.end()</code> members, via overloading:</p>

<pre><code>#include &lt;array&gt;
#include &lt;vector&gt;

#include &lt;iterator&gt;

int main()
{
    int c_array[5] = {};
    std::array&lt;int, 5&gt; cpp_array = {};
    std::vector&lt;int&gt; cpp_dynarray(5);

    auto c_array_begin = std::begin(c_array); // = c_array + 0
    auto c_array_end = std::end(c_array);     // = c_array + 5

    auto cpp_array_begin = std::begin(cpp_array); // = cpp_array.begin()
    auto cpp_array_end = std::end(cpp_array);     // = cpp_array.end()

    auto cpp_dynarray_begin = std::begin(cpp_dynarray); // = cpp_dynarray.begin()
    auto cpp_dynarray_end = std::end(cpp_dynarray);     // = cpp_dynarray.end()
}
</code></pre>
"
"<p><em>How do I modify the following function template so that it returns 42 if template parameters <code>T</code> and <code>U</code> are exactly the same type?</em></p>

<pre><code>template&lt;typename T,typename U&gt;
int Foo()
{
  return 0;
}
</code></pre>
","87234","","<p>Just for completeness in the answers, here's how you can make this choice at compile-time without classes:</p>

<pre><code>namespace detail
{
    int Foo(std::true_type)
    {
        return 42;
    }

    int Foo(std::false_type)
    {
        return 0;
    }
}

template &lt;typename T, typename U&gt;
int Foo()
{
    return detail::Foo(std::is_same&lt;T, U&gt;());
}
</code></pre>

<p>This compile-time branching is important when the two different code paths have different requirements on your arguments (none in this case, though). For example, in one path you use member function <code>x()</code> and in the other <code>y()</code>; or as you've noted, even entirely ""different"" functions.</p>

<p>This, to me, is much simpler than managing a class.</p>
"
"<p>I was looking at my headers (g++-4.5.2) for the implementations of some templates in , and I found the following:</p>

<pre><code>/// is_function
template&lt;typename&gt;
  struct is_function
  : public false_type { };
template&lt;typename _Res, typename... _ArgTypes&gt;
  struct is_function&lt;_Res(_ArgTypes...)&gt;
  : public true_type { };
template&lt;typename _Res, typename... _ArgTypes&gt;
  struct is_function&lt;_Res(_ArgTypes......)&gt;
  : public true_type { };
</code></pre>

<p>The first two declarations seem reasonable, but I can't figure out how the third works. What is <code>......</code>? I looked for it in the standard, and couldn't find anything.</p>
","87234","","<p>It's the same as:</p>

<pre><code>_Res(_ArgTypes..., ...)
</code></pre>

<p>The comma before an ellipses parameter is optional.</p>
"
"<p>Inside a method can one create an uninitialised object from the class?</p>

<p>Here's some context: imagine a class where the constructors all allocate memory:</p>

<pre><code>class NumberArray
{
  size_t m_Size;
  int *m_Numbers;

public:
  NumberArray() { m_Size = 1; m_Numbers = new int[1]; m_Numbers[0] = 0; }

  // . . . other methods for manipulating or constructing . . .

  ~NumberArray() { delete[] m_Numbers; }

  // What if I had a method that concatenates two arrays?
  NumberArray ConcatenateWith(const NumberArray &amp;) const;
};
</code></pre>

<p>Inside such a method one would desire to create an uninitialised object of class <code>NumberArray</code>, and then 'construct' a new object based on <code>this</code> and the object in the parameter?  AKA:</p>

<pre><code>NumberArray NumberArray::ConcatenateWith(const NumberArray &amp;other) const
{
  // Mystery manner of creating an uninitialised NumberArray 'returnObject'.
  returnObject.m_Size = m_Size + other.m_Size;
  returnObject.m_Numbers = new int[returnObject.m_Size];
  std::copy(m_Numbers, m_Numbers + m_Size, returnObject.m_Numbers);
  std::copy(other.m_Numbers, other.m_Numbers + other.m_Size, returnObject.m_Numbers + m_Size);
  return returnObject;
}
</code></pre>

<p>What's the best way of doing this?  Basically, I don't want the default constructor to create a size 1 array that I will just delete and then allocate a new array for again anyway.</p>
","87234","","<p>What you're asking for is <strong>placement new</strong>. This looks something like this:</p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;new&gt;

void* mem = std::malloc(sizeof(T)); // memory for a T (properly aligned per malloc)

T* x = new (mem) T; // construct a T in that memory location
x-&gt;~T();            // destruct that T

std::free(mem); // and free the memory
</code></pre>

<p>Doing this correctly (in an exception-safe manner with properly managed and aligned memory) is not a trivial task. You need to be careful about the lifetime of your objects.</p>

<p>For your question, you are describing exactly what <code>std::vector</code> does. It allocates raw uninitialized memory and constructs inserted elements directly into that memory. And lots of its code is dedicated to just getting the lifetime and memory management correct and exception safe!</p>

<p>You should strongly prefer to use <code>std::vector</code> instead of writing it yourself.</p>
"
"<p>I am using C++ and i have 2 vectors that a related to each other:</p>

<pre><code>vector&lt;double&gt; val = {.3,.5,.2,.4};
vector&lt;string&gt; str = {'a','b','c','d'};
</code></pre>

<p>I would like to search val for the max, and then return the string from str in the same position:</p>

<pre><code>vector&lt;double&gt;::const_iterator it;
it = max_element(val.begin(), val.end());
</code></pre>

<p>So, how can i use <code>it</code> inside <code>str</code> to get the letter?</p>

<pre><code>string lettter;
letter = str.at(it-&gt; ????? );
</code></pre>

<p>Thank!!!</p>
","87234","","<p>Get the index of the element like so:</p>

<pre><code>auto index = std::distance(val.begin(), it);
</code></pre>

<p>Then index into your string array:</p>

<pre><code>auto letter = str[index];
</code></pre>

<hr>

<p>Note that if these values are correlated, you should probably forcibly keep them together:</p>

<pre><code>typedef std::pair&lt;double, string&gt; valstr_pair;
std::vector&lt;valstr_pair&gt; valstr;

auto it = std::max_element(valstr.begin(), valstr.end(),
    [](const valstr_pair&amp; first, const valstr_pair&amp; second)
    {
        return first.first &lt; second.first; // compare values
    });

it-&gt;first;  // max value
it-&gt;second; // string of max value
</code></pre>
"
"<p><code>boost::shared_polymorphic_downcast</code> disappeared between boost <a href=""http://www.boost.org/doc/libs/1_52_0/boost/smart_ptr/shared_ptr.hpp"">1.52.0</a> and <a href=""http://www.boost.org/doc/libs/1_53_0/boost/smart_ptr/shared_ptr.hpp"">1.53.0</a>.  Nothing is mentioned about this in the <a href=""http://www.boost.org/users/history/version_1_53_0.html"">release notes</a>, and the commit (r81463) contains only the cryptic log message ""Update shared_ptr casts.""</p>

<p>It is not clear to me what I should be using now instead, or why this functionality was removed.  Can anybody help?</p>

<p>EDIT: Thanks everyone for the insightful comments.  I find myself a bit frustrated that boost will make backwards-incompatible changes in a release without any justification or notice, and I also find it frustrating that they remove useful features.  But based on the responses, I can do what I want in two lines of code instead of one, so I think that will suffice.  Still, I am leaving this question ""unanswered"" because nobody has provided a simple way to get the old behavior of <code>boost::shared_polymorphic_downcast</code>; that is, to use a <code>dynamic_cast</code> when debugging is enabled and a <code>static_cast</code> when it is not.</p>
","87234","","<p>Use <code>boost::dynamic_pointer_cast</code>.</p>

<p>The update it talks about is to match the design of C++11. In C++11 the pointer casts are generalized as the functions <code>std::dynamic_pointer_cast</code> (and friends) to allow us to write:</p>

<pre><code>template &lt;typename PointerToBase&gt; // models Base* in some way
void foo(PointerToBase ptr)
{
    auto ptrToDerived = std::dynamic_pointer_cast&lt;Derived&gt;(ptr);
}
</code></pre>

<p>So that <code>PointerToBase</code> could be a raw <code>Base*</code> or a <code>std::shared_ptr&lt;Base&gt;</code>, without us writing cases.</p>

<p>Boost of course simply wants to match C++ as much as possible.</p>
"
"<p>I need a bitset with a slightly diffrent behavior when asigning variables with integer type to a specific bit. The bit should be set to zero if the assigned integer is smaller then one, and to one elsewise.</p>

<p>As a simple solution I copied the STL bitset, replaced the classname with altbitset, adjusted namespaces and include guard and added following function under <code>reference&amp; operator=(bool __x)</code> in the nested <code>reference</code> class:</p>

<pre><code>template &lt;typename T&gt; 
reference&amp; operator=(T i) {
    if (i&lt;1) return operator=(false);
    return operator=(true);
}
</code></pre>

<p>It works as expected. </p>

<p><strong>Question is</strong> if there is a better way doing this.</p>
","87234","","<p>You shouldn't copy a library just to add a new function. Not only that, the new function is wildly unintuitive and could possibly be the source of errors for even just <em>reading</em> the code, let alone writing it.</p>

<p>Before:</p>

<pre><code>bv[n] = -1; // I know a Boolean conversion on -1 will take place
assert(bv[n]); // of course, since -1 as a Boolean is true
</code></pre>

<p>After:</p>

<pre><code>bv[n] = -1; // I guess an integer &lt; 1 means false?
assert(bv[n]); // Who changed my bitvector semantics?!
</code></pre>

<p>Just write it out so it makes sense in <em>your</em> domain:</p>

<pre><code>bv[n] = (i &lt; 1);
</code></pre>

<p>Remember: simplest doesn't always mean fewest characters, it means clearest to read.</p>

<hr>

<p>If you <em>do</em> want to extend the functionality of existing types, you should do so with free functions:</p>

<pre><code>template &lt;typename BitSet, typename Integer&gt;
auto assign_bit_integer(BitSet&amp; bits, const std::size_t bit, const Integer integer) -&gt;
    typename std::enable_if&lt;std::is_integral&lt;Integer&gt;::value,
                            typename BitSet::reference&gt;::type
{
    return bits[bit] = (integer &lt; 1);
}
</code></pre>

<p>Giving:</p>

<pre><code>std::bitset&lt;8&gt; bits;

assign_bit_integer(bits, 0, 5);
// ERROR: assign_bit_integer(bits, 0, 5.5);
</code></pre>

<p>But for such a small function with no clear ""obvious"" name that describes what it does concisely(<code>assign_bit_true_if_less_than_one_otherwise_false</code> is verbose, to say the least), just write out the code; it says the same thing anyway.</p>
"
"<p>As far as I understand C++11 references, I should not be able to bind an rvalue reference to a (non-const) lvalue reference as the former might be bound to a temporary and the latter must never be bound to a temporary.</p>

<p>However I found this odd behaviour in conjunction temporary stream objects (which I reduced as far as I could)</p>

<pre><code>struct Dummy {};
template &lt;typename Stream&gt;
Stream&amp; operator&lt;&lt;(Stream&amp; s, Dummy) {
  return s &lt;&lt; ""."";          // &lt;- (A)
}

template &lt;typename Stream&gt;
void pass(Stream&amp;&amp; s) {
  std::move(s) &lt;&lt; Dummy();  // &lt;- (X)   rvalue-&gt;lvalue conversion?
}

#include &lt;fstream&gt;
int main() {
  pass(std::fstream(""test"",std::ios::out));
}
</code></pre>

<p>If I write <code>s &lt;&lt; Dummy()</code> in line <code>(X)</code>, C++ complains in line <code>(A)</code>, saying</p>

<blockquote>
  <p><code>error: invalid initialization of reference of type ‘std::basic_fstream&lt;char&gt;&amp;’ from expression of type ‘std::basic_ostream&lt;char&gt;’</code></p>
</blockquote>

<p>However, why does the code (as shown above) compiles <em>and works as expected</em>? The rvalue reference returned by <code>std::move</code> should just be as unable to being bound to an lvalue reference as the expression <code>s</code> is, but both <code>gcc 4.6.1</code> and <code>gcc 4.7.2</code> react identically.</p>

<p>And why does this phenomenon only appear to work with streams? When directly passing a <code>Dummy&amp;&amp;</code> to a function that expects a <code>T&amp;</code> fails both with and without <code>std::move</code>.</p>
","87234","","<p><code>basic_ostream</code> has an overload of <code>operator&lt;&lt;</code> that looks like this:</p>

<pre><code>template &lt;typename Elem, typename Traits, typename T&gt;
basic_ostream&lt;Elem, Traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;Elem, Traits&gt;&amp;&amp; sink, const T&amp; val)
{
    return sink &lt;&lt; val;
}
</code></pre>

<p>This is called ""Rvalue stream insertion"" in the standard, at §27.7.3.9 [ostream.rvalue].</p>

<p>It allows implicit conversion (of sorts) from an rvalue <code>basic_ostream</code> to an lvalue.  It was introduced specifically to allow <a href=""http://stackoverflow.com/questions/5179522/why-does-writing-to-temporary-stream-fail"">temporary streams to be usable without resorting to tricks</a>.</p>

<hr>

<p>As for why the compile fails when you omit the move:</p>

<p>When <code>Stream&amp; operator&lt;&lt;(Stream&amp; s, Dummy)</code> is called <em>without</em> the move, <code>Stream</code> will be <code>std::fstream</code> which inherits from <code>std::ostream</code> (i.e. <code>basic_ostream&lt;char&gt;</code>).</p>

<p>It will use the <code>basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt;(basic_ostream&lt;E, T&gt;&amp;, const char*)</code> overload to insert your string, then try to return the result of that expression <em>which will be an <code>ostream</code></em>. You cannot implicitly downcast from <code>std::ostream&amp;</code> to <code>std::fstream&amp;</code>, so you get an error.</p>

<p>You can fix this by returning <code>s</code> on it's own line (where it won't have been implicitly upcasted.)</p>

<p>This isn't a problem <em>with</em> move because you go through that rvalue-to-lvalue insertion operator we just discovered first. Inside that function, the stream is a <code>basic_ostream</code> and so <code>Stream</code> is as well, and the return types will match.</p>
"
"<p>I got a vector of pointers to a base class <em>foo</em> which got a couple of child classes and what I would like to do is based on which child class it is, create a new class of the same instance.</p>

<p>I've solved it earlier by having a gigantic for loop which uses typeid to find out what class it is but is there no way to solve it in a more general way?</p>

<p>Basically, something like this is what I'm looking for:</p>

<pre class=""lang-c prettyprint-override""><code>std::vector&lt;foo*&gt; a;
std::vector&lt;foo*&gt; b;

//Store a couple of classes in a and b

b[0] = new typeid(a[0]).name();
</code></pre>
","87234","","<p>Whenever you have a giant switch based on type, you should probably use virtual functions instead.</p>

<p>You should introduce some sort of virtual <code>clone()</code> function:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

struct base
{
    virtual ~base() {};

    virtual void do_stuff() = 0;

    // cloning interface
    std::unique_ptr&lt;base&gt; clone() const
    {
        return std::unique_ptr&lt;base&gt;(do_clone());
    }

private:
    // actual clone implementation; uses a raw pointer to support covariance
    virtual base* do_clone() const = 0;
};

struct derived_A : base
{
    void do_stuff() override { std::cout &lt;&lt; ""stuff in derived_A"" &lt;&lt; std::endl; }

    // purposefully hide the base implementation,
    // since we know we'll be returning a derived_A
    std::unique_ptr&lt;derived_A&gt; clone() const
    {
        return std::unique_ptr&lt;derived_A&gt;(do_clone());
    }

private:
    derived_A* do_clone() const override
    {
        return new derived_A(*this);
    }
};

struct derived_B : base
{
    void do_stuff() override { std::cout &lt;&lt; ""stuff in derived_B"" &lt;&lt; std::endl; }

    // purposefully hide the base implementation,
    // since we know we'll be returning a derived_B
    std::unique_ptr&lt;derived_B&gt; clone() const
    {
        return std::unique_ptr&lt;derived_B&gt;(do_clone());
    }

private:
    derived_B* do_clone() const override
    {
        return new derived_B(*this);
    }
};

#include &lt;vector&gt;

int main()
{
    std::vector&lt;std::unique_ptr&lt;base&gt;&gt; v1;
    std::vector&lt;std::unique_ptr&lt;base&gt;&gt; v2;

    std::unique_ptr&lt;base&gt; x(new derived_A);
    v1.push_back(std::move(x));

    std::unique_ptr&lt;base&gt; y(new derived_B);
    v1.push_back(std::move(y));

    v1[0]-&gt;do_stuff();
    v1[1]-&gt;do_stuff();

    // clone
    v2.push_back(v1[0]-&gt;clone());
    v2.push_back(v1[1]-&gt;clone());

    v2[0]-&gt;do_stuff();
    v2[1]-&gt;do_stuff();
}
</code></pre>

<p>We want covariance on the return type (if you hold a pointer to a statically-typed <code>derived_A</code>, cloning it should yield a <code>derived_A</code> to avoid redundant casts), which is why the cloning interface is split into two pieces. It could be done in one if <code>std::unique_ptr&lt;base&gt;</code> was covariant to <code>std::unique_ptr&lt;derived&gt;</code>, but that's only the case for raw pointers.</p>

<p>I'm sure there's a way to hide the repeated boilerplate, that's an exercise for the reader.</p>

<hr>

<p>EDIT: Actually, here ya go; not too hard:</p>

<pre><code>#include &lt;memory&gt;

// Note: leaves with a public: access specifier
#define DEFINE_ABSTRACT_CLONEABLE(selfType)         \
        DEFINE_CLONEABLE_DETAIL(selfType)           \
        private:                                    \
            virtual selfType* do_clone() const = 0; \
                                                    \
        public:

// Note: leaves with a public: access specifier
#define DEFINE_CLONEABLE(selfType)              \
        DEFINE_CLONEABLE_DETAIL(selfType)       \
        private:                                \
            selfType* do_clone() const override \
            {                                   \
                return new selfType(*this);     \
            }                                   \
                                                \
        public:

#define DEFINE_CLONEABLE_DETAIL(selfType)                                   \
        public:                                                             \
            std::unique_ptr&lt;selfType&gt; clone() const                         \
            {                                                               \
                static_assert(std::is_same&lt;selfType,                        \
                                          std::decay&lt;decltype(*this)&gt;::type \
                                          &gt;::value,                         \
                             ""Must specify current class name."");           \
                                                                            \
                return std::unique_ptr&lt;selfType&gt;(do_clone());               \
            }                                                               \
</code></pre>

<p>And the test (note the smaller size):</p>

<pre><code>#include &lt;iostream&gt;

#include ""cloneable.hpp"" // or whatever 

struct base
{
    // readable error: DEFINE_ABSTRACT_CLONEABLE(int);
    DEFINE_ABSTRACT_CLONEABLE(base);

    virtual ~base() {};

    virtual void do_stuff() = 0;
};

struct derived_A : base
{
    DEFINE_CLONEABLE(derived_A);

    void do_stuff() override { std::cout &lt;&lt; ""stuff in derived_A"" &lt;&lt; std::endl; }
};

struct derived_B : base
{
    // error: DEFINE_CLONEABLE(derived_B);
    DEFINE_ABSTRACT_CLONEABLE(derived_B);

    void do_stuff() override { std::cout &lt;&lt; ""stuff in derived_B"" &lt;&lt; std::endl; }
    virtual void do_thing() = 0; // abstract again
};

struct derived_AA : derived_A
{
    DEFINE_CLONEABLE(derived_AA);

    void do_stuff() override { std::cout &lt;&lt; ""stuff in derived_AA"" &lt;&lt; std::endl; }
};

struct derived_BB : derived_B
{
    DEFINE_CLONEABLE(derived_BB);

    void do_stuff() override { std::cout &lt;&lt; ""doing stuff in derived_BB"" &lt;&lt; std::endl; }
    void do_thing() override { std::cout &lt;&lt; ""doing thing"" &lt;&lt; std::endl; }
};

int main()
{
    std::unique_ptr&lt;derived_AA&gt; x(new derived_AA());
    x-&gt;do_stuff();

    auto xx = x-&gt;clone();
    xx-&gt;do_stuff();

    std::unique_ptr&lt;derived_A&gt; xxx = xx-&gt;clone();
    xxx-&gt;do_stuff();

    std::unique_ptr&lt;base&gt; xxxx = xxx-&gt;clone();
    xxxx-&gt;do_stuff();

    xxxx-&gt;clone()-&gt;do_stuff();

    std::unique_ptr&lt;derived_BB&gt; y(new derived_BB());
    y-&gt;do_stuff();
    y-&gt;do_thing();

    auto yy = y-&gt;clone();
    yy-&gt;do_stuff();
    yy-&gt;do_thing();

    std::unique_ptr&lt;derived_B&gt; yyy = yy-&gt;clone();
    yyy-&gt;do_stuff();
    yyy-&gt;do_thing();

    std::unique_ptr&lt;base&gt; yyyy = yyy-&gt;clone();
    yyyy-&gt;do_stuff();
    // error, lost derived information: yyyy-&gt;do_thing(); 

    yyyy-&gt;clone()-&gt;do_stuff();
}
</code></pre>

<p>One more improvement would be to make each new declaration of <code>do_clone</code> pure virtual to force further deriving classes to implement it, but <em>this</em> is left to the reader.</p>
"
"<p>I can't understand what standard need to do with calling operator delete for void* == nullptr.</p>

<p>Something like this:</p>

<pre><code>void foo(void* ptr) // ptr == nullptr here
{
    delete ptr;
}
</code></pre>

<p>On the one hand, we have the following statement in standard:</p>

<p><strong>ISO/IEC 14882:2011</strong></p>

<p>5.3.5 Delete [expr.delete]</p>

<blockquote>
  <p>1 ... The operand shall have a pointer to object type, or a class type
  having a single non-explicit conversion function (12.3.2) to a pointer
  to object type. The result has type void.78</p>
  
  <p>78) <strong>This implies that an object cannot be deleted using a pointer of
  type void* because void is not an object type</strong>.</p>
</blockquote>

<p>which makes code with deleting void* ill-formed. On the other hand, we have another statement about nullptr in delete:</p>

<p><strong>ISO/IEC 14882:2011</strong></p>

<p>5.3.5 Delete [expr.delete]</p>

<blockquote>
  <p>2 ... In the first alternative (delete object), <strong>the value of the
  operand of delete may be a null pointer value</strong>, a pointer to a
  non-array object created by a previous new-expression, or a pointer to
  a subobject (1.8) representing a base class of such an object (Clause
  10). If not, the behavior is undefined. In the second alternative
  (delete array), <strong>the value of the operand of delete may be a null
  pointer value</strong> or a pointer value that resulted from a previous array
  new-expression.79 If not, the behavior is undefined.</p>
</blockquote>

<p>What implementation need to do in such kind of situation?</p>
","87234","","<p>Null and <code>void*</code> are two different things:</p>

<pre><code>delete static_cast&lt;int*&gt;(nullptr); // deleting null pointer, of int*
</code></pre>

<p>Your given code would be ill-formed, but it has nothing to do with the <em>value</em> of the pointer (which may be null), but its <em>type</em> (which cannot be <code>void*</code>).</p>
"
"<p>Why arrays in C++ didn't have member function size() until C++11 (std::array) ? What was the reason behind this ? Questions like 'how to obtain size of an array?' are quite frequent. </p>

<p><strong>Edition</strong>
As plain arrays are inherited from C, what is the reason it doesn't have such functionality ? As we can check type of data in array.</p>
","87234","","<p>Because they come from C, and C doesn't have member functions (nor is array even a class-type).</p>

<p>Compatibility with C was paramount, because allowing existing C codebases to compile as C++ greatly increased the adoption rate of the language. Mucking with something that works while worrying about compatibility was low on the priorities list, when you've got new language features to design.</p>

<p>In C++11 the language reached a point where all these nice little things got to come into existence. So why not add it <em>now</em>? Because C arrays still work just fine and it would be a ton of work to change that. It's much easier to introduce a new container (and a very simple one at that), and that's exactly what happened.</p>
"
"<p>Just wondering if anyone could point me in the right direction. I have a friend extraction operator that works if i include namespace std; but fails if i do not. can anyone give me a hint? </p>

<pre><code>ostream&amp; operator &lt;&lt; (ostream &amp;out, coins &amp;value)
</code></pre>

<p>this is also a friend function, so i have this in my class.h file (as a friend)
in my functions.h file (as the prototype) and in my functions.cpp file (the logic).</p>

<p>ive tried making it</p>

<p>std::ostream&amp; operator....
std::ostream&amp; operator std::&lt;&lt; (etc)</p>

<p>but i just cant see where im going wrong. My compiler keeps telling me 'ostream does not name a type'</p>

<p>thank you</p>
","87234","","<p>It's <code>ostream</code> that exists in the <code>std</code> namespace, don't do <code>std::&lt;&lt;</code> (that doesn't even make sense!). Try to take less of a shotgun approach to programming; that is, don't just try random things until it works. The error tells you <code>ostream</code> (unqualified) is the problem, so you have to solve that issue first.</p>

<pre><code>#include &lt;iostream&gt;

struct coins
{
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; sink, const coins&amp; value);
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; sink, const coins&amp; value)
{
    sink &lt;&lt; ""doing coins output"";
    return sink;
}

int main()
{
    coins c;
    std::cout &lt;&lt; c &lt;&lt; std::endl;
}
</code></pre>

<p>This is an insertion operator, by the way, as you're inserting data to a stream. Extraction would be <code>&gt;&gt;</code>.</p>
"
"<p>I think I may be missing something really obvious here, but I have been struggling for way too long on this and my C++ is way rusty (10yrs+) </p>

<p>The code below works fine, but I need to be able to pass a variable into the query for lname.  If I build the query in a string or char array I get an error that it is not compatible with parameter type of SQLWCHAR*</p>

<p>I know the code below is vulnerable to sql injection, but this is a one time hit on an isolated system, so I am really looking for simplicity more than anything else...</p>

<pre><code>SQLHENV env;
SQLHDBC dbc;
SQLHSTMT  sql_hStmt;
SQLRETURN ret;
SQLWCHAR outstr[1024];
SQLSMALLINT outstrlen;

SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;env);
SQLSetEnvAttr(env, SQL_ATTR_ODBC_VERSION, (void *) SQL_OV_ODBC3, 0);
SQLAllocHandle(SQL_HANDLE_DBC, env, &amp;dbc);

ret = SQLDriverConnect(dbc, NULL, L""DSN=myDSN"", SQL_NTS, NULL, 0, NULL, SQL_DRIVER_COMPLETE);

ret = SQLAllocHandle(SQL_HANDLE_STMT, dbc, &amp;sql_hStmt);
SQLWCHAR* SQL = L""select * from DB.employees where lname='Smith'"";
ret = SQLExecDirect(sql_hStmt, SQL, SQL_NTS);

SQLFetch(sql_hStmt);
</code></pre>
","87234","","<p>There are two problems here, one is constructing a string containing the query you want, the other is passing that string as an argument to the function.</p>

<p>My recommendation is to stay as ""C++"" as possible until you reach these C boundaries. So we should use <code>std::wstring</code> for the string processing up until the point where it needs to be a C-style string:</p>

<pre><code>std::wstring statementText = L""select * from DB.employees where lname='Smith'"";
ret = SQLExecDirect(sql_hStmt, const_cast&lt;SQLWCHAR*&gt;(statementText.c_str()), SQL_NTS);
</code></pre>

<p>The <code>c_str()</code> member function returns a pointer to a null-terminated array (i.e., a C-style string), but this pointer has the type <code>const wchar_t*</code>; that is, the contents of this C-style string cannot be modified.</p>

<p>This is a problem because <code>SQLWCHAR*</code> is just <code>wchar_t*</code>; it doesn't make any promise to leave the data alone. That is why I included the <code>const_cast</code>, to remove the <code>const</code> from the <code>c_str()</code> value.</p>

<p><strong>This is not something you generally want to do.</strong> <code>const_cast</code> is arguably the scariest cast because you directly open up the door to undefined behavior, as it's UB to modify a const object:</p>

<pre><code>const int x = 0;
const int* p = &amp;x; // anyone using this pointer can't modify x

int* bad = const_cast&lt;int*&gt;(p); // but this one is not so good
*bad = 5; // undefined behavior
</code></pre>

<p>The reason it's okay here, though, is that <code>SQLExecDirect</code> doesn't <em>actually</em> modify the string it's passed; it's simply an implementation error that const isn't used, so us taking that away is okay. (This lack of const mistake is very common in C.)</p>

<p>If you really need a buffer that <em>can</em> be modified, then starting in the current version of C++ (C++11) you can do this safely:</p>

<pre><code>std::wstring statementText = L""select * from DB.employees where lname='Smith'"";
ret = SQLExecDirect(sql_hStmt, &amp;statementText[0], SQL_NTS);
</code></pre>

<p>We're taking the address of the first element, which itself is in a null-terminated array; another C-style string. This time, though, we have a modifiable array; the type already matches.</p>

<p>(The reason I make note this is okay in C++11 is that <em>technically</em> in the previous version, C++03, this behavior wasn't guaranteed. It was actually intended to be, but an error in wording in the standard made it not so. To be practical, you're fine either way.)</p>

<p>Whichever one you want to use is up to you. Some will argue to just use <code>&amp;str[0]</code> all the time so we definitely have no UB, I would argue to document your intent and belief that the function doesn't modify the string and cast away const but ultimately operate in a const mindset. If something bad happens it's easy to relax away from const than it is to wish you had put it on.</p>

<p>One important thing to note is that all these returned pointers (either <code>str.c_str()</code> or <code>&amp;str[0]</code>) are only good as long as the <code>str</code> object itself is alive and not modified. This is bad:</p>

<pre><code>const wchar_t* get_query()
{
    std::wstring result = /* build query */;

    // oops, this pointer stops being meaningful when result stops existing!
    return result.c_str();
}
</code></pre>

<hr>

<p>With that all out of the way, building up these strings is easy. We have <code>std::wstringstream</code>:</p>

<pre><code>std::wstringstream ss; 

ss &lt;&lt; ""this is basically an expanding buffer that accepts anything std::wcout will"";
ss &lt;&lt; std::endl;
ss &lt;&lt; ""this includes integers "" &lt;&lt; 5 &lt;&lt; "" and other stream-insertable types"";
</code></pre>

<p>So you probably want something like this:</p>

<pre><code>std::wstring build_query(const std::wstring&amp; name)
{
    // you can provide a starting string
    std::wstringstream result(L""select * from DB.employees where lname="");

    result &lt;&lt; ""\'"" &lt;&lt; name &lt;&lt; ""\'"";

    return result.str(); // this captures the buffer as a C++ string
}

// Remember, this would be bad!
//
// SQLWCHAR* SQL = const_cast&lt;SQLWCHAR*&gt;(build_query(L""Smith"").c_str());
//
// Because the C++ string returned by build_query is temporary;
// it stops existing at the end of this full expression,
// so SQL would be a bad pointer. This is right:

std::wstring SQL = build_query(L""Smith"");
ret = SQLExecDirect(sql_hStmt, const_cast&lt;SQLWCHAR*&gt;(SQL.c_str()), SQL_NTS);
</code></pre>

<p>Hope that helps.</p>

<hr>

<p>Also, I would avoid using all-upper identifiers except for macros, because such names are overwhelmingly expected to be macros by people reading C++ code. Additionally, I've used C++-style casts in my example code; you should do the same. The C-style cast (<code>(type)value</code>) is simply too powerful to be safe.</p>
"
"<p>I am trying to understand the way move constructors and assignment ops work in C++11 but I'm having problems with delegating to parent classes.</p>

<p>The code:</p>

<pre><code>class T0
{
public:
    T0() { puts(""ctor 0""); }
    ~T0() { puts(""dtor 0""); }
    T0(T0 const&amp;) { puts(""copy 0""); }
    T0(T0&amp;&amp;) { puts(""move 0""); }
    T0&amp; operator=(T0 const&amp;) { puts(""assign 0""); return *this; }
    T0&amp; operator=(T0&amp;&amp;) { puts(""move assign 0""); return *this; }
};

class T : public T0
{
public:
    T(): T0() { puts(""ctor""); }
    ~T() { puts(""dtor""); }
    T(T const&amp; o): T0(o) { puts(""copy""); }
    T(T&amp;&amp; o): T0(o) { puts(""move""); }
    T&amp; operator=(T const&amp; o) { puts(""assign""); return static_cast&lt;T&amp;&gt;(T0::operator=(o)); }
    T&amp; operator=(T&amp;&amp; o) { puts(""move assign""); return static_cast&lt;T&amp;&gt;(T0::operator=(o)); }
};

int main()
{
    T t = std::move(T());
    return 0;
}
</code></pre>

<p>However, when I compile and run under VS2012, the output indicates that the lvalue versions of the T0 members are called:</p>

<pre><code>ctor 0
ctor
copy 0  &lt;--
move    &lt;--
dtor
dtor 0
dtor
dtor 0
</code></pre>

<p>A similar situation (with a slightly different test case) happens with move assignments -- the move assignment operator of T calls the ""normal"" assignment operator of T0.</p>

<p>What am I doing wrong?</p>
","87234","","<p>You're only ever calling your base class's stuff with lvalues:</p>

<pre><code>void foo(int&amp;){}  // A
void foo(int&amp;&amp;){} // B

void example(int&amp;&amp; x)
{
    // while the caller had to use an rvalue expression to pass a value for x,
    // since x now has a name in here it's an lvalue:
    foo(x); // calls variant A
}

example(std::move(myinteger)); // rvalue for us, lvalue for example
</code></pre>

<p>That is, you need:</p>

<pre><code>T(T&amp;&amp; o):
T0(std::move(o)) // rvalue derived converts to rvalue base
{
    puts(""move"");
}
</code></pre>

<p>And:</p>

<pre><code>T&amp; operator=(T&amp;&amp; o)
{
    puts(""move assign"");

    T0::operator=(std::move(o)));

    return *this;
}
</code></pre>
"
"<p>I'm trying to understand the <code>unique_ptr</code>, <code>shared_ptr</code>, and <code>weak_ptr</code> that came in with c++11.</p>

<p>I've heard that <code>weak_ptr</code>'s would be nice for things like caching, and breaking cycles, and so on. I've heard that they work well with <code>shared_ptrs</code>.</p>

<p>But in this regard, what's the difference between <code>shared_ptrs</code> and <code>unique_ptrs</code>? Why does <code>weak_ptr</code> only get to be used with one and not the other? Why wouldn't I want to have a weak reference to something owned by someone else?</p>
","87234","","<p>The major point of a weak pointer is that you can try to make the pointer strong, that is owning:</p>

<pre><code>auto strongPtr = weakPtr.lock();

if (strongPtr)
{
    // still existed, now have another reference to the resource
}
else
{
    // didn't still exist
}
</code></pre>

<p>Note the first path: <em>making a weak pointer stronger requires we take ownership of the object</em>.</p>

<p>This is why it doesn't make sense with <code>unique_ptr</code>: the only way to make the weak pointer strong is to <em>take</em> the resource from somewhere else, and for <code>unique_ptr</code> that would mean leaving that somewhere else with an unexpected null pointer. <code>shared_ptr</code> gets a pass because taking it really means sharing it.</p>
"
"<p>I need to wrap a raw pointer into a <code>shared_ptr</code> in order to pass it to a function. The function doesn't hold any reference to the input object once it returns.</p>

<pre><code>{
  MyClass i;
  shared_ptr&lt;MyClass&gt; p(&amp;i);
  f(p);
  // BAD: shared_ptr will delete i.
}
</code></pre>

<p>How to prevent <code>shared_ptr</code> from deleting the referenced object?</p>
","87234","","<p>As <a href=""http://stackoverflow.com/users/962089/chris"">chris</a> alluded to in the comments, write an empty deleter:</p>

<pre><code>#include &lt;type_traits&gt;

template &lt;typename T&gt;
struct empty_delete
{
    empty_delete() /* noexcept */
    {
    }

    template &lt;typename U&gt;
    empty_delete(const empty_delete&lt;U&gt;&amp;,
        typename std::enable_if&lt;
            std::is_convertible&lt;U*, T*&gt;::value
        &gt;::type* = nullptr) /* noexcept */
    {
    }

    void operator()(T* const) const /* noexcept */
    {
        // do nothing
    }
};
</code></pre>

<p>Example of use:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

struct noisy
{
    noisy() { std::cout &lt;&lt; ""alive"" &lt;&lt; std::endl; }
    ~noisy() { std::cout &lt;&lt; ""dead"" &lt;&lt; std::endl; }

    noisy(const noisy&amp;);
    noisy&amp; operator=(const noisy&amp;);
};

template &lt;typename T&gt;
void take(T&amp; yours)
{
    std::cout &lt;&lt; ""Taking..."" &lt;&lt; std::endl;
    {
        auto mine = std::move(yours);
    }
    std::cout &lt;&lt; ""Took."" &lt;&lt; std::endl;
}

int main()
{
    std::unique_ptr&lt;noisy&gt; a(new noisy());
    std::shared_ptr&lt;noisy&gt; b(new noisy());
    std::unique_ptr&lt;noisy, empty_delete&lt;noisy&gt;&gt; c(new noisy());
    std::shared_ptr&lt;noisy&gt; d(new noisy(), empty_delete&lt;noisy&gt;());

    take(a);
    take(b);
    take(c);
    take(d);
}
</code></pre>

<p>Output:</p>

<blockquote>
  <p>alive<br>
  alive<br>
  alive<br>
  alive<br>
  Taking...<br>
  dead<br>
  Took.<br>
  Taking...<br>
  dead<br>
  Took.<br>
  Taking...<br>
  Took.<br>
  Taking...<br>
  Took.  </p>
</blockquote>

<p>Of course, this example leaks memory.</p>
"
"<p>Should the following sample compile?</p>

<pre><code>struct B;
struct A
{
  A(B*&amp;&amp;){}
};

struct B : A
{
  B() : A(this){}
};

int main(){}
</code></pre>

<p>On <a href=""http://liveworkspace.org/code/1v4bC9%241"" rel=""nofollow"">LWS</a> with clang it compiles, but with gcc I get:</p>

<blockquote>
  <p>no known conversion for argument 1 from 'B* const' to 'B*&amp;&amp;'</p>
</blockquote>

<p>and if I add a <code>const</code> it compiles.</p>

<p>I would like to also point out MSVC gets it wrong too:</p>

<blockquote>
  <p>cannot convert parameter 2 from 'B *const ' to 'B *&amp;&amp;'</p>
</blockquote>

<p>so it looks like we have a bug in two compilers.</p>

<p><strong>BUGS FILED</strong></p>

<p><a href=""https://connect.microsoft.com/VisualStudio/feedback/details/781977/this-pointer-fails-to-bind-to-rvalue-reference-to-pointer"" rel=""nofollow"">MSVC bug link</a></p>

<p><a href=""http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56701"" rel=""nofollow"">GCC bug link</a></p>
","87234","","<p>Yes, that should compile.</p>

<p>It is incorrect to implement <code>this</code> as <code>cv T* const</code> (where cv is the cv-qualifiers for the function, if any, and <code>T</code> is the class type). <code>this</code> is not <code>const</code>, merely a prvalue expression of a built-in type (not modifiable).</p>

<p>Many people think that because you can't modify <code>this</code> it must be <code>const</code>, but as <a href=""http://stackoverflow.com/users/34509/johannes-schaub-litb"">Johannes Schaub - litb</a> once commented long ago, a much better explanation is something like this:</p>

<pre><code>// by the compiler
#define this (__this + 0)

// where __this is the ""real"" value of this
</code></pre>

<p>Here it's clear that you can't modify <code>this</code> (say, <code>this = nullptr</code>), but also clear no <code>const</code> is necessary for such an explanation. (And the value you have in your constructor is just the value of the temporary.)</p>
"
"<p>Considering the <a href=""http://blogs.msdn.com/b/oldnewthing/archive/2005/05/19/420038.aspx"">following code</a> (and the fact that <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa366887%28v=vs.85%29.aspx""><code>VirtualAlloc()</code> returns a <code>void*</code></a>):</p>

<pre><code>BYTE* pbNext = reinterpret_cast&lt;BYTE*&gt;(
    VirtualAlloc(NULL, cbAlloc, MEM_COMMIT, PAGE_READWRITE));
</code></pre>

<p>why is <code>reinterpret_cast</code> chosen instead of <code>static_cast</code>?</p>

<p>I used to think that <code>reinterpret_cast</code> is OK for e.g. casting pointers to and from integer types (like e.g. <code>DWORD_PTR</code>), but to cast from a <code>void*</code> to a <code>BYTE*</code>, isn't <code>static_cast</code> OK?</p>

<p>Are there any (subtle?) differences in this particular case, or are they just both valid pointer casts?</p>

<p>Does the C++ standard have a preference for this case, suggesting a way instead of the other?</p>
","87234","","<p>You should <code>static_cast</code>. <strong>Use <code>static_cast</code> in cases where you're undoing an implicit conversion.</strong></p>

<p>In this particular case, however, there is no difference because you're converting from <code>void*</code>. But in general, <code>reinterpret_cast</code>ing between two object pointers is defined to be (§5.2.10/7):</p>

<blockquote>
  <p>An object pointer can be explicitly converted to an object pointer of a diﬀerent type. When a prvalue <code>v</code> of type “pointer to <code>T1</code>” is converted to the type “pointer to cv <code>T2</code>”, <strong>the result is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code></strong> if both <code>T1</code> and <code>T2</code> are standard-layout types and the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>, or if either type is <code>void</code>. Converting a prvalue of type “pointer to <code>T1</code>” to the type “pointer to <code>T2</code>” (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value. The result of any other such pointer conversion is unspeciﬁed. </p>
</blockquote>

<p>Emphasis mine. Since <code>T1</code> for you is already <code>void*</code>, the cast to <code>void*</code> in <code>reinterpret_cast</code> does nothing. This is not true in general, which is what <a href=""http://stackoverflow.com/a/15579008/87234"">Drew Dormann is saying</a>:</p>

<pre><code>#include &lt;iostream&gt;

template &lt;typename T&gt;
void print_pointer(const volatile T* ptr)
{
    // this is needed by oversight in the standard
    std::cout &lt;&lt; static_cast&lt;void*&gt;(const_cast&lt;T*&gt;(ptr)) &lt;&lt; std::endl;
}

struct base_a {};
struct base_b {};
struct derived : base_a, base_b {};

int main()
{
    derived d;

    base_b* b = &amp;d; // implicit cast

    // undo implicit cast with static_cast
    derived* x = static_cast&lt;derived*&gt;(b);

    // reinterpret the value with reinterpret_cast
    derived* y = reinterpret_cast&lt;derived*&gt;(b);

    print_pointer(&amp;d);
    print_pointer(x);
    print_pointer(y);
}
</code></pre>

<p>Output:</p>

<blockquote>
  <p>00CBFD5B<br>
  00CBFD5B<br>
  00CBFD5C  </p>
</blockquote>

<p>(Note that because <code>y</code> doesn't actually point to a <code>derived</code>, using it is undefined behavior.)</p>

<p>Here, <code>reinterpret_cast</code> comes up with a different value because it goes through <code>void*</code>. This is why you should use <code>static_cast</code> when you can, and <code>reinterpret_cast</code> when you have to.</p>
"
"<p>If I have an <code>std::ostringstream</code> object called <code>oss</code>, I understand I can do <code>std::cout &lt;&lt; oss.str()</code> to print out the string. But doing <code>oss.str()</code> would result in the returned string being copied. Is there a way to print directly the underlying <code>streambuf</code>?</p>

<p>Thanks in advance!</p>
","87234","","<p>Not if you're using <a href=""http://en.cppreference.com/w/cpp/io/basic_ostringstream"" rel=""nofollow""><code>std::ostringstream</code></a>. The underlying buffer for this cannot be read from (hence the <code>o</code> in <code>ostringstream</code>), so you have to rely on the implementation to do it for you, via <code>str()</code>.</p>

<p>However, if you use <a href=""http://en.cppreference.com/w/cpp/io/basic_stringstream"" rel=""nofollow""><code>std::stringstream</code></a> (note the lack of <code>o</code>), then the underlying buffer is readable, and <code>basic_ostream</code>'s have a special overload forreading from buffers:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;

int main()
{
    std::stringstream ss1;
    ss1 &lt;&lt; ""some "" &lt;&lt; 111605 &lt;&lt; "" stuff"" &lt;&lt; std::flush;

    std::cout &lt;&lt; ss1.rdbuf() &lt;&lt; std::endl;
    std::cout &lt;&lt; ss1.str() &lt;&lt; std::endl;
}
</code></pre>

<p>Output:</p>

<blockquote>
  <p>some 111605 stuff<br>
  some 111605 stuff  </p>
</blockquote>

<p>(<a href=""http://stackoverflow.com/a/3442561/87234"">Example derived from here</a>.)</p>

<p>This copies directly from the underlying buffer, without an intermediate copy.</p>
"
"<p>I am trying to benchmark many (about 25) variations of an algorithm written in C++. </p>

<p>I implemented these variations using a combination of three methods:</p>

<ol>
<li><p>copying code and making minor changes to the copied version</p></li>
<li><p>subclassing the base algorithm class</p></li>
<li><p>using <code>#ifdef</code>s to switch between snippets of code</p></li>
</ol>

<p>The variations that arise from options 1 and 2 are okay because I can select which variation of the algorithm to run in a configuration file. I can then iterate through different configuration files and keep a record of ""configuration:results"" pairs - keeping these records is very important to my work.</p>

<p>I am currently having a problem with the <code>#ifdef</code>s because I have to compile multiple versions of the code to access these variations, making it much harder to run automated experiment scripts and to keep accurate records of results. The <code>#ifdef</code>s, however, are very useful because if I find a mistake in one copy of the code, then I do not have to remember to correct this mistake in multiple copies.</p>

<p><em>The <code>#ifdef</code>s expand six variations that I created by both copying code and subclassing into 24 total variations (4 variations for each basic variation).</em></p>

<p>Here is an example - mostly the I am using the <code>#ifdef</code>s to avoid replicating too much code:</p>

<pre><code>    ....

    double lasso_gam=*gamma;
    *lasso_idx=-1;
    for(int aj=0;aj&lt;(int)a_idx.size();aj++){
        int j=a_idx[aj];
        assert(j&lt;=C*L);
        double inc=wa[aj]*(*gamma)*signs[aj];
        if( (beta_sp(j)&gt;0 &amp;&amp; beta_sp(j)+inc&lt;0)
#ifdef ALLOW_NEG_LARS
            || (beta_sp(j)&lt;0 &amp;&amp; beta_sp(j)+inc&gt;0)
#else
            || (beta_sp(j)==0 &amp;&amp; beta_sp(j)+inc&lt;0)
#endif
            ){
            double tmp_gam=-beta_sp(j)/wa[aj]*signs[aj];

            if(tmp_gam&gt;=0 &amp;&amp; tmp_gam&lt;lasso_gam) {
                *lasso_idx=aj;
                *next_active=j;
                lasso_gam=tmp_gam;
            }
        }
    }

    if(lasso_idx&gt;=0){
        *gamma=lasso_gam;
    }

    ....
</code></pre>

<p><strong>Question:</strong> What is the best way to allow the multiple variations of the algorithm, which are currently specified by <code>#ifdef</code>s, to be run given a configuration file that specifies which variation of the algorithm to run.</p>

<p>Ideally I would like to compile the code only once and select an algorithm variation at runtime using the config file.</p>
","87234","","<p>You can augment your algorithm with a (possibly additional) template argument like this:</p>

<pre><code>enum class algorithm_type
{
    type_a,
    type_b,
    type_c
};

template &lt;algorithm_type AlgorithmType&gt;
void foo(int usual, double args)
{
    std::cout &lt;&lt; ""common code"" &lt;&lt; std::endl;

    if (AlgorithmType == algorithm_type::type_a)
    {
        std::cout &lt;&lt; ""doing type a..."" &lt;&lt; usual &lt;&lt; "", "" &lt;&lt; args &lt;&lt; std::endl;
    }
    else if (AlgorithmType == algorithm_type::type_b)
    {
        std::cout &lt;&lt; ""doing type b..."" &lt;&lt; usual &lt;&lt; "", "" &lt;&lt; args &lt;&lt; std::endl;
    }
    else if (AlgorithmType == algorithm_type::type_c)
    {
        std::cout &lt;&lt; ""doing type c..."" &lt;&lt; usual &lt;&lt; "", "" &lt;&lt; args &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; ""more common code"" &lt;&lt; std::endl;
}
</code></pre>

<p>Now you can select your behavior via this template argument:</p>

<pre><code>foo&lt;algorithm_type::type_a&gt;(11, 0.1605);
foo&lt;algorithm_type::type_b&gt;(11, 0.1605);
foo&lt;algorithm_type::type_c&gt;(11, 0.1605);
</code></pre>

<p>The type, being a constant expression, yields a compile-time decided branch (that is, the others are known to be dead code and removed). In fact, your compiler should warn you about this (how you deal with that is up to you).</p>

<p>But you can still dispatch off a runtime value just fine:</p>

<pre><code>#include &lt;stdexcept&gt;

void foo_with_runtime_switch(algorithm_type algorithmType,
                             int usual, double args)
{
    switch (algorithmType)
    {
    case algorithm_type::type_a:
        return foo&lt;algorithm_type::type_a&gt;(usual, args);
    case algorithm_type::type_b:
        return foo&lt;algorithm_type::type_b&gt;(usual, args);
    case algorithm_type::type_c:
        return foo&lt;algorithm_type::type_c&gt;(usual, args);
    default:
        throw std::runtime_error(""wat"");
    }
}

foo_with_runtime_switch(algorithm_type::type_a, 11, 0.1605);
foo_with_runtime_switch(algorithm_type::type_b, 11, 0.1605);
foo_with_runtime_switch(algorithm_type::type_c, 11, 0.1605);
</code></pre>

<p>The internals of the algorithm remain the same (dead branches eliminated, same optimizations), just how you get there has changed. (Note that it's possible to generalize the enum idea so that this switch is generated automatically; if you find yourself with handfuls of variations, this might be good to learn.)</p>

<p>And of course you still can <code>#define</code> a specific algorithm as a default:</p>

<pre><code>#define FOO_ALGORITHM algorithm_type::type_a

void foo_with_define(int usual, double args)
{
    return foo&lt;FOO_ALGORITHM&gt;(usual, args);
}

foo_with_define(11, 0.1605);
</code></pre>

<p>All these together give you the advantages of all three, with no repetition.</p>

<p>In practice, you can have all three as overloads: one for users who know which algorithm to use at compile-time, those who need to select it at runtime, and those who just want a default (which you can override via a project-wide <code>#define</code>):</p>

<pre><code>// foo.hpp

enum class algorithm_type
{
    type_a,
    type_b,
    type_c
};

// for those who know which algorithm to use
template &lt;algorithm_type AlgorithmType&gt;
void foo(int usual, double args)
{
    std::cout &lt;&lt; ""common code"" &lt;&lt; std::endl;

    if (AlgorithmType == algorithm_type::type_a)
    {
        std::cout &lt;&lt; ""doing type a..."" &lt;&lt; usual &lt;&lt; "", "" &lt;&lt; args &lt;&lt; std::endl;
    }
    else if (AlgorithmType == algorithm_type::type_b)
    {
        std::cout &lt;&lt; ""doing type b..."" &lt;&lt; usual &lt;&lt; "", "" &lt;&lt; args &lt;&lt; std::endl;
    }
    else if (AlgorithmType == algorithm_type::type_c)
    {
        std::cout &lt;&lt; ""doing type c..."" &lt;&lt; usual &lt;&lt; "", "" &lt;&lt; args &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; ""more common code"" &lt;&lt; std::endl;
}

// for those who will know at runtime
void foo(algorithm_type algorithmType, int usual, double args)
{
    switch (algorithmType)
    {
    case algorithm_type::type_a:
        return foo&lt;algorithm_type::type_a&gt;(usual, args);
    case algorithm_type::type_b:
        return foo&lt;algorithm_type::type_b&gt;(usual, args);
    case algorithm_type::type_c:
        return foo&lt;algorithm_type::type_c&gt;(usual, args);
    default:
        throw std::runtime_error(""wat"");
    }
}

#ifndef FOO_ALGORITHM
    // chosen to be the best default by profiling
    #define FOO_ALGORITHM algorithm_type::type_b
#endif

// for those who just want a good default
void foo(int usual, double args)
{
    return foo&lt;FOO_ALGORITHM&gt;(usual, args);
}
</code></pre>

<p>Of course, if some implementation types are always worse than some other, get rid of it. But if you find there are two useful implementations, there's no harm in keeping both around this way.</p>
"
"<p>I'm having problem with this piece of code, valgrind detects memory leaks in std::basic_string and I don't know what am I doing wrong. The leak is only when std::string is used in child process. Could you please tell me, where the problem is? I've never used fork() in C++ before so I don't have much exprience.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cerrno&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

int main(int argc, char *argv[])
{
    pid_t childPid = fork();
    if (childPid == -1)
    {
      perror(""fork"");
      return EXIT_FAILURE;
    }
    else if (childPid == 0)
    {
      std::cout &lt;&lt; ""Child PID: "" &lt;&lt; getpid() &lt;&lt; std::endl;
      std::string str(""something"");      //valgrind detects mem leak here
      _Exit(EXIT_SUCCESS);
    }
    else
    {
      //std::string str(""something"");    //but not here
    }

    waitpid(-1, 0, 0);
  return EXIT_SUCCESS;
}
</code></pre>
","87234","","<p><code>_Exit</code> will not run any destructors or <code>atexit</code> functions, it simply ends immediately.</p>

<p>Obviously this punches a giant hole through RAII, so Don't Do That.</p>

<hr>

<p>One way of implementing Don't Do That while maintaining the same exit strategy might be:</p>

<pre><code>template &lt;typename Func, typename... Args&gt;
int wrap_cpp_code(Func&amp;&amp; func, Args&amp;&amp;.. args)
{
    try
    {
        return std::forward&lt;Func&gt;(func)(std::forward&lt;Args&gt;(args)...);
    }
    catch (...)
    {
        return EXIT_FAILURE;
    }
}
</code></pre>

<p>Which won't cough up an return value until all destructors under its scope are run, giving:</p>

<pre><code>int child_main(int argc, char *argv[])
{
    std::cout &lt;&lt; ""Child PID: "" &lt;&lt; getpid() &lt;&lt; std::endl;
    std::string str(""something"");

    return EXIT_SUCCESS;
}

int main(int argc, char *argv[])
{
    pid_t childPid = fork();
    if (childPid == -1)
    {
      perror(""fork"");

      return EXIT_FAILURE;
    }
    else if (childPid == 0)
    {
      int ret = wrap_cpp_code(child_main, argc, argv);
      _Exit(ret);
    }
    else
    {
      /*
      int ret = wrap_cpp_code(xyz, argc, argv);
      */
    }

    waitpid(-1, 0, 0);

    return EXIT_SUCCESS;
}
</code></pre>

<p>But this still fails to account for <code>atexit</code> functions or global destructors. So still Avoid Doing That.</p>
"
"<p>I am trying to test the speed of various pointer speeds and ran into a really weird problem. When allocating for raw pointers, it runs fine. (There is a memory leak, but that isn't the problem.) When I run the second test with shared_ptr, It runs the fill fine, prints the log and then when it returns, it enters an infinite loop. It appears the ref count is garbage, but I'm doing everything by value. </p>

<pre><code>#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

#include &lt;Windows.h&gt;

using namespace std;

static const int TOTAL = 1000000;

int* newTest(int i)
{
  return new int(i);
}

shared_ptr&lt;int&gt; sharedTest(int i)
{
  return shared_ptr&lt;int&gt;(new int(i));
}

template &lt;typename T&gt;
pair&lt;int, vector&lt;typename T::result_type&gt;&gt; Fill(T fn)
{
  unsigned long start = GetTickCount();
  vector&lt;typename T::result_type&gt; vec;
  vec.reserve(TOTAL);
  for(int i = 0; i &lt; TOTAL; i++)
  {
    vec.push_back(fn(i));
  }
  unsigned long end = GetTickCount();
  return make_pair(end - start, move(vec));
}

template &lt;typename T&gt;
void Test(T fn, string name)
{
  vector&lt;typename T::result_type&gt; newTest;
  int milliseconds = 0;
  tie(milliseconds, newTest) = Fill(fn);
  cout &lt;&lt; ""Fill "" &lt;&lt; name &lt;&lt; "" Took "" &lt;&lt; milliseconds &lt;&lt; "" milliseconds."" &lt;&lt; endl;
}

int main()
{
  function&lt;int*(int)&gt; fn1 = newTest;
  Test(fn1, ""Raw Ptr"");

  function&lt;shared_ptr&lt;int&gt;(int)&gt; fn2 = sharedTest;
  Test(fn2, ""Shared New"");

  return 0;
}
</code></pre>

<p>OK. It appears I have asked a stack overflow question on Stackoverflow....
When I set TOTAL to 10000 it's fine. So, is that just a symptom of something else or do I need to increase my stack size?</p>

<p><em>Edit from comment:</em></p>

<blockquote>
  <p>Tavison: OK. after several minutes it ended. You're right about not being an infinite loop. But, 1043 ms to new and many minutes to delete makes it hard to justify using them. This is not a result I would expect.</p>
</blockquote>
","87234","","<p>There is no infinite loop, you're just being impatient. It's taking time to free all the <code>shared_ptr</code>'s.</p>

<p>To be able to claim there is an infinite loop, you need to actually step into the code and take a look. Check that there is some loop somewhere with a condition that will never change. This is not the case here.</p>

<hr>

<p>Lower your <code>TOTAL</code>, for example, and verify it actually ends. Having more of these will not magically introduce an infinite loop at some number, so if it works at a lower number, it works at a higher one.</p>

<p>Or, don't allocate <code>int</code>s; allocate some test struct that outputs <code>""bye""</code> (along with some counter) when its destructing, and you'll see ""post""-test that they're all being deleted. (Of course, performing IO will increase the destruction time, but the point is to verify a condition is moving towards stopping a loop.)</p>

<p>Also, you can cut the allocations in half by using <code>return make_shared&lt;int&gt;(i);</code> rather than <code>new</code>ing the int yourself and putting it into a <code>shared_ptr</code>. Always use <code>make_shared</code>.</p>

<p>Lastly, this is only slow if you have a debugger attached, because it'll, well, debug your memory usage. That is, verify that what you're deleting is sensible to delete, isn't corrupting anything, etc.</p>

<p><sub>
And for the love of programming use four spaces to indent, not two.
</sub></p>
"
"<p>One of the highest voted questions under the c++ tag is called <a href=""http://stackoverflow.com/questions/236129/splitting-a-string-in-c"">""Splitting a string in C++""</a>. In it, the questioner asks: ""What's the most elegant way to split a string in C++?"".</p>

<p><a href=""http://stackoverflow.com/a/236803/12711"">The highest voted answer</a> to this question provides these two functions:</p>

<pre><code>std::vector&lt;std::string&gt; &amp;split(const std::string &amp;s, char delim, std::vector&lt;std::string&gt; &amp;elems) {
    std::stringstream ss(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}


std::vector&lt;std::string&gt; split(const std::string &amp;s, char delim) {
    std::vector&lt;std::string&gt; elems;
    return split(s, delim, elems);
}
</code></pre>

<p>These functions work great. But I am trying to understand why the answerer didn't combine these two functions into one function. Is there some performance, usability or readability benefit that I am not seeing that you miss out on when you combine these functions? Full program with combined function is below:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;    
// splitting them into two seperate functions is unnecessary it seems to me, and makes the underlying function harder to understand.
std::vector&lt;std::string&gt; split(const std::string &amp;s, char delim) {
    std::vector&lt;std::string&gt; elems;
    std::stringstream ss(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}

int main()
{
    std::vector&lt;std::string&gt; x = split(""one:two::three"", ':');
    for (int i = 0; i&lt;x.size(); ++i) cout &lt;&lt; x[i] &lt;&lt; '\n';
    return 0;
}
</code></pre>

<p>I find this function split apart to be exceedingly less elegant - and harder to understand - but I feel like I must be missing something. Why didn't he just combine them?</p>
","87234","","<p>Imagine that you are going to split a bunch of different sources, but want the results to all end up in one container. For that, you don't want the function to always allocate a new container for you:</p>

<p>Before, requires extra work:</p>

<pre><code>std::vector&lt;std::string&gt; sources = /* populate */;

std::vector&lt;std::string&gt; results;

for (const auto&amp; source : sources)
{
    auto result = split(source, "":"");

    // or maintain a vector of vectors...yuck
    results.insert(std::make_move_iterator(result.begin()),
                   std::make_move_iterator(result.end()));
}
</code></pre>

<p>After, straightforward:</p>

<pre><code>std::vector&lt;std::string&gt; sources = /* populate */;

std::vector&lt;std::string&gt; results;

for (const auto&amp; source : sources)
{
    split(source, "":"", results);
}
</code></pre>

<hr>

<p>Or: imagine you're going to split a bunch of difference sources, and for efficiency you want to minimize memory allocation (your <strong>profiler</strong> says you allocate too much here, for example). So you reuse the same vector over and over, to avoid subsequent memory allocations after the first split.</p>

<p>Before, slow:</p>

<pre><code>std::vector&lt;std::string&gt; sources = /* populate */;

for (const auto&amp; source : sources)
{
    auto result = split(source, "":"");

    process(result);
}
</code></pre>

<p>After, better:</p>

<pre><code>std::vector&lt;std::string&gt; sources = /* populate */;

std::vector&lt;std::string&gt; result;
for (const auto&amp; source : sources)
{
    result.clear();
    split(source, "":"", result);

    process(result);
}
</code></pre>

<hr>

<p>Of course, the simplicity of having the container created for you is nice in the general case, and we can easily reuse the more general function to create the second function at little cost.</p>
"
"<p>Given the following code:</p>

<pre><code>#include &lt;iostream&gt;

using std::cout;

class A {
    public:
        virtual ~A() {}
        int x,y,z;
};

int main (void)
{
    std::cout&lt;&lt;&amp;A::x;
    std::cout&lt;&lt;&amp;A::y;
    std::cout&lt;&lt;&amp;A::z;
}
</code></pre>

<p>The output is: </p>

<blockquote>
  <p>111</p>
</blockquote>

<p>What is the meaning of the output? Why is it 1? Are there any good reason to access class members via pointers (without created object)?</p>

<p>EDIT - Using:</p>

<pre><code>printf(""%p"",&amp;A::x);
printf(""%p"",&amp;A::y);
printf(""%p"",&amp;A::z);
</code></pre>

<p>prints: 4 , 8 and C.</p>

<p>It makes more sense now I guess.. (bytes)
But still, is there any use for that?</p>
","87234","","<p>There is no <code>operator&lt;&lt;(std::ostream&amp;, T)</code> defined for <code>T = &amp;C::m</code>. Normally you'd get an error.</p>

<p>But instead, there is one for <code>T = bool</code> and an implicit conversion from a member-pointer to <code>bool</code>. So the output you're seeing is just the result of those pointers not being null (being converted to <code>true</code>).</p>

<p>Try this, for example:</p>

<pre><code>#include &lt;iomanip&gt;
#include &lt;iostream&gt;

struct A
{
    int x, y, z;
};

int main()
{
    std::cout &lt;&lt; std::boolalpha; // print boolean values as text

    std::cout &lt;&lt; &amp;A::x &lt;&lt; std::endl;
    std::cout &lt;&lt; &amp;A::y &lt;&lt; std::endl;
    std::cout &lt;&lt; &amp;A::z &lt;&lt; std::endl;
}
</code></pre>

<p>Output:</p>

<blockquote>
  <p>true<br>
  true<br>
  true  </p>
</blockquote>

<hr>

<p>Note that in the code <code>printf(""%p"", &amp;A::X)</code>, you have undefined behavior.</p>

<p>The value for the <code>%p</code> specifier must be a <code>void*</code>, and there is no conversion from a member-pointer to a <code>void*</code>. Instead, what you have aliases (type-puns) to <code>void*</code>, which is undefined behavior. (Imagine that <code>sizeof(&amp;A::x)</code> was 4 while <code>sizeof(void*)</code>was 64; nothing says this cannot be the case.)</p>

<p>You just have to come to terms with the idea that not all pointers can be viewed as integer offsets. That we can even print a pointer is implementation-defined: it could print ""apple"" for null, ""pear"" for one value, and ""milk"" for another if a (dumb) implementation wanted to. <a href=""http://stackoverflow.com/questions/14167455/is-it-possible-to-hash-pointers-in-portable-c03-code/14169897#14169897"">I've touched on this difference between values and their representations before</a>.</p>

<p>And in this case, there is no output for the value <em>at all</em>. And that's okay, not all values have meaningful printed outputs. The most you can do is print out the individual bits:</p>

<pre><code>#include &lt;climits&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

template &lt;typename T&gt;
auto print_bits(const T&amp; value)
    -&gt; typename std::enable_if&lt;std::is_standard_layout&lt;T&gt;::value&gt;::type
{
    // it's okay to alias a standard-layout type as a sequence of bytes:
    const auto valueAsBytes = reinterpret_cast&lt;const unsigned char*&gt;(&amp;value);

    for (std::size_t byte = 0; byte &lt; sizeof(T); ++byte)
    {
        // print in reverse order
        const std::size_t byteIndex = sizeof(T) - byte - 1;

        const unsigned char byteValue = valueAsBytes[byteIndex];

        for (std::size_t bit = 0; bit &lt; CHAR_BIT; ++bit)
        {
            // print in reverse order
            const std::size_t bitIndex = CHAR_BIT - bit - 1;

            const bool bitValue = (byteValue &amp; (1U &lt;&lt; bitIndex)) != 0;

            std::cout &lt;&lt; (bitValue ? 1 : 0);
        }

        std::cout &lt;&lt; ' ';
    }

    std::cout &lt;&lt; std::endl;
}
</code></pre>

<p>(I print the bytes and bits in reverse order because on my architectures this puts the least-significant bit on the right. I prefer to view binary values this way.)</p>

<p>This gives:</p>

<pre><code>struct A
{
    int x, y, z;
};

int main()
{
    // example:
    for (unsigned i = 0; i &lt; 64; ++i)
        print_bits(i);

    std::cout &lt;&lt; std::endl;

    // member-pointers:
    print_bits(&amp;A::x);
    print_bits(&amp;A::y);
    print_bits(&amp;A::z);
}
</code></pre>

<p>Output:</p>

<blockquote>
  <p>00000000 00000000 00000000 00000000<br>
  00000000 00000000 00000000 00000001<br>
  00000000 00000000 00000000 00000010<br>
  [...]<br>
  00000000 00000000 00000000 00111101<br>
  00000000 00000000 00000000 00111110<br>
  00000000 00000000 00000000 00111111  </p>
  
  <p>00000000 00000000 00000000 00000000<br>
  00000000 00000000 00000000 00000100<br>
  00000000 00000000 00000000 00001000  </p>
</blockquote>

<p>There are no guarantees on what you see for the member-pointers.</p>
"
"<p>Recently in my code I have been explicitly writing <code>noexcept(false)</code> on functions that I know do throw exceptions, mainly for people reading the code. However, I am wondering if this affects the behavior of my code or the way the compiler interprets it. Does it make any difference?</p>

<p>Note: I am aware that destructors are implicitly noexcept and that you have to specify <code>noexcept(false)</code> to change that, I am wondering about other functions.</p>
","87234","","<p>Having no exception-specifier and explicitly stating <code>noexcept(false)</code> are equivalent, see §15.4/12:</p>

<blockquote>
  <p>A function with no exception-specification or with an exception-specification of the form <code>noexcept(constant-expression)</code> where the constant-expression yields <code>false</code> allows all exceptions. </p>
</blockquote>

<p>So the compiler should not distinguish between them when considering exceptions.</p>

<hr>

<p>More importantly, there's no need for you to be tacking on <code>noexcept(false)</code> to your functions. As a C++ developer, you should assume every function throws by default (which is why the standard takes this stance), so you're adding no new information by writing it out; it's a waste of time for everyone.</p>

<p>Rather, do mark the special case where a function <em>definitely</em> does not throw with <code>noexcept</code>, and do mark the cases where a function <em>may</em> throw depending on some condition with <code>noexcept(condition)</code>.</p>

<p>If your function is purposefully the source of some exception <code>E</code>, write that in your documentation.</p>
"
"<p>There are no problems compiling this code:</p>

<pre><code>struct A
{
    template&lt;typename T&gt;
    void f(int) {}
};

A a;
a.f&lt;double&gt;(42);
</code></pre>

<p>However, similar code with templated constructor does not compile:</p>

<pre><code>struct A
{
    template&lt;typename T&gt;
    A(int) {}
};

A a&lt;double&gt;(42);
</code></pre>

<p>Gcc gives the following error in the last line: <em>error: unexpected initializer before '&lt;' token</em></p>

<p>Is there a way to make constructor example work?</p>
","87234","","<p>There is no way to explicitly specify templates for a constructor, as you cannot name a constructor.</p>

<p>Depending on what you're trying to do, this can be used:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

struct A
{
    template &lt;typename T&gt;
    struct with_type {};

    template&lt;typename T&gt;
    A(int x, with_type&lt;T&gt;)
    {
        std::cout &lt;&lt; ""x: "" &lt;&lt; x &lt;&lt; '\n'
                  &lt;&lt; ""T: "" &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
    }
};

int main()
{
    A a(42, A::with_type&lt;double&gt;());
}
</code></pre>

<p>This ""cheats"" by taking advantage of type deduction.</p>

<p>This is quite unorthodox, though, so there's probably a better way of doing what you need.</p>
"
"<p>During my work on writing a unit test for a framework that shall work with all kind of standard C++11 container I stepped over the problem that I want to create in a generic way test data.
Here I need to know if an associated container C is a multi* container. Eg. if C is a std::set or a std::multiset. I searched through the interface of all of these containers and all of them have in common that they have an insert(value_type const&amp;) method. But from my point of view the significant difference is that the multi* version returns just an iterator, but the 'non' multi* version return a std::pair. So I choose this as differentiator.</p>

<p>My resulting code is:</p>

<pre><code>#include &lt;type_traits&gt;
#include &lt;utility&gt;

template &lt;typename Container&gt;
class is_multi_container
{
  typedef typename Container::value_type T;
  typedef typename Container::iterator ExpectedType;
  typedef decltype(Container().insert(T())) ResultType;
public:
  static const bool value = std::is_same&lt;ResultType, ExpectedType&gt;::value;
};

#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;

int main() {
  std::cout &lt;&lt; ""std::set&lt;T&gt; is "" &lt;&lt; is_multi_container&lt;std::set&lt;int&gt;&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; ""std::multiset&lt;T&gt; is "" &lt;&lt; is_multi_container&lt;std::multiset&lt;int&gt;&gt;::value &lt;&lt; std::endl;

  std::cout &lt;&lt; ""std::map&lt;K,T&gt; is "" &lt;&lt; is_multi_container&lt;std::map&lt;int,double&gt;&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; ""std::multimap&lt;K,T&gt; is "" &lt;&lt; is_multi_container&lt;std::multimap&lt;int,double&gt;&gt;::value &lt;&lt; std::endl;

  std::cout &lt;&lt; ""std::unordered_set&lt;T&gt; is "" &lt;&lt; is_multi_container&lt;std::unordered_set&lt;int&gt;&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; ""std::unordered_multiset&lt;T&gt; is "" &lt;&lt; is_multi_container&lt;std::unordered_multiset&lt;int&gt;&gt;::value &lt;&lt; std::endl;

  std::cout &lt;&lt; ""std::unordered_map&lt;K,T&gt; is "" &lt;&lt; is_multi_container&lt;std::unordered_map&lt;int,double&gt;&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; ""std::unordered_multimap&lt;K,T&gt; is "" &lt;&lt; is_multi_container&lt;std::unordered_multimap&lt;int,double&gt;&gt;::value &lt;&lt; std::endl;
}
</code></pre>

<p>According to this small test program, it seems to work, but I am not sure if a) this solutions has problems that I do not see so far and b) if there is a more elegant way to write such a trait? I am aware that the trait only works with associative container.</p>

<p>Many thanks in advance!</p>

<p>PS.: I have to work with Visual Studio 2010.</p>
","87234","","<p>Seeing as there are a small finite number of <code>std::multi*</code> containers, you can just list them:</p>

<pre><code>#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;

#include &lt;type_traits&gt;

template &lt;typename Container&gt;
struct is_multi_container :
    std::false_type
{};

template &lt;typename T, typename Compare, typename Alloc&gt;
struct is_multi_container&lt;std::multiset&lt;T, Compare, Alloc&gt;&gt; :
    std::true_type
{};

template &lt;typename T, typename Compare, typename Alloc&gt;
struct is_multi_container&lt;std::multimap&lt;T, Compare, Alloc&gt;&gt; :
    std::true_type
{};

template &lt;typename T, typename Compare, typename Alloc&gt;
struct is_multi_container&lt;std::unordered_multiset&lt;T, Compare, Alloc&gt;&gt; :
    std::true_type
{};

template &lt;typename T, typename Compare, typename Alloc&gt;
struct is_multi_container&lt;std::unordered_multimap&lt;T, Compare, Alloc&gt;&gt; :
    std::true_type
{};
</code></pre>

<p>More lines of code, but it's easy to read and is direct in its reasoning (i.e., it definitely works!).</p>

<p>Being an explicit list, the caveat is that it doesn't extend itself automatically. For that, your solution is good. C++14 may have an <code>AssociativeContainer</code> concept which would make this even easier; research on this is left as an exercise for the reader. ;)</p>

<p>Example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main()
{
    std::cout &lt;&lt; std::boolalpha;

    #define TEST(type, ...)                                     \
            std::cout &lt;&lt; type "" is: ""                           \
                      &lt;&lt; is_multi_container&lt;__VA_ARGS__&gt;::value \
                      &lt;&lt; std::endl

    TEST(""std::set&lt;T&gt;"", std::set&lt;int&gt;);
    TEST(""std::multiset&lt;T&gt;"", std::multiset&lt;int&gt;);

    TEST(""std::map&lt;K,T&gt;"", std::map&lt;int, double&gt;);
    TEST(""std::multimap&lt;K,T&gt;"", std::multimap&lt;int, double&gt;);

    TEST(""std::unordered_set&lt;T&gt;"", std::unordered_set&lt;int&gt;);
    TEST(""std::unordered_multiset&lt;T&gt;"", std::unordered_multiset&lt;int&gt;);

    TEST(""std::unordered_map&lt;K,T&gt;"", std::unordered_map&lt;int, double&gt;);
    TEST(""std::unordered_multimap&lt;K,T&gt;"", std::unordered_multimap&lt;int, double&gt;);
}
</code></pre>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code>std::set&lt;T&gt; is: false
std::multiset&lt;T&gt; is: true
std::map&lt;K,T&gt; is: false
std::multimap&lt;K,T&gt; is: true
std::unordered_set&lt;T&gt; is: false
std::unordered_multiset&lt;T&gt; is: true
std::unordered_map&lt;K,T&gt; is: false
std::unordered_multimap&lt;K,T&gt; is: true
</code></pre>
"
"<p>In C++11, I can iterate over some container like so:</p>

<pre><code>for(auto i : vec){
   std::cout &lt;&lt; i &lt;&lt; std::endl;
}
</code></pre>

<p>But I know that this needlessly - <em>needlessly</em>, since I only need to <em>print</em> the values of <code>vec</code> - makes a copy of (<strong>EDIT</strong>:  each element of) <code>vec</code>, so instead I could do:</p>

<pre><code>for(auto &amp;i : vec){
   std::cout &lt;&lt; i &lt;&lt; std::endl;
}
</code></pre>

<p>But I want to make sure that the values of <code>vec</code> are never modified and abide by const-correctness, so I can do:</p>

<pre><code>for(const auto &amp;i : vec){
   std::cout &lt;&lt; i &lt;&lt; std::endl;
}
</code></pre>

<p>So my question is:  If I only need to <em>look</em> at the values of some container, wouldn't the very last loop (<code>const auto &amp;i</code>) always be preferred due to the increased effieciency of not having an extra copy of (<strong>EDIT</strong>:  each element of) <code>vec</code>?</p>

<p>I have a program that I'm developing in which I'm considering making this change throughout, since efficiency is critical in it (the reason I'm using C++ in the fist place).</p>
","87234","","<p>Yes. The same reason if you only ever read an argument you make the parameter <code>const&amp;</code>.</p>

<pre><code>T        // I'm copying this
T&amp;       // I'm modifying this
const T&amp; // I'm reading this
</code></pre>

<p>Those are your ""defaults"". When <code>T</code> is a fundamental type (built-in), though, you generally just revert to <code>const T</code> (no reference) for reading, because a copy is cheaper than aliasing.</p>

<hr>

<blockquote>
  <p>I have a program that I'm developing in which I'm considering making this change throughout, since efficiency is critical in it</p>
</blockquote>

<ol>
<li>Don't make blind sweeping changes. A working program is better than a fast but broken program.  </li>
<li>How you iterate through your loops probably won't make much of a difference; you're looping for a reason, aren't you? The body of your loop will much more likely be the culprit.</li>
<li>If efficiency is critical, you want to use a <strong>profiler</strong> to find which parts of your program are <em>actually</em> slow, rather than guess at parts that <em>might</em> be slow. See #2 for why your guess may be wrong.</li>
</ol>
"
"<p>I frequently see people only overriding operator&lt;, not > or ==. Does it mean that by default, operator> and operator== are implemented using operator&lt; ? </p>

<p>I also frequently see people writing (see <a href=""http://stackoverflow.com/questions/2214295/is-it-impossible-to-use-stl-map-with-struct/2214324#2214324"">here</a>)</p>

<pre><code>bool operator() (Node const&amp; n1, Node const&amp; n2) const
{
    // TODO: your condition
    return n1.a &lt; n2.a;
}
</code></pre>

<p>What does operator() mean here then? it seems very counter-intuitive. </p>
","87234","","<p>The reason they're only overriding <code>&lt;</code> is because by default that's what ordered containers use to compare values, so that's all they need to define to answer the question.</p>

<pre><code>#include &lt;set&gt;

struct my_fancy_integer
{
    int fancy;
};

// This is all std::set (or any ordered container) needs by default,
// So for an example answer I won't do anything else (as I expect you to
// learn and understand *why* it needs this by default).
bool operator&lt;(const my_fancy_integer&amp; first, const my_fancy_integer&amp; second)
{
    return first.fancy &lt; second.fancy;
}

// But I should really also defined the other comparison operators...
// For example, without operator&gt; defined this would fail:
//
// std::set&lt;my_fancy_integer, std::greater&lt;my_fancy_integer&gt;&gt; x;
//
// But since you read documentation for std::set and std::greater you
// understand why this fails: std::set will use std::greater to order
// the values, and std::greater (by default) will try to use operator&gt;.

int main()
{
    std::set&lt;my_fancy_integer&gt; x; // okay
}
</code></pre>

<p>No, the other operators are not implicitly defined in terms of it (nor in terms of anything else). In a real application, if you've defined one you should define them all. </p>

<p>Alternatively, if <code>&lt;</code> doesn't make sense for your type syntactically, but ordering them is still valuable, define a usable default predicate that users should pass to the ordered container's predicate template argument.</p>

<pre><code>#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

struct my_employee
{
    std::string name;
    int salary;
    int yearsEmployed;
};

// Saying one employee is ""less"" than another doesn't really make sense...
// But I can still give an *ordering* on them:
struct my_employee_ordering
{
    bool operator()(const my_employee&amp; first, const my_employee&amp; second) const
    {
        // I'll just reuse std::tuple's comparison operator, and tie the
        // fields of each structure into a tuple to use it. This orders
        // by name, salary, then yearsEmployed.
        return std::tie(first.name, first.salary, first.yearsEmployed) &lt;
               std::tie(second.name, second.salary, second.yearsEmployed);
    }
};

int main()
{
    // We need to tell std::set how to order employees:
    std::set&lt;my_employee, my_employee_ordering&gt; x; // okay
}
</code></pre>

<hr>

<p><code>operator()</code> is the <em>function call operator</em>. It allows your object to be ""called"":</p>

<pre><code>struct foo
{
    void operator()(int x) { std::cout &lt;&lt; x &lt;&lt; std::endl; }
};

foo f;
f(5); // calls foo::operator()(5)
</code></pre>
"
"<p>I'm doing some testing...
Firstly I post my source code</p>

<p>the .h file</p>

<pre><code>class Complex{
    private:
        int r = 0;//initializer
        int i ; 
    public:
        Complex(int , int I = 0);
        Complex();
        void print();
        void set(int, int I = 1);
        static void print_count();
        static int count;
};
</code></pre>

<p>the .cpp file</p>

<pre><code>#include &lt;iostream&gt;
#include ""complex.h""

int Complex::count = 1;

Complex::Complex(int R , int I){
    r = R;
    i = I;

    count++;

    std::cout &lt;&lt; ""constructing Complex object...count is "" &lt;&lt; Complex::count &lt;&lt; std::endl;
}

Complex::Complex(){//default constructor
    std::cout &lt;&lt; ""default constructor is called..."" &lt;&lt; std::endl;
}

void Complex::print(){
    std::cout &lt;&lt; ""r = "" &lt;&lt; r &lt;&lt; ';' &lt;&lt; ""i = "" &lt;&lt; i &lt;&lt; std::endl;
    return;
}

void Complex::set(int R, int I /*= 2*/){//will be ""redefaulting"", an error
    r = R;
    i = I;
    return;
}

void Complex::print_count(){//static
    Complex::count = -1;//jsut for signaling...

    std::cout &lt;&lt; ""count is "" &lt;&lt; count &lt;&lt; std::endl;
    return;
}
</code></pre>

<p>the main function</p>

<pre><code>#include &lt;iostream&gt;
#include ""complex.h""

int main(){
    Complex d;//using default constructor
    d.print();

    /*Complex c(4, 5);*/
    Complex c(4);
    //c.print();

    /*c.set(2, 3)*/
    c.print();
    c.set(2 );
    c.print();

    std::cout &lt;&lt; ""count is "" &lt;&lt; c.count &lt;&lt; std::endl;//c can access member data
    c.print_count();
    c.count++;//

    return 0;
}
</code></pre>

<p>consider the Complex object d constructed with default ctor</p>

<p>because the data member r is initialized using with 0, when executing d.print(),
r is expected to be 0</p>

<p>and i isn't, so I expected it to be garbage value</p>

<p>but when I'm testing, one strange thing happens.</p>

<p>if I eliminate this and the following lines of code in the main file:</p>

<p>std::cout &lt;&lt; ""count is "" &lt;&lt; c.count &lt;&lt; std::endl;//c can access member data</p>

<p>then d.print() will give the value of i as 32767 on my system, which I guess it's a garbage value;</p>

<p>but once that line is added, d.print() just give i's value to 0 on my system.</p>

<p>I don't get it. I hasn't set, modiify or initialize i's value, why should it be 0?</p>

<p>or, it is also a garbage value?</p>

<p>or, calling one of those function corrupts the value of i?</p>

<p>how is the thing run behind the scene here?</p>

<p>thx for helping.</p>
","87234","","<p>0 is just as garbage value as any other. Don't make the mistake of thinking otherwise.</p>

<p>Formally, reading an uninitialized variable is undefined behavior, so there's no point in wondering about it: just fix it by initializing the variable properly.</p>
"
"<p>I have a <code>set</code> of <code>unique_ptr</code> instances and want to pass all of them as an argument to a function. Example demonstrated by below code.</p>

<pre><code>#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;vector&gt;

using std::set;
using std::unique_ptr;
using std::vector;

void doStuff(unique_ptr&lt;int&gt; ptr)
{
  // doing stuff...
}

int main()
{
  vector&lt;unique_ptr&lt;int&gt;&gt; ptrVector;
  set&lt;unique_ptr&lt;int&gt;&gt; ptrSet;

  for (auto cur = ptrVector.begin(); cur != ptrVector.end(); cur++)
  {
    doStuff(std::move(*cur));
  }

  for (auto cur = ptrSet.begin(); cur != ptrSet.end(); cur++)
  {
    doStuff(std::move(*cur));
  }

  return 0;
}
</code></pre>

<p>This results in the following compiler error (GCC 4.8.1):</p>

<pre>uptrfncall.cpp: In function ‘int main()’:
uptrfncall.cpp:27:25: error: use of deleted function ‘std::unique_ptr::unique_ptr(const std::unique_ptr&) [with _Tp = int; _Dp = std::default_delete]’
  doStuff(std::move(*cur)); // line 25, compiler error
                         ^
In file included from /usr/include/c++/4.8/memory:81:0,
                 from uptrfncall.cpp:1:
/usr/include/c++/4.8/bits/unique_ptr.h:273:7: error: declared here
       unique_ptr(const unique_ptr&) = delete;
       ^
uptrfncall.cpp:9:10: error:   initializing argument 1 of ‘void doStuff(std::unique_ptr)’
     void doStuff(unique_ptr ptr)
          ^</pre>

<p>Note that it works flawlessly for the <code>vector</code> but not for the <code>set</code>. As the <code>set</code> is not <code>const</code>, the <code>begin()</code> call should not return a <code>const_iterator</code> so it should be possible to move the values when dereferencing the iterator. Why does this not compile?</p>
","87234","","<p>The set may not be const, but the elements within it are. You cannot modify a set's elements, as it wouldn't be able to guarantee it's maintaining its invariants.</p>
"
"<p>The following code is taken <a href=""https://github.com/SuperV1234/SSVOpenHexagon/blob/JSONTest/include/SSVOpenHexagon/Online/OHServer.h"" rel=""nofollow"">straight out of one of my projects</a>. The first version causes a crash (segmentation fault). The second version works as intended.</p>

<p><strong>Aren't the two code snippets equivalent?</strong></p>

<hr>

<p><em>This one crashes</em></p>

<pre><code>auto getUserFromPacket = [&amp;](sf::Packet&amp; mP) -&gt; User&amp; 
{ 
    return users.getUser(ssvuj::as&lt;std::string&gt;(getDecompressedPacket(mP), 0)); 
};
pHandler[FromClient::US_Death] = [&amp;](ClientHandler&amp;, sf::Packet&amp; mP)        
{
    getUserFromPacket(mP).stats.deaths += 1; // segmentation fault here!
};
</code></pre>

<hr>

<p><em>This one works</em></p>

<pre><code>pHandler[FromClient::US_Death] = [&amp;](ClientHandler&amp;, sf::Packet&amp; mP)        
{
    users.getUser(ssvuj::as&lt;std::string&gt;(getDecompressedPacket(mP), 0)).stats.deaths += 1; 
    // this works fine
};
</code></pre>

<hr>

<p>Compiler used: <em>clang++ 3.4</em> - it also couldn't deduce the return type of <code>getUserFromPacket</code>. <code>users</code> is an instance of an <code>UserDB</code>. The function signature is <code>User&amp; UserDB::getUser(const std::string&amp;)</code> - why does the compiler fail to deduce <code>User&amp;</code> as the return type?</p>
","87234","","<p>No, they aren't equivalent. The first one will refer to the lambda, which (likely) will not be in scope by the time it is needed. The second has no such dependency. Always be careful capturing by reference. :)</p>
"
"<p><strong>This question builds on this <a href=""http://stackoverflow.com/questions/8193102/initializer-list-and-move-semantics"">@FredOverflow's question</a>.</strong></p>

<blockquote>
  <p><strong>CLARIFICATION</strong>: <code>initializer_list</code> approach is required as the <a href=""http://connect.microsoft.com/VisualStudio/feedback/details/773505"" rel=""nofollow""><em>VC++2012 has a bug</em></a> the prevents forwarded expansion of namespaced arguments. <code>_MSC_VER &lt;= 1700</code> has the bug.</p>
</blockquote>

<p>I've written a variadic template function that collapses any number of arguments in a typed container. I use the type's constructor to convert the variadic arguments into consumable values. E.g. <code>_variant_t</code> :)</p>

<p>I need this for my <code>MySql</code> C++ library when pushing arguments to prepared statements in one strike, while my <code>MySqlVariant</code> converts the input data to <code>MYSQL_BIND</code>s. As I may work with <code>BLOB</code>s, I'd like to avoid copy-construct as much as possible when I can <code>move&amp;&amp;</code> the large containers around.</p>

<p>I've done a simple test and noticed that the <code>initialize_list</code> does <code>copy-construct</code> for the stored elements and destroys them when it goes out of scope. Perfect... Then I tried to move the data out of the <code>initializer_list</code> and, to my surprise, it used <code>lvalues</code> not <code>rvalues</code> as I expected with <code>std::move</code>.</p>

<blockquote>
  <p>Funny as this happens just after <a href=""http://channel9.msdn.com/Events/GoingNative/2013"" rel=""nofollow""><strong>Going Native 2013</strong></a> clearly warned me that <strong>move does not move, forward does not forward</strong>... <strong>be like water, my friend</strong> - to stay on the deep end of thinking.</p>
</blockquote>

<p><strong>But that did not stop me :)</strong> I decided to <code>const_cast</code> the <code>initializer_list</code> values and still move them out. An eviction order needs to be enforced. And this is <strong>my implementation</strong>:</p>

<pre><code>template &lt;typename Output_t, typename ...Input_t&gt;
inline Output_t&amp; Compact(Output_t&amp; aOutput, Input_t&amp;&amp; ...aInput){
    // should I do this? makes sense...
    if(!sizeof...(aInput)){
        return aOutput;
    }

    // I like typedefs as they shorten the code :)
    typedef Output_t::value_type Type_t;

    // can be either lvalues or rvalues in the initializer_list when it's populated.
    std::initializer_list&lt;Type_t&gt; vInput = { std::forward&lt;Input_t&gt;(aInput)... };

    // now move the initializer_list into the vector.
    aOutput.reserve(aOutput.size() + vInput.size());
    for(auto vIter(vInput.begin()), vEnd(vInput.end()); vIter != vEnd; ++vIter){
        // move (don't copy) out the lvalue or rvalue out of the initializer_list.
        // aOutput.emplace_back(std::move(const_cast&lt;Type_t&amp;&gt;(*vIter))); // &lt;- BAD!
        // the answer points out that the above is undefined so, use the below
        aOutput.emplace_back(*vIter); // &lt;- THIS is STANDARD LEGAL (copy ctor)!
    }

    // done! :)
    return aOutput;
}
</code></pre>

<p><strong>Using it</strong> is easy:</p>

<pre><code>// You need to pre-declare the container as you could use a vector or a list...
// as long as .emplace_back is on duty!
std::vector&lt;MySqlVariant&gt; vParams;
Compact(vParams, 1, 1.5, 1.6F, ""string"", L""wstring"",
    std::move(aBlob), aSystemTime); // MySql params :)
</code></pre>

<p><strong>I've also uploaded a full test</strong> <a href=""http://ideone.com/kTn2BC"" rel=""nofollow""><strong>on IDEone ^</strong></a> that shows as the memory of a <code>std::string</code> moves properly with this function. <em>(I would paste it all here but it's slightly long...)</em></p>

<p>As long as the <code>_variant_t</code> <em>(or whatever final wrapping object)</em> has the right constructors, it's great. And if the data can be moved out, it's even better. And it pretty much works as I tested it and things <code>std::move</code> in the right direction :)</p>

<p><strong>My questions are simple:</strong></p>

<ul>
<li><strong>Am I doing this right standard-wise?</strong></li>
<li><strong>Is the fact that it's working right intended or just a side effect?</strong></li>
<li><strong>If <code>std::move</code> does not work by default on <code>initializer_list</code>, is what I'm doing here: <em>illegal, immoral, hacky... or just plain wrong</em>?</strong></li>
</ul>

<p><em><strong>PS</strong>: I'm a self-taught <code>Windows Native C++</code> developer, ignorant of the standards.<br>
^ my excuse if I'm doing really non-standard things here.</em></p>

<p><strong>UPDATE</strong></p>

<p>Thanks everyone, I have both the answer and the solution <em>(a short and long one)</em> now.</p>

<blockquote>
  <p><strong>And I love the C++11 side of SO.</strong> <em>Many knowledgeable people here...</em></p>
</blockquote>
","87234","","<p>In the general case, this is undefined behavior, unfortunately. At §8.5.4/5, emphasis mine:</p>

<blockquote>
  <p>An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an initializer list <strong>as if the implementation allocated a temporary array of <code>N</code> elements of type <code>const E</code></strong>, where <code>N</code> is the number of elements in the initializer list. Each element of that array is copy-initialized with the corresponding element of the initializer list,
  and the <code>std::initializer_list&lt;E&gt;</code> object is constructed to refer to that array.</p>
</blockquote>

<p>Where you see a <code>std::initializer_list&lt;E&gt;</code>, you can act as if it's a <code>const E[N]</code>.</p>

<p>So when you <code>const_cast</code> away the <code>const</code>, you're looking at a mutable reference to a <code>const</code> object. Any modification to a <code>const</code> object is undefined behavior.</p>

<p>When you move that <code>std::string</code>, you're modifying a <code>const</code> object. Unfortunately , one of the behaviors of undefined behavior is seemingly correct behavior. But this is technically undefined.</p>

<p>Note that when you <code>std::move(int)</code> into another, <em>that</em> is well-defined because <code>int</code>
's can only be copied, so the move does nothing and no <code>const</code> objects are modified. But in general, it's undefined.</p>
"
"<p>I have a class where the constructor takes parameter as reference. For eg.</p>

<pre><code>class A
{
    A(Tracer&amp; t) : m_t(t) { }
  private:
     Tracer&amp; m_t;
};
</code></pre>

<p>I have this <code>class A</code> as boost::optional and want to construct it only when needed. If I use boost::in_place to construct it. Since <code>boost::in_place</code> takes the parameters as const_refs, I had to modify the signature of the constructor to </p>

<pre><code>A(const Tracer&amp; t) : m_t(const_cast&lt;Tracer&amp;&gt;(t)  { }
</code></pre>

<p>is there any other way of passing the object by reference ? </p>

<p>The s/w limitation is boost 1.4.3, VS2010. </p>

<p><strong>EDIT</strong>: The class is not copy-constructible and assignable as well. I haven't showed that in the sample class mentioned above.</p>
","87234","","<p>Like this:</p>

<pre><code>#include &lt;boost/optional.hpp&gt;
#include &lt;boost/ref.hpp&gt;

struct Tracer
{
    Tracer() = default;

    Tracer(const Tracer&amp;) = delete;
    Tracer(Tracer&amp;&amp;) = delete;
    Tracer&amp; operator=(const Tracer&amp;) = delete;
    Tracer&amp; operator=(Tracer&amp;&amp;) = delete;
};

class A
{
public: // Note: I had to add this.
    A(Tracer&amp; t) : m_t(t) { }
private:
     Tracer&amp; m_t;
};

int main()
{
    Tracer tracer;
    boost::optional&lt;A&gt; x;

    x = boost::in_place(boost::ref(tracer));
}
</code></pre>

<p><code>boost::ref</code> returns a <code>boost::reference_wrapper</code>, which models a reference as a value.</p>
"
"<p>I have to maintain a program that nobody has touched since 2004.</p>

<pre><code>class CSolver
{  
 ...  
 ClauseIdx add_clause (int * lits, int n_lits);
}

void and2 (CSolver &amp; solver)   
{  
vector &lt;int&gt; lits;  
...  
solver.add_clause(lits.begin(), lits.size());  
}
</code></pre>

<p>The compiler complains that:</p>

<blockquote>
  <p>error: no matching function for call to ‘CSolver::add_clause(__gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;, size_t)’</p>
</blockquote>

<p>I try to cast it</p>

<pre><code>solver.add_clause((int*)lits.begin(), lits.size());
</code></pre>

<p>But there is still a complaint:</p>

<blockquote>
  <p>error: invalid cast from type ‘__gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;’ to type ‘int*’  </p>
</blockquote>

<p>I want to look for a quick fix on this, because changing interface of CSolver will result
changing the whole program.</p>

<p>Thanks in advance.</p>
","87234","","<p>Like this:</p>

<pre><code>solver.add_clause(lits.data(), lits.size());
</code></pre>

<p>Don't add casts without understanding what you're doing.</p>

<p>The function wants an array of <code>int</code>s, and it's asking for them by a pointer to the first element along with a size. This is a common C convention.</p>

<p>Lucky for us, <code>std::vector</code> stores elements precisely as a contiguous array, so we can get a pointer to the first element (<code>lits.data()</code>, <code>&amp;lits[0]</code>, <code>&amp;lits.front()</code>, etc.) and then just pass the size.</p>
"
"<p>Disclaimer : This is C++03. My apologies for not making that clear before. Also auto_ptr is out because of company guidelines.</p>

<p>Example code:</p>

<pre><code>void foo(boost::ptr_vector&lt;MyType&gt;&amp; iPtrVector)
{
    boost::scoped_ptr&lt;MyType&gt; aScopedPtr = new MyType();
    // lots of logic here

    if (condition)
        iPtrVector.push_back(*aScopedPtr);
} // eek! Resource is freed, but maybe referenced in iPtrVector now!
</code></pre>

<p>My issue with this is that the resource will be deleted when the scoped pointer goes out of scope, but actually I want the resource to be maintained in the ptr_vector <em>if</em> my condition is true. My approach would be to <em>revoke ownership</em> from the scoped_ptr if I decided I needed to hold it in the ptr vector. However, scoped_ptr doesn't permit this.</p>

<p>Thus I've built a simple class to handle it for me :</p>

<pre><code>template &lt;class T&gt;
struct CustomScopedPointer
{
    CustomScopedPointer() : _targetPtr(NULL) { }
    ~CustomScopedPointer() { delete _targetPtr; }
    T* _targetPtr;

    // calling this with a null ptr will ensure the resource 
    // isn't deleted at dtor time
    CustomScopedPointer&amp; operator=(T* rhs)
    {
        _targetPtr = rhs;
        return *this;
    }

};
</code></pre>

<p>Is there a way to do this without defining my own class, however? It seems overkill for a particular specific circumstance, and I was very surprised to find that there is no way to prevent a smart pointer from deleting its managed resource - even a reset or reassignment first frees the original resource. </p>

<p>(As for why I'm forced to handle it like this, it's because of <em>business</em> reasons. Suffice to say that the resource must be freed in case of exception, etc, but equally cannot be inside the ptr_vector except in some circumstances)</p>
","87234","","<p>Use <code>std::unique_ptr</code>:</p>

<pre><code>auto aScopedPtr = make_unique&lt;MyType&gt;();
// lots of logic here

if (condition)
    iPtrVector.push_back(aScopedPtr.release());
</code></pre>

<p>You can search around for an implementation of <code>make_unique</code> to copy and paste. You can use:</p>

<pre><code>std::unique_ptr&lt;MyType&gt; aScopePtr{ new MyType() };
</code></pre>

<p>If you really have to, but strongly prefer <code>make_unique</code>.</p>

<hr>

<p>If you can't use C++11 features, you can do the same with <code>std::auto_ptr</code>:</p>

<pre><code>std::auto_ptr&lt;MyType&gt; aScopePtr{ new MyType() };
</code></pre>

<p>Just be aware it's deprecated and has pitfalls.</p>
"
"<p>The following code fails in GCC, Clang and Visual Studio:</p>

<pre><code>#include &lt;string&gt;
#include &lt;sstream&gt;

int main() {
    std::string s = ""hello""; // ok, copy-initialization
    std::stringstream ss1(s); // ok, direct-initialization
    std::stringstream ss2 = s; // error
}
</code></pre>

<p>I thought the only case where direct-initialization works while copy-initialization doesn't is when the constructor is explicit, which it is not in this case. What's going on?</p>
","87234","","<p>That constructor <em>is</em> marked explicit, so can only be used with direct-initialization. §27.8.5:</p>

<pre><code>explicit basic_stringstream(
ios_base::openmode which = ios_base::out | ios_base::in);

explicit basic_stringstream(
const basic_string&lt;charT,traits,Allocator&gt;&amp; str,
ios_base::openmode which = ios_base::out | ios_base::in);

basic_stringstream(const basic_stringstream&amp; rhs) = delete;

basic_stringstream(basic_stringstream&amp;&amp; rhs);
</code></pre>

<p>(The same is true for <code>basic_stringbuf</code>, <code>basic_istringstream</code>, and <code>basic_ostringstream</code>.)</p>
"
"<p>I am fairly familiar with the basics of C++, but lack experience (mainly code in Java), so slightly ""dumbed down"" replies would be appreciated :)</p>

<p>I am extending a larger open source project, which uses a standard visual studio class limits.h, where the following code can be found:</p>

<pre><code>template&lt;&gt; class numeric_limits&lt;double&gt;
    : public _Num_float_base
    {   // limits for type double
public:
    typedef double _Ty;

    static _Ty (max)() _THROW0()
    {   // return maximum value
        return (DBL_MAX);
    }
</code></pre>

<p>I have now imported another open source project, which uses minwindef.h which has this piece of code in it:</p>

<pre><code>#ifndef max
#define max(a,b)            (((a) &gt; (b)) ? (a) : (b))
#endif
</code></pre>

<p>The build now breaks because for this line</p>

<pre><code>SUMOReal distance = std::numeric_limits&lt;SUMOReal&gt;::max();
</code></pre>

<p>the compiler complains about max() being used without any parameters.
Is there any quick way to get around this issue, or can I simply not use the library I imported? :/</p>

<p>Hope this was clear enough, thanks for any suggestions!!</p>
","87234","","<p>In your compiler settings, have <code>NOMINMAX</code> be defined. This will stop the Windows headers from trying to define the <code>min</code> and <code>max</code> macros. This is the correct way to handle this issue; trying to <code>#undef</code> it is unreliable and error-prone. Search for <code>NOMINMAX</code> for more information on this flag.</p>

<p>You can also do this in a pinch, but don't make it a habit:</p>

<pre><code>SUMOReal distance = (std::numeric_limits&lt;SUMOReal&gt;::max)();
</code></pre>
"
"<p>Reading some C++ code I came across what I'll call a ""functional"" use of function Macros roughly as follows (this is a totally stylized example to make the point):</p>

<pre><code>#define TOP_LEVEL(ARG1)     \
ARG1(""foo1"",""bar1"")     \
ARG1(""foo2"",""bar2"")

#define NEXT_LEVEL(ARG2A, ARG2B)    \
cout &lt;&lt; ARG2A &lt;&lt; "" and "" &lt;&lt; ARG2B;

TOP_LEVEL(NEXT_LEVEL)
</code></pre>

<p>I'm relatively new to the language and at first I couldn't figure this out, but then I ran it through just the preprocessor (<code>g++ -E</code>) and lo and behold it resolves to:</p>

<pre><code>cout &lt;&lt; ""foo1"" &lt;&lt; "" and "" &lt;&lt; ""bar1""; cout &lt;&lt; ""foo2"" &lt;&lt; "" and "" &lt;&lt; ""bar2"";
</code></pre>

<p>Do you see what it did there?  It passed the Macro NEXT_LEVEL <strong>like a function pointer</strong> to the Macro TOP_LEVEL.  Seeing how useful this could potentially be, I wanted to learn more about it:  passing around functions to other functions is <a href=""http://en.wikipedia.org/wiki/First-class_function"" rel=""nofollow"">pretty sophisticated stuff</a> and there must be at least something more to say about the technique.  </p>

<p>Yet despite a ton of Googling I can't find evidence that this feature of the preprocessor even exists, let alone anything approaching documentation:  <a href=""http://www.cplusplus.com/doc/tutorial/preprocessor/"" rel=""nofollow"">here</a>, <a href=""http://gcc.gnu.org/onlinedocs/cpp/Macros.html"" rel=""nofollow"">here</a>, <a href=""http://publib.boulder.ibm.com/infocenter/macxhelp/v6v81/index.jsp?topic=%2Fcom.ibm.vacpp6m.doc%2Flanguage%2Fref%2Fclrc09cpxmac.htm"" rel=""nofollow"">here</a> and <a href=""http://www.cprogramming.com/tutorial/cpreprocessor.html"" rel=""nofollow"">here</a> are just four examples of Macro tutorials that skip right past this; the last even has a section called ""Advanced Macro tricks"" - surely this qualifies!?</p>

<p>(Please note this is totally different than simply calling a function macro with another <strong>evaluated</strong> function macro as an argument- FOO(BAR(2)) is much more straightforward.) </p>

<p>My questions are:</p>

<ul>
<li>Is there an actual name for this behavior?</li>
<li>Is it documented anywhere?</li>
<li>It is commonly used, or are there well known pitfalls, etc.?</li>
</ul>
","87234","","<p>The idea is coined ""X-Macro"". Some definitions won't include your particular example (X-macros generally are a bit more involved, with a file being included), but any relevant info. about this will fall under that term when searching.</p>

<p>As <a href=""http://stackoverflow.com/users/962089/chris"">chris</a> mentioned in the comments, Boost.Preprocessor uses this idea to great effect. Popular uses are: <code>BOOST_PP_REPEAT</code>, <code>BOOST_PP_LIST_FOR_EACH</code>, and most powerfully: <code>BOOST_PP_ITERATE</code>.</p>

<p><code>BOOST_PP_ITERATE</code> is a ""true"" X-Macro; including a single file is expands to something dependent on a macro defined just prior. I show a more ""proper"" skeleton framework in this <a href=""http://stackoverflow.com/a/12963911/87234"">other answer</a>, but an example would be:</p>

<pre><code>// in xyz_data.def
DEFINE_XYZ(foo, 1, ""Description A"")
DEFINE_XYZ(bar, 5, ""Description B"")
DEFINE_XYZ(baz, 7, ""Description C"")
</code></pre>

<p>Then later when I just want column 1 I can do:</p>

<pre><code>#define DEFINE_XYZ(name, number, desc) some_func(name)
#include ""xyz_data.def""
</code></pre>

<p>And somewhere else where I want to generate some function for each one, I can do:</p>

<pre><code>#define DEFINE_XYZ(name, number, desc)                              \
    int BOOST_PP_CAT(get_number_for_, name)()                       \
    {                                                               \
       std::clog &lt;&lt; ""Getting number, which is: "" desc &lt;&lt; std::endl; \
                                                                    \
       return number;                                               \
    }

#include ""xyz_data.def""
</code></pre>

<p>You can then generate an enum where the name equals the number, etc.</p>

<p>The power is that when I want to add a new xyz, I just add it in one spot and it magically shows up everywhere it needs to be. I have done something like this in a very large codebase to keep some bookmarking data in one central place, but the various attributes were used differently in various locations.</p>

<p>Note that there is often no way around this; what I have are <em>syntactically different</em>, so no other language feature will generalize it for me to that level, only macros. Macros are not evil.</p>

<p>What you have is effectively an X-macro where the .def file is self-contained enough to be a <code>#define</code>. In other words, <code>#include ""xyz_data.def""</code> is just <code>TOP_LEVEL</code>.</p>

<p>There is only one large downside to this, and ironically it's not the use of X-macros themselves but the effect they have on C and C++ compilers. The problem is that the preprocessor has allowed us to change the preprocessed result of a file every time its included, even if the file contents are <em>exactly the same</em>.</p>

<p>You may have heard that C and C++ are slow to compile compared to modern languages, this is one of the reasons why. It has no proper module/packaging system, just ad-hoc inclusion of other files. And we just learned, <em>in general this cannot be avoided</em>. Oops. (That said, compilers are smart and will note when you have include guards around a file, for example, and avoid processing it multiple times. But this is situational.)</p>

<p>That said, using X-Macros themselves shouldn't be a huge contributor to the compilation time of a real program. It's just that their mere potential existence reaches out into the real word and screws with compiler's heads.</p>
"